
MTA_response_box.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000ee10  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000140  20000000  0000ee10  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000098c  20000140  0000ef50  00020140  2**2
                  ALLOC
  3 .stack        00002004  20000acc  0000f8dc  00020140  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00020140  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020168  2**0
                  CONTENTS, READONLY
  6 .debug_info   0005c583  00000000  00000000  000201c1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000080a3  00000000  00000000  0007c744  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00025809  00000000  00000000  000847e7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00001ac8  00000000  00000000  000a9ff0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00001c38  00000000  00000000  000abab8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00027617  00000000  00000000  000ad6f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0002744b  00000000  00000000  000d4d07  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0009f9cd  00000000  00000000  000fc152  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000050b8  00000000  00000000  0019bb20  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	d0 2a 00 20 55 01 00 00 51 01 00 00 51 01 00 00     .*. U...Q...Q...
	...
      2c:	51 01 00 00 00 00 00 00 00 00 00 00 51 01 00 00     Q...........Q...
      3c:	51 01 00 00 51 01 00 00 51 01 00 00 51 01 00 00     Q...Q...Q...Q...
      4c:	3d 33 00 00 85 2d 00 00 05 32 00 00 51 01 00 00     =3...-...2..Q...
      5c:	19 54 00 00 51 01 00 00 51 01 00 00 01 3d 00 00     .T..Q...Q....=..
      6c:	51 01 00 00 51 01 00 00 51 01 00 00 51 01 00 00     Q...Q...Q...Q...
      7c:	51 01 00 00 51 01 00 00 51 01 00 00 51 01 00 00     Q...Q...Q...Q...
      8c:	51 01 00 00 51 01 00 00 51 01 00 00 51 01 00 00     Q...Q...Q...Q...
      9c:	c9 2a 00 00 51 01 00 00 cd 2b 00 00 51 01 00 00     .*..Q....+..Q...
      ac:	51 01 00 00 00 00 00 00                             Q.......

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	20000140 	.word	0x20000140
      d4:	00000000 	.word	0x00000000
      d8:	0000ee10 	.word	0x0000ee10

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	20000144 	.word	0x20000144
     108:	0000ee10 	.word	0x0000ee10
     10c:	0000ee10 	.word	0x0000ee10
     110:	00000000 	.word	0x00000000

00000114 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     114:	b510      	push	{r4, lr}
	system_init();
     116:	4b07      	ldr	r3, [pc, #28]	; (134 <atmel_start_init+0x20>)
     118:	4798      	blx	r3
	stdio_redirect_init();
     11a:	4b07      	ldr	r3, [pc, #28]	; (138 <atmel_start_init+0x24>)
     11c:	4798      	blx	r3
	usb_init();
     11e:	4b07      	ldr	r3, [pc, #28]	; (13c <atmel_start_init+0x28>)
     120:	4798      	blx	r3
	
	printf("\r\nbefore composite device start\r\n");
     122:	4807      	ldr	r0, [pc, #28]	; (140 <atmel_start_init+0x2c>)
     124:	4b07      	ldr	r3, [pc, #28]	; (144 <atmel_start_init+0x30>)
     126:	4798      	blx	r3
	composite_device_start();	
     128:	4b07      	ldr	r3, [pc, #28]	; (148 <atmel_start_init+0x34>)
     12a:	4798      	blx	r3
	persistent_storage_init();
     12c:	4b07      	ldr	r3, [pc, #28]	; (14c <atmel_start_init+0x38>)
     12e:	4798      	blx	r3
}
     130:	bd10      	pop	{r4, pc}
     132:	46c0      	nop			; (mov r8, r8)
     134:	00000b0d 	.word	0x00000b0d
     138:	00007939 	.word	0x00007939
     13c:	00009181 	.word	0x00009181
     140:	0000a9dc 	.word	0x0000a9dc
     144:	00009659 	.word	0x00009659
     148:	0000914d 	.word	0x0000914d
     14c:	00007859 	.word	0x00007859

00000150 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     150:	e7fe      	b.n	150 <Dummy_Handler>
	...

00000154 <Reset_Handler>:
{
     154:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
     156:	4a23      	ldr	r2, [pc, #140]	; (1e4 <Reset_Handler+0x90>)
     158:	4b23      	ldr	r3, [pc, #140]	; (1e8 <Reset_Handler+0x94>)
     15a:	429a      	cmp	r2, r3
     15c:	d009      	beq.n	172 <Reset_Handler+0x1e>
     15e:	4b22      	ldr	r3, [pc, #136]	; (1e8 <Reset_Handler+0x94>)
     160:	4a20      	ldr	r2, [pc, #128]	; (1e4 <Reset_Handler+0x90>)
     162:	e003      	b.n	16c <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
     164:	6811      	ldr	r1, [r2, #0]
     166:	6019      	str	r1, [r3, #0]
     168:	3304      	adds	r3, #4
     16a:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     16c:	491f      	ldr	r1, [pc, #124]	; (1ec <Reset_Handler+0x98>)
     16e:	428b      	cmp	r3, r1
     170:	d3f8      	bcc.n	164 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
     172:	4b1f      	ldr	r3, [pc, #124]	; (1f0 <Reset_Handler+0x9c>)
     174:	e002      	b.n	17c <Reset_Handler+0x28>
                *pDest++ = 0;
     176:	2200      	movs	r2, #0
     178:	601a      	str	r2, [r3, #0]
     17a:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
     17c:	4a1d      	ldr	r2, [pc, #116]	; (1f4 <Reset_Handler+0xa0>)
     17e:	4293      	cmp	r3, r2
     180:	d3f9      	bcc.n	176 <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     182:	4a1d      	ldr	r2, [pc, #116]	; (1f8 <Reset_Handler+0xa4>)
     184:	21ff      	movs	r1, #255	; 0xff
     186:	4b1d      	ldr	r3, [pc, #116]	; (1fc <Reset_Handler+0xa8>)
     188:	438b      	bics	r3, r1
     18a:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
     18c:	39fd      	subs	r1, #253	; 0xfd
     18e:	2390      	movs	r3, #144	; 0x90
     190:	005b      	lsls	r3, r3, #1
     192:	4a1b      	ldr	r2, [pc, #108]	; (200 <Reset_Handler+0xac>)
     194:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
     196:	4a1b      	ldr	r2, [pc, #108]	; (204 <Reset_Handler+0xb0>)
     198:	78d3      	ldrb	r3, [r2, #3]
     19a:	2503      	movs	r5, #3
     19c:	43ab      	bics	r3, r5
     19e:	2402      	movs	r4, #2
     1a0:	4323      	orrs	r3, r4
     1a2:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
     1a4:	78d3      	ldrb	r3, [r2, #3]
     1a6:	270c      	movs	r7, #12
     1a8:	43bb      	bics	r3, r7
     1aa:	2608      	movs	r6, #8
     1ac:	4333      	orrs	r3, r6
     1ae:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
     1b0:	4b15      	ldr	r3, [pc, #84]	; (208 <Reset_Handler+0xb4>)
     1b2:	7b98      	ldrb	r0, [r3, #14]
     1b4:	2230      	movs	r2, #48	; 0x30
     1b6:	4390      	bics	r0, r2
     1b8:	2220      	movs	r2, #32
     1ba:	4310      	orrs	r0, r2
     1bc:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
     1be:	7b99      	ldrb	r1, [r3, #14]
     1c0:	43b9      	bics	r1, r7
     1c2:	4331      	orrs	r1, r6
     1c4:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
     1c6:	7b9a      	ldrb	r2, [r3, #14]
     1c8:	43aa      	bics	r2, r5
     1ca:	4322      	orrs	r2, r4
     1cc:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
     1ce:	4a0f      	ldr	r2, [pc, #60]	; (20c <Reset_Handler+0xb8>)
     1d0:	6851      	ldr	r1, [r2, #4]
     1d2:	2380      	movs	r3, #128	; 0x80
     1d4:	430b      	orrs	r3, r1
     1d6:	6053      	str	r3, [r2, #4]
        __libc_init_array();
     1d8:	4b0d      	ldr	r3, [pc, #52]	; (210 <Reset_Handler+0xbc>)
     1da:	4798      	blx	r3
        main();
     1dc:	4b0d      	ldr	r3, [pc, #52]	; (214 <Reset_Handler+0xc0>)
     1de:	4798      	blx	r3
     1e0:	e7fe      	b.n	1e0 <Reset_Handler+0x8c>
     1e2:	46c0      	nop			; (mov r8, r8)
     1e4:	0000ee10 	.word	0x0000ee10
     1e8:	20000000 	.word	0x20000000
     1ec:	20000140 	.word	0x20000140
     1f0:	20000140 	.word	0x20000140
     1f4:	20000acc 	.word	0x20000acc
     1f8:	e000ed00 	.word	0xe000ed00
     1fc:	00000000 	.word	0x00000000
     200:	41007000 	.word	0x41007000
     204:	41005000 	.word	0x41005000
     208:	41004800 	.word	0x41004800
     20c:	41004000 	.word	0x41004000
     210:	000094dd 	.word	0x000094dd
     214:	000064dd 	.word	0x000064dd

00000218 <TIMER_0_init>:
 * \brief Timer initialization function
 *
 * Enables Timer peripheral, clocks and initializes Timer driver
 */
static void TIMER_0_init(void)
{
     218:	b510      	push	{r4, lr}
			peripheral = (uint32_t)_pm_get_ahb_index(module);
			PM->AHBMASK.reg |= 1 << peripheral;
		}
		break;
	case PM_BUS_APBA:
		PM->APBAMASK.reg |= 1 << peripheral;
     21a:	4a08      	ldr	r2, [pc, #32]	; (23c <TIMER_0_init+0x24>)
     21c:	6993      	ldr	r3, [r2, #24]
     21e:	2120      	movs	r1, #32
     220:	430b      	orrs	r3, r1
     222:	6193      	str	r3, [r2, #24]
}

static inline void hri_gclk_write_CLKCTRL_reg(const void *const hw, hri_gclk_clkctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->CLKCTRL.reg = data;
     224:	4a06      	ldr	r2, [pc, #24]	; (240 <TIMER_0_init+0x28>)
     226:	4b07      	ldr	r3, [pc, #28]	; (244 <TIMER_0_init+0x2c>)
     228:	805a      	strh	r2, [r3, #2]
	_pm_enable_bus_clock(PM_BUS_APBA, RTC);
	_gclk_enable_channel(RTC_GCLK_ID, CONF_GCLK_RTC_SRC);
	timer_init(&TIMER_0, RTC, _rtc_get_timer());
     22a:	4b07      	ldr	r3, [pc, #28]	; (248 <TIMER_0_init+0x30>)
     22c:	4798      	blx	r3
     22e:	0002      	movs	r2, r0
     230:	4906      	ldr	r1, [pc, #24]	; (24c <TIMER_0_init+0x34>)
     232:	4807      	ldr	r0, [pc, #28]	; (250 <TIMER_0_init+0x38>)
     234:	4b07      	ldr	r3, [pc, #28]	; (254 <TIMER_0_init+0x3c>)
     236:	4798      	blx	r3
}
     238:	bd10      	pop	{r4, pc}
     23a:	46c0      	nop			; (mov r8, r8)
     23c:	40000400 	.word	0x40000400
     240:	00004004 	.word	0x00004004
     244:	40000c00 	.word	0x40000c00
     248:	00003339 	.word	0x00003339
     24c:	40001400 	.word	0x40001400
     250:	20000a18 	.word	0x20000a18
     254:	00001b8d 	.word	0x00001b8d

00000258 <ADC_0_init>:
{
     258:	b5f0      	push	{r4, r5, r6, r7, lr}
     25a:	b085      	sub	sp, #20
			peripheral = (uint32_t)_pm_get_apbb_index(module);
			PM->APBBMASK.reg |= 1 << peripheral;
		}
		break;
	case PM_BUS_APBC:
		PM->APBCMASK.reg |= 1 << peripheral;
     25c:	4a1b      	ldr	r2, [pc, #108]	; (2cc <ADC_0_init+0x74>)
     25e:	6a11      	ldr	r1, [r2, #32]
     260:	2380      	movs	r3, #128	; 0x80
     262:	025b      	lsls	r3, r3, #9
     264:	430b      	orrs	r3, r1
     266:	6213      	str	r3, [r2, #32]
     268:	4a19      	ldr	r2, [pc, #100]	; (2d0 <ADC_0_init+0x78>)
     26a:	4b1a      	ldr	r3, [pc, #104]	; (2d4 <ADC_0_init+0x7c>)
     26c:	805a      	strh	r2, [r3, #2]
	adc_async_init(&ADC_0, ADC, ADC_0_map, ADC_0_CH_MAX, ADC_0_CH_AMOUNT, &ADC_0_ch[0], (void *)NULL);
     26e:	4c1a      	ldr	r4, [pc, #104]	; (2d8 <ADC_0_init+0x80>)
     270:	4e1a      	ldr	r6, [pc, #104]	; (2dc <ADC_0_init+0x84>)
     272:	2300      	movs	r3, #0
     274:	9302      	str	r3, [sp, #8]
     276:	4b1a      	ldr	r3, [pc, #104]	; (2e0 <ADC_0_init+0x88>)
     278:	9301      	str	r3, [sp, #4]
     27a:	2501      	movs	r5, #1
     27c:	9500      	str	r5, [sp, #0]
     27e:	2300      	movs	r3, #0
     280:	0022      	movs	r2, r4
     282:	4918      	ldr	r1, [pc, #96]	; (2e4 <ADC_0_init+0x8c>)
     284:	0030      	movs	r0, r6
     286:	4f18      	ldr	r7, [pc, #96]	; (2e8 <ADC_0_init+0x90>)
     288:	47b8      	blx	r7
	adc_async_register_channel_buffer(&ADC_0, 0, ADC_0_buffer, ADC_0_BUFFER_SIZE);
     28a:	1d22      	adds	r2, r4, #4
     28c:	2310      	movs	r3, #16
     28e:	2100      	movs	r1, #0
     290:	0030      	movs	r0, r6
     292:	4c16      	ldr	r4, [pc, #88]	; (2ec <ADC_0_init+0x94>)
     294:	47a0      	blx	r4
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = ~data;
}

static inline void hri_port_clear_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     296:	2208      	movs	r2, #8
     298:	23c0      	movs	r3, #192	; 0xc0
     29a:	05db      	lsls	r3, r3, #23
     29c:	605a      	str	r2, [r3, #4]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     29e:	4a14      	ldr	r2, [pc, #80]	; (2f0 <ADC_0_init+0x98>)
     2a0:	4b14      	ldr	r3, [pc, #80]	; (2f4 <ADC_0_init+0x9c>)
     2a2:	6293      	str	r3, [r2, #40]	; 0x28
     2a4:	23c0      	movs	r3, #192	; 0xc0
     2a6:	061b      	lsls	r3, r3, #24
     2a8:	6293      	str	r3, [r2, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     2aa:	2143      	movs	r1, #67	; 0x43
     2ac:	5c53      	ldrb	r3, [r2, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     2ae:	43ab      	bics	r3, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     2b0:	2001      	movs	r0, #1
     2b2:	4303      	orrs	r3, r0
     2b4:	b2db      	uxtb	r3, r3
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     2b6:	5453      	strb	r3, [r2, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     2b8:	3912      	subs	r1, #18
     2ba:	5c53      	ldrb	r3, [r2, r1]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     2bc:	200f      	movs	r0, #15
     2be:	4003      	ands	r3, r0
	tmp |= PORT_PMUX_PMUXO(data);
     2c0:	2010      	movs	r0, #16
     2c2:	4303      	orrs	r3, r0
     2c4:	b2db      	uxtb	r3, r3
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     2c6:	5453      	strb	r3, [r2, r1]
}
     2c8:	b005      	add	sp, #20
     2ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
     2cc:	40000400 	.word	0x40000400
     2d0:	0000401e 	.word	0x0000401e
     2d4:	40000c00 	.word	0x40000c00
     2d8:	2000015c 	.word	0x2000015c
     2dc:	2000091c 	.word	0x2000091c
     2e0:	2000096c 	.word	0x2000096c
     2e4:	42004000 	.word	0x42004000
     2e8:	00000f49 	.word	0x00000f49
     2ec:	00000ffd 	.word	0x00000ffd
     2f0:	41004400 	.word	0x41004400
     2f4:	40000008 	.word	0x40000008

000002f8 <EXTERNAL_IRQ_0_init>:
{
     2f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     2fa:	46de      	mov	lr, fp
     2fc:	4657      	mov	r7, sl
     2fe:	464e      	mov	r6, r9
     300:	4645      	mov	r5, r8
     302:	b5e0      	push	{r5, r6, r7, lr}
     304:	4ad8      	ldr	r2, [pc, #864]	; (668 <EXTERNAL_IRQ_0_init+0x370>)
     306:	4bd9      	ldr	r3, [pc, #868]	; (66c <EXTERNAL_IRQ_0_init+0x374>)
     308:	805a      	strh	r2, [r3, #2]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     30a:	21c0      	movs	r1, #192	; 0xc0
     30c:	05c9      	lsls	r1, r1, #23
     30e:	2001      	movs	r0, #1
     310:	2384      	movs	r3, #132	; 0x84
     312:	50c8      	str	r0, [r1, r3]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     314:	4bd6      	ldr	r3, [pc, #856]	; (670 <EXTERNAL_IRQ_0_init+0x378>)
     316:	22a8      	movs	r2, #168	; 0xa8
     318:	4cd6      	ldr	r4, [pc, #856]	; (674 <EXTERNAL_IRQ_0_init+0x37c>)
     31a:	509c      	str	r4, [r3, r2]
     31c:	4dd6      	ldr	r5, [pc, #856]	; (678 <EXTERNAL_IRQ_0_init+0x380>)
     31e:	509d      	str	r5, [r3, r2]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     320:	2484      	movs	r4, #132	; 0x84
     322:	5108      	str	r0, [r1, r4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     324:	343c      	adds	r4, #60	; 0x3c
     326:	46a4      	mov	ip, r4
     328:	5d1c      	ldrb	r4, [r3, r4]
     32a:	2704      	movs	r7, #4
     32c:	46bb      	mov	fp, r7
     32e:	46b9      	mov	r9, r7
     330:	464f      	mov	r7, r9
     332:	433c      	orrs	r4, r7
     334:	b2e4      	uxtb	r4, r4
     336:	4667      	mov	r7, ip
     338:	55dc      	strb	r4, [r3, r7]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     33a:	2494      	movs	r4, #148	; 0x94
     33c:	5108      	str	r0, [r1, r4]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     33e:	5ddf      	ldrb	r7, [r3, r7]
	tmp &= ~PORT_PINCFG_PMUXEN;
     340:	4387      	bics	r7, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     342:	2401      	movs	r4, #1
     344:	4327      	orrs	r7, r4
     346:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     348:	4666      	mov	r6, ip
     34a:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     34c:	3e10      	subs	r6, #16
     34e:	46b4      	mov	ip, r6
     350:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     352:	3ea1      	subs	r6, #161	; 0xa1
     354:	43b7      	bics	r7, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     356:	4666      	mov	r6, ip
     358:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     35a:	3eae      	subs	r6, #174	; 0xae
     35c:	46b2      	mov	sl, r6
     35e:	2784      	movs	r7, #132	; 0x84
     360:	51ce      	str	r6, [r1, r7]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     362:	4fc6      	ldr	r7, [pc, #792]	; (67c <EXTERNAL_IRQ_0_init+0x384>)
     364:	509f      	str	r7, [r3, r2]
     366:	509d      	str	r5, [r3, r2]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     368:	2784      	movs	r7, #132	; 0x84
     36a:	51ce      	str	r6, [r1, r7]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     36c:	36bf      	adds	r6, #191	; 0xbf
     36e:	46b0      	mov	r8, r6
     370:	5d9f      	ldrb	r7, [r3, r6]
     372:	464e      	mov	r6, r9
     374:	4337      	orrs	r7, r6
     376:	b2ff      	uxtb	r7, r7
     378:	4646      	mov	r6, r8
     37a:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     37c:	3e2d      	subs	r6, #45	; 0x2d
     37e:	4657      	mov	r7, sl
     380:	518f      	str	r7, [r1, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     382:	4646      	mov	r6, r8
     384:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     386:	4387      	bics	r7, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     388:	4327      	orrs	r7, r4
     38a:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     38c:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     38e:	4666      	mov	r6, ip
     390:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     392:	3ea1      	subs	r6, #161	; 0xa1
     394:	46b2      	mov	sl, r6
     396:	4037      	ands	r7, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     398:	4666      	mov	r6, ip
     39a:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     39c:	465e      	mov	r6, fp
     39e:	2784      	movs	r7, #132	; 0x84
     3a0:	51ce      	str	r6, [r1, r7]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     3a2:	4fb7      	ldr	r7, [pc, #732]	; (680 <EXTERNAL_IRQ_0_init+0x388>)
     3a4:	509f      	str	r7, [r3, r2]
     3a6:	509d      	str	r5, [r3, r2]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     3a8:	36be      	adds	r6, #190	; 0xbe
     3aa:	46b4      	mov	ip, r6
     3ac:	5d9f      	ldrb	r7, [r3, r6]
     3ae:	465e      	mov	r6, fp
     3b0:	43b7      	bics	r7, r6
     3b2:	4666      	mov	r6, ip
     3b4:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     3b6:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     3b8:	4387      	bics	r7, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     3ba:	4327      	orrs	r7, r4
     3bc:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     3be:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     3c0:	3e11      	subs	r6, #17
     3c2:	46b4      	mov	ip, r6
     3c4:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     3c6:	3ea2      	subs	r6, #162	; 0xa2
     3c8:	43b7      	bics	r7, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     3ca:	4666      	mov	r6, ip
     3cc:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     3ce:	3ea9      	subs	r6, #169	; 0xa9
     3d0:	2784      	movs	r7, #132	; 0x84
     3d2:	51ce      	str	r6, [r1, r7]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     3d4:	4fab      	ldr	r7, [pc, #684]	; (684 <EXTERNAL_IRQ_0_init+0x38c>)
     3d6:	509f      	str	r7, [r3, r2]
     3d8:	509d      	str	r5, [r3, r2]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     3da:	2784      	movs	r7, #132	; 0x84
     3dc:	51ce      	str	r6, [r1, r7]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     3de:	36bb      	adds	r6, #187	; 0xbb
     3e0:	46b0      	mov	r8, r6
     3e2:	5d9f      	ldrb	r7, [r3, r6]
     3e4:	464e      	mov	r6, r9
     3e6:	4337      	orrs	r7, r6
     3e8:	b2ff      	uxtb	r7, r7
     3ea:	4646      	mov	r6, r8
     3ec:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     3ee:	2798      	movs	r7, #152	; 0x98
     3f0:	3ebb      	subs	r6, #187	; 0xbb
     3f2:	51ce      	str	r6, [r1, r7]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     3f4:	4646      	mov	r6, r8
     3f6:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     3f8:	4387      	bics	r7, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     3fa:	4327      	orrs	r7, r4
     3fc:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     3fe:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     400:	4666      	mov	r6, ip
     402:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     404:	4656      	mov	r6, sl
     406:	4037      	ands	r7, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     408:	4666      	mov	r6, ip
     40a:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     40c:	2780      	movs	r7, #128	; 0x80
     40e:	00bf      	lsls	r7, r7, #2
     410:	3e2d      	subs	r6, #45	; 0x2d
     412:	518f      	str	r7, [r1, r6]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     414:	4f9c      	ldr	r7, [pc, #624]	; (688 <EXTERNAL_IRQ_0_init+0x390>)
     416:	509f      	str	r7, [r3, r2]
     418:	509d      	str	r5, [r3, r2]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     41a:	3645      	adds	r6, #69	; 0x45
     41c:	46b4      	mov	ip, r6
     41e:	5d9f      	ldrb	r7, [r3, r6]
     420:	465e      	mov	r6, fp
     422:	43b7      	bics	r7, r6
     424:	4666      	mov	r6, ip
     426:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     428:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     42a:	4387      	bics	r7, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     42c:	4327      	orrs	r7, r4
     42e:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     430:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     432:	3e15      	subs	r6, #21
     434:	46b0      	mov	r8, r6
     436:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     438:	4656      	mov	r6, sl
     43a:	4037      	ands	r7, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     43c:	4646      	mov	r6, r8
     43e:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     440:	2780      	movs	r7, #128	; 0x80
     442:	01ff      	lsls	r7, r7, #7
     444:	3e30      	subs	r6, #48	; 0x30
     446:	518f      	str	r7, [r1, r6]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     448:	4f90      	ldr	r7, [pc, #576]	; (68c <EXTERNAL_IRQ_0_init+0x394>)
     44a:	509f      	str	r7, [r3, r2]
     44c:	509d      	str	r5, [r3, r2]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     44e:	364a      	adds	r6, #74	; 0x4a
     450:	46b4      	mov	ip, r6
     452:	5d9f      	ldrb	r7, [r3, r6]
     454:	465e      	mov	r6, fp
     456:	43b7      	bics	r7, r6
     458:	4666      	mov	r6, ip
     45a:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     45c:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     45e:	4387      	bics	r7, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     460:	4327      	orrs	r7, r4
     462:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     464:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     466:	3e17      	subs	r6, #23
     468:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     46a:	3ea8      	subs	r6, #168	; 0xa8
     46c:	43b7      	bics	r7, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     46e:	36a8      	adds	r6, #168	; 0xa8
     470:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     472:	2710      	movs	r7, #16
     474:	604f      	str	r7, [r1, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     476:	4f86      	ldr	r7, [pc, #536]	; (690 <EXTERNAL_IRQ_0_init+0x398>)
     478:	629f      	str	r7, [r3, #40]	; 0x28
     47a:	629d      	str	r5, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     47c:	3e73      	subs	r6, #115	; 0x73
     47e:	46b4      	mov	ip, r6
     480:	5d9f      	ldrb	r7, [r3, r6]
     482:	465e      	mov	r6, fp
     484:	43b7      	bics	r7, r6
     486:	4666      	mov	r6, ip
     488:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     48a:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     48c:	4387      	bics	r7, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     48e:	4327      	orrs	r7, r4
     490:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     492:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     494:	3e12      	subs	r6, #18
     496:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     498:	3e23      	subs	r6, #35	; 0x23
     49a:	43b7      	bics	r7, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     49c:	3623      	adds	r6, #35	; 0x23
     49e:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     4a0:	2780      	movs	r7, #128	; 0x80
     4a2:	01bf      	lsls	r7, r7, #6
     4a4:	3652      	adds	r6, #82	; 0x52
     4a6:	518f      	str	r7, [r1, r6]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     4a8:	4f7a      	ldr	r7, [pc, #488]	; (694 <EXTERNAL_IRQ_0_init+0x39c>)
     4aa:	509f      	str	r7, [r3, r2]
     4ac:	509d      	str	r5, [r3, r2]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     4ae:	3649      	adds	r6, #73	; 0x49
     4b0:	46b4      	mov	ip, r6
     4b2:	5d9f      	ldrb	r7, [r3, r6]
     4b4:	465e      	mov	r6, fp
     4b6:	43b7      	bics	r7, r6
     4b8:	4666      	mov	r6, ip
     4ba:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     4bc:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     4be:	4387      	bics	r7, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     4c0:	4327      	orrs	r7, r4
     4c2:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     4c4:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     4c6:	3e17      	subs	r6, #23
     4c8:	46b4      	mov	ip, r6
     4ca:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     4cc:	4656      	mov	r6, sl
     4ce:	4037      	ands	r7, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     4d0:	4666      	mov	r6, ip
     4d2:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     4d4:	2780      	movs	r7, #128	; 0x80
     4d6:	007f      	lsls	r7, r7, #1
     4d8:	3e32      	subs	r6, #50	; 0x32
     4da:	518f      	str	r7, [r1, r6]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     4dc:	4f6e      	ldr	r7, [pc, #440]	; (698 <EXTERNAL_IRQ_0_init+0x3a0>)
     4de:	509f      	str	r7, [r3, r2]
     4e0:	509d      	str	r5, [r3, r2]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     4e2:	3644      	adds	r6, #68	; 0x44
     4e4:	46b1      	mov	r9, r6
     4e6:	5d9f      	ldrb	r7, [r3, r6]
     4e8:	465e      	mov	r6, fp
     4ea:	43b7      	bics	r7, r6
     4ec:	464e      	mov	r6, r9
     4ee:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     4f0:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     4f2:	4387      	bics	r7, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     4f4:	4327      	orrs	r7, r4
     4f6:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     4f8:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     4fa:	4646      	mov	r6, r8
     4fc:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     4fe:	3ea5      	subs	r6, #165	; 0xa5
     500:	43b7      	bics	r7, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     502:	4646      	mov	r6, r8
     504:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     506:	2780      	movs	r7, #128	; 0x80
     508:	023f      	lsls	r7, r7, #8
     50a:	3e30      	subs	r6, #48	; 0x30
     50c:	518f      	str	r7, [r1, r6]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     50e:	4f63      	ldr	r7, [pc, #396]	; (69c <EXTERNAL_IRQ_0_init+0x3a4>)
     510:	509f      	str	r7, [r3, r2]
     512:	509d      	str	r5, [r3, r2]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     514:	364b      	adds	r6, #75	; 0x4b
     516:	46b0      	mov	r8, r6
     518:	5d9f      	ldrb	r7, [r3, r6]
     51a:	465e      	mov	r6, fp
     51c:	43b7      	bics	r7, r6
     51e:	4646      	mov	r6, r8
     520:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     522:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     524:	4387      	bics	r7, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     526:	4327      	orrs	r7, r4
     528:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     52a:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     52c:	3e18      	subs	r6, #24
     52e:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     530:	4656      	mov	r6, sl
     532:	4037      	ands	r7, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     534:	36a8      	adds	r6, #168	; 0xa8
     536:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     538:	2720      	movs	r7, #32
     53a:	604f      	str	r7, [r1, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     53c:	4f58      	ldr	r7, [pc, #352]	; (6a0 <EXTERNAL_IRQ_0_init+0x3a8>)
     53e:	629f      	str	r7, [r3, #40]	; 0x28
     540:	629d      	str	r5, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     542:	3e72      	subs	r6, #114	; 0x72
     544:	46b0      	mov	r8, r6
     546:	5d9f      	ldrb	r7, [r3, r6]
     548:	465e      	mov	r6, fp
     54a:	43b7      	bics	r7, r6
     54c:	4646      	mov	r6, r8
     54e:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     550:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     552:	4387      	bics	r7, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     554:	4327      	orrs	r7, r4
     556:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     558:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     55a:	3e13      	subs	r6, #19
     55c:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     55e:	4656      	mov	r6, sl
     560:	4037      	ands	r7, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     562:	3623      	adds	r6, #35	; 0x23
     564:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     566:	2780      	movs	r7, #128	; 0x80
     568:	017f      	lsls	r7, r7, #5
     56a:	3652      	adds	r6, #82	; 0x52
     56c:	518f      	str	r7, [r1, r6]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     56e:	4f4d      	ldr	r7, [pc, #308]	; (6a4 <EXTERNAL_IRQ_0_init+0x3ac>)
     570:	509f      	str	r7, [r3, r2]
     572:	509d      	str	r5, [r3, r2]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     574:	3648      	adds	r6, #72	; 0x48
     576:	46b0      	mov	r8, r6
     578:	5d9f      	ldrb	r7, [r3, r6]
     57a:	465e      	mov	r6, fp
     57c:	43b7      	bics	r7, r6
     57e:	4646      	mov	r6, r8
     580:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     582:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     584:	4387      	bics	r7, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     586:	4327      	orrs	r7, r4
     588:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     58a:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     58c:	4666      	mov	r6, ip
     58e:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     590:	3ea7      	subs	r6, #167	; 0xa7
     592:	43b7      	bics	r7, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     594:	4666      	mov	r6, ip
     596:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     598:	2740      	movs	r7, #64	; 0x40
     59a:	604f      	str	r7, [r1, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     59c:	4f42      	ldr	r7, [pc, #264]	; (6a8 <EXTERNAL_IRQ_0_init+0x3b0>)
     59e:	629f      	str	r7, [r3, #40]	; 0x28
     5a0:	629d      	str	r5, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     5a2:	3e70      	subs	r6, #112	; 0x70
     5a4:	46b4      	mov	ip, r6
     5a6:	5d9f      	ldrb	r7, [r3, r6]
     5a8:	465e      	mov	r6, fp
     5aa:	43b7      	bics	r7, r6
     5ac:	4666      	mov	r6, ip
     5ae:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5b0:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     5b2:	4387      	bics	r7, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5b4:	4327      	orrs	r7, r4
     5b6:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     5b8:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     5ba:	3e13      	subs	r6, #19
     5bc:	46b0      	mov	r8, r6
     5be:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     5c0:	3e24      	subs	r6, #36	; 0x24
     5c2:	43b7      	bics	r7, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     5c4:	4646      	mov	r6, r8
     5c6:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     5c8:	2780      	movs	r7, #128	; 0x80
     5ca:	013f      	lsls	r7, r7, #4
     5cc:	3651      	adds	r6, #81	; 0x51
     5ce:	518f      	str	r7, [r1, r6]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     5d0:	4f36      	ldr	r7, [pc, #216]	; (6ac <EXTERNAL_IRQ_0_init+0x3b4>)
     5d2:	509f      	str	r7, [r3, r2]
     5d4:	509d      	str	r5, [r3, r2]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     5d6:	3647      	adds	r6, #71	; 0x47
     5d8:	46b4      	mov	ip, r6
     5da:	5d9f      	ldrb	r7, [r3, r6]
     5dc:	465e      	mov	r6, fp
     5de:	43b7      	bics	r7, r6
     5e0:	4666      	mov	r6, ip
     5e2:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5e4:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     5e6:	4387      	bics	r7, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5e8:	4327      	orrs	r7, r4
     5ea:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     5ec:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     5ee:	3e16      	subs	r6, #22
     5f0:	46b4      	mov	ip, r6
     5f2:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     5f4:	4656      	mov	r6, sl
     5f6:	4037      	ands	r7, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     5f8:	4666      	mov	r6, ip
     5fa:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     5fc:	2780      	movs	r7, #128	; 0x80
     5fe:	604f      	str	r7, [r1, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     600:	4f2b      	ldr	r7, [pc, #172]	; (6b0 <EXTERNAL_IRQ_0_init+0x3b8>)
     602:	629f      	str	r7, [r3, #40]	; 0x28
     604:	629d      	str	r5, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     606:	3e6e      	subs	r6, #110	; 0x6e
     608:	46b1      	mov	r9, r6
     60a:	5d9f      	ldrb	r7, [r3, r6]
     60c:	465e      	mov	r6, fp
     60e:	43b7      	bics	r7, r6
     610:	464e      	mov	r6, r9
     612:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     614:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     616:	4387      	bics	r7, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     618:	4327      	orrs	r7, r4
     61a:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     61c:	559f      	strb	r7, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     61e:	4646      	mov	r6, r8
     620:	5d9f      	ldrb	r7, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     622:	4656      	mov	r6, sl
     624:	4037      	ands	r7, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     626:	4646      	mov	r6, r8
     628:	559f      	strb	r7, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     62a:	2780      	movs	r7, #128	; 0x80
     62c:	00ff      	lsls	r7, r7, #3
     62e:	3651      	adds	r6, #81	; 0x51
     630:	518f      	str	r7, [r1, r6]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     632:	4920      	ldr	r1, [pc, #128]	; (6b4 <EXTERNAL_IRQ_0_init+0x3bc>)
     634:	5099      	str	r1, [r3, r2]
     636:	509d      	str	r5, [r3, r2]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     638:	21ca      	movs	r1, #202	; 0xca
     63a:	5c5a      	ldrb	r2, [r3, r1]
     63c:	465d      	mov	r5, fp
     63e:	43aa      	bics	r2, r5
     640:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     642:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     644:	4382      	bics	r2, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     646:	4314      	orrs	r4, r2
     648:	b2e4      	uxtb	r4, r4
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     64a:	545c      	strb	r4, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     64c:	4662      	mov	r2, ip
     64e:	5c9a      	ldrb	r2, [r3, r2]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     650:	39bb      	subs	r1, #187	; 0xbb
     652:	438a      	bics	r2, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     654:	4661      	mov	r1, ip
     656:	545a      	strb	r2, [r3, r1]
	ext_irq_init();
     658:	4b17      	ldr	r3, [pc, #92]	; (6b8 <EXTERNAL_IRQ_0_init+0x3c0>)
     65a:	4798      	blx	r3
}
     65c:	bc3c      	pop	{r2, r3, r4, r5}
     65e:	4690      	mov	r8, r2
     660:	4699      	mov	r9, r3
     662:	46a2      	mov	sl, r4
     664:	46ab      	mov	fp, r5
     666:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     668:	00004005 	.word	0x00004005
     66c:	40000c00 	.word	0x40000c00
     670:	41004400 	.word	0x41004400
     674:	40020001 	.word	0x40020001
     678:	c0020000 	.word	0xc0020000
     67c:	40020002 	.word	0x40020002
     680:	40020004 	.word	0x40020004
     684:	40020008 	.word	0x40020008
     688:	40020200 	.word	0x40020200
     68c:	40024000 	.word	0x40024000
     690:	40020010 	.word	0x40020010
     694:	40022000 	.word	0x40022000
     698:	40020100 	.word	0x40020100
     69c:	40028000 	.word	0x40028000
     6a0:	40020020 	.word	0x40020020
     6a4:	40021000 	.word	0x40021000
     6a8:	40020040 	.word	0x40020040
     6ac:	40020800 	.word	0x40020800
     6b0:	40020080 	.word	0x40020080
     6b4:	40020400 	.word	0x40020400
     6b8:	00001481 	.word	0x00001481

000006bc <FLASH_0_CLOCK_init>:
			PM->APBBMASK.reg |= 1 << peripheral;
     6bc:	4a02      	ldr	r2, [pc, #8]	; (6c8 <FLASH_0_CLOCK_init+0xc>)
     6be:	69d3      	ldr	r3, [r2, #28]
     6c0:	2104      	movs	r1, #4
     6c2:	430b      	orrs	r3, r1
     6c4:	61d3      	str	r3, [r2, #28]
}
     6c6:	4770      	bx	lr
     6c8:	40000400 	.word	0x40000400

000006cc <FLASH_0_init>:
{
     6cc:	b510      	push	{r4, lr}
	FLASH_0_CLOCK_init();
     6ce:	4b03      	ldr	r3, [pc, #12]	; (6dc <FLASH_0_init+0x10>)
     6d0:	4798      	blx	r3
	flash_init(&FLASH_0, NVMCTRL);
     6d2:	4903      	ldr	r1, [pc, #12]	; (6e0 <FLASH_0_init+0x14>)
     6d4:	4803      	ldr	r0, [pc, #12]	; (6e4 <FLASH_0_init+0x18>)
     6d6:	4b04      	ldr	r3, [pc, #16]	; (6e8 <FLASH_0_init+0x1c>)
     6d8:	4798      	blx	r3
}
     6da:	bd10      	pop	{r4, pc}
     6dc:	000006bd 	.word	0x000006bd
     6e0:	41004000 	.word	0x41004000
     6e4:	20000900 	.word	0x20000900
     6e8:	000015f1 	.word	0x000015f1

000006ec <SPI_0_PORT_init>:
{
     6ec:	b5f0      	push	{r4, r5, r6, r7, lr}
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     6ee:	24c0      	movs	r4, #192	; 0xc0
     6f0:	05e4      	lsls	r4, r4, #23
     6f2:	2380      	movs	r3, #128	; 0x80
     6f4:	005b      	lsls	r3, r3, #1
     6f6:	6163      	str	r3, [r4, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     6f8:	60a3      	str	r3, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     6fa:	4b22      	ldr	r3, [pc, #136]	; (784 <SPI_0_PORT_init+0x98>)
     6fc:	4a22      	ldr	r2, [pc, #136]	; (788 <SPI_0_PORT_init+0x9c>)
     6fe:	629a      	str	r2, [r3, #40]	; 0x28
     700:	20c0      	movs	r0, #192	; 0xc0
     702:	0600      	lsls	r0, r0, #24
     704:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     706:	2148      	movs	r1, #72	; 0x48
     708:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     70a:	2501      	movs	r5, #1
     70c:	46ac      	mov	ip, r5
     70e:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     710:	2701      	movs	r7, #1
     712:	433a      	orrs	r2, r7
     714:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     716:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     718:	3914      	subs	r1, #20
     71a:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     71c:	350e      	adds	r5, #14
     71e:	43aa      	bics	r2, r5
	tmp |= PORT_PMUX_PMUXE(data);
     720:	2502      	movs	r5, #2
     722:	432a      	orrs	r2, r5
     724:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     726:	545a      	strb	r2, [r3, r1]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     728:	2280      	movs	r2, #128	; 0x80
     72a:	0092      	lsls	r2, r2, #2
     72c:	6162      	str	r2, [r4, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     72e:	60a2      	str	r2, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     730:	4a16      	ldr	r2, [pc, #88]	; (78c <SPI_0_PORT_init+0xa0>)
     732:	629a      	str	r2, [r3, #40]	; 0x28
     734:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     736:	2049      	movs	r0, #73	; 0x49
     738:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
     73a:	4665      	mov	r5, ip
     73c:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     73e:	433a      	orrs	r2, r7
     740:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     742:	541a      	strb	r2, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     744:	5c58      	ldrb	r0, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     746:	260f      	movs	r6, #15
     748:	4030      	ands	r0, r6
	tmp |= PORT_PMUX_PMUXO(data);
     74a:	2520      	movs	r5, #32
     74c:	4328      	orrs	r0, r5
     74e:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     750:	5458      	strb	r0, [r3, r1]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     752:	2280      	movs	r2, #128	; 0x80
     754:	0112      	lsls	r2, r2, #4
     756:	6062      	str	r2, [r4, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     758:	4a0d      	ldr	r2, [pc, #52]	; (790 <SPI_0_PORT_init+0xa4>)
     75a:	629a      	str	r2, [r3, #40]	; 0x28
     75c:	4a0d      	ldr	r2, [pc, #52]	; (794 <SPI_0_PORT_init+0xa8>)
     75e:	629a      	str	r2, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     760:	224b      	movs	r2, #75	; 0x4b
     762:	5c99      	ldrb	r1, [r3, r2]
     764:	2004      	movs	r0, #4
     766:	4381      	bics	r1, r0
     768:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     76a:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
     76c:	4660      	mov	r0, ip
     76e:	4381      	bics	r1, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     770:	4339      	orrs	r1, r7
     772:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     774:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     776:	2135      	movs	r1, #53	; 0x35
     778:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     77a:	4032      	ands	r2, r6
	tmp |= PORT_PMUX_PMUXO(data);
     77c:	432a      	orrs	r2, r5
     77e:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     780:	545a      	strb	r2, [r3, r1]
}
     782:	bdf0      	pop	{r4, r5, r6, r7, pc}
     784:	41004400 	.word	0x41004400
     788:	40000100 	.word	0x40000100
     78c:	40000200 	.word	0x40000200
     790:	40020800 	.word	0x40020800
     794:	c0020000 	.word	0xc0020000

00000798 <SPI_0_CLOCK_init>:
		PM->APBCMASK.reg |= 1 << peripheral;
     798:	4a04      	ldr	r2, [pc, #16]	; (7ac <SPI_0_CLOCK_init+0x14>)
     79a:	6a13      	ldr	r3, [r2, #32]
     79c:	2104      	movs	r1, #4
     79e:	430b      	orrs	r3, r1
     7a0:	6213      	str	r3, [r2, #32]
     7a2:	4a03      	ldr	r2, [pc, #12]	; (7b0 <SPI_0_CLOCK_init+0x18>)
     7a4:	4b03      	ldr	r3, [pc, #12]	; (7b4 <SPI_0_CLOCK_init+0x1c>)
     7a6:	805a      	strh	r2, [r3, #2]
}
     7a8:	4770      	bx	lr
     7aa:	46c0      	nop			; (mov r8, r8)
     7ac:	40000400 	.word	0x40000400
     7b0:	00004014 	.word	0x00004014
     7b4:	40000c00 	.word	0x40000c00

000007b8 <SPI_0_init>:
{
     7b8:	b510      	push	{r4, lr}
	SPI_0_CLOCK_init();
     7ba:	4b04      	ldr	r3, [pc, #16]	; (7cc <SPI_0_init+0x14>)
     7bc:	4798      	blx	r3
	spi_m_sync_init(&SPI_0, SERCOM0);
     7be:	4904      	ldr	r1, [pc, #16]	; (7d0 <SPI_0_init+0x18>)
     7c0:	4804      	ldr	r0, [pc, #16]	; (7d4 <SPI_0_init+0x1c>)
     7c2:	4b05      	ldr	r3, [pc, #20]	; (7d8 <SPI_0_init+0x20>)
     7c4:	4798      	blx	r3
	SPI_0_PORT_init();
     7c6:	4b05      	ldr	r3, [pc, #20]	; (7dc <SPI_0_init+0x24>)
     7c8:	4798      	blx	r3
}
     7ca:	bd10      	pop	{r4, pc}
     7cc:	00000799 	.word	0x00000799
     7d0:	42000800 	.word	0x42000800
     7d4:	20000984 	.word	0x20000984
     7d8:	000019b9 	.word	0x000019b9
     7dc:	000006ed 	.word	0x000006ed

000007e0 <USART_1_CLOCK_init>:
     7e0:	4a04      	ldr	r2, [pc, #16]	; (7f4 <USART_1_CLOCK_init+0x14>)
     7e2:	6a13      	ldr	r3, [r2, #32]
     7e4:	2108      	movs	r1, #8
     7e6:	430b      	orrs	r3, r1
     7e8:	6213      	str	r3, [r2, #32]
     7ea:	4a03      	ldr	r2, [pc, #12]	; (7f8 <USART_1_CLOCK_init+0x18>)
     7ec:	4b03      	ldr	r3, [pc, #12]	; (7fc <USART_1_CLOCK_init+0x1c>)
     7ee:	805a      	strh	r2, [r3, #2]
}
     7f0:	4770      	bx	lr
     7f2:	46c0      	nop			; (mov r8, r8)
     7f4:	40000400 	.word	0x40000400
     7f8:	00004015 	.word	0x00004015
     7fc:	40000c00 	.word	0x40000c00

00000800 <USART_1_PORT_init>:
{
     800:	b530      	push	{r4, r5, lr}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     802:	4b0f      	ldr	r3, [pc, #60]	; (840 <USART_1_PORT_init+0x40>)
     804:	2250      	movs	r2, #80	; 0x50
     806:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
     808:	2501      	movs	r5, #1
     80a:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     80c:	2401      	movs	r4, #1
     80e:	4321      	orrs	r1, r4
     810:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     812:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     814:	2038      	movs	r0, #56	; 0x38
     816:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     818:	3a41      	subs	r2, #65	; 0x41
     81a:	4391      	bics	r1, r2
	tmp |= PORT_PMUX_PMUXE(data);
     81c:	2202      	movs	r2, #2
     81e:	4311      	orrs	r1, r2
     820:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     822:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     824:	2151      	movs	r1, #81	; 0x51
     826:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     828:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     82a:	4322      	orrs	r2, r4
     82c:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     82e:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     830:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     832:	3942      	subs	r1, #66	; 0x42
     834:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
     836:	2120      	movs	r1, #32
     838:	430a      	orrs	r2, r1
     83a:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     83c:	541a      	strb	r2, [r3, r0]
}
     83e:	bd30      	pop	{r4, r5, pc}
     840:	41004400 	.word	0x41004400

00000844 <USART_1_init>:
{
     844:	b510      	push	{r4, lr}
     846:	b082      	sub	sp, #8
	USART_1_CLOCK_init();
     848:	4b07      	ldr	r3, [pc, #28]	; (868 <USART_1_init+0x24>)
     84a:	4798      	blx	r3
	usart_async_init(&USART_1, SERCOM1, USART_1_buffer, USART_1_BUFFER_SIZE, (void *)NULL);
     84c:	2300      	movs	r3, #0
     84e:	9300      	str	r3, [sp, #0]
     850:	3310      	adds	r3, #16
     852:	4a06      	ldr	r2, [pc, #24]	; (86c <USART_1_init+0x28>)
     854:	3214      	adds	r2, #20
     856:	4906      	ldr	r1, [pc, #24]	; (870 <USART_1_init+0x2c>)
     858:	4806      	ldr	r0, [pc, #24]	; (874 <USART_1_init+0x30>)
     85a:	4c07      	ldr	r4, [pc, #28]	; (878 <USART_1_init+0x34>)
     85c:	47a0      	blx	r4
	USART_1_PORT_init();
     85e:	4b07      	ldr	r3, [pc, #28]	; (87c <USART_1_init+0x38>)
     860:	4798      	blx	r3
}
     862:	b002      	add	sp, #8
     864:	bd10      	pop	{r4, pc}
     866:	46c0      	nop			; (mov r8, r8)
     868:	000007e1 	.word	0x000007e1
     86c:	2000015c 	.word	0x2000015c
     870:	42000c00 	.word	0x42000c00
     874:	200009a8 	.word	0x200009a8
     878:	00001e29 	.word	0x00001e29
     87c:	00000801 	.word	0x00000801

00000880 <I2C_0_PORT_init>:
{
     880:	b570      	push	{r4, r5, r6, lr}
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     882:	4b13      	ldr	r3, [pc, #76]	; (8d0 <I2C_0_PORT_init+0x50>)
     884:	2056      	movs	r0, #86	; 0x56
     886:	5c19      	ldrb	r1, [r3, r0]
     888:	2204      	movs	r2, #4
     88a:	4391      	bics	r1, r2
     88c:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     88e:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
     890:	2501      	movs	r5, #1
     892:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     894:	2401      	movs	r4, #1
     896:	4321      	orrs	r1, r4
     898:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     89a:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     89c:	381b      	subs	r0, #27
     89e:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     8a0:	260f      	movs	r6, #15
     8a2:	43b1      	bics	r1, r6
	tmp |= PORT_PMUX_PMUXE(data);
     8a4:	2602      	movs	r6, #2
     8a6:	4331      	orrs	r1, r6
     8a8:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     8aa:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     8ac:	2157      	movs	r1, #87	; 0x57
     8ae:	5c5e      	ldrb	r6, [r3, r1]
     8b0:	4396      	bics	r6, r2
     8b2:	545e      	strb	r6, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8b4:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     8b6:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     8b8:	4322      	orrs	r2, r4
     8ba:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8bc:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     8be:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     8c0:	3948      	subs	r1, #72	; 0x48
     8c2:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
     8c4:	2120      	movs	r1, #32
     8c6:	430a      	orrs	r2, r1
     8c8:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     8ca:	541a      	strb	r2, [r3, r0]
}
     8cc:	bd70      	pop	{r4, r5, r6, pc}
     8ce:	46c0      	nop			; (mov r8, r8)
     8d0:	41004400 	.word	0x41004400

000008d4 <I2C_0_CLOCK_init>:
     8d4:	4a05      	ldr	r2, [pc, #20]	; (8ec <I2C_0_CLOCK_init+0x18>)
     8d6:	6a13      	ldr	r3, [r2, #32]
     8d8:	2120      	movs	r1, #32
     8da:	430b      	orrs	r3, r1
     8dc:	6213      	str	r3, [r2, #32]
     8de:	4b04      	ldr	r3, [pc, #16]	; (8f0 <I2C_0_CLOCK_init+0x1c>)
     8e0:	4a04      	ldr	r2, [pc, #16]	; (8f4 <I2C_0_CLOCK_init+0x20>)
     8e2:	805a      	strh	r2, [r3, #2]
     8e4:	4a04      	ldr	r2, [pc, #16]	; (8f8 <I2C_0_CLOCK_init+0x24>)
     8e6:	805a      	strh	r2, [r3, #2]
}
     8e8:	4770      	bx	lr
     8ea:	46c0      	nop			; (mov r8, r8)
     8ec:	40000400 	.word	0x40000400
     8f0:	40000c00 	.word	0x40000c00
     8f4:	00004017 	.word	0x00004017
     8f8:	00004313 	.word	0x00004313

000008fc <I2C_0_init>:
{
     8fc:	b510      	push	{r4, lr}
	I2C_0_CLOCK_init();
     8fe:	4b04      	ldr	r3, [pc, #16]	; (910 <I2C_0_init+0x14>)
     900:	4798      	blx	r3
	i2c_m_sync_init(&I2C_0, SERCOM3);
     902:	4904      	ldr	r1, [pc, #16]	; (914 <I2C_0_init+0x18>)
     904:	4804      	ldr	r0, [pc, #16]	; (918 <I2C_0_init+0x1c>)
     906:	4b05      	ldr	r3, [pc, #20]	; (91c <I2C_0_init+0x20>)
     908:	4798      	blx	r3
	I2C_0_PORT_init();
     90a:	4b05      	ldr	r3, [pc, #20]	; (920 <I2C_0_init+0x24>)
     90c:	4798      	blx	r3
}
     90e:	bd10      	pop	{r4, pc}
     910:	000008d5 	.word	0x000008d5
     914:	42001400 	.word	0x42001400
     918:	200009f8 	.word	0x200009f8
     91c:	00001909 	.word	0x00001909
     920:	00000881 	.word	0x00000881

00000924 <USART_0_PORT_init>:
{
     924:	b530      	push	{r4, r5, lr}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     926:	4b0f      	ldr	r3, [pc, #60]	; (964 <USART_0_PORT_init+0x40>)
     928:	22d6      	movs	r2, #214	; 0xd6
     92a:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
     92c:	2501      	movs	r5, #1
     92e:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     930:	2401      	movs	r4, #1
     932:	4321      	orrs	r1, r4
     934:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     936:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     938:	20bb      	movs	r0, #187	; 0xbb
     93a:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     93c:	3ac7      	subs	r2, #199	; 0xc7
     93e:	4391      	bics	r1, r2
	tmp |= PORT_PMUX_PMUXE(data);
     940:	2203      	movs	r2, #3
     942:	4311      	orrs	r1, r2
     944:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     946:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     948:	21d7      	movs	r1, #215	; 0xd7
     94a:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     94c:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     94e:	4322      	orrs	r2, r4
     950:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     952:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     954:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     956:	39c8      	subs	r1, #200	; 0xc8
     958:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
     95a:	2130      	movs	r1, #48	; 0x30
     95c:	430a      	orrs	r2, r1
     95e:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     960:	541a      	strb	r2, [r3, r0]
}
     962:	bd30      	pop	{r4, r5, pc}
     964:	41004400 	.word	0x41004400

00000968 <USART_0_CLOCK_init>:
     968:	4a04      	ldr	r2, [pc, #16]	; (97c <USART_0_CLOCK_init+0x14>)
     96a:	6a13      	ldr	r3, [r2, #32]
     96c:	2180      	movs	r1, #128	; 0x80
     96e:	430b      	orrs	r3, r1
     970:	6213      	str	r3, [r2, #32]
     972:	4a03      	ldr	r2, [pc, #12]	; (980 <USART_0_CLOCK_init+0x18>)
     974:	4b03      	ldr	r3, [pc, #12]	; (984 <USART_0_CLOCK_init+0x1c>)
     976:	805a      	strh	r2, [r3, #2]
}
     978:	4770      	bx	lr
     97a:	46c0      	nop			; (mov r8, r8)
     97c:	40000400 	.word	0x40000400
     980:	00004019 	.word	0x00004019
     984:	40000c00 	.word	0x40000c00

00000988 <USART_0_init>:
{
     988:	b510      	push	{r4, lr}
	USART_0_CLOCK_init();
     98a:	4b05      	ldr	r3, [pc, #20]	; (9a0 <USART_0_init+0x18>)
     98c:	4798      	blx	r3
	usart_sync_init(&USART_0, SERCOM5, (void *)NULL);
     98e:	2200      	movs	r2, #0
     990:	4904      	ldr	r1, [pc, #16]	; (9a4 <USART_0_init+0x1c>)
     992:	4805      	ldr	r0, [pc, #20]	; (9a8 <USART_0_init+0x20>)
     994:	4b05      	ldr	r3, [pc, #20]	; (9ac <USART_0_init+0x24>)
     996:	4798      	blx	r3
	USART_0_PORT_init();
     998:	4b05      	ldr	r3, [pc, #20]	; (9b0 <USART_0_init+0x28>)
     99a:	4798      	blx	r3
}
     99c:	bd10      	pop	{r4, pc}
     99e:	46c0      	nop			; (mov r8, r8)
     9a0:	00000969 	.word	0x00000969
     9a4:	42001c00 	.word	0x42001c00
     9a8:	2000099c 	.word	0x2000099c
     9ac:	000020a1 	.word	0x000020a1
     9b0:	00000925 	.word	0x00000925

000009b4 <DAC_0_PORT_init>:

void DAC_0_PORT_init(void)
{
     9b4:	b510      	push	{r4, lr}
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     9b6:	2204      	movs	r2, #4
     9b8:	23c0      	movs	r3, #192	; 0xc0
     9ba:	05db      	lsls	r3, r3, #23
     9bc:	605a      	str	r2, [r3, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     9be:	490a      	ldr	r1, [pc, #40]	; (9e8 <DAC_0_PORT_init+0x34>)
     9c0:	4b0a      	ldr	r3, [pc, #40]	; (9ec <DAC_0_PORT_init+0x38>)
     9c2:	628b      	str	r3, [r1, #40]	; 0x28
     9c4:	23c0      	movs	r3, #192	; 0xc0
     9c6:	061b      	lsls	r3, r3, #24
     9c8:	628b      	str	r3, [r1, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     9ca:	2342      	movs	r3, #66	; 0x42
     9cc:	5cca      	ldrb	r2, [r1, r3]
	tmp &= ~PORT_PINCFG_PMUXEN;
     9ce:	2001      	movs	r0, #1
     9d0:	4382      	bics	r2, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     9d2:	4302      	orrs	r2, r0
     9d4:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     9d6:	54ca      	strb	r2, [r1, r3]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     9d8:	2231      	movs	r2, #49	; 0x31
     9da:	5c8b      	ldrb	r3, [r1, r2]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     9dc:	240f      	movs	r4, #15
     9de:	43a3      	bics	r3, r4
	tmp |= PORT_PMUX_PMUXE(data);
     9e0:	4303      	orrs	r3, r0
     9e2:	b2db      	uxtb	r3, r3
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     9e4:	548b      	strb	r3, [r1, r2]

	// Disable digital pin circuitry
	gpio_set_pin_direction(uC_AUD, GPIO_DIRECTION_OFF);

	gpio_set_pin_function(uC_AUD, PINMUX_PA02B_DAC_VOUT);
}
     9e6:	bd10      	pop	{r4, pc}
     9e8:	41004400 	.word	0x41004400
     9ec:	40000004 	.word	0x40000004

000009f0 <DAC_0_CLOCK_init>:
     9f0:	4a04      	ldr	r2, [pc, #16]	; (a04 <DAC_0_CLOCK_init+0x14>)
     9f2:	6a11      	ldr	r1, [r2, #32]
     9f4:	2380      	movs	r3, #128	; 0x80
     9f6:	02db      	lsls	r3, r3, #11
     9f8:	430b      	orrs	r3, r1
     9fa:	6213      	str	r3, [r2, #32]
     9fc:	4a02      	ldr	r2, [pc, #8]	; (a08 <DAC_0_CLOCK_init+0x18>)
     9fe:	4b03      	ldr	r3, [pc, #12]	; (a0c <DAC_0_CLOCK_init+0x1c>)
     a00:	805a      	strh	r2, [r3, #2]
void DAC_0_CLOCK_init(void)
{

	_pm_enable_bus_clock(PM_BUS_APBC, DAC);
	_gclk_enable_channel(DAC_GCLK_ID, CONF_GCLK_DAC_SRC);
}
     a02:	4770      	bx	lr
     a04:	40000400 	.word	0x40000400
     a08:	00004021 	.word	0x00004021
     a0c:	40000c00 	.word	0x40000c00

00000a10 <DAC_0_init>:

void DAC_0_init(void)
{
     a10:	b510      	push	{r4, lr}
	DAC_0_CLOCK_init();
     a12:	4b04      	ldr	r3, [pc, #16]	; (a24 <DAC_0_init+0x14>)
     a14:	4798      	blx	r3
	dac_async_init(&DAC_0, DAC);
     a16:	4904      	ldr	r1, [pc, #16]	; (a28 <DAC_0_init+0x18>)
     a18:	4804      	ldr	r0, [pc, #16]	; (a2c <DAC_0_init+0x1c>)
     a1a:	4b05      	ldr	r3, [pc, #20]	; (a30 <DAC_0_init+0x20>)
     a1c:	4798      	blx	r3
	DAC_0_PORT_init();
     a1e:	4b05      	ldr	r3, [pc, #20]	; (a34 <DAC_0_init+0x24>)
     a20:	4798      	blx	r3
}
     a22:	bd10      	pop	{r4, pc}
     a24:	000009f1 	.word	0x000009f1
     a28:	42004800 	.word	0x42004800
     a2c:	20000948 	.word	0x20000948
     a30:	000012e1 	.word	0x000012e1
     a34:	000009b5 	.word	0x000009b5

00000a38 <USB_0_PORT_init>:

void USB_0_PORT_init(void)
{
     a38:	b5f0      	push	{r4, r5, r6, r7, lr}
     a3a:	46c6      	mov	lr, r8
     a3c:	b500      	push	{lr}
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     a3e:	24c0      	movs	r4, #192	; 0xc0
     a40:	05e4      	lsls	r4, r4, #23
     a42:	2280      	movs	r2, #128	; 0x80
     a44:	0452      	lsls	r2, r2, #17
     a46:	60a2      	str	r2, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     a48:	4b1c      	ldr	r3, [pc, #112]	; (abc <USB_0_PORT_init+0x84>)
     a4a:	2780      	movs	r7, #128	; 0x80
     a4c:	05ff      	lsls	r7, r7, #23
     a4e:	629f      	str	r7, [r3, #40]	; 0x28
     a50:	491b      	ldr	r1, [pc, #108]	; (ac0 <USB_0_PORT_init+0x88>)
     a52:	6299      	str	r1, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     a54:	6162      	str	r2, [r4, #20]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     a56:	2058      	movs	r0, #88	; 0x58
     a58:	5c19      	ldrb	r1, [r3, r0]
     a5a:	2204      	movs	r2, #4
     a5c:	4690      	mov	r8, r2
     a5e:	4391      	bics	r1, r2
     a60:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a62:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
     a64:	2601      	movs	r6, #1
     a66:	43b1      	bics	r1, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     a68:	2501      	movs	r5, #1
     a6a:	4329      	orrs	r1, r5
     a6c:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a6e:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     a70:	381c      	subs	r0, #28
     a72:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     a74:	320b      	adds	r2, #11
     a76:	4391      	bics	r1, r2
	tmp |= PORT_PMUX_PMUXE(data);
     a78:	2206      	movs	r2, #6
     a7a:	4694      	mov	ip, r2
     a7c:	4662      	mov	r2, ip
     a7e:	4311      	orrs	r1, r2
     a80:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     a82:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     a84:	2180      	movs	r1, #128	; 0x80
     a86:	0489      	lsls	r1, r1, #18
     a88:	60a1      	str	r1, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     a8a:	629f      	str	r7, [r3, #40]	; 0x28
     a8c:	4f0d      	ldr	r7, [pc, #52]	; (ac4 <USB_0_PORT_init+0x8c>)
     a8e:	629f      	str	r7, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     a90:	6161      	str	r1, [r4, #20]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     a92:	2159      	movs	r1, #89	; 0x59
     a94:	5c5c      	ldrb	r4, [r3, r1]
     a96:	4642      	mov	r2, r8
     a98:	4394      	bics	r4, r2
     a9a:	545c      	strb	r4, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a9c:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     a9e:	43b2      	bics	r2, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     aa0:	432a      	orrs	r2, r5
     aa2:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     aa4:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     aa6:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     aa8:	394a      	subs	r1, #74	; 0x4a
     aaa:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
     aac:	2160      	movs	r1, #96	; 0x60
     aae:	430a      	orrs	r2, r1
     ab0:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     ab2:	541a      	strb	r2, [r3, r0]
	                      // <GPIO_PIN_FUNCTION_E"> E
	                      // <GPIO_PIN_FUNCTION_F"> F
	                      // <GPIO_PIN_FUNCTION_G"> G
	                      // <GPIO_PIN_FUNCTION_H"> H
	                      PINMUX_PA25G_USB_DP);
}
     ab4:	bc04      	pop	{r2}
     ab6:	4690      	mov	r8, r2
     ab8:	bdf0      	pop	{r4, r5, r6, r7, pc}
     aba:	46c0      	nop			; (mov r8, r8)
     abc:	41004400 	.word	0x41004400
     ac0:	c0000100 	.word	0xc0000100
     ac4:	c0000200 	.word	0xc0000200

00000ac8 <USB_0_CLOCK_init>:
			PM->APBBMASK.reg |= 1 << peripheral;
     ac8:	4b06      	ldr	r3, [pc, #24]	; (ae4 <USB_0_CLOCK_init+0x1c>)
     aca:	69da      	ldr	r2, [r3, #28]
     acc:	2120      	movs	r1, #32
     ace:	430a      	orrs	r2, r1
     ad0:	61da      	str	r2, [r3, #28]
			PM->AHBMASK.reg |= 1 << peripheral;
     ad2:	695a      	ldr	r2, [r3, #20]
     ad4:	3120      	adds	r1, #32
     ad6:	430a      	orrs	r2, r1
     ad8:	615a      	str	r2, [r3, #20]
     ada:	4a03      	ldr	r2, [pc, #12]	; (ae8 <USB_0_CLOCK_init+0x20>)
     adc:	4b03      	ldr	r3, [pc, #12]	; (aec <USB_0_CLOCK_init+0x24>)
     ade:	805a      	strh	r2, [r3, #2]
{

	_pm_enable_bus_clock(PM_BUS_APBB, USB);
	_pm_enable_bus_clock(PM_BUS_AHB, USB);
	_gclk_enable_channel(USB_GCLK_ID, CONF_GCLK_USB_SRC);
}
     ae0:	4770      	bx	lr
     ae2:	46c0      	nop			; (mov r8, r8)
     ae4:	40000400 	.word	0x40000400
     ae8:	00004706 	.word	0x00004706
     aec:	40000c00 	.word	0x40000c00

00000af0 <USB_0_init>:

void USB_0_init(void)
{
     af0:	b510      	push	{r4, lr}
	USB_0_CLOCK_init();
     af2:	4b03      	ldr	r3, [pc, #12]	; (b00 <USB_0_init+0x10>)
     af4:	4798      	blx	r3
	usb_d_init();
     af6:	4b03      	ldr	r3, [pc, #12]	; (b04 <USB_0_init+0x14>)
     af8:	4798      	blx	r3
	USB_0_PORT_init();
     afa:	4b03      	ldr	r3, [pc, #12]	; (b08 <USB_0_init+0x18>)
     afc:	4798      	blx	r3
}
     afe:	bd10      	pop	{r4, pc}
     b00:	00000ac9 	.word	0x00000ac9
     b04:	00002365 	.word	0x00002365
     b08:	00000a39 	.word	0x00000a39

00000b0c <system_init>:

void system_init(void)
{
     b0c:	b5f0      	push	{r4, r5, r6, r7, lr}
     b0e:	46de      	mov	lr, fp
     b10:	4657      	mov	r7, sl
     b12:	464e      	mov	r6, r9
     b14:	4645      	mov	r5, r8
     b16:	b5e0      	push	{r5, r6, r7, lr}
     b18:	b083      	sub	sp, #12
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
     b1a:	4bcc      	ldr	r3, [pc, #816]	; (e4c <system_init+0x340>)
     b1c:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     b1e:	22c0      	movs	r2, #192	; 0xc0
     b20:	05d2      	lsls	r2, r2, #23
     b22:	2380      	movs	r3, #128	; 0x80
     b24:	00db      	lsls	r3, r3, #3
     b26:	6153      	str	r3, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b28:	6093      	str	r3, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b2a:	4bc9      	ldr	r3, [pc, #804]	; (e50 <system_init+0x344>)
     b2c:	49c9      	ldr	r1, [pc, #804]	; (e54 <system_init+0x348>)
     b2e:	6299      	str	r1, [r3, #40]	; 0x28
     b30:	24c0      	movs	r4, #192	; 0xc0
     b32:	0624      	lsls	r4, r4, #24
     b34:	629c      	str	r4, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b36:	254a      	movs	r5, #74	; 0x4a
     b38:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     b3a:	2101      	movs	r1, #1
     b3c:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b3e:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     b40:	2080      	movs	r0, #128	; 0x80
     b42:	0140      	lsls	r0, r0, #5
     b44:	4684      	mov	ip, r0
     b46:	6050      	str	r0, [r2, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b48:	48c3      	ldr	r0, [pc, #780]	; (e58 <system_init+0x34c>)
     b4a:	6298      	str	r0, [r3, #40]	; 0x28
     b4c:	48c3      	ldr	r0, [pc, #780]	; (e5c <system_init+0x350>)
     b4e:	6298      	str	r0, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     b50:	4660      	mov	r0, ip
     b52:	6050      	str	r0, [r2, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     b54:	3502      	adds	r5, #2
     b56:	5d58      	ldrb	r0, [r3, r5]
     b58:	2604      	movs	r6, #4
     b5a:	4330      	orrs	r0, r6
     b5c:	b2c0      	uxtb	r0, r0
     b5e:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     b60:	4660      	mov	r0, ip
     b62:	6190      	str	r0, [r2, #24]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b64:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     b66:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b68:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     b6a:	2080      	movs	r0, #128	; 0x80
     b6c:	0180      	lsls	r0, r0, #6
     b6e:	6150      	str	r0, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b70:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b72:	48bb      	ldr	r0, [pc, #748]	; (e60 <system_init+0x354>)
     b74:	6298      	str	r0, [r3, #40]	; 0x28
     b76:	629c      	str	r4, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b78:	3501      	adds	r5, #1
     b7a:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     b7c:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b7e:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     b80:	2080      	movs	r0, #128	; 0x80
     b82:	0340      	lsls	r0, r0, #13
     b84:	6150      	str	r0, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b86:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b88:	2080      	movs	r0, #128	; 0x80
     b8a:	05c0      	lsls	r0, r0, #23
     b8c:	6298      	str	r0, [r3, #40]	; 0x28
     b8e:	48b5      	ldr	r0, [pc, #724]	; (e64 <system_init+0x358>)
     b90:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b92:	2054      	movs	r0, #84	; 0x54
     b94:	4684      	mov	ip, r0
     b96:	5c18      	ldrb	r0, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
     b98:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b9a:	4665      	mov	r5, ip
     b9c:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     b9e:	2080      	movs	r0, #128	; 0x80
     ba0:	0380      	lsls	r0, r0, #14
     ba2:	6150      	str	r0, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     ba4:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     ba6:	2080      	movs	r0, #128	; 0x80
     ba8:	05c0      	lsls	r0, r0, #23
     baa:	6298      	str	r0, [r3, #40]	; 0x28
     bac:	48ae      	ldr	r0, [pc, #696]	; (e68 <system_init+0x35c>)
     bae:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     bb0:	2055      	movs	r0, #85	; 0x55
     bb2:	4684      	mov	ip, r0
     bb4:	5c18      	ldrb	r0, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
     bb6:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     bb8:	4665      	mov	r5, ip
     bba:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     bbc:	2080      	movs	r0, #128	; 0x80
     bbe:	02c0      	lsls	r0, r0, #11
     bc0:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     bc2:	2580      	movs	r5, #128	; 0x80
     bc4:	05ed      	lsls	r5, r5, #23
     bc6:	629d      	str	r5, [r3, #40]	; 0x28
     bc8:	4da8      	ldr	r5, [pc, #672]	; (e6c <system_init+0x360>)
     bca:	629d      	str	r5, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     bcc:	6150      	str	r0, [r2, #20]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     bce:	2052      	movs	r0, #82	; 0x52
     bd0:	4684      	mov	ip, r0
     bd2:	5c18      	ldrb	r0, [r3, r0]
     bd4:	2504      	movs	r5, #4
     bd6:	43a8      	bics	r0, r5
     bd8:	4665      	mov	r5, ip
     bda:	5558      	strb	r0, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     bdc:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     bde:	4388      	bics	r0, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     be0:	2501      	movs	r5, #1
     be2:	46a8      	mov	r8, r5
     be4:	4645      	mov	r5, r8
     be6:	4328      	orrs	r0, r5
     be8:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     bea:	4665      	mov	r5, ip
     bec:	5558      	strb	r0, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     bee:	2039      	movs	r0, #57	; 0x39
     bf0:	4684      	mov	ip, r0
     bf2:	5c18      	ldrb	r0, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     bf4:	3d43      	subs	r5, #67	; 0x43
     bf6:	43a8      	bics	r0, r5
	tmp |= PORT_PMUX_PMUXE(data);
     bf8:	2502      	movs	r5, #2
     bfa:	46a8      	mov	r8, r5
     bfc:	4645      	mov	r5, r8
     bfe:	4328      	orrs	r0, r5
     c00:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     c02:	4665      	mov	r5, ip
     c04:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     c06:	2080      	movs	r0, #128	; 0x80
     c08:	0300      	lsls	r0, r0, #12
     c0a:	4681      	mov	r9, r0
     c0c:	6050      	str	r0, [r2, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     c0e:	4898      	ldr	r0, [pc, #608]	; (e70 <system_init+0x364>)
     c10:	4684      	mov	ip, r0
     c12:	6298      	str	r0, [r3, #40]	; 0x28
     c14:	4897      	ldr	r0, [pc, #604]	; (e74 <system_init+0x368>)
     c16:	6298      	str	r0, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     c18:	4648      	mov	r0, r9
     c1a:	6050      	str	r0, [r2, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     c1c:	2053      	movs	r0, #83	; 0x53
     c1e:	4680      	mov	r8, r0
     c20:	5c18      	ldrb	r0, [r3, r0]
     c22:	4330      	orrs	r0, r6
     c24:	b2c0      	uxtb	r0, r0
     c26:	4645      	mov	r5, r8
     c28:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     c2a:	4648      	mov	r0, r9
     c2c:	6150      	str	r0, [r2, #20]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     c2e:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     c30:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     c32:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     c34:	2080      	movs	r0, #128	; 0x80
     c36:	01c0      	lsls	r0, r0, #7
     c38:	6150      	str	r0, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     c3a:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     c3c:	488e      	ldr	r0, [pc, #568]	; (e78 <system_init+0x36c>)
     c3e:	6298      	str	r0, [r3, #40]	; 0x28
     c40:	629c      	str	r4, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     c42:	204e      	movs	r0, #78	; 0x4e
     c44:	4680      	mov	r8, r0
     c46:	5c18      	ldrb	r0, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
     c48:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     c4a:	4645      	mov	r5, r8
     c4c:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     c4e:	2080      	movs	r0, #128	; 0x80
     c50:	0200      	lsls	r0, r0, #8
     c52:	6150      	str	r0, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     c54:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     c56:	4889      	ldr	r0, [pc, #548]	; (e7c <system_init+0x370>)
     c58:	6298      	str	r0, [r3, #40]	; 0x28
     c5a:	629c      	str	r4, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     c5c:	244f      	movs	r4, #79	; 0x4f
     c5e:	5d18      	ldrb	r0, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     c60:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     c62:	5518      	strb	r0, [r3, r4]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     c64:	2080      	movs	r0, #128	; 0x80
     c66:	0500      	lsls	r0, r0, #20
     c68:	4680      	mov	r8, r0
     c6a:	6050      	str	r0, [r2, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     c6c:	4660      	mov	r0, ip
     c6e:	6298      	str	r0, [r3, #40]	; 0x28
     c70:	4883      	ldr	r0, [pc, #524]	; (e80 <system_init+0x374>)
     c72:	6298      	str	r0, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     c74:	4640      	mov	r0, r8
     c76:	6050      	str	r0, [r2, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     c78:	340c      	adds	r4, #12
     c7a:	5d18      	ldrb	r0, [r3, r4]
     c7c:	4330      	orrs	r0, r6
     c7e:	b2c0      	uxtb	r0, r0
     c80:	5518      	strb	r0, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     c82:	4640      	mov	r0, r8
     c84:	6190      	str	r0, [r2, #24]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     c86:	5d18      	ldrb	r0, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     c88:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     c8a:	5518      	strb	r0, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     c8c:	2080      	movs	r0, #128	; 0x80
     c8e:	0540      	lsls	r0, r0, #21
     c90:	6150      	str	r0, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     c92:	6090      	str	r0, [r2, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     c94:	2080      	movs	r0, #128	; 0x80
     c96:	05c0      	lsls	r0, r0, #23
     c98:	6298      	str	r0, [r3, #40]	; 0x28
     c9a:	487a      	ldr	r0, [pc, #488]	; (e84 <system_init+0x378>)
     c9c:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     c9e:	3401      	adds	r4, #1
     ca0:	5d18      	ldrb	r0, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     ca2:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     ca4:	5518      	strb	r0, [r3, r4]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     ca6:	3428      	adds	r4, #40	; 0x28
     ca8:	2010      	movs	r0, #16
     caa:	4682      	mov	sl, r0
     cac:	5110      	str	r0, [r2, r4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     cae:	3098      	adds	r0, #152	; 0x98
     cb0:	4d75      	ldr	r5, [pc, #468]	; (e88 <system_init+0x37c>)
     cb2:	501d      	str	r5, [r3, r0]
     cb4:	4d69      	ldr	r5, [pc, #420]	; (e5c <system_init+0x350>)
     cb6:	501d      	str	r5, [r3, r0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     cb8:	4655      	mov	r5, sl
     cba:	5115      	str	r5, [r2, r4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     cbc:	35b4      	adds	r5, #180	; 0xb4
     cbe:	46a9      	mov	r9, r5
     cc0:	5d5d      	ldrb	r5, [r3, r5]
     cc2:	4335      	orrs	r5, r6
     cc4:	466f      	mov	r7, sp
     cc6:	71fd      	strb	r5, [r7, #7]
     cc8:	79fd      	ldrb	r5, [r7, #7]
     cca:	46a8      	mov	r8, r5
     ccc:	464d      	mov	r5, r9
     cce:	4647      	mov	r7, r8
     cd0:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     cd2:	3d30      	subs	r5, #48	; 0x30
     cd4:	46a8      	mov	r8, r5
     cd6:	4657      	mov	r7, sl
     cd8:	5157      	str	r7, [r2, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     cda:	464d      	mov	r5, r9
     cdc:	5d5d      	ldrb	r5, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     cde:	438d      	bics	r5, r1
     ce0:	46aa      	mov	sl, r5
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     ce2:	464d      	mov	r5, r9
     ce4:	4657      	mov	r7, sl
     ce6:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     ce8:	3da4      	subs	r5, #164	; 0xa4
     cea:	46ab      	mov	fp, r5
     cec:	5115      	str	r5, [r2, r4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     cee:	4d67      	ldr	r5, [pc, #412]	; (e8c <system_init+0x380>)
     cf0:	501d      	str	r5, [r3, r0]
     cf2:	4d5a      	ldr	r5, [pc, #360]	; (e5c <system_init+0x350>)
     cf4:	501d      	str	r5, [r3, r0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     cf6:	465d      	mov	r5, fp
     cf8:	5115      	str	r5, [r2, r4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     cfa:	35a5      	adds	r5, #165	; 0xa5
     cfc:	46aa      	mov	sl, r5
     cfe:	5d5d      	ldrb	r5, [r3, r5]
     d00:	4335      	orrs	r5, r6
     d02:	466f      	mov	r7, sp
     d04:	71fd      	strb	r5, [r7, #7]
     d06:	79fd      	ldrb	r5, [r7, #7]
     d08:	46a9      	mov	r9, r5
     d0a:	4655      	mov	r5, sl
     d0c:	464f      	mov	r7, r9
     d0e:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     d10:	4645      	mov	r5, r8
     d12:	465f      	mov	r7, fp
     d14:	5157      	str	r7, [r2, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     d16:	4655      	mov	r5, sl
     d18:	5d5d      	ldrb	r5, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     d1a:	438d      	bics	r5, r1
     d1c:	46a9      	mov	r9, r5
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     d1e:	4655      	mov	r5, sl
     d20:	464f      	mov	r7, r9
     d22:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     d24:	3d85      	subs	r5, #133	; 0x85
     d26:	46ab      	mov	fp, r5
     d28:	5115      	str	r5, [r2, r4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     d2a:	4d59      	ldr	r5, [pc, #356]	; (e90 <system_init+0x384>)
     d2c:	501d      	str	r5, [r3, r0]
     d2e:	4d4b      	ldr	r5, [pc, #300]	; (e5c <system_init+0x350>)
     d30:	501d      	str	r5, [r3, r0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     d32:	465d      	mov	r5, fp
     d34:	5115      	str	r5, [r2, r4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     d36:	3586      	adds	r5, #134	; 0x86
     d38:	46a9      	mov	r9, r5
     d3a:	5d5d      	ldrb	r5, [r3, r5]
     d3c:	4335      	orrs	r5, r6
     d3e:	466f      	mov	r7, sp
     d40:	71fd      	strb	r5, [r7, #7]
     d42:	79fd      	ldrb	r5, [r7, #7]
     d44:	46aa      	mov	sl, r5
     d46:	464d      	mov	r5, r9
     d48:	4657      	mov	r7, sl
     d4a:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     d4c:	3d2e      	subs	r5, #46	; 0x2e
     d4e:	46aa      	mov	sl, r5
     d50:	465f      	mov	r7, fp
     d52:	5157      	str	r7, [r2, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     d54:	464d      	mov	r5, r9
     d56:	5d5d      	ldrb	r5, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     d58:	438d      	bics	r5, r1
     d5a:	46ab      	mov	fp, r5
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     d5c:	464d      	mov	r5, r9
     d5e:	465f      	mov	r7, fp
     d60:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     d62:	3d46      	subs	r5, #70	; 0x46
     d64:	46ab      	mov	fp, r5
     d66:	5115      	str	r5, [r2, r4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     d68:	4d4a      	ldr	r5, [pc, #296]	; (e94 <system_init+0x388>)
     d6a:	501d      	str	r5, [r3, r0]
     d6c:	4d3b      	ldr	r5, [pc, #236]	; (e5c <system_init+0x350>)
     d6e:	501d      	str	r5, [r3, r0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     d70:	465d      	mov	r5, fp
     d72:	5115      	str	r5, [r2, r4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     d74:	3547      	adds	r5, #71	; 0x47
     d76:	46a9      	mov	r9, r5
     d78:	5d5f      	ldrb	r7, [r3, r5]
     d7a:	4337      	orrs	r7, r6
     d7c:	b2ff      	uxtb	r7, r7
     d7e:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     d80:	4655      	mov	r5, sl
     d82:	465f      	mov	r7, fp
     d84:	5157      	str	r7, [r2, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     d86:	464d      	mov	r5, r9
     d88:	5d5f      	ldrb	r7, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     d8a:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     d8c:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     d8e:	2780      	movs	r7, #128	; 0x80
     d90:	02bf      	lsls	r7, r7, #10
     d92:	4645      	mov	r5, r8
     d94:	5157      	str	r7, [r2, r5]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     d96:	3d0c      	subs	r5, #12
     d98:	46a9      	mov	r9, r5
     d9a:	5157      	str	r7, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     d9c:	2580      	movs	r5, #128	; 0x80
     d9e:	05ed      	lsls	r5, r5, #23
     da0:	501d      	str	r5, [r3, r0]
     da2:	4f3d      	ldr	r7, [pc, #244]	; (e98 <system_init+0x38c>)
     da4:	501f      	str	r7, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     da6:	25d1      	movs	r5, #209	; 0xd1
     da8:	5d5f      	ldrb	r7, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     daa:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     dac:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     dae:	2780      	movs	r7, #128	; 0x80
     db0:	027f      	lsls	r7, r7, #9
     db2:	4645      	mov	r5, r8
     db4:	5157      	str	r7, [r2, r5]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     db6:	464d      	mov	r5, r9
     db8:	5157      	str	r7, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     dba:	2580      	movs	r5, #128	; 0x80
     dbc:	05ed      	lsls	r5, r5, #23
     dbe:	501d      	str	r5, [r3, r0]
     dc0:	4f36      	ldr	r7, [pc, #216]	; (e9c <system_init+0x390>)
     dc2:	501f      	str	r7, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     dc4:	25d0      	movs	r5, #208	; 0xd0
     dc6:	5d5f      	ldrb	r7, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     dc8:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     dca:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     dcc:	2580      	movs	r5, #128	; 0x80
     dce:	05ed      	lsls	r5, r5, #23
     dd0:	5115      	str	r5, [r2, r4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     dd2:	4665      	mov	r5, ip
     dd4:	501d      	str	r5, [r3, r0]
     dd6:	4f32      	ldr	r7, [pc, #200]	; (ea0 <system_init+0x394>)
     dd8:	501f      	str	r7, [r3, r0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     dda:	2580      	movs	r5, #128	; 0x80
     ddc:	05ed      	lsls	r5, r5, #23
     dde:	5115      	str	r5, [r2, r4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     de0:	27de      	movs	r7, #222	; 0xde
     de2:	5ddd      	ldrb	r5, [r3, r7]
     de4:	432e      	orrs	r6, r5
     de6:	b2f6      	uxtb	r6, r6
     de8:	55de      	strb	r6, [r3, r7]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     dea:	4655      	mov	r5, sl
     dec:	2680      	movs	r6, #128	; 0x80
     dee:	05f6      	lsls	r6, r6, #23
     df0:	5156      	str	r6, [r2, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     df2:	5ddd      	ldrb	r5, [r3, r7]
	tmp &= ~PORT_PINCFG_PMUXEN;
     df4:	438d      	bics	r5, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     df6:	55dd      	strb	r5, [r3, r7]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     df8:	2580      	movs	r5, #128	; 0x80
     dfa:	062d      	lsls	r5, r5, #24
     dfc:	5115      	str	r5, [r2, r4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     dfe:	4662      	mov	r2, ip
     e00:	501a      	str	r2, [r3, r0]
     e02:	4a28      	ldr	r2, [pc, #160]	; (ea4 <system_init+0x398>)
     e04:	501a      	str	r2, [r3, r0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     e06:	22df      	movs	r2, #223	; 0xdf
     e08:	5c98      	ldrb	r0, [r3, r2]
     e0a:	3c80      	subs	r4, #128	; 0x80
     e0c:	43a0      	bics	r0, r4
     e0e:	5498      	strb	r0, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     e10:	5c98      	ldrb	r0, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
     e12:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     e14:	5498      	strb	r0, [r3, r2]
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(LCD_IO1, GPIO_PIN_FUNCTION_OFF);

	ADC_0_init();
     e16:	4b24      	ldr	r3, [pc, #144]	; (ea8 <system_init+0x39c>)
     e18:	4798      	blx	r3
	EXTERNAL_IRQ_0_init();
     e1a:	4b24      	ldr	r3, [pc, #144]	; (eac <system_init+0x3a0>)
     e1c:	4798      	blx	r3

	FLASH_0_init();
     e1e:	4b24      	ldr	r3, [pc, #144]	; (eb0 <system_init+0x3a4>)
     e20:	4798      	blx	r3

	SPI_0_init();
     e22:	4b24      	ldr	r3, [pc, #144]	; (eb4 <system_init+0x3a8>)
     e24:	4798      	blx	r3
	USART_1_init();
     e26:	4b24      	ldr	r3, [pc, #144]	; (eb8 <system_init+0x3ac>)
     e28:	4798      	blx	r3

	I2C_0_init();
     e2a:	4b24      	ldr	r3, [pc, #144]	; (ebc <system_init+0x3b0>)
     e2c:	4798      	blx	r3

	USART_0_init();
     e2e:	4b24      	ldr	r3, [pc, #144]	; (ec0 <system_init+0x3b4>)
     e30:	4798      	blx	r3

	TIMER_0_init();
     e32:	4b24      	ldr	r3, [pc, #144]	; (ec4 <system_init+0x3b8>)
     e34:	4798      	blx	r3

	DAC_0_init();
     e36:	4b24      	ldr	r3, [pc, #144]	; (ec8 <system_init+0x3bc>)
     e38:	4798      	blx	r3

	USB_0_init();
     e3a:	4b24      	ldr	r3, [pc, #144]	; (ecc <system_init+0x3c0>)
     e3c:	4798      	blx	r3
}
     e3e:	b003      	add	sp, #12
     e40:	bc3c      	pop	{r2, r3, r4, r5}
     e42:	4690      	mov	r8, r2
     e44:	4699      	mov	r9, r3
     e46:	46a2      	mov	sl, r4
     e48:	46ab      	mov	fp, r5
     e4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
     e4c:	00002b59 	.word	0x00002b59
     e50:	41004400 	.word	0x41004400
     e54:	40000400 	.word	0x40000400
     e58:	40021000 	.word	0x40021000
     e5c:	c0020000 	.word	0xc0020000
     e60:	40002000 	.word	0x40002000
     e64:	c0000010 	.word	0xc0000010
     e68:	c0000020 	.word	0xc0000020
     e6c:	c0000004 	.word	0xc0000004
     e70:	40020000 	.word	0x40020000
     e74:	c0020008 	.word	0xc0020008
     e78:	40004000 	.word	0x40004000
     e7c:	40008000 	.word	0x40008000
     e80:	c0020800 	.word	0xc0020800
     e84:	c0001000 	.word	0xc0001000
     e88:	40020010 	.word	0x40020010
     e8c:	40020020 	.word	0x40020020
     e90:	40020040 	.word	0x40020040
     e94:	40020080 	.word	0x40020080
     e98:	c0000002 	.word	0xc0000002
     e9c:	c0000001 	.word	0xc0000001
     ea0:	c0024000 	.word	0xc0024000
     ea4:	c0028000 	.word	0xc0028000
     ea8:	00000259 	.word	0x00000259
     eac:	000002f9 	.word	0x000002f9
     eb0:	000006cd 	.word	0x000006cd
     eb4:	000007b9 	.word	0x000007b9
     eb8:	00000845 	.word	0x00000845
     ebc:	000008fd 	.word	0x000008fd
     ec0:	00000989 	.word	0x00000989
     ec4:	00000219 	.word	0x00000219
     ec8:	00000a11 	.word	0x00000a11
     ecc:	00000af1 	.word	0x00000af1

00000ed0 <adc_async_window_threshold_reached>:
		descr_ch->adc_async_ch_cb.convert_done(descr, channel);
	}
}

static void adc_async_window_threshold_reached(struct _adc_async_device *device, const uint8_t channel)
{
     ed0:	b510      	push	{r4, lr}
	struct adc_async_descriptor *const descr = CONTAINER_OF(device, struct adc_async_descriptor, device);

	if (descr->adc_async_cb.monitor) {
     ed2:	6983      	ldr	r3, [r0, #24]
     ed4:	2b00      	cmp	r3, #0
     ed6:	d000      	beq.n	eda <adc_async_window_threshold_reached+0xa>
		descr->adc_async_cb.monitor(descr, channel);
     ed8:	4798      	blx	r3
	}
}
     eda:	bd10      	pop	{r4, pc}

00000edc <adc_async_error_occured>:

static void adc_async_error_occured(struct _adc_async_device *device, const uint8_t channel)
{
     edc:	b510      	push	{r4, lr}
	struct adc_async_descriptor *const descr = CONTAINER_OF(device, struct adc_async_descriptor, device);

	if (descr->adc_async_cb.error) {
     ede:	69c3      	ldr	r3, [r0, #28]
     ee0:	2b00      	cmp	r3, #0
     ee2:	d000      	beq.n	ee6 <adc_async_error_occured+0xa>
		descr->adc_async_cb.error(descr, channel);
     ee4:	4798      	blx	r3
	}
}
     ee6:	bd10      	pop	{r4, pc}

00000ee8 <adc_async_channel_conversion_done>:
{
     ee8:	b5f0      	push	{r4, r5, r6, r7, lr}
     eea:	b083      	sub	sp, #12
     eec:	0005      	movs	r5, r0
     eee:	000e      	movs	r6, r1
     ef0:	0011      	movs	r1, r2
	uint8_t                              index    = descr->channel_map[channel];
     ef2:	6a03      	ldr	r3, [r0, #32]
     ef4:	5d9a      	ldrb	r2, [r3, r6]
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
     ef6:	0053      	lsls	r3, r2, #1
     ef8:	189b      	adds	r3, r3, r2
     efa:	00dc      	lsls	r4, r3, #3
     efc:	6a83      	ldr	r3, [r0, #40]	; 0x28
     efe:	469c      	mov	ip, r3
     f00:	4464      	add	r4, ip
	ringbuffer_put(&descr_ch->convert, data);
     f02:	1d27      	adds	r7, r4, #4
     f04:	9101      	str	r1, [sp, #4]
     f06:	466b      	mov	r3, sp
     f08:	7919      	ldrb	r1, [r3, #4]
     f0a:	0038      	movs	r0, r7
     f0c:	4b0c      	ldr	r3, [pc, #48]	; (f40 <adc_async_channel_conversion_done+0x58>)
     f0e:	4798      	blx	r3
	if (1 < _adc_async_get_data_size(&descr->device)) {
     f10:	0028      	movs	r0, r5
     f12:	4b0c      	ldr	r3, [pc, #48]	; (f44 <adc_async_channel_conversion_done+0x5c>)
     f14:	4798      	blx	r3
     f16:	2801      	cmp	r0, #1
     f18:	d907      	bls.n	f2a <adc_async_channel_conversion_done+0x42>
		ringbuffer_put(&descr_ch->convert, data >> 8);
     f1a:	9b01      	ldr	r3, [sp, #4]
     f1c:	0a19      	lsrs	r1, r3, #8
     f1e:	0038      	movs	r0, r7
     f20:	4b07      	ldr	r3, [pc, #28]	; (f40 <adc_async_channel_conversion_done+0x58>)
     f22:	4798      	blx	r3
		++descr_ch->bytes_in_buffer;
     f24:	8aa3      	ldrh	r3, [r4, #20]
     f26:	3301      	adds	r3, #1
     f28:	82a3      	strh	r3, [r4, #20]
	++descr_ch->bytes_in_buffer;
     f2a:	8aa3      	ldrh	r3, [r4, #20]
     f2c:	3301      	adds	r3, #1
     f2e:	82a3      	strh	r3, [r4, #20]
	if (descr_ch->adc_async_ch_cb.convert_done) {
     f30:	6823      	ldr	r3, [r4, #0]
     f32:	2b00      	cmp	r3, #0
     f34:	d002      	beq.n	f3c <adc_async_channel_conversion_done+0x54>
		descr_ch->adc_async_ch_cb.convert_done(descr, channel);
     f36:	0031      	movs	r1, r6
     f38:	0028      	movs	r0, r5
     f3a:	4798      	blx	r3
}
     f3c:	b003      	add	sp, #12
     f3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
     f40:	00002801 	.word	0x00002801
     f44:	00002a5b 	.word	0x00002a5b

00000f48 <adc_async_init>:
{
     f48:	b5f0      	push	{r4, r5, r6, r7, lr}
     f4a:	46d6      	mov	lr, sl
     f4c:	b500      	push	{lr}
     f4e:	b082      	sub	sp, #8
     f50:	0005      	movs	r5, r0
     f52:	9101      	str	r1, [sp, #4]
     f54:	0016      	movs	r6, r2
     f56:	001c      	movs	r4, r3
     f58:	ab08      	add	r3, sp, #32
     f5a:	781f      	ldrb	r7, [r3, #0]
	ASSERT(descr && hw && channel_map && channel_amount && descr_ch);
     f5c:	2800      	cmp	r0, #0
     f5e:	d00c      	beq.n	f7a <adc_async_init+0x32>
     f60:	2900      	cmp	r1, #0
     f62:	d00c      	beq.n	f7e <adc_async_init+0x36>
     f64:	2a00      	cmp	r2, #0
     f66:	d00c      	beq.n	f82 <adc_async_init+0x3a>
     f68:	2f00      	cmp	r7, #0
     f6a:	d00c      	beq.n	f86 <adc_async_init+0x3e>
     f6c:	9b09      	ldr	r3, [sp, #36]	; 0x24
     f6e:	2b00      	cmp	r3, #0
     f70:	d001      	beq.n	f76 <adc_async_init+0x2e>
     f72:	2001      	movs	r0, #1
     f74:	e008      	b.n	f88 <adc_async_init+0x40>
     f76:	2000      	movs	r0, #0
     f78:	e006      	b.n	f88 <adc_async_init+0x40>
     f7a:	2000      	movs	r0, #0
     f7c:	e004      	b.n	f88 <adc_async_init+0x40>
     f7e:	2000      	movs	r0, #0
     f80:	e002      	b.n	f88 <adc_async_init+0x40>
     f82:	2000      	movs	r0, #0
     f84:	e000      	b.n	f88 <adc_async_init+0x40>
     f86:	2000      	movs	r0, #0
     f88:	223f      	movs	r2, #63	; 0x3f
     f8a:	4916      	ldr	r1, [pc, #88]	; (fe4 <adc_async_init+0x9c>)
     f8c:	4b16      	ldr	r3, [pc, #88]	; (fe8 <adc_async_init+0xa0>)
     f8e:	469a      	mov	sl, r3
     f90:	4798      	blx	r3
	ASSERT(channel_amount <= (channel_max + 1));
     f92:	1c62      	adds	r2, r4, #1
     f94:	0ffb      	lsrs	r3, r7, #31
     f96:	17d0      	asrs	r0, r2, #31
     f98:	42ba      	cmp	r2, r7
     f9a:	4158      	adcs	r0, r3
     f9c:	b2c0      	uxtb	r0, r0
     f9e:	2240      	movs	r2, #64	; 0x40
     fa0:	4910      	ldr	r1, [pc, #64]	; (fe4 <adc_async_init+0x9c>)
     fa2:	47d0      	blx	sl
	for (uint8_t i = 0; i <= channel_max; i++) {
     fa4:	2300      	movs	r3, #0
     fa6:	e003      	b.n	fb0 <adc_async_init+0x68>
		channel_map[i] = 0xFF;
     fa8:	22ff      	movs	r2, #255	; 0xff
     faa:	54f2      	strb	r2, [r6, r3]
	for (uint8_t i = 0; i <= channel_max; i++) {
     fac:	3301      	adds	r3, #1
     fae:	b2db      	uxtb	r3, r3
     fb0:	42a3      	cmp	r3, r4
     fb2:	d9f9      	bls.n	fa8 <adc_async_init+0x60>
	descr->channel_map    = channel_map;
     fb4:	622e      	str	r6, [r5, #32]
	descr->channel_max    = channel_max;
     fb6:	2324      	movs	r3, #36	; 0x24
     fb8:	54ec      	strb	r4, [r5, r3]
	descr->channel_amount = channel_amount;
     fba:	3301      	adds	r3, #1
     fbc:	54ef      	strb	r7, [r5, r3]
	descr->descr_ch       = descr_ch;
     fbe:	9b09      	ldr	r3, [sp, #36]	; 0x24
     fc0:	62ab      	str	r3, [r5, #40]	; 0x28
	init_status           = _adc_async_init(device, hw);
     fc2:	9901      	ldr	r1, [sp, #4]
     fc4:	0028      	movs	r0, r5
     fc6:	4b09      	ldr	r3, [pc, #36]	; (fec <adc_async_init+0xa4>)
     fc8:	4798      	blx	r3
	if (init_status) {
     fca:	2800      	cmp	r0, #0
     fcc:	d105      	bne.n	fda <adc_async_init+0x92>
	device->adc_async_ch_cb.convert_done = adc_async_channel_conversion_done;
     fce:	4b08      	ldr	r3, [pc, #32]	; (ff0 <adc_async_init+0xa8>)
     fd0:	60ab      	str	r3, [r5, #8]
	device->adc_async_cb.window_cb       = adc_async_window_threshold_reached;
     fd2:	4b08      	ldr	r3, [pc, #32]	; (ff4 <adc_async_init+0xac>)
     fd4:	602b      	str	r3, [r5, #0]
	device->adc_async_cb.error_cb        = adc_async_error_occured;
     fd6:	4b08      	ldr	r3, [pc, #32]	; (ff8 <adc_async_init+0xb0>)
     fd8:	606b      	str	r3, [r5, #4]
}
     fda:	b002      	add	sp, #8
     fdc:	bc04      	pop	{r2}
     fde:	4692      	mov	sl, r2
     fe0:	bdf0      	pop	{r4, r5, r6, r7, pc}
     fe2:	46c0      	nop			; (mov r8, r8)
     fe4:	0000aa00 	.word	0x0000aa00
     fe8:	000026c1 	.word	0x000026c1
     fec:	000029ed 	.word	0x000029ed
     ff0:	00000ee9 	.word	0x00000ee9
     ff4:	00000ed1 	.word	0x00000ed1
     ff8:	00000edd 	.word	0x00000edd

00000ffc <adc_async_register_channel_buffer>:
{
     ffc:	b5f0      	push	{r4, r5, r6, r7, lr}
     ffe:	b083      	sub	sp, #12
    1000:	0007      	movs	r7, r0
    1002:	000c      	movs	r4, r1
    1004:	9200      	str	r2, [sp, #0]
    1006:	9301      	str	r3, [sp, #4]
	ASSERT(descr && convert_buffer && convert_buffer_length);
    1008:	2800      	cmp	r0, #0
    100a:	d019      	beq.n	1040 <adc_async_register_channel_buffer+0x44>
    100c:	2a00      	cmp	r2, #0
    100e:	d019      	beq.n	1044 <adc_async_register_channel_buffer+0x48>
    1010:	2b00      	cmp	r3, #0
    1012:	d119      	bne.n	1048 <adc_async_register_channel_buffer+0x4c>
    1014:	2000      	movs	r0, #0
    1016:	4e24      	ldr	r6, [pc, #144]	; (10a8 <adc_async_register_channel_buffer+0xac>)
    1018:	2266      	movs	r2, #102	; 0x66
    101a:	0031      	movs	r1, r6
    101c:	4d23      	ldr	r5, [pc, #140]	; (10ac <adc_async_register_channel_buffer+0xb0>)
    101e:	47a8      	blx	r5
	ASSERT(descr->channel_max >= channel);
    1020:	2324      	movs	r3, #36	; 0x24
    1022:	5cfb      	ldrb	r3, [r7, r3]
    1024:	2000      	movs	r0, #0
    1026:	42a3      	cmp	r3, r4
    1028:	4140      	adcs	r0, r0
    102a:	b2c0      	uxtb	r0, r0
    102c:	2267      	movs	r2, #103	; 0x67
    102e:	0031      	movs	r1, r6
    1030:	47a8      	blx	r5
	if (descr->channel_map[channel] != 0xFF) {
    1032:	6a39      	ldr	r1, [r7, #32]
    1034:	5d0b      	ldrb	r3, [r1, r4]
    1036:	2bff      	cmp	r3, #255	; 0xff
    1038:	d12c      	bne.n	1094 <adc_async_register_channel_buffer+0x98>
    103a:	2600      	movs	r6, #0
    103c:	2300      	movs	r3, #0
    103e:	e007      	b.n	1050 <adc_async_register_channel_buffer+0x54>
	ASSERT(descr && convert_buffer && convert_buffer_length);
    1040:	2000      	movs	r0, #0
    1042:	e7e8      	b.n	1016 <adc_async_register_channel_buffer+0x1a>
    1044:	2000      	movs	r0, #0
    1046:	e7e6      	b.n	1016 <adc_async_register_channel_buffer+0x1a>
    1048:	2001      	movs	r0, #1
    104a:	e7e4      	b.n	1016 <adc_async_register_channel_buffer+0x1a>
	for (i = 0; i <= descr->channel_max; i++) {
    104c:	3301      	adds	r3, #1
    104e:	b2db      	uxtb	r3, r3
    1050:	2224      	movs	r2, #36	; 0x24
    1052:	5cba      	ldrb	r2, [r7, r2]
    1054:	4293      	cmp	r3, r2
    1056:	d805      	bhi.n	1064 <adc_async_register_channel_buffer+0x68>
		if (descr->channel_map[i] != 0xFF) {
    1058:	5cca      	ldrb	r2, [r1, r3]
    105a:	2aff      	cmp	r2, #255	; 0xff
    105c:	d0f6      	beq.n	104c <adc_async_register_channel_buffer+0x50>
			index++;
    105e:	3601      	adds	r6, #1
    1060:	b2f6      	uxtb	r6, r6
    1062:	e7f3      	b.n	104c <adc_async_register_channel_buffer+0x50>
	if (index > descr->channel_amount) {
    1064:	2325      	movs	r3, #37	; 0x25
    1066:	5cfb      	ldrb	r3, [r7, r3]
    1068:	429e      	cmp	r6, r3
    106a:	d816      	bhi.n	109a <adc_async_register_channel_buffer+0x9e>
	if (ERR_NONE != ringbuffer_init(&descr->descr_ch[index].convert, convert_buffer, convert_buffer_length)) {
    106c:	0073      	lsls	r3, r6, #1
    106e:	199b      	adds	r3, r3, r6
    1070:	00dd      	lsls	r5, r3, #3
    1072:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1074:	1958      	adds	r0, r3, r5
    1076:	3004      	adds	r0, #4
    1078:	9a01      	ldr	r2, [sp, #4]
    107a:	9900      	ldr	r1, [sp, #0]
    107c:	4b0c      	ldr	r3, [pc, #48]	; (10b0 <adc_async_register_channel_buffer+0xb4>)
    107e:	4798      	blx	r3
    1080:	2800      	cmp	r0, #0
    1082:	d10d      	bne.n	10a0 <adc_async_register_channel_buffer+0xa4>
	descr->channel_map[channel]            = index;
    1084:	6a3b      	ldr	r3, [r7, #32]
    1086:	551e      	strb	r6, [r3, r4]
	descr->descr_ch[index].bytes_in_buffer = 0;
    1088:	6abb      	ldr	r3, [r7, #40]	; 0x28
    108a:	195b      	adds	r3, r3, r5
    108c:	2200      	movs	r2, #0
    108e:	829a      	strh	r2, [r3, #20]
}
    1090:	b003      	add	sp, #12
    1092:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_INVALID_ARG;
    1094:	200d      	movs	r0, #13
    1096:	4240      	negs	r0, r0
    1098:	e7fa      	b.n	1090 <adc_async_register_channel_buffer+0x94>
		return ERR_NO_RESOURCE;
    109a:	201c      	movs	r0, #28
    109c:	4240      	negs	r0, r0
    109e:	e7f7      	b.n	1090 <adc_async_register_channel_buffer+0x94>
		return ERR_INVALID_ARG;
    10a0:	200d      	movs	r0, #13
    10a2:	4240      	negs	r0, r0
    10a4:	e7f4      	b.n	1090 <adc_async_register_channel_buffer+0x94>
    10a6:	46c0      	nop			; (mov r8, r8)
    10a8:	0000aa00 	.word	0x0000aa00
    10ac:	000026c1 	.word	0x000026c1
    10b0:	00002769 	.word	0x00002769

000010b4 <adc_async_enable_channel>:
{
    10b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    10b6:	0006      	movs	r6, r0
    10b8:	000c      	movs	r4, r1
	ASSERT(descr);
    10ba:	4d0b      	ldr	r5, [pc, #44]	; (10e8 <adc_async_enable_channel+0x34>)
    10bc:	1e43      	subs	r3, r0, #1
    10be:	4198      	sbcs	r0, r3
    10c0:	b2c0      	uxtb	r0, r0
    10c2:	2283      	movs	r2, #131	; 0x83
    10c4:	0029      	movs	r1, r5
    10c6:	4f09      	ldr	r7, [pc, #36]	; (10ec <adc_async_enable_channel+0x38>)
    10c8:	47b8      	blx	r7
	ASSERT(descr->channel_max >= channel);
    10ca:	2324      	movs	r3, #36	; 0x24
    10cc:	5cf3      	ldrb	r3, [r6, r3]
    10ce:	2000      	movs	r0, #0
    10d0:	42a3      	cmp	r3, r4
    10d2:	4140      	adcs	r0, r0
    10d4:	b2c0      	uxtb	r0, r0
    10d6:	2284      	movs	r2, #132	; 0x84
    10d8:	0029      	movs	r1, r5
    10da:	47b8      	blx	r7
	_adc_async_enable_channel(&descr->device, channel);
    10dc:	0021      	movs	r1, r4
    10de:	0030      	movs	r0, r6
    10e0:	4b03      	ldr	r3, [pc, #12]	; (10f0 <adc_async_enable_channel+0x3c>)
    10e2:	4798      	blx	r3
}
    10e4:	2000      	movs	r0, #0
    10e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    10e8:	0000aa00 	.word	0x0000aa00
    10ec:	000026c1 	.word	0x000026c1
    10f0:	00002a4d 	.word	0x00002a4d

000010f4 <adc_async_register_callback>:
{
    10f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    10f6:	46ce      	mov	lr, r9
    10f8:	b500      	push	{lr}
    10fa:	0004      	movs	r4, r0
    10fc:	000d      	movs	r5, r1
    10fe:	0017      	movs	r7, r2
    1100:	001e      	movs	r6, r3
	ASSERT(descr);
    1102:	1e43      	subs	r3, r0, #1
    1104:	4198      	sbcs	r0, r3
    1106:	b2c0      	uxtb	r0, r0
    1108:	229c      	movs	r2, #156	; 0x9c
    110a:	4916      	ldr	r1, [pc, #88]	; (1164 <adc_async_register_callback+0x70>)
    110c:	4b16      	ldr	r3, [pc, #88]	; (1168 <adc_async_register_callback+0x74>)
    110e:	4699      	mov	r9, r3
    1110:	4798      	blx	r3
	ASSERT(descr->channel_max >= channel);
    1112:	2324      	movs	r3, #36	; 0x24
    1114:	5ce3      	ldrb	r3, [r4, r3]
    1116:	2000      	movs	r0, #0
    1118:	42ab      	cmp	r3, r5
    111a:	4140      	adcs	r0, r0
    111c:	b2c0      	uxtb	r0, r0
    111e:	229d      	movs	r2, #157	; 0x9d
    1120:	4910      	ldr	r1, [pc, #64]	; (1164 <adc_async_register_callback+0x70>)
    1122:	47c8      	blx	r9
	uint8_t index = descr->channel_map[channel];
    1124:	6a23      	ldr	r3, [r4, #32]
    1126:	5d5b      	ldrb	r3, [r3, r5]
	switch (type) {
    1128:	2f01      	cmp	r7, #1
    112a:	d017      	beq.n	115c <adc_async_register_callback+0x68>
    112c:	2f00      	cmp	r7, #0
    112e:	d004      	beq.n	113a <adc_async_register_callback+0x46>
    1130:	2f02      	cmp	r7, #2
    1132:	d015      	beq.n	1160 <adc_async_register_callback+0x6c>
		return ERR_INVALID_ARG;
    1134:	200d      	movs	r0, #13
    1136:	4240      	negs	r0, r0
    1138:	e00d      	b.n	1156 <adc_async_register_callback+0x62>
		descr->descr_ch[index].adc_async_ch_cb.convert_done = cb;
    113a:	005a      	lsls	r2, r3, #1
    113c:	18d3      	adds	r3, r2, r3
    113e:	00da      	lsls	r2, r3, #3
    1140:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    1142:	509e      	str	r6, [r3, r2]
	_adc_async_set_irq_state(&descr->device, channel, (enum _adc_async_callback_type)type, cb != NULL);
    1144:	1e73      	subs	r3, r6, #1
    1146:	419e      	sbcs	r6, r3
    1148:	b2f3      	uxtb	r3, r6
    114a:	003a      	movs	r2, r7
    114c:	0029      	movs	r1, r5
    114e:	0020      	movs	r0, r4
    1150:	4c06      	ldr	r4, [pc, #24]	; (116c <adc_async_register_callback+0x78>)
    1152:	47a0      	blx	r4
	return ERR_NONE;
    1154:	2000      	movs	r0, #0
}
    1156:	bc04      	pop	{r2}
    1158:	4691      	mov	r9, r2
    115a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		descr->adc_async_cb.monitor = cb;
    115c:	61a6      	str	r6, [r4, #24]
		break;
    115e:	e7f1      	b.n	1144 <adc_async_register_callback+0x50>
		descr->adc_async_cb.error = cb;
    1160:	61e6      	str	r6, [r4, #28]
		break;
    1162:	e7ef      	b.n	1144 <adc_async_register_callback+0x50>
    1164:	0000aa00 	.word	0x0000aa00
    1168:	000026c1 	.word	0x000026c1
    116c:	00002a8b 	.word	0x00002a8b

00001170 <adc_async_read_channel>:
{
    1170:	b5f0      	push	{r4, r5, r6, r7, lr}
    1172:	46ce      	mov	lr, r9
    1174:	4647      	mov	r7, r8
    1176:	b580      	push	{r7, lr}
    1178:	b083      	sub	sp, #12
    117a:	0005      	movs	r5, r0
    117c:	000c      	movs	r4, r1
    117e:	4690      	mov	r8, r2
    1180:	001e      	movs	r6, r3
	ASSERT(descr && buffer && length);
    1182:	2800      	cmp	r0, #0
    1184:	d034      	beq.n	11f0 <adc_async_read_channel+0x80>
    1186:	2a00      	cmp	r2, #0
    1188:	d034      	beq.n	11f4 <adc_async_read_channel+0x84>
    118a:	2e00      	cmp	r6, #0
    118c:	d134      	bne.n	11f8 <adc_async_read_channel+0x88>
    118e:	2000      	movs	r0, #0
    1190:	22bc      	movs	r2, #188	; 0xbc
    1192:	4925      	ldr	r1, [pc, #148]	; (1228 <adc_async_read_channel+0xb8>)
    1194:	4f25      	ldr	r7, [pc, #148]	; (122c <adc_async_read_channel+0xbc>)
    1196:	47b8      	blx	r7
	ASSERT(descr->channel_max >= channel);
    1198:	2324      	movs	r3, #36	; 0x24
    119a:	5ceb      	ldrb	r3, [r5, r3]
    119c:	2000      	movs	r0, #0
    119e:	42a3      	cmp	r3, r4
    11a0:	4140      	adcs	r0, r0
    11a2:	b2c0      	uxtb	r0, r0
    11a4:	22bd      	movs	r2, #189	; 0xbd
    11a6:	4920      	ldr	r1, [pc, #128]	; (1228 <adc_async_read_channel+0xb8>)
    11a8:	47b8      	blx	r7
	data_size = _adc_async_get_data_size(&descr->device);
    11aa:	0028      	movs	r0, r5
    11ac:	4b20      	ldr	r3, [pc, #128]	; (1230 <adc_async_read_channel+0xc0>)
    11ae:	4798      	blx	r3
    11b0:	0001      	movs	r1, r0
	ASSERT(!(length % data_size));
    11b2:	0030      	movs	r0, r6
    11b4:	4b1f      	ldr	r3, [pc, #124]	; (1234 <adc_async_read_channel+0xc4>)
    11b6:	4798      	blx	r3
    11b8:	4248      	negs	r0, r1
    11ba:	4148      	adcs	r0, r1
    11bc:	b2c0      	uxtb	r0, r0
    11be:	22bf      	movs	r2, #191	; 0xbf
    11c0:	4919      	ldr	r1, [pc, #100]	; (1228 <adc_async_read_channel+0xb8>)
    11c2:	47b8      	blx	r7
	index                                         = descr->channel_map[channel];
    11c4:	6a2b      	ldr	r3, [r5, #32]
    11c6:	5d1a      	ldrb	r2, [r3, r4]
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
    11c8:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    11ca:	0053      	lsls	r3, r2, #1
    11cc:	189b      	adds	r3, r3, r2
    11ce:	00da      	lsls	r2, r3, #3
    11d0:	4689      	mov	r9, r1
    11d2:	4491      	add	r9, r2
	CRITICAL_SECTION_ENTER()
    11d4:	a801      	add	r0, sp, #4
    11d6:	4b18      	ldr	r3, [pc, #96]	; (1238 <adc_async_read_channel+0xc8>)
    11d8:	4798      	blx	r3
	num = ringbuffer_num(&descr_ch->convert);
    11da:	464b      	mov	r3, r9
    11dc:	1d1d      	adds	r5, r3, #4
    11de:	0028      	movs	r0, r5
    11e0:	4b16      	ldr	r3, [pc, #88]	; (123c <adc_async_read_channel+0xcc>)
    11e2:	4798      	blx	r3
    11e4:	0007      	movs	r7, r0
	CRITICAL_SECTION_LEAVE()
    11e6:	a801      	add	r0, sp, #4
    11e8:	4b15      	ldr	r3, [pc, #84]	; (1240 <adc_async_read_channel+0xd0>)
    11ea:	4798      	blx	r3
	uint16_t was_read = 0;
    11ec:	2400      	movs	r4, #0
	while ((was_read < num) && (was_read < length)) {
    11ee:	e00b      	b.n	1208 <adc_async_read_channel+0x98>
	ASSERT(descr && buffer && length);
    11f0:	2000      	movs	r0, #0
    11f2:	e7cd      	b.n	1190 <adc_async_read_channel+0x20>
    11f4:	2000      	movs	r0, #0
    11f6:	e7cb      	b.n	1190 <adc_async_read_channel+0x20>
    11f8:	2001      	movs	r0, #1
    11fa:	e7c9      	b.n	1190 <adc_async_read_channel+0x20>
		ringbuffer_get(&descr_ch->convert, &buffer[was_read++]);
    11fc:	3401      	adds	r4, #1
    11fe:	b2a4      	uxth	r4, r4
    1200:	4441      	add	r1, r8
    1202:	0028      	movs	r0, r5
    1204:	4b0f      	ldr	r3, [pc, #60]	; (1244 <adc_async_read_channel+0xd4>)
    1206:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
    1208:	0021      	movs	r1, r4
    120a:	42a7      	cmp	r7, r4
    120c:	d901      	bls.n	1212 <adc_async_read_channel+0xa2>
    120e:	42b4      	cmp	r4, r6
    1210:	d3f4      	bcc.n	11fc <adc_async_read_channel+0x8c>
	descr_ch->bytes_in_buffer -= was_read;
    1212:	464b      	mov	r3, r9
    1214:	8a9b      	ldrh	r3, [r3, #20]
    1216:	1b1b      	subs	r3, r3, r4
    1218:	464a      	mov	r2, r9
    121a:	8293      	strh	r3, [r2, #20]
}
    121c:	0020      	movs	r0, r4
    121e:	b003      	add	sp, #12
    1220:	bc0c      	pop	{r2, r3}
    1222:	4690      	mov	r8, r2
    1224:	4699      	mov	r9, r3
    1226:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1228:	0000aa00 	.word	0x0000aa00
    122c:	000026c1 	.word	0x000026c1
    1230:	00002a5b 	.word	0x00002a5b
    1234:	0000947d 	.word	0x0000947d
    1238:	00001271 	.word	0x00001271
    123c:	00002841 	.word	0x00002841
    1240:	0000127f 	.word	0x0000127f
    1244:	000027b5 	.word	0x000027b5

00001248 <adc_async_start_conversion>:
{
    1248:	b510      	push	{r4, lr}
    124a:	0004      	movs	r4, r0
	ASSERT(descr);
    124c:	1e43      	subs	r3, r0, #1
    124e:	4198      	sbcs	r0, r3
    1250:	b2c0      	uxtb	r0, r0
    1252:	22d6      	movs	r2, #214	; 0xd6
    1254:	4903      	ldr	r1, [pc, #12]	; (1264 <adc_async_start_conversion+0x1c>)
    1256:	4b04      	ldr	r3, [pc, #16]	; (1268 <adc_async_start_conversion+0x20>)
    1258:	4798      	blx	r3
	_adc_async_convert(&descr->device);
    125a:	0020      	movs	r0, r4
    125c:	4b03      	ldr	r3, [pc, #12]	; (126c <adc_async_start_conversion+0x24>)
    125e:	4798      	blx	r3
}
    1260:	2000      	movs	r0, #0
    1262:	bd10      	pop	{r4, pc}
    1264:	0000aa00 	.word	0x0000aa00
    1268:	000026c1 	.word	0x000026c1
    126c:	00002a77 	.word	0x00002a77

00001270 <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    1270:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
    1274:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
    1276:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    1278:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
    127c:	4770      	bx	lr

0000127e <atomic_leave_critical>:
    127e:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
    1282:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
    1284:	f383 8810 	msr	PRIMASK, r3
}
    1288:	4770      	bx	lr

0000128a <dac_tx_error>:
 * \internal Error occurs in transfer process
 *
 * \param[in] device The pointer to DAC device structure
 */
static void dac_tx_error(struct _dac_async_device *device, const uint8_t ch)
{
    128a:	b510      	push	{r4, lr}
	struct dac_async_descriptor *const descr = CONTAINER_OF(device, struct dac_async_descriptor, device);
    128c:	3808      	subs	r0, #8

	if (descr->dac_cb.error) {
    128e:	6843      	ldr	r3, [r0, #4]
    1290:	2b00      	cmp	r3, #0
    1292:	d000      	beq.n	1296 <dac_tx_error+0xc>
		descr->dac_cb.error(descr, ch);
    1294:	4798      	blx	r3
	}
}
    1296:	bd10      	pop	{r4, pc}

00001298 <dac_tx_ready>:
{
    1298:	b570      	push	{r4, r5, r6, lr}
	struct dac_async_descriptor *const descr = CONTAINER_OF(device, struct dac_async_descriptor, device);
    129a:	0005      	movs	r5, r0
    129c:	3d08      	subs	r5, #8
	if (descr->sel_ch[ch].length) {
    129e:	1ccb      	adds	r3, r1, #3
    12a0:	00db      	lsls	r3, r3, #3
    12a2:	18eb      	adds	r3, r5, r3
    12a4:	689b      	ldr	r3, [r3, #8]
    12a6:	2b00      	cmp	r3, #0
    12a8:	d00c      	beq.n	12c4 <dac_tx_ready+0x2c>
		descr->sel_ch[ch].length--;
    12aa:	3b01      	subs	r3, #1
    12ac:	1cca      	adds	r2, r1, #3
    12ae:	00d2      	lsls	r2, r2, #3
    12b0:	18ac      	adds	r4, r5, r2
    12b2:	60a3      	str	r3, [r4, #8]
		if (descr->sel_ch[ch].length) {
    12b4:	2b00      	cmp	r3, #0
    12b6:	d106      	bne.n	12c6 <dac_tx_ready+0x2e>
			if (descr->dac_cb.conversion_done) {
    12b8:	3808      	subs	r0, #8
    12ba:	6803      	ldr	r3, [r0, #0]
    12bc:	2b00      	cmp	r3, #0
    12be:	d001      	beq.n	12c4 <dac_tx_ready+0x2c>
				descr->dac_cb.conversion_done(descr, ch);
    12c0:	0028      	movs	r0, r5
    12c2:	4798      	blx	r3
}
    12c4:	bd70      	pop	{r4, r5, r6, pc}
			descr->sel_ch[ch].buffer++;
    12c6:	0023      	movs	r3, r4
    12c8:	6862      	ldr	r2, [r4, #4]
    12ca:	1c94      	adds	r4, r2, #2
    12cc:	605c      	str	r4, [r3, #4]
			_dac_async_write_data(&descr->device, *(descr->sel_ch[ch].buffer), ch);
    12ce:	8853      	ldrh	r3, [r2, #2]
    12d0:	000a      	movs	r2, r1
    12d2:	0019      	movs	r1, r3
    12d4:	4b01      	ldr	r3, [pc, #4]	; (12dc <dac_tx_ready+0x44>)
    12d6:	4798      	blx	r3
    12d8:	e7f4      	b.n	12c4 <dac_tx_ready+0x2c>
    12da:	46c0      	nop			; (mov r8, r8)
    12dc:	00002c8b 	.word	0x00002c8b

000012e0 <dac_async_init>:
{
    12e0:	b570      	push	{r4, r5, r6, lr}
    12e2:	0004      	movs	r4, r0
    12e4:	000d      	movs	r5, r1
	ASSERT(descr && hw);
    12e6:	2800      	cmp	r0, #0
    12e8:	d017      	beq.n	131a <dac_async_init+0x3a>
    12ea:	2900      	cmp	r1, #0
    12ec:	d013      	beq.n	1316 <dac_async_init+0x36>
    12ee:	2001      	movs	r0, #1
    12f0:	2238      	movs	r2, #56	; 0x38
    12f2:	490f      	ldr	r1, [pc, #60]	; (1330 <dac_async_init+0x50>)
    12f4:	4b0f      	ldr	r3, [pc, #60]	; (1334 <dac_async_init+0x54>)
    12f6:	4798      	blx	r3
	device = &descr->device;
    12f8:	0020      	movs	r0, r4
    12fa:	3008      	adds	r0, #8
	rc = _dac_async_init(device, hw);
    12fc:	0029      	movs	r1, r5
    12fe:	4b0e      	ldr	r3, [pc, #56]	; (1338 <dac_async_init+0x58>)
    1300:	4798      	blx	r3
	if (rc) {
    1302:	2800      	cmp	r0, #0
    1304:	d106      	bne.n	1314 <dac_async_init+0x34>
	device->dac_cb.tx_ready_cb = dac_tx_ready;
    1306:	4b0d      	ldr	r3, [pc, #52]	; (133c <dac_async_init+0x5c>)
    1308:	60a3      	str	r3, [r4, #8]
	device->dac_cb.tx_error_cb = dac_tx_error;
    130a:	4b0d      	ldr	r3, [pc, #52]	; (1340 <dac_async_init+0x60>)
    130c:	60e3      	str	r3, [r4, #12]
	for (i = 0; i < CHANNEL_NUM; i++) {
    130e:	2300      	movs	r3, #0
    1310:	2b00      	cmp	r3, #0
    1312:	d004      	beq.n	131e <dac_async_init+0x3e>
}
    1314:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw);
    1316:	2000      	movs	r0, #0
    1318:	e7ea      	b.n	12f0 <dac_async_init+0x10>
    131a:	2000      	movs	r0, #0
    131c:	e7e8      	b.n	12f0 <dac_async_init+0x10>
		descr->sel_ch[i].buffer = NULL;
    131e:	1cda      	adds	r2, r3, #3
    1320:	00d2      	lsls	r2, r2, #3
    1322:	18a2      	adds	r2, r4, r2
    1324:	2100      	movs	r1, #0
    1326:	6051      	str	r1, [r2, #4]
		descr->sel_ch[i].length = 0;
    1328:	6091      	str	r1, [r2, #8]
	for (i = 0; i < CHANNEL_NUM; i++) {
    132a:	3301      	adds	r3, #1
    132c:	b2db      	uxtb	r3, r3
    132e:	e7ef      	b.n	1310 <dac_async_init+0x30>
    1330:	0000aa1c 	.word	0x0000aa1c
    1334:	000026c1 	.word	0x000026c1
    1338:	00002c11 	.word	0x00002c11
    133c:	00001299 	.word	0x00001299
    1340:	0000128b 	.word	0x0000128b

00001344 <dac_async_enable_channel>:
{
    1344:	b570      	push	{r4, r5, r6, lr}
    1346:	0004      	movs	r4, r0
    1348:	000d      	movs	r5, r1
	ASSERT(descr && (ch < CHANNEL_NUM));
    134a:	2800      	cmp	r0, #0
    134c:	d00d      	beq.n	136a <dac_async_enable_channel+0x26>
    134e:	2900      	cmp	r1, #0
    1350:	d00d      	beq.n	136e <dac_async_enable_channel+0x2a>
    1352:	2000      	movs	r0, #0
    1354:	225d      	movs	r2, #93	; 0x5d
    1356:	4907      	ldr	r1, [pc, #28]	; (1374 <dac_async_enable_channel+0x30>)
    1358:	4b07      	ldr	r3, [pc, #28]	; (1378 <dac_async_enable_channel+0x34>)
    135a:	4798      	blx	r3
	_dac_async_enable_channel(&descr->device, ch);
    135c:	0020      	movs	r0, r4
    135e:	3008      	adds	r0, #8
    1360:	0029      	movs	r1, r5
    1362:	4b06      	ldr	r3, [pc, #24]	; (137c <dac_async_enable_channel+0x38>)
    1364:	4798      	blx	r3
}
    1366:	2000      	movs	r0, #0
    1368:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && (ch < CHANNEL_NUM));
    136a:	2000      	movs	r0, #0
    136c:	e7f2      	b.n	1354 <dac_async_enable_channel+0x10>
    136e:	2001      	movs	r0, #1
    1370:	e7f0      	b.n	1354 <dac_async_enable_channel+0x10>
    1372:	46c0      	nop			; (mov r8, r8)
    1374:	0000aa1c 	.word	0x0000aa1c
    1378:	000026c1 	.word	0x000026c1
    137c:	00002c65 	.word	0x00002c65

00001380 <dac_async_write>:
{
    1380:	b5f0      	push	{r4, r5, r6, r7, lr}
    1382:	46c6      	mov	lr, r8
    1384:	b500      	push	{lr}
    1386:	0004      	movs	r4, r0
    1388:	000d      	movs	r5, r1
    138a:	0017      	movs	r7, r2
    138c:	4698      	mov	r8, r3
	ASSERT(descr && (ch < CHANNEL_NUM) && buffer && length);
    138e:	2800      	cmp	r0, #0
    1390:	d007      	beq.n	13a2 <dac_async_write+0x22>
    1392:	2900      	cmp	r1, #0
    1394:	d107      	bne.n	13a6 <dac_async_write+0x26>
    1396:	2a00      	cmp	r2, #0
    1398:	d021      	beq.n	13de <dac_async_write+0x5e>
    139a:	2b00      	cmp	r3, #0
    139c:	d121      	bne.n	13e2 <dac_async_write+0x62>
    139e:	2000      	movs	r0, #0
    13a0:	e002      	b.n	13a8 <dac_async_write+0x28>
    13a2:	2000      	movs	r0, #0
    13a4:	e000      	b.n	13a8 <dac_async_write+0x28>
    13a6:	2000      	movs	r0, #0
    13a8:	228f      	movs	r2, #143	; 0x8f
    13aa:	4910      	ldr	r1, [pc, #64]	; (13ec <dac_async_write+0x6c>)
    13ac:	4b10      	ldr	r3, [pc, #64]	; (13f0 <dac_async_write+0x70>)
    13ae:	4798      	blx	r3
	if (!_dac_async_is_channel_enable(&descr->device, ch)) {
    13b0:	0026      	movs	r6, r4
    13b2:	3608      	adds	r6, #8
    13b4:	0029      	movs	r1, r5
    13b6:	0030      	movs	r0, r6
    13b8:	4b0e      	ldr	r3, [pc, #56]	; (13f4 <dac_async_write+0x74>)
    13ba:	4798      	blx	r3
    13bc:	2800      	cmp	r0, #0
    13be:	d012      	beq.n	13e6 <dac_async_write+0x66>
	descr->sel_ch[ch].buffer = buffer;
    13c0:	1ceb      	adds	r3, r5, #3
    13c2:	00db      	lsls	r3, r3, #3
    13c4:	18e4      	adds	r4, r4, r3
    13c6:	6067      	str	r7, [r4, #4]
	descr->sel_ch[ch].length = length;
    13c8:	4643      	mov	r3, r8
    13ca:	60a3      	str	r3, [r4, #8]
	_dac_async_write_data(&descr->device, *(descr->sel_ch[ch].buffer), ch);
    13cc:	8839      	ldrh	r1, [r7, #0]
    13ce:	002a      	movs	r2, r5
    13d0:	0030      	movs	r0, r6
    13d2:	4b09      	ldr	r3, [pc, #36]	; (13f8 <dac_async_write+0x78>)
    13d4:	4798      	blx	r3
	return ERR_NONE;
    13d6:	2000      	movs	r0, #0
}
    13d8:	bc04      	pop	{r2}
    13da:	4690      	mov	r8, r2
    13dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ASSERT(descr && (ch < CHANNEL_NUM) && buffer && length);
    13de:	2000      	movs	r0, #0
    13e0:	e7e2      	b.n	13a8 <dac_async_write+0x28>
    13e2:	2001      	movs	r0, #1
    13e4:	e7e0      	b.n	13a8 <dac_async_write+0x28>
		return ERR_INVALID_ARG;
    13e6:	200d      	movs	r0, #13
    13e8:	4240      	negs	r0, r0
    13ea:	e7f5      	b.n	13d8 <dac_async_write+0x58>
    13ec:	0000aa1c 	.word	0x0000aa1c
    13f0:	000026c1 	.word	0x000026c1
    13f4:	00002c79 	.word	0x00002c79
    13f8:	00002c8b 	.word	0x00002c8b

000013fc <delay_us>:

/**
 * \brief Perform delay in us
 */
void delay_us(const uint16_t us)
{
    13fc:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_us(us));
    13fe:	4b04      	ldr	r3, [pc, #16]	; (1410 <delay_us+0x14>)
    1400:	681c      	ldr	r4, [r3, #0]
    1402:	4b04      	ldr	r3, [pc, #16]	; (1414 <delay_us+0x18>)
    1404:	4798      	blx	r3
    1406:	0001      	movs	r1, r0
    1408:	0020      	movs	r0, r4
    140a:	4b03      	ldr	r3, [pc, #12]	; (1418 <delay_us+0x1c>)
    140c:	4798      	blx	r3
}
    140e:	bd10      	pop	{r4, pc}
    1410:	20000188 	.word	0x20000188
    1414:	00002b15 	.word	0x00002b15
    1418:	00002b51 	.word	0x00002b51

0000141c <delay_ms>:

/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
    141c:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    141e:	4b04      	ldr	r3, [pc, #16]	; (1430 <delay_ms+0x14>)
    1420:	681c      	ldr	r4, [r3, #0]
    1422:	4b04      	ldr	r3, [pc, #16]	; (1434 <delay_ms+0x18>)
    1424:	4798      	blx	r3
    1426:	0001      	movs	r1, r0
    1428:	0020      	movs	r0, r4
    142a:	4b03      	ldr	r3, [pc, #12]	; (1438 <delay_ms+0x1c>)
    142c:	4798      	blx	r3
}
    142e:	bd10      	pop	{r4, pc}
    1430:	20000188 	.word	0x20000188
    1434:	00002b31 	.word	0x00002b31
    1438:	00002b51 	.word	0x00002b51

0000143c <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
    143c:	b570      	push	{r4, r5, r6, lr}
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
    143e:	2510      	movs	r5, #16
    1440:	2400      	movs	r4, #0

	while (upper >= lower) {
    1442:	e007      	b.n	1454 <process_ext_irq+0x18>
		if (middle >= EXT_IRQ_AMOUNT) {
			return;
		}

		if (ext_irqs[middle].pin == pin) {
			if (ext_irqs[middle].cb) {
    1444:	4a0d      	ldr	r2, [pc, #52]	; (147c <process_ext_irq+0x40>)
    1446:	58b3      	ldr	r3, [r6, r2]
    1448:	2b00      	cmp	r3, #0
    144a:	d000      	beq.n	144e <process_ext_irq+0x12>
				ext_irqs[middle].cb();
    144c:	4798      	blx	r3
			lower = middle + 1;
		} else {
			upper = middle - 1;
		}
	}
}
    144e:	bd70      	pop	{r4, r5, r6, pc}
			upper = middle - 1;
    1450:	3a01      	subs	r2, #1
    1452:	b2d5      	uxtb	r5, r2
	while (upper >= lower) {
    1454:	42ac      	cmp	r4, r5
    1456:	d8fa      	bhi.n	144e <process_ext_irq+0x12>
		middle = (upper + lower) >> 1;
    1458:	192b      	adds	r3, r5, r4
    145a:	105b      	asrs	r3, r3, #1
    145c:	b2da      	uxtb	r2, r3
		if (middle >= EXT_IRQ_AMOUNT) {
    145e:	2a0f      	cmp	r2, #15
    1460:	d8f5      	bhi.n	144e <process_ext_irq+0x12>
    1462:	21ff      	movs	r1, #255	; 0xff
    1464:	400b      	ands	r3, r1
		if (ext_irqs[middle].pin == pin) {
    1466:	00de      	lsls	r6, r3, #3
    1468:	4904      	ldr	r1, [pc, #16]	; (147c <process_ext_irq+0x40>)
    146a:	1989      	adds	r1, r1, r6
    146c:	6849      	ldr	r1, [r1, #4]
    146e:	4281      	cmp	r1, r0
    1470:	d0e8      	beq.n	1444 <process_ext_irq+0x8>
		if (ext_irqs[middle].pin < pin) {
    1472:	d2ed      	bcs.n	1450 <process_ext_irq+0x14>
			lower = middle + 1;
    1474:	3201      	adds	r2, #1
    1476:	b2d4      	uxtb	r4, r2
    1478:	e7ec      	b.n	1454 <process_ext_irq+0x18>
    147a:	46c0      	nop			; (mov r8, r8)
    147c:	2000018c 	.word	0x2000018c

00001480 <ext_irq_init>:
{
    1480:	b510      	push	{r4, lr}
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    1482:	2300      	movs	r3, #0
    1484:	e009      	b.n	149a <ext_irq_init+0x1a>
		ext_irqs[i].pin = 0xFFFFFFFF;
    1486:	4a08      	ldr	r2, [pc, #32]	; (14a8 <ext_irq_init+0x28>)
    1488:	00d9      	lsls	r1, r3, #3
    148a:	1850      	adds	r0, r2, r1
    148c:	2401      	movs	r4, #1
    148e:	4264      	negs	r4, r4
    1490:	6044      	str	r4, [r0, #4]
		ext_irqs[i].cb  = NULL;
    1492:	2000      	movs	r0, #0
    1494:	5088      	str	r0, [r1, r2]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    1496:	3301      	adds	r3, #1
    1498:	b29b      	uxth	r3, r3
    149a:	2b0f      	cmp	r3, #15
    149c:	d9f3      	bls.n	1486 <ext_irq_init+0x6>
	return _ext_irq_init(process_ext_irq);
    149e:	4803      	ldr	r0, [pc, #12]	; (14ac <ext_irq_init+0x2c>)
    14a0:	4b03      	ldr	r3, [pc, #12]	; (14b0 <ext_irq_init+0x30>)
    14a2:	4798      	blx	r3
}
    14a4:	bd10      	pop	{r4, pc}
    14a6:	46c0      	nop			; (mov r8, r8)
    14a8:	2000018c 	.word	0x2000018c
    14ac:	0000143d 	.word	0x0000143d
    14b0:	00002c99 	.word	0x00002c99

000014b4 <ext_irq_register>:
{
    14b4:	b5f0      	push	{r4, r5, r6, r7, lr}
    14b6:	46d6      	mov	lr, sl
    14b8:	464f      	mov	r7, r9
    14ba:	4646      	mov	r6, r8
    14bc:	b5c0      	push	{r6, r7, lr}
    14be:	b084      	sub	sp, #16
	uint8_t i = 0, j = 0;
    14c0:	2300      	movs	r3, #0
	for (; i < EXT_IRQ_AMOUNT; i++) {
    14c2:	2b0f      	cmp	r3, #15
    14c4:	d80d      	bhi.n	14e2 <ext_irq_register+0x2e>
		if (ext_irqs[i].pin == pin) {
    14c6:	00dc      	lsls	r4, r3, #3
    14c8:	4a33      	ldr	r2, [pc, #204]	; (1598 <ext_irq_register+0xe4>)
    14ca:	1912      	adds	r2, r2, r4
    14cc:	6852      	ldr	r2, [r2, #4]
    14ce:	4282      	cmp	r2, r0
    14d0:	d002      	beq.n	14d8 <ext_irq_register+0x24>
	for (; i < EXT_IRQ_AMOUNT; i++) {
    14d2:	3301      	adds	r3, #1
    14d4:	b2db      	uxtb	r3, r3
    14d6:	e7f4      	b.n	14c2 <ext_irq_register+0xe>
			ext_irqs[i].cb = cb;
    14d8:	4b2f      	ldr	r3, [pc, #188]	; (1598 <ext_irq_register+0xe4>)
    14da:	50e1      	str	r1, [r4, r3]
			found          = true;
    14dc:	2301      	movs	r3, #1
    14de:	469a      	mov	sl, r3
			break;
    14e0:	e001      	b.n	14e6 <ext_irq_register+0x32>
	bool    found = false;
    14e2:	2300      	movs	r3, #0
    14e4:	469a      	mov	sl, r3
	if (NULL == cb) {
    14e6:	2900      	cmp	r1, #0
    14e8:	d00c      	beq.n	1504 <ext_irq_register+0x50>
	if (!found) {
    14ea:	4653      	mov	r3, sl
    14ec:	2b00      	cmp	r3, #0
    14ee:	d141      	bne.n	1574 <ext_irq_register+0xc0>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    14f0:	2b0f      	cmp	r3, #15
    14f2:	d813      	bhi.n	151c <ext_irq_register+0x68>
			if (NULL == ext_irqs[i].cb) {
    14f4:	00da      	lsls	r2, r3, #3
    14f6:	4d28      	ldr	r5, [pc, #160]	; (1598 <ext_irq_register+0xe4>)
    14f8:	5952      	ldr	r2, [r2, r5]
    14fa:	2a00      	cmp	r2, #0
    14fc:	d008      	beq.n	1510 <ext_irq_register+0x5c>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    14fe:	3301      	adds	r3, #1
    1500:	b2db      	uxtb	r3, r3
    1502:	e7f5      	b.n	14f0 <ext_irq_register+0x3c>
		if (!found) {
    1504:	4653      	mov	r3, sl
    1506:	2b00      	cmp	r3, #0
    1508:	d040      	beq.n	158c <ext_irq_register+0xd8>
		return _ext_irq_enable(pin, false);
    150a:	4b24      	ldr	r3, [pc, #144]	; (159c <ext_irq_register+0xe8>)
    150c:	4798      	blx	r3
    150e:	e037      	b.n	1580 <ext_irq_register+0xcc>
				ext_irqs[i].cb  = cb;
    1510:	00dc      	lsls	r4, r3, #3
    1512:	5161      	str	r1, [r4, r5]
				ext_irqs[i].pin = pin;
    1514:	192c      	adds	r4, r5, r4
    1516:	6060      	str	r0, [r4, #4]
				found           = true;
    1518:	2201      	movs	r2, #1
    151a:	4692      	mov	sl, r2
    151c:	2200      	movs	r2, #0
    151e:	e001      	b.n	1524 <ext_irq_register+0x70>
		for (; (j < EXT_IRQ_AMOUNT) && (i < EXT_IRQ_AMOUNT); j++) {
    1520:	3201      	adds	r2, #1
    1522:	b2d2      	uxtb	r2, r2
    1524:	2a0f      	cmp	r2, #15
    1526:	d825      	bhi.n	1574 <ext_irq_register+0xc0>
    1528:	2b0f      	cmp	r3, #15
    152a:	d823      	bhi.n	1574 <ext_irq_register+0xc0>
			if ((ext_irqs[i].pin < ext_irqs[j].pin) && (ext_irqs[j].pin != 0xFFFFFFFF)) {
    152c:	9301      	str	r3, [sp, #4]
    152e:	491a      	ldr	r1, [pc, #104]	; (1598 <ext_irq_register+0xe4>)
    1530:	00dc      	lsls	r4, r3, #3
    1532:	190c      	adds	r4, r1, r4
    1534:	6867      	ldr	r7, [r4, #4]
    1536:	00d4      	lsls	r4, r2, #3
    1538:	1909      	adds	r1, r1, r4
    153a:	6849      	ldr	r1, [r1, #4]
    153c:	428f      	cmp	r7, r1
    153e:	d2ef      	bcs.n	1520 <ext_irq_register+0x6c>
    1540:	1c4c      	adds	r4, r1, #1
    1542:	d0ed      	beq.n	1520 <ext_irq_register+0x6c>
				struct ext_irq tmp = ext_irqs[j];
    1544:	a902      	add	r1, sp, #8
    1546:	468c      	mov	ip, r1
    1548:	4f13      	ldr	r7, [pc, #76]	; (1598 <ext_irq_register+0xe4>)
    154a:	00d4      	lsls	r4, r2, #3
    154c:	46a0      	mov	r8, r4
    154e:	193c      	adds	r4, r7, r4
    1550:	4666      	mov	r6, ip
    1552:	cc22      	ldmia	r4!, {r1, r5}
    1554:	c622      	stmia	r6!, {r1, r5}
				ext_irqs[j] = ext_irqs[i];
    1556:	9901      	ldr	r1, [sp, #4]
    1558:	00c9      	lsls	r1, r1, #3
    155a:	4689      	mov	r9, r1
    155c:	4641      	mov	r1, r8
    155e:	1879      	adds	r1, r7, r1
    1560:	464c      	mov	r4, r9
    1562:	193c      	adds	r4, r7, r4
    1564:	cc60      	ldmia	r4!, {r5, r6}
    1566:	c160      	stmia	r1!, {r5, r6}
				ext_irqs[i] = tmp;
    1568:	003d      	movs	r5, r7
    156a:	444d      	add	r5, r9
    156c:	4661      	mov	r1, ip
    156e:	c950      	ldmia	r1!, {r4, r6}
    1570:	c550      	stmia	r5!, {r4, r6}
    1572:	e7d5      	b.n	1520 <ext_irq_register+0x6c>
	if (!found) {
    1574:	4653      	mov	r3, sl
    1576:	2b00      	cmp	r3, #0
    1578:	d00b      	beq.n	1592 <ext_irq_register+0xde>
	return _ext_irq_enable(pin, true);
    157a:	2101      	movs	r1, #1
    157c:	4b07      	ldr	r3, [pc, #28]	; (159c <ext_irq_register+0xe8>)
    157e:	4798      	blx	r3
}
    1580:	b004      	add	sp, #16
    1582:	bc1c      	pop	{r2, r3, r4}
    1584:	4690      	mov	r8, r2
    1586:	4699      	mov	r9, r3
    1588:	46a2      	mov	sl, r4
    158a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return ERR_INVALID_ARG;
    158c:	200d      	movs	r0, #13
    158e:	4240      	negs	r0, r0
    1590:	e7f6      	b.n	1580 <ext_irq_register+0xcc>
		return ERR_INVALID_ARG;
    1592:	200d      	movs	r0, #13
    1594:	4240      	negs	r0, r0
    1596:	e7f3      	b.n	1580 <ext_irq_register+0xcc>
    1598:	2000018c 	.word	0x2000018c
    159c:	00002d31 	.word	0x00002d31

000015a0 <flash_ready>:
 * \internal Ready for a new flash command
 *
 * \param[in] device The pointer to flash device structure
 */
static void flash_ready(struct _flash_device *device)
{
    15a0:	b510      	push	{r4, lr}
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_ready) {
    15a2:	6943      	ldr	r3, [r0, #20]
    15a4:	2b00      	cmp	r3, #0
    15a6:	d000      	beq.n	15aa <flash_ready+0xa>
		descr->callbacks.cb_ready(descr);
    15a8:	4798      	blx	r3
	}
}
    15aa:	bd10      	pop	{r4, pc}

000015ac <flash_error>:
 * \internal Error occurs in flash command
 *
 * \param[in] device The pointer to flash device structure
 */
static void flash_error(struct _flash_device *device)
{
    15ac:	b510      	push	{r4, lr}
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_error) {
    15ae:	6983      	ldr	r3, [r0, #24]
    15b0:	2b00      	cmp	r3, #0
    15b2:	d000      	beq.n	15b6 <flash_error+0xa>
		descr->callbacks.cb_error(descr);
    15b4:	4798      	blx	r3
	}
}
    15b6:	bd10      	pop	{r4, pc}

000015b8 <flash_is_address_aligned>:
{
    15b8:	b570      	push	{r4, r5, r6, lr}
    15ba:	0004      	movs	r4, r0
    15bc:	000d      	movs	r5, r1
	ASSERT(flash);
    15be:	1e43      	subs	r3, r0, #1
    15c0:	4198      	sbcs	r0, r3
    15c2:	b2c0      	uxtb	r0, r0
    15c4:	2218      	movs	r2, #24
    15c6:	32ff      	adds	r2, #255	; 0xff
    15c8:	4906      	ldr	r1, [pc, #24]	; (15e4 <flash_is_address_aligned+0x2c>)
    15ca:	4b07      	ldr	r3, [pc, #28]	; (15e8 <flash_is_address_aligned+0x30>)
    15cc:	4798      	blx	r3
	uint32_t page_size = _flash_get_page_size(&flash->dev);
    15ce:	0020      	movs	r0, r4
    15d0:	4b06      	ldr	r3, [pc, #24]	; (15ec <flash_is_address_aligned+0x34>)
    15d2:	4798      	blx	r3
	if (flash_addr & (page_size - 1)) {
    15d4:	3801      	subs	r0, #1
    15d6:	4205      	tst	r5, r0
    15d8:	d101      	bne.n	15de <flash_is_address_aligned+0x26>
	return ERR_NONE;
    15da:	2000      	movs	r0, #0
}
    15dc:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_BAD_ADDRESS;
    15de:	200e      	movs	r0, #14
    15e0:	4240      	negs	r0, r0
    15e2:	e7fb      	b.n	15dc <flash_is_address_aligned+0x24>
    15e4:	0000aa38 	.word	0x0000aa38
    15e8:	000026c1 	.word	0x000026c1
    15ec:	00002f99 	.word	0x00002f99

000015f0 <flash_init>:
{
    15f0:	b570      	push	{r4, r5, r6, lr}
    15f2:	0004      	movs	r4, r0
    15f4:	000d      	movs	r5, r1
	ASSERT(flash && hw);
    15f6:	2800      	cmp	r0, #0
    15f8:	d013      	beq.n	1622 <flash_init+0x32>
    15fa:	2900      	cmp	r1, #0
    15fc:	d00f      	beq.n	161e <flash_init+0x2e>
    15fe:	2001      	movs	r0, #1
    1600:	2238      	movs	r2, #56	; 0x38
    1602:	4909      	ldr	r1, [pc, #36]	; (1628 <flash_init+0x38>)
    1604:	4b09      	ldr	r3, [pc, #36]	; (162c <flash_init+0x3c>)
    1606:	4798      	blx	r3
	rc = _flash_init(&flash->dev, hw);
    1608:	0029      	movs	r1, r5
    160a:	0020      	movs	r0, r4
    160c:	4b08      	ldr	r3, [pc, #32]	; (1630 <flash_init+0x40>)
    160e:	4798      	blx	r3
	if (rc) {
    1610:	2800      	cmp	r0, #0
    1612:	d103      	bne.n	161c <flash_init+0x2c>
	flash->dev.flash_cb.ready_cb = flash_ready;
    1614:	4b07      	ldr	r3, [pc, #28]	; (1634 <flash_init+0x44>)
    1616:	6023      	str	r3, [r4, #0]
	flash->dev.flash_cb.error_cb = flash_error;
    1618:	4b07      	ldr	r3, [pc, #28]	; (1638 <flash_init+0x48>)
    161a:	6063      	str	r3, [r4, #4]
}
    161c:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(flash && hw);
    161e:	2000      	movs	r0, #0
    1620:	e7ee      	b.n	1600 <flash_init+0x10>
    1622:	2000      	movs	r0, #0
    1624:	e7ec      	b.n	1600 <flash_init+0x10>
    1626:	46c0      	nop			; (mov r8, r8)
    1628:	0000aa38 	.word	0x0000aa38
    162c:	000026c1 	.word	0x000026c1
    1630:	00002f39 	.word	0x00002f39
    1634:	000015a1 	.word	0x000015a1
    1638:	000015ad 	.word	0x000015ad

0000163c <flash_read>:
{
    163c:	b5f0      	push	{r4, r5, r6, r7, lr}
    163e:	46c6      	mov	lr, r8
    1640:	b500      	push	{lr}
    1642:	0004      	movs	r4, r0
    1644:	000e      	movs	r6, r1
    1646:	0015      	movs	r5, r2
    1648:	001f      	movs	r7, r3
	ASSERT(flash && buffer && length);
    164a:	2800      	cmp	r0, #0
    164c:	d020      	beq.n	1690 <flash_read+0x54>
    164e:	2a00      	cmp	r2, #0
    1650:	d020      	beq.n	1694 <flash_read+0x58>
    1652:	2b00      	cmp	r3, #0
    1654:	d120      	bne.n	1698 <flash_read+0x5c>
    1656:	2000      	movs	r0, #0
    1658:	2256      	movs	r2, #86	; 0x56
    165a:	4913      	ldr	r1, [pc, #76]	; (16a8 <flash_read+0x6c>)
    165c:	4b13      	ldr	r3, [pc, #76]	; (16ac <flash_read+0x70>)
    165e:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    1660:	0020      	movs	r0, r4
    1662:	4b13      	ldr	r3, [pc, #76]	; (16b0 <flash_read+0x74>)
    1664:	4798      	blx	r3
    1666:	4680      	mov	r8, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    1668:	0020      	movs	r0, r4
    166a:	4b12      	ldr	r3, [pc, #72]	; (16b4 <flash_read+0x78>)
    166c:	4798      	blx	r3
	if ((src_addr > page_size * total_pages) || (src_addr + length > page_size * total_pages)) {
    166e:	4643      	mov	r3, r8
    1670:	4358      	muls	r0, r3
    1672:	42b0      	cmp	r0, r6
    1674:	d312      	bcc.n	169c <flash_read+0x60>
    1676:	19bb      	adds	r3, r7, r6
    1678:	4298      	cmp	r0, r3
    167a:	d312      	bcc.n	16a2 <flash_read+0x66>
	_flash_read(&flash->dev, src_addr, buffer, length);
    167c:	003b      	movs	r3, r7
    167e:	002a      	movs	r2, r5
    1680:	0031      	movs	r1, r6
    1682:	0020      	movs	r0, r4
    1684:	4c0c      	ldr	r4, [pc, #48]	; (16b8 <flash_read+0x7c>)
    1686:	47a0      	blx	r4
	return ERR_NONE;
    1688:	2000      	movs	r0, #0
}
    168a:	bc04      	pop	{r2}
    168c:	4690      	mov	r8, r2
    168e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ASSERT(flash && buffer && length);
    1690:	2000      	movs	r0, #0
    1692:	e7e1      	b.n	1658 <flash_read+0x1c>
    1694:	2000      	movs	r0, #0
    1696:	e7df      	b.n	1658 <flash_read+0x1c>
    1698:	2001      	movs	r0, #1
    169a:	e7dd      	b.n	1658 <flash_read+0x1c>
		return ERR_BAD_ADDRESS;
    169c:	200e      	movs	r0, #14
    169e:	4240      	negs	r0, r0
    16a0:	e7f3      	b.n	168a <flash_read+0x4e>
    16a2:	200e      	movs	r0, #14
    16a4:	4240      	negs	r0, r0
    16a6:	e7f0      	b.n	168a <flash_read+0x4e>
    16a8:	0000aa38 	.word	0x0000aa38
    16ac:	000026c1 	.word	0x000026c1
    16b0:	00002f99 	.word	0x00002f99
    16b4:	00002f9d 	.word	0x00002f9d
    16b8:	00002fa3 	.word	0x00002fa3

000016bc <flash_write>:
{
    16bc:	b5f0      	push	{r4, r5, r6, r7, lr}
    16be:	46c6      	mov	lr, r8
    16c0:	b500      	push	{lr}
    16c2:	0004      	movs	r4, r0
    16c4:	000d      	movs	r5, r1
    16c6:	0016      	movs	r6, r2
    16c8:	001f      	movs	r7, r3
	ASSERT(flash && buffer && length);
    16ca:	2800      	cmp	r0, #0
    16cc:	d026      	beq.n	171c <flash_write+0x60>
    16ce:	2a00      	cmp	r2, #0
    16d0:	d026      	beq.n	1720 <flash_write+0x64>
    16d2:	2b00      	cmp	r3, #0
    16d4:	d126      	bne.n	1724 <flash_write+0x68>
    16d6:	2000      	movs	r0, #0
    16d8:	226a      	movs	r2, #106	; 0x6a
    16da:	4918      	ldr	r1, [pc, #96]	; (173c <flash_write+0x80>)
    16dc:	4b18      	ldr	r3, [pc, #96]	; (1740 <flash_write+0x84>)
    16de:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    16e0:	0020      	movs	r0, r4
    16e2:	4b18      	ldr	r3, [pc, #96]	; (1744 <flash_write+0x88>)
    16e4:	4798      	blx	r3
    16e6:	4680      	mov	r8, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    16e8:	0020      	movs	r0, r4
    16ea:	4b17      	ldr	r3, [pc, #92]	; (1748 <flash_write+0x8c>)
    16ec:	4798      	blx	r3
	if ((dst_addr > page_size * total_pages) || (dst_addr + length > page_size * total_pages)) {
    16ee:	4643      	mov	r3, r8
    16f0:	4358      	muls	r0, r3
    16f2:	42a8      	cmp	r0, r5
    16f4:	d318      	bcc.n	1728 <flash_write+0x6c>
    16f6:	197b      	adds	r3, r7, r5
    16f8:	4298      	cmp	r0, r3
    16fa:	d318      	bcc.n	172e <flash_write+0x72>
	if (_flash_is_locked(&flash->dev, dst_addr)) {
    16fc:	0029      	movs	r1, r5
    16fe:	0020      	movs	r0, r4
    1700:	4b12      	ldr	r3, [pc, #72]	; (174c <flash_write+0x90>)
    1702:	4798      	blx	r3
    1704:	2800      	cmp	r0, #0
    1706:	d115      	bne.n	1734 <flash_write+0x78>
	_flash_write(&flash->dev, dst_addr, buffer, length);
    1708:	003b      	movs	r3, r7
    170a:	0032      	movs	r2, r6
    170c:	0029      	movs	r1, r5
    170e:	0020      	movs	r0, r4
    1710:	4c0f      	ldr	r4, [pc, #60]	; (1750 <flash_write+0x94>)
    1712:	47a0      	blx	r4
	return ERR_NONE;
    1714:	2000      	movs	r0, #0
}
    1716:	bc04      	pop	{r2}
    1718:	4690      	mov	r8, r2
    171a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ASSERT(flash && buffer && length);
    171c:	2000      	movs	r0, #0
    171e:	e7db      	b.n	16d8 <flash_write+0x1c>
    1720:	2000      	movs	r0, #0
    1722:	e7d9      	b.n	16d8 <flash_write+0x1c>
    1724:	2001      	movs	r0, #1
    1726:	e7d7      	b.n	16d8 <flash_write+0x1c>
		return ERR_BAD_ADDRESS;
    1728:	200e      	movs	r0, #14
    172a:	4240      	negs	r0, r0
    172c:	e7f3      	b.n	1716 <flash_write+0x5a>
    172e:	200e      	movs	r0, #14
    1730:	4240      	negs	r0, r0
    1732:	e7f0      	b.n	1716 <flash_write+0x5a>
		return ERR_DENIED;
    1734:	2011      	movs	r0, #17
    1736:	4240      	negs	r0, r0
    1738:	e7ed      	b.n	1716 <flash_write+0x5a>
    173a:	46c0      	nop			; (mov r8, r8)
    173c:	0000aa38 	.word	0x0000aa38
    1740:	000026c1 	.word	0x000026c1
    1744:	00002f99 	.word	0x00002f99
    1748:	00002f9d 	.word	0x00002f9d
    174c:	000031ed 	.word	0x000031ed
    1750:	00002ff1 	.word	0x00002ff1

00001754 <flash_append>:
{
    1754:	b5f0      	push	{r4, r5, r6, r7, lr}
    1756:	46c6      	mov	lr, r8
    1758:	b500      	push	{lr}
    175a:	0004      	movs	r4, r0
    175c:	000d      	movs	r5, r1
    175e:	0016      	movs	r6, r2
    1760:	001f      	movs	r7, r3
	ASSERT(flash && buffer && length);
    1762:	2800      	cmp	r0, #0
    1764:	d026      	beq.n	17b4 <flash_append+0x60>
    1766:	2a00      	cmp	r2, #0
    1768:	d026      	beq.n	17b8 <flash_append+0x64>
    176a:	2b00      	cmp	r3, #0
    176c:	d126      	bne.n	17bc <flash_append+0x68>
    176e:	2000      	movs	r0, #0
    1770:	2282      	movs	r2, #130	; 0x82
    1772:	4918      	ldr	r1, [pc, #96]	; (17d4 <flash_append+0x80>)
    1774:	4b18      	ldr	r3, [pc, #96]	; (17d8 <flash_append+0x84>)
    1776:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    1778:	0020      	movs	r0, r4
    177a:	4b18      	ldr	r3, [pc, #96]	; (17dc <flash_append+0x88>)
    177c:	4798      	blx	r3
    177e:	4680      	mov	r8, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    1780:	0020      	movs	r0, r4
    1782:	4b17      	ldr	r3, [pc, #92]	; (17e0 <flash_append+0x8c>)
    1784:	4798      	blx	r3
	if ((dst_addr > page_size * total_pages) || (dst_addr + length > page_size * total_pages)) {
    1786:	4643      	mov	r3, r8
    1788:	4358      	muls	r0, r3
    178a:	42a8      	cmp	r0, r5
    178c:	d318      	bcc.n	17c0 <flash_append+0x6c>
    178e:	197b      	adds	r3, r7, r5
    1790:	4298      	cmp	r0, r3
    1792:	d318      	bcc.n	17c6 <flash_append+0x72>
	if (_flash_is_locked(&flash->dev, dst_addr)) {
    1794:	0029      	movs	r1, r5
    1796:	0020      	movs	r0, r4
    1798:	4b12      	ldr	r3, [pc, #72]	; (17e4 <flash_append+0x90>)
    179a:	4798      	blx	r3
    179c:	2800      	cmp	r0, #0
    179e:	d115      	bne.n	17cc <flash_append+0x78>
	_flash_append(&flash->dev, dst_addr, buffer, length);
    17a0:	003b      	movs	r3, r7
    17a2:	0032      	movs	r2, r6
    17a4:	0029      	movs	r1, r5
    17a6:	0020      	movs	r0, r4
    17a8:	4c0f      	ldr	r4, [pc, #60]	; (17e8 <flash_append+0x94>)
    17aa:	47a0      	blx	r4
	return ERR_NONE;
    17ac:	2000      	movs	r0, #0
}
    17ae:	bc04      	pop	{r2}
    17b0:	4690      	mov	r8, r2
    17b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ASSERT(flash && buffer && length);
    17b4:	2000      	movs	r0, #0
    17b6:	e7db      	b.n	1770 <flash_append+0x1c>
    17b8:	2000      	movs	r0, #0
    17ba:	e7d9      	b.n	1770 <flash_append+0x1c>
    17bc:	2001      	movs	r0, #1
    17be:	e7d7      	b.n	1770 <flash_append+0x1c>
		return ERR_BAD_ADDRESS;
    17c0:	200e      	movs	r0, #14
    17c2:	4240      	negs	r0, r0
    17c4:	e7f3      	b.n	17ae <flash_append+0x5a>
    17c6:	200e      	movs	r0, #14
    17c8:	4240      	negs	r0, r0
    17ca:	e7f0      	b.n	17ae <flash_append+0x5a>
		return ERR_DENIED;
    17cc:	2011      	movs	r0, #17
    17ce:	4240      	negs	r0, r0
    17d0:	e7ed      	b.n	17ae <flash_append+0x5a>
    17d2:	46c0      	nop			; (mov r8, r8)
    17d4:	0000aa38 	.word	0x0000aa38
    17d8:	000026c1 	.word	0x000026c1
    17dc:	00002f99 	.word	0x00002f99
    17e0:	00002f9d 	.word	0x00002f9d
    17e4:	000031ed 	.word	0x000031ed
    17e8:	000030c9 	.word	0x000030c9

000017ec <flash_erase>:
{
    17ec:	b5f0      	push	{r4, r5, r6, r7, lr}
    17ee:	b083      	sub	sp, #12
    17f0:	0004      	movs	r4, r0
    17f2:	9100      	str	r1, [sp, #0]
    17f4:	0017      	movs	r7, r2
	ASSERT(flash && page_nums);
    17f6:	2800      	cmp	r0, #0
    17f8:	d025      	beq.n	1846 <flash_erase+0x5a>
    17fa:	2a00      	cmp	r2, #0
    17fc:	d125      	bne.n	184a <flash_erase+0x5e>
    17fe:	2000      	movs	r0, #0
    1800:	229a      	movs	r2, #154	; 0x9a
    1802:	4916      	ldr	r1, [pc, #88]	; (185c <flash_erase+0x70>)
    1804:	4b16      	ldr	r3, [pc, #88]	; (1860 <flash_erase+0x74>)
    1806:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    1808:	0020      	movs	r0, r4
    180a:	4b16      	ldr	r3, [pc, #88]	; (1864 <flash_erase+0x78>)
    180c:	4798      	blx	r3
    180e:	9001      	str	r0, [sp, #4]
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    1810:	0020      	movs	r0, r4
    1812:	4b15      	ldr	r3, [pc, #84]	; (1868 <flash_erase+0x7c>)
    1814:	4798      	blx	r3
    1816:	0005      	movs	r5, r0
	rc = flash_is_address_aligned(flash, dst_addr);
    1818:	9900      	ldr	r1, [sp, #0]
    181a:	0020      	movs	r0, r4
    181c:	4b13      	ldr	r3, [pc, #76]	; (186c <flash_erase+0x80>)
    181e:	4798      	blx	r3
    1820:	1e06      	subs	r6, r0, #0
	if (rc) {
    1822:	d10d      	bne.n	1840 <flash_erase+0x54>
	if ((page_nums > total_pages) || (dst_addr / page_size + page_nums > total_pages)) {
    1824:	42af      	cmp	r7, r5
    1826:	d812      	bhi.n	184e <flash_erase+0x62>
    1828:	9901      	ldr	r1, [sp, #4]
    182a:	9800      	ldr	r0, [sp, #0]
    182c:	4b10      	ldr	r3, [pc, #64]	; (1870 <flash_erase+0x84>)
    182e:	4798      	blx	r3
    1830:	1838      	adds	r0, r7, r0
    1832:	4285      	cmp	r5, r0
    1834:	d30e      	bcc.n	1854 <flash_erase+0x68>
	_flash_erase(&flash->dev, dst_addr, page_nums);
    1836:	003a      	movs	r2, r7
    1838:	9900      	ldr	r1, [sp, #0]
    183a:	0020      	movs	r0, r4
    183c:	4b0d      	ldr	r3, [pc, #52]	; (1874 <flash_erase+0x88>)
    183e:	4798      	blx	r3
}
    1840:	0030      	movs	r0, r6
    1842:	b003      	add	sp, #12
    1844:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ASSERT(flash && page_nums);
    1846:	2000      	movs	r0, #0
    1848:	e7da      	b.n	1800 <flash_erase+0x14>
    184a:	2001      	movs	r0, #1
    184c:	e7d8      	b.n	1800 <flash_erase+0x14>
		return ERR_INVALID_ARG;
    184e:	260d      	movs	r6, #13
    1850:	4276      	negs	r6, r6
    1852:	e7f5      	b.n	1840 <flash_erase+0x54>
    1854:	260d      	movs	r6, #13
    1856:	4276      	negs	r6, r6
    1858:	e7f2      	b.n	1840 <flash_erase+0x54>
    185a:	46c0      	nop			; (mov r8, r8)
    185c:	0000aa38 	.word	0x0000aa38
    1860:	000026c1 	.word	0x000026c1
    1864:	00002f99 	.word	0x00002f99
    1868:	00002f9d 	.word	0x00002f9d
    186c:	000015b9 	.word	0x000015b9
    1870:	0000919d 	.word	0x0000919d
    1874:	00003145 	.word	0x00003145

00001878 <flash_get_page_size>:
{
    1878:	b510      	push	{r4, lr}
    187a:	0004      	movs	r4, r0
	ASSERT(flash);
    187c:	1e43      	subs	r3, r0, #1
    187e:	4198      	sbcs	r0, r3
    1880:	b2c0      	uxtb	r0, r0
    1882:	22f7      	movs	r2, #247	; 0xf7
    1884:	4903      	ldr	r1, [pc, #12]	; (1894 <flash_get_page_size+0x1c>)
    1886:	4b04      	ldr	r3, [pc, #16]	; (1898 <flash_get_page_size+0x20>)
    1888:	4798      	blx	r3
	return _flash_get_page_size(&flash->dev);
    188a:	0020      	movs	r0, r4
    188c:	4b03      	ldr	r3, [pc, #12]	; (189c <flash_get_page_size+0x24>)
    188e:	4798      	blx	r3
}
    1890:	bd10      	pop	{r4, pc}
    1892:	46c0      	nop			; (mov r8, r8)
    1894:	0000aa38 	.word	0x0000aa38
    1898:	000026c1 	.word	0x000026c1
    189c:	00002f99 	.word	0x00002f99

000018a0 <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
    18a0:	b510      	push	{r4, lr}
    18a2:	b084      	sub	sp, #16
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
    18a4:	3814      	subs	r0, #20
    18a6:	8b84      	ldrh	r4, [r0, #28]
    18a8:	ab01      	add	r3, sp, #4
    18aa:	801c      	strh	r4, [r3, #0]
	msg.len    = n;
    18ac:	0014      	movs	r4, r2
    18ae:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP;
    18b0:	4a06      	ldr	r2, [pc, #24]	; (18cc <i2c_m_sync_write+0x2c>)
    18b2:	805a      	strh	r2, [r3, #2]
	msg.buffer = (uint8_t *)buf;
    18b4:	9103      	str	r1, [sp, #12]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    18b6:	0019      	movs	r1, r3
    18b8:	4b05      	ldr	r3, [pc, #20]	; (18d0 <i2c_m_sync_write+0x30>)
    18ba:	4798      	blx	r3

	if (ret) {
    18bc:	2800      	cmp	r0, #0
    18be:	d102      	bne.n	18c6 <i2c_m_sync_write+0x26>
		return ret;
	}

	return n;
}
    18c0:	0020      	movs	r0, r4
    18c2:	b004      	add	sp, #16
    18c4:	bd10      	pop	{r4, pc}
		return ret;
    18c6:	0004      	movs	r4, r0
    18c8:	e7fa      	b.n	18c0 <i2c_m_sync_write+0x20>
    18ca:	46c0      	nop			; (mov r8, r8)
    18cc:	ffff8000 	.word	0xffff8000
    18d0:	00003a85 	.word	0x00003a85

000018d4 <i2c_m_sync_read>:
{
    18d4:	b510      	push	{r4, lr}
    18d6:	b084      	sub	sp, #16
	msg.addr   = i2c->slave_addr;
    18d8:	3814      	subs	r0, #20
    18da:	8b84      	ldrh	r4, [r0, #28]
    18dc:	ab01      	add	r3, sp, #4
    18de:	801c      	strh	r4, [r3, #0]
	msg.len    = n;
    18e0:	0014      	movs	r4, r2
    18e2:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
    18e4:	4a06      	ldr	r2, [pc, #24]	; (1900 <i2c_m_sync_read+0x2c>)
    18e6:	805a      	strh	r2, [r3, #2]
	msg.buffer = buf;
    18e8:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    18ea:	0019      	movs	r1, r3
    18ec:	4b05      	ldr	r3, [pc, #20]	; (1904 <i2c_m_sync_read+0x30>)
    18ee:	4798      	blx	r3
	if (ret) {
    18f0:	2800      	cmp	r0, #0
    18f2:	d102      	bne.n	18fa <i2c_m_sync_read+0x26>
}
    18f4:	0020      	movs	r0, r4
    18f6:	b004      	add	sp, #16
    18f8:	bd10      	pop	{r4, pc}
		return ret;
    18fa:	0004      	movs	r4, r0
    18fc:	e7fa      	b.n	18f4 <i2c_m_sync_read+0x20>
    18fe:	46c0      	nop			; (mov r8, r8)
    1900:	ffff8001 	.word	0xffff8001
    1904:	00003a85 	.word	0x00003a85

00001908 <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
    1908:	b570      	push	{r4, r5, r6, lr}
    190a:	0004      	movs	r4, r0
    190c:	000d      	movs	r5, r1
	int32_t init_status;
	ASSERT(i2c);
    190e:	1e43      	subs	r3, r0, #1
    1910:	4198      	sbcs	r0, r3
    1912:	b2c0      	uxtb	r0, r0
    1914:	225e      	movs	r2, #94	; 0x5e
    1916:	4907      	ldr	r1, [pc, #28]	; (1934 <i2c_m_sync_init+0x2c>)
    1918:	4b07      	ldr	r3, [pc, #28]	; (1938 <i2c_m_sync_init+0x30>)
    191a:	4798      	blx	r3

	init_status = _i2c_m_sync_init(&i2c->device, hw);
    191c:	0029      	movs	r1, r5
    191e:	0020      	movs	r0, r4
    1920:	4b06      	ldr	r3, [pc, #24]	; (193c <i2c_m_sync_init+0x34>)
    1922:	4798      	blx	r3
	if (init_status) {
    1924:	2800      	cmp	r0, #0
    1926:	d103      	bne.n	1930 <i2c_m_sync_init+0x28>
		return init_status;
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
    1928:	4b05      	ldr	r3, [pc, #20]	; (1940 <i2c_m_sync_init+0x38>)
    192a:	61a3      	str	r3, [r4, #24]
	i2c->io.write = i2c_m_sync_write;
    192c:	4b05      	ldr	r3, [pc, #20]	; (1944 <i2c_m_sync_init+0x3c>)
    192e:	6163      	str	r3, [r4, #20]

	return ERR_NONE;
}
    1930:	bd70      	pop	{r4, r5, r6, pc}
    1932:	46c0      	nop			; (mov r8, r8)
    1934:	0000aa50 	.word	0x0000aa50
    1938:	000026c1 	.word	0x000026c1
    193c:	00003a55 	.word	0x00003a55
    1940:	000018d5 	.word	0x000018d5
    1944:	000018a1 	.word	0x000018a1

00001948 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    1948:	b570      	push	{r4, r5, r6, lr}
    194a:	0004      	movs	r4, r0
    194c:	000d      	movs	r5, r1
    194e:	0016      	movs	r6, r2
	ASSERT(io_descr && buf);
    1950:	2800      	cmp	r0, #0
    1952:	d00e      	beq.n	1972 <io_write+0x2a>
    1954:	2900      	cmp	r1, #0
    1956:	d00a      	beq.n	196e <io_write+0x26>
    1958:	2001      	movs	r0, #1
    195a:	2234      	movs	r2, #52	; 0x34
    195c:	4906      	ldr	r1, [pc, #24]	; (1978 <io_write+0x30>)
    195e:	4b07      	ldr	r3, [pc, #28]	; (197c <io_write+0x34>)
    1960:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
    1962:	6823      	ldr	r3, [r4, #0]
    1964:	0032      	movs	r2, r6
    1966:	0029      	movs	r1, r5
    1968:	0020      	movs	r0, r4
    196a:	4798      	blx	r3
}
    196c:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(io_descr && buf);
    196e:	2000      	movs	r0, #0
    1970:	e7f3      	b.n	195a <io_write+0x12>
    1972:	2000      	movs	r0, #0
    1974:	e7f1      	b.n	195a <io_write+0x12>
    1976:	46c0      	nop			; (mov r8, r8)
    1978:	0000aa6c 	.word	0x0000aa6c
    197c:	000026c1 	.word	0x000026c1

00001980 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    1980:	b570      	push	{r4, r5, r6, lr}
    1982:	0004      	movs	r4, r0
    1984:	000d      	movs	r5, r1
    1986:	0016      	movs	r6, r2
	ASSERT(io_descr && buf);
    1988:	2800      	cmp	r0, #0
    198a:	d00e      	beq.n	19aa <io_read+0x2a>
    198c:	2900      	cmp	r1, #0
    198e:	d00a      	beq.n	19a6 <io_read+0x26>
    1990:	2001      	movs	r0, #1
    1992:	223d      	movs	r2, #61	; 0x3d
    1994:	4906      	ldr	r1, [pc, #24]	; (19b0 <io_read+0x30>)
    1996:	4b07      	ldr	r3, [pc, #28]	; (19b4 <io_read+0x34>)
    1998:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
    199a:	6863      	ldr	r3, [r4, #4]
    199c:	0032      	movs	r2, r6
    199e:	0029      	movs	r1, r5
    19a0:	0020      	movs	r0, r4
    19a2:	4798      	blx	r3
}
    19a4:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(io_descr && buf);
    19a6:	2000      	movs	r0, #0
    19a8:	e7f3      	b.n	1992 <io_read+0x12>
    19aa:	2000      	movs	r0, #0
    19ac:	e7f1      	b.n	1992 <io_read+0x12>
    19ae:	46c0      	nop			; (mov r8, r8)
    19b0:	0000aa6c 	.word	0x0000aa6c
    19b4:	000026c1 	.word	0x000026c1

000019b8 <spi_m_sync_init>:
	ASSERT(spi);
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
    19b8:	b570      	push	{r4, r5, r6, lr}
    19ba:	0004      	movs	r4, r0
    19bc:	000d      	movs	r5, r1
	int32_t rc = 0;
	ASSERT(spi && hw);
    19be:	2800      	cmp	r0, #0
    19c0:	d017      	beq.n	19f2 <spi_m_sync_init+0x3a>
    19c2:	2900      	cmp	r1, #0
    19c4:	d013      	beq.n	19ee <spi_m_sync_init+0x36>
    19c6:	2001      	movs	r0, #1
    19c8:	2240      	movs	r2, #64	; 0x40
    19ca:	490b      	ldr	r1, [pc, #44]	; (19f8 <spi_m_sync_init+0x40>)
    19cc:	4b0b      	ldr	r3, [pc, #44]	; (19fc <spi_m_sync_init+0x44>)
    19ce:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
    19d0:	6065      	str	r5, [r4, #4]
	rc            = _spi_m_sync_init(&spi->dev, hw);
    19d2:	1d20      	adds	r0, r4, #4
    19d4:	0029      	movs	r1, r5
    19d6:	4b0a      	ldr	r3, [pc, #40]	; (1a00 <spi_m_sync_init+0x48>)
    19d8:	4798      	blx	r3

	if (rc < 0) {
    19da:	2800      	cmp	r0, #0
    19dc:	db06      	blt.n	19ec <spi_m_sync_init+0x34>
		return rc;
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
    19de:	4b09      	ldr	r3, [pc, #36]	; (1a04 <spi_m_sync_init+0x4c>)
    19e0:	82a3      	strh	r3, [r4, #20]
	spi->io.read  = _spi_m_sync_io_read;
    19e2:	4b09      	ldr	r3, [pc, #36]	; (1a08 <spi_m_sync_init+0x50>)
    19e4:	6123      	str	r3, [r4, #16]
	spi->io.write = _spi_m_sync_io_write;
    19e6:	4b09      	ldr	r3, [pc, #36]	; (1a0c <spi_m_sync_init+0x54>)
    19e8:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
    19ea:	2000      	movs	r0, #0
}
    19ec:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(spi && hw);
    19ee:	2000      	movs	r0, #0
    19f0:	e7ea      	b.n	19c8 <spi_m_sync_init+0x10>
    19f2:	2000      	movs	r0, #0
    19f4:	e7e8      	b.n	19c8 <spi_m_sync_init+0x10>
    19f6:	46c0      	nop			; (mov r8, r8)
    19f8:	0000aa80 	.word	0x0000aa80
    19fc:	000026c1 	.word	0x000026c1
    1a00:	00003d15 	.word	0x00003d15
    1a04:	ffff8000 	.word	0xffff8000
    1a08:	00001a95 	.word	0x00001a95
    1a0c:	00001a59 	.word	0x00001a59

00001a10 <spi_m_sync_transfer>:

	return spi_m_sync_transfer(spi, &xfer);
}

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
    1a10:	b530      	push	{r4, r5, lr}
    1a12:	b087      	sub	sp, #28
    1a14:	0004      	movs	r4, r0
    1a16:	000d      	movs	r5, r1
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
    1a18:	2800      	cmp	r0, #0
    1a1a:	d015      	beq.n	1a48 <spi_m_sync_transfer+0x38>
    1a1c:	2900      	cmp	r1, #0
    1a1e:	d011      	beq.n	1a44 <spi_m_sync_transfer+0x34>
    1a20:	2001      	movs	r0, #1
    1a22:	22b3      	movs	r2, #179	; 0xb3
    1a24:	4909      	ldr	r1, [pc, #36]	; (1a4c <spi_m_sync_transfer+0x3c>)
    1a26:	4b0a      	ldr	r3, [pc, #40]	; (1a50 <spi_m_sync_transfer+0x40>)
    1a28:	4798      	blx	r3

	msg.txbuf = p_xfer->txbuf;
    1a2a:	682b      	ldr	r3, [r5, #0]
    1a2c:	9303      	str	r3, [sp, #12]
	msg.rxbuf = p_xfer->rxbuf;
    1a2e:	686b      	ldr	r3, [r5, #4]
    1a30:	9304      	str	r3, [sp, #16]
	msg.size  = p_xfer->size;
    1a32:	68ab      	ldr	r3, [r5, #8]
    1a34:	9301      	str	r3, [sp, #4]
    1a36:	9305      	str	r3, [sp, #20]
	return _spi_m_sync_trans(&spi->dev, &msg);
    1a38:	1d20      	adds	r0, r4, #4
    1a3a:	a903      	add	r1, sp, #12
    1a3c:	4b05      	ldr	r3, [pc, #20]	; (1a54 <spi_m_sync_transfer+0x44>)
    1a3e:	4798      	blx	r3
}
    1a40:	b007      	add	sp, #28
    1a42:	bd30      	pop	{r4, r5, pc}
	ASSERT(spi && p_xfer);
    1a44:	2000      	movs	r0, #0
    1a46:	e7ec      	b.n	1a22 <spi_m_sync_transfer+0x12>
    1a48:	2000      	movs	r0, #0
    1a4a:	e7ea      	b.n	1a22 <spi_m_sync_transfer+0x12>
    1a4c:	0000aa80 	.word	0x0000aa80
    1a50:	000026c1 	.word	0x000026c1
    1a54:	00003f11 	.word	0x00003f11

00001a58 <_spi_m_sync_io_write>:
{
    1a58:	b570      	push	{r4, r5, r6, lr}
    1a5a:	b084      	sub	sp, #16
    1a5c:	0004      	movs	r4, r0
    1a5e:	000e      	movs	r6, r1
    1a60:	0015      	movs	r5, r2
	ASSERT(io);
    1a62:	1e43      	subs	r3, r0, #1
    1a64:	4198      	sbcs	r0, r3
    1a66:	b2c0      	uxtb	r0, r0
    1a68:	22a3      	movs	r2, #163	; 0xa3
    1a6a:	4907      	ldr	r1, [pc, #28]	; (1a88 <_spi_m_sync_io_write+0x30>)
    1a6c:	4b07      	ldr	r3, [pc, #28]	; (1a8c <_spi_m_sync_io_write+0x34>)
    1a6e:	4798      	blx	r3
	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
    1a70:	0020      	movs	r0, r4
    1a72:	380c      	subs	r0, #12
	xfer.rxbuf = 0;
    1a74:	2300      	movs	r3, #0
    1a76:	9302      	str	r3, [sp, #8]
	xfer.txbuf = (uint8_t *)buf;
    1a78:	9601      	str	r6, [sp, #4]
	xfer.size  = length;
    1a7a:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
    1a7c:	a901      	add	r1, sp, #4
    1a7e:	4b04      	ldr	r3, [pc, #16]	; (1a90 <_spi_m_sync_io_write+0x38>)
    1a80:	4798      	blx	r3
}
    1a82:	b004      	add	sp, #16
    1a84:	bd70      	pop	{r4, r5, r6, pc}
    1a86:	46c0      	nop			; (mov r8, r8)
    1a88:	0000aa80 	.word	0x0000aa80
    1a8c:	000026c1 	.word	0x000026c1
    1a90:	00001a11 	.word	0x00001a11

00001a94 <_spi_m_sync_io_read>:
{
    1a94:	b570      	push	{r4, r5, r6, lr}
    1a96:	b084      	sub	sp, #16
    1a98:	0004      	movs	r4, r0
    1a9a:	000e      	movs	r6, r1
    1a9c:	0015      	movs	r5, r2
	ASSERT(io);
    1a9e:	1e43      	subs	r3, r0, #1
    1aa0:	4198      	sbcs	r0, r3
    1aa2:	b2c0      	uxtb	r0, r0
    1aa4:	2287      	movs	r2, #135	; 0x87
    1aa6:	4907      	ldr	r1, [pc, #28]	; (1ac4 <_spi_m_sync_io_read+0x30>)
    1aa8:	4b07      	ldr	r3, [pc, #28]	; (1ac8 <_spi_m_sync_io_read+0x34>)
    1aaa:	4798      	blx	r3
	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
    1aac:	0020      	movs	r0, r4
    1aae:	380c      	subs	r0, #12
	xfer.rxbuf = buf;
    1ab0:	9602      	str	r6, [sp, #8]
	xfer.txbuf = 0;
    1ab2:	2300      	movs	r3, #0
    1ab4:	9301      	str	r3, [sp, #4]
	xfer.size  = length;
    1ab6:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
    1ab8:	a901      	add	r1, sp, #4
    1aba:	4b04      	ldr	r3, [pc, #16]	; (1acc <_spi_m_sync_io_read+0x38>)
    1abc:	4798      	blx	r3
}
    1abe:	b004      	add	sp, #16
    1ac0:	bd70      	pop	{r4, r5, r6, pc}
    1ac2:	46c0      	nop			; (mov r8, r8)
    1ac4:	0000aa80 	.word	0x0000aa80
    1ac8:	000026c1 	.word	0x000026c1
    1acc:	00001a11 	.word	0x00001a11

00001ad0 <timer_add_timer_task>:
 * \param[in] head The pointer to the head of timer task list
 * \param[in] task The pointer to task to add
 * \param[in] time Current timer time
 */
static void timer_add_timer_task(struct list_descriptor *list, struct timer_task *const new_task, const uint32_t time)
{
    1ad0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * \return A pointer to the head of the given list or NULL if the list is
 * empty
 */
static inline void *list_get_head(const struct list_descriptor *const list)
{
	return (void *)list->head;
    1ad2:	6806      	ldr	r6, [r0, #0]
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);

	if (!head) {
    1ad4:	2e00      	cmp	r6, #0
    1ad6:	d002      	beq.n	1ade <timer_add_timer_task+0xe>
    1ad8:	0033      	movs	r3, r6
    1ada:	2500      	movs	r5, #0
    1adc:	e00c      	b.n	1af8 <timer_add_timer_task+0x28>
		list_insert_as_head(list, new_task);
    1ade:	4b10      	ldr	r3, [pc, #64]	; (1b20 <timer_add_timer_task+0x50>)
    1ae0:	4798      	blx	r3
		return;
    1ae2:	e018      	b.n	1b16 <timer_add_timer_task+0x46>
		uint32_t time_left;

		if (it->time_label <= time) {
			time_left = it->interval - (time - it->time_label);
		} else {
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    1ae4:	689f      	ldr	r7, [r3, #8]
    1ae6:	46bc      	mov	ip, r7
    1ae8:	4464      	add	r4, ip
    1aea:	1aa4      	subs	r4, r4, r2
    1aec:	3401      	adds	r4, #1
		}
		if (time_left >= new_task->interval)
    1aee:	688f      	ldr	r7, [r1, #8]
    1af0:	42bc      	cmp	r4, r7
    1af2:	d20b      	bcs.n	1b0c <timer_add_timer_task+0x3c>
			break;
		prev = it;
    1af4:	001d      	movs	r5, r3
	for (it = head; it; it = (struct timer_task *)list_get_next_element(it)) {
    1af6:	681b      	ldr	r3, [r3, #0]
    1af8:	2b00      	cmp	r3, #0
    1afa:	d007      	beq.n	1b0c <timer_add_timer_task+0x3c>
		if (it->time_label <= time) {
    1afc:	685c      	ldr	r4, [r3, #4]
    1afe:	4294      	cmp	r4, r2
    1b00:	d8f0      	bhi.n	1ae4 <timer_add_timer_task+0x14>
			time_left = it->interval - (time - it->time_label);
    1b02:	1aa4      	subs	r4, r4, r2
    1b04:	689f      	ldr	r7, [r3, #8]
    1b06:	46bc      	mov	ip, r7
    1b08:	4464      	add	r4, ip
    1b0a:	e7f0      	b.n	1aee <timer_add_timer_task+0x1e>
	}

	if (it == head) {
    1b0c:	42b3      	cmp	r3, r6
    1b0e:	d003      	beq.n	1b18 <timer_add_timer_task+0x48>
		list_insert_as_head(list, new_task);
	} else {
		list_insert_after(prev, new_task);
    1b10:	0028      	movs	r0, r5
    1b12:	4b04      	ldr	r3, [pc, #16]	; (1b24 <timer_add_timer_task+0x54>)
    1b14:	4798      	blx	r3
	}
}
    1b16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		list_insert_as_head(list, new_task);
    1b18:	4b01      	ldr	r3, [pc, #4]	; (1b20 <timer_add_timer_task+0x50>)
    1b1a:	4798      	blx	r3
    1b1c:	e7fb      	b.n	1b16 <timer_add_timer_task+0x46>
    1b1e:	46c0      	nop			; (mov r8, r8)
    1b20:	000026e1 	.word	0x000026e1
    1b24:	0000270d 	.word	0x0000270d

00001b28 <timer_process_counted>:

/**
 * \internal Process interrupts
 */
static void timer_process_counted(struct _timer_device *device)
{
    1b28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1b2a:	0005      	movs	r5, r0
    1b2c:	6944      	ldr	r4, [r0, #20]
	struct timer_descriptor *timer = CONTAINER_OF(device, struct timer_descriptor, device);
	struct timer_task *      it    = (struct timer_task *)list_get_head(&timer->tasks);
	uint32_t                 time  = ++timer->time;
    1b2e:	6903      	ldr	r3, [r0, #16]
    1b30:	1c5e      	adds	r6, r3, #1
    1b32:	6106      	str	r6, [r0, #16]

	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    1b34:	7e03      	ldrb	r3, [r0, #24]
    1b36:	07db      	lsls	r3, r3, #31
    1b38:	d402      	bmi.n	1b40 <timer_process_counted+0x18>
    1b3a:	7e03      	ldrb	r3, [r0, #24]
    1b3c:	079b      	lsls	r3, r3, #30
    1b3e:	d50a      	bpl.n	1b56 <timer_process_counted+0x2e>
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
    1b40:	7e2b      	ldrb	r3, [r5, #24]
    1b42:	2202      	movs	r2, #2
    1b44:	4313      	orrs	r3, r2
    1b46:	b2db      	uxtb	r3, r3
    1b48:	762b      	strb	r3, [r5, #24]
		}
		it = (struct timer_task *)list_get_head(&timer->tasks);

		tmp->cb(tmp);
	}
}
    1b4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1b4c:	696f      	ldr	r7, [r5, #20]
		tmp->cb(tmp);
    1b4e:	68e3      	ldr	r3, [r4, #12]
    1b50:	0020      	movs	r0, r4
    1b52:	4798      	blx	r3
		it = (struct timer_task *)list_get_head(&timer->tasks);
    1b54:	003c      	movs	r4, r7
	while (it && ((time - it->time_label) >= it->interval)) {
    1b56:	2c00      	cmp	r4, #0
    1b58:	d0f7      	beq.n	1b4a <timer_process_counted+0x22>
    1b5a:	6863      	ldr	r3, [r4, #4]
    1b5c:	1af3      	subs	r3, r6, r3
    1b5e:	68a2      	ldr	r2, [r4, #8]
    1b60:	4293      	cmp	r3, r2
    1b62:	d3f2      	bcc.n	1b4a <timer_process_counted+0x22>
		list_remove_head(&timer->tasks);
    1b64:	002f      	movs	r7, r5
    1b66:	3714      	adds	r7, #20
    1b68:	0038      	movs	r0, r7
    1b6a:	4b06      	ldr	r3, [pc, #24]	; (1b84 <timer_process_counted+0x5c>)
    1b6c:	4798      	blx	r3
		if (TIMER_TASK_REPEAT == tmp->mode) {
    1b6e:	7c23      	ldrb	r3, [r4, #16]
    1b70:	2b01      	cmp	r3, #1
    1b72:	d1eb      	bne.n	1b4c <timer_process_counted+0x24>
			tmp->time_label = time;
    1b74:	6066      	str	r6, [r4, #4]
			timer_add_timer_task(&timer->tasks, tmp, time);
    1b76:	0032      	movs	r2, r6
    1b78:	0021      	movs	r1, r4
    1b7a:	0038      	movs	r0, r7
    1b7c:	4b02      	ldr	r3, [pc, #8]	; (1b88 <timer_process_counted+0x60>)
    1b7e:	4798      	blx	r3
    1b80:	e7e4      	b.n	1b4c <timer_process_counted+0x24>
    1b82:	46c0      	nop			; (mov r8, r8)
    1b84:	00002755 	.word	0x00002755
    1b88:	00001ad1 	.word	0x00001ad1

00001b8c <timer_init>:
{
    1b8c:	b570      	push	{r4, r5, r6, lr}
    1b8e:	0004      	movs	r4, r0
    1b90:	000d      	movs	r5, r1
	ASSERT(descr && hw);
    1b92:	2800      	cmp	r0, #0
    1b94:	d012      	beq.n	1bbc <timer_init+0x30>
    1b96:	2900      	cmp	r1, #0
    1b98:	d00e      	beq.n	1bb8 <timer_init+0x2c>
    1b9a:	2001      	movs	r0, #1
    1b9c:	223b      	movs	r2, #59	; 0x3b
    1b9e:	4908      	ldr	r1, [pc, #32]	; (1bc0 <timer_init+0x34>)
    1ba0:	4b08      	ldr	r3, [pc, #32]	; (1bc4 <timer_init+0x38>)
    1ba2:	4798      	blx	r3
	_timer_init(&descr->device, hw);
    1ba4:	0029      	movs	r1, r5
    1ba6:	0020      	movs	r0, r4
    1ba8:	4b07      	ldr	r3, [pc, #28]	; (1bc8 <timer_init+0x3c>)
    1baa:	4798      	blx	r3
	descr->time                           = 0;
    1bac:	2300      	movs	r3, #0
    1bae:	6123      	str	r3, [r4, #16]
	descr->device.timer_cb.period_expired = timer_process_counted;
    1bb0:	4b06      	ldr	r3, [pc, #24]	; (1bcc <timer_init+0x40>)
    1bb2:	6023      	str	r3, [r4, #0]
}
    1bb4:	2000      	movs	r0, #0
    1bb6:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw);
    1bb8:	2000      	movs	r0, #0
    1bba:	e7ef      	b.n	1b9c <timer_init+0x10>
    1bbc:	2000      	movs	r0, #0
    1bbe:	e7ed      	b.n	1b9c <timer_init+0x10>
    1bc0:	0000aa9c 	.word	0x0000aa9c
    1bc4:	000026c1 	.word	0x000026c1
    1bc8:	00003271 	.word	0x00003271
    1bcc:	00001b29 	.word	0x00001b29

00001bd0 <timer_start>:
{
    1bd0:	b510      	push	{r4, lr}
    1bd2:	0004      	movs	r4, r0
	ASSERT(descr);
    1bd4:	1e43      	subs	r3, r0, #1
    1bd6:	4198      	sbcs	r0, r3
    1bd8:	b2c0      	uxtb	r0, r0
    1bda:	2253      	movs	r2, #83	; 0x53
    1bdc:	4907      	ldr	r1, [pc, #28]	; (1bfc <timer_start+0x2c>)
    1bde:	4b08      	ldr	r3, [pc, #32]	; (1c00 <timer_start+0x30>)
    1be0:	4798      	blx	r3
	if (_timer_is_started(&descr->device)) {
    1be2:	0020      	movs	r0, r4
    1be4:	4b07      	ldr	r3, [pc, #28]	; (1c04 <timer_start+0x34>)
    1be6:	4798      	blx	r3
    1be8:	2800      	cmp	r0, #0
    1bea:	d104      	bne.n	1bf6 <timer_start+0x26>
	_timer_start(&descr->device);
    1bec:	0020      	movs	r0, r4
    1bee:	4b06      	ldr	r3, [pc, #24]	; (1c08 <timer_start+0x38>)
    1bf0:	4798      	blx	r3
	return ERR_NONE;
    1bf2:	2000      	movs	r0, #0
}
    1bf4:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
    1bf6:	2011      	movs	r0, #17
    1bf8:	4240      	negs	r0, r0
    1bfa:	e7fb      	b.n	1bf4 <timer_start+0x24>
    1bfc:	0000aa9c 	.word	0x0000aa9c
    1c00:	000026c1 	.word	0x000026c1
    1c04:	00003325 	.word	0x00003325
    1c08:	000032cd 	.word	0x000032cd

00001c0c <timer_add_task>:
{
    1c0c:	b570      	push	{r4, r5, r6, lr}
    1c0e:	b082      	sub	sp, #8
    1c10:	0004      	movs	r4, r0
    1c12:	000d      	movs	r5, r1
	ASSERT(descr && task);
    1c14:	2800      	cmp	r0, #0
    1c16:	d026      	beq.n	1c66 <timer_add_task+0x5a>
    1c18:	2900      	cmp	r1, #0
    1c1a:	d022      	beq.n	1c62 <timer_add_task+0x56>
    1c1c:	2001      	movs	r0, #1
    1c1e:	227a      	movs	r2, #122	; 0x7a
    1c20:	491f      	ldr	r1, [pc, #124]	; (1ca0 <timer_add_task+0x94>)
    1c22:	4b20      	ldr	r3, [pc, #128]	; (1ca4 <timer_add_task+0x98>)
    1c24:	4798      	blx	r3
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
    1c26:	7e23      	ldrb	r3, [r4, #24]
    1c28:	2201      	movs	r2, #1
    1c2a:	4313      	orrs	r3, r2
    1c2c:	b2db      	uxtb	r3, r3
    1c2e:	7623      	strb	r3, [r4, #24]
	if (is_list_element(&descr->tasks, task)) {
    1c30:	0026      	movs	r6, r4
    1c32:	3614      	adds	r6, #20
    1c34:	0029      	movs	r1, r5
    1c36:	0030      	movs	r0, r6
    1c38:	4b1b      	ldr	r3, [pc, #108]	; (1ca8 <timer_add_task+0x9c>)
    1c3a:	4798      	blx	r3
    1c3c:	2800      	cmp	r0, #0
    1c3e:	d114      	bne.n	1c6a <timer_add_task+0x5e>
	task->time_label = descr->time;
    1c40:	6923      	ldr	r3, [r4, #16]
    1c42:	606b      	str	r3, [r5, #4]
	timer_add_timer_task(&descr->tasks, task, descr->time);
    1c44:	6922      	ldr	r2, [r4, #16]
    1c46:	0029      	movs	r1, r5
    1c48:	0030      	movs	r0, r6
    1c4a:	4b18      	ldr	r3, [pc, #96]	; (1cac <timer_add_task+0xa0>)
    1c4c:	4798      	blx	r3
	descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    1c4e:	7e23      	ldrb	r3, [r4, #24]
    1c50:	2201      	movs	r2, #1
    1c52:	4393      	bics	r3, r2
    1c54:	7623      	strb	r3, [r4, #24]
	if (descr->flags & TIMER_FLAG_INTERRUPT_TRIGERRED) {
    1c56:	7e23      	ldrb	r3, [r4, #24]
    1c58:	079b      	lsls	r3, r3, #30
    1c5a:	d412      	bmi.n	1c82 <timer_add_task+0x76>
	return ERR_NONE;
    1c5c:	2000      	movs	r0, #0
}
    1c5e:	b002      	add	sp, #8
    1c60:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && task);
    1c62:	2000      	movs	r0, #0
    1c64:	e7db      	b.n	1c1e <timer_add_task+0x12>
    1c66:	2000      	movs	r0, #0
    1c68:	e7d9      	b.n	1c1e <timer_add_task+0x12>
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    1c6a:	7e23      	ldrb	r3, [r4, #24]
    1c6c:	2201      	movs	r2, #1
    1c6e:	4393      	bics	r3, r2
    1c70:	7623      	strb	r3, [r4, #24]
		ASSERT(false);
    1c72:	327e      	adds	r2, #126	; 0x7e
    1c74:	490a      	ldr	r1, [pc, #40]	; (1ca0 <timer_add_task+0x94>)
    1c76:	2000      	movs	r0, #0
    1c78:	4b0a      	ldr	r3, [pc, #40]	; (1ca4 <timer_add_task+0x98>)
    1c7a:	4798      	blx	r3
		return ERR_ALREADY_INITIALIZED;
    1c7c:	2012      	movs	r0, #18
    1c7e:	4240      	negs	r0, r0
    1c80:	e7ed      	b.n	1c5e <timer_add_task+0x52>
		CRITICAL_SECTION_ENTER()
    1c82:	a801      	add	r0, sp, #4
    1c84:	4b0a      	ldr	r3, [pc, #40]	; (1cb0 <timer_add_task+0xa4>)
    1c86:	4798      	blx	r3
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
    1c88:	7e23      	ldrb	r3, [r4, #24]
    1c8a:	2202      	movs	r2, #2
    1c8c:	4393      	bics	r3, r2
    1c8e:	7623      	strb	r3, [r4, #24]
		_timer_set_irq(&descr->device);
    1c90:	0020      	movs	r0, r4
    1c92:	4b08      	ldr	r3, [pc, #32]	; (1cb4 <timer_add_task+0xa8>)
    1c94:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
    1c96:	a801      	add	r0, sp, #4
    1c98:	4b07      	ldr	r3, [pc, #28]	; (1cb8 <timer_add_task+0xac>)
    1c9a:	4798      	blx	r3
	return ERR_NONE;
    1c9c:	2000      	movs	r0, #0
    1c9e:	e7de      	b.n	1c5e <timer_add_task+0x52>
    1ca0:	0000aa9c 	.word	0x0000aa9c
    1ca4:	000026c1 	.word	0x000026c1
    1ca8:	000026c9 	.word	0x000026c9
    1cac:	00001ad1 	.word	0x00001ad1
    1cb0:	00001271 	.word	0x00001271
    1cb4:	00003337 	.word	0x00003337
    1cb8:	0000127f 	.word	0x0000127f

00001cbc <usart_transmission_complete>:
 * \brief Process completion of data sending
 *
 * \param[in] device The pointer to device structure
 */
static void usart_transmission_complete(struct _usart_async_device *device)
{
    1cbc:	b510      	push	{r4, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
    1cbe:	3808      	subs	r0, #8

	descr->stat = 0;
    1cc0:	2300      	movs	r3, #0
    1cc2:	6303      	str	r3, [r0, #48]	; 0x30
	if (descr->usart_cb.tx_done) {
    1cc4:	6a43      	ldr	r3, [r0, #36]	; 0x24
    1cc6:	2b00      	cmp	r3, #0
    1cc8:	d000      	beq.n	1ccc <usart_transmission_complete+0x10>
		descr->usart_cb.tx_done(descr);
    1cca:	4798      	blx	r3
	}
}
    1ccc:	bd10      	pop	{r4, pc}

00001cce <usart_error>:
 * \brief Process error interrupt
 *
 * \param[in] device The pointer to device structure
 */
static void usart_error(struct _usart_async_device *device)
{
    1cce:	b510      	push	{r4, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
    1cd0:	3808      	subs	r0, #8

	descr->stat = 0;
    1cd2:	2300      	movs	r3, #0
    1cd4:	6303      	str	r3, [r0, #48]	; 0x30
	if (descr->usart_cb.error) {
    1cd6:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    1cd8:	2b00      	cmp	r3, #0
    1cda:	d000      	beq.n	1cde <usart_error+0x10>
		descr->usart_cb.error(descr);
    1cdc:	4798      	blx	r3
	}
}
    1cde:	bd10      	pop	{r4, pc}

00001ce0 <usart_fill_rx_buffer>:
{
    1ce0:	b510      	push	{r4, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
    1ce2:	0004      	movs	r4, r0
	ringbuffer_put(&descr->rx, data);
    1ce4:	302c      	adds	r0, #44	; 0x2c
    1ce6:	4b04      	ldr	r3, [pc, #16]	; (1cf8 <usart_fill_rx_buffer+0x18>)
    1ce8:	4798      	blx	r3
	if (descr->usart_cb.rx_done) {
    1cea:	6a23      	ldr	r3, [r4, #32]
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
    1cec:	3c08      	subs	r4, #8
	if (descr->usart_cb.rx_done) {
    1cee:	2b00      	cmp	r3, #0
    1cf0:	d001      	beq.n	1cf6 <usart_fill_rx_buffer+0x16>
		descr->usart_cb.rx_done(descr);
    1cf2:	0020      	movs	r0, r4
    1cf4:	4798      	blx	r3
}
    1cf6:	bd10      	pop	{r4, pc}
    1cf8:	00002801 	.word	0x00002801

00001cfc <usart_async_write>:
{
    1cfc:	b570      	push	{r4, r5, r6, lr}
    1cfe:	0004      	movs	r4, r0
    1d00:	000e      	movs	r6, r1
    1d02:	0015      	movs	r5, r2
	ASSERT(descr && buf && length);
    1d04:	2800      	cmp	r0, #0
    1d06:	d01d      	beq.n	1d44 <usart_async_write+0x48>
    1d08:	2900      	cmp	r1, #0
    1d0a:	d01d      	beq.n	1d48 <usart_async_write+0x4c>
    1d0c:	2a00      	cmp	r2, #0
    1d0e:	d11d      	bne.n	1d4c <usart_async_write+0x50>
    1d10:	2000      	movs	r0, #0
    1d12:	223c      	movs	r2, #60	; 0x3c
    1d14:	32ff      	adds	r2, #255	; 0xff
    1d16:	4910      	ldr	r1, [pc, #64]	; (1d58 <usart_async_write+0x5c>)
    1d18:	4b10      	ldr	r3, [pc, #64]	; (1d5c <usart_async_write+0x60>)
    1d1a:	4798      	blx	r3
	if (descr->tx_por != descr->tx_buffer_length) {
    1d1c:	2344      	movs	r3, #68	; 0x44
    1d1e:	5ae2      	ldrh	r2, [r4, r3]
    1d20:	3308      	adds	r3, #8
    1d22:	5ae3      	ldrh	r3, [r4, r3]
    1d24:	429a      	cmp	r2, r3
    1d26:	d113      	bne.n	1d50 <usart_async_write+0x54>
	descr->tx_buffer        = (uint8_t *)buf;
    1d28:	64a6      	str	r6, [r4, #72]	; 0x48
	descr->tx_buffer_length = length;
    1d2a:	234c      	movs	r3, #76	; 0x4c
    1d2c:	52e5      	strh	r5, [r4, r3]
	descr->tx_por           = 0;
    1d2e:	2200      	movs	r2, #0
    1d30:	3b08      	subs	r3, #8
    1d32:	52e2      	strh	r2, [r4, r3]
	descr->stat             = USART_ASYNC_STATUS_BUSY;
    1d34:	3b43      	subs	r3, #67	; 0x43
    1d36:	6323      	str	r3, [r4, #48]	; 0x30
	_usart_async_enable_byte_sent_irq(&descr->device);
    1d38:	0020      	movs	r0, r4
    1d3a:	3008      	adds	r0, #8
    1d3c:	4b08      	ldr	r3, [pc, #32]	; (1d60 <usart_async_write+0x64>)
    1d3e:	4798      	blx	r3
	return (int32_t)length;
    1d40:	0028      	movs	r0, r5
}
    1d42:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && buf && length);
    1d44:	2000      	movs	r0, #0
    1d46:	e7e4      	b.n	1d12 <usart_async_write+0x16>
    1d48:	2000      	movs	r0, #0
    1d4a:	e7e2      	b.n	1d12 <usart_async_write+0x16>
    1d4c:	2001      	movs	r0, #1
    1d4e:	e7e0      	b.n	1d12 <usart_async_write+0x16>
		return ERR_NO_RESOURCE;
    1d50:	201c      	movs	r0, #28
    1d52:	4240      	negs	r0, r0
    1d54:	e7f5      	b.n	1d42 <usart_async_write+0x46>
    1d56:	46c0      	nop			; (mov r8, r8)
    1d58:	0000aab4 	.word	0x0000aab4
    1d5c:	000026c1 	.word	0x000026c1
    1d60:	000039cd 	.word	0x000039cd

00001d64 <usart_process_byte_sent>:
{
    1d64:	b570      	push	{r4, r5, r6, lr}
    1d66:	0004      	movs	r4, r0
	if (descr->tx_por != descr->tx_buffer_length) {
    1d68:	0002      	movs	r2, r0
    1d6a:	3a08      	subs	r2, #8
    1d6c:	2344      	movs	r3, #68	; 0x44
    1d6e:	5ad3      	ldrh	r3, [r2, r3]
    1d70:	214c      	movs	r1, #76	; 0x4c
    1d72:	5a52      	ldrh	r2, [r2, r1]
    1d74:	4293      	cmp	r3, r2
    1d76:	d00d      	beq.n	1d94 <usart_process_byte_sent+0x30>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
    1d78:	0002      	movs	r2, r0
    1d7a:	6c01      	ldr	r1, [r0, #64]	; 0x40
    1d7c:	3a08      	subs	r2, #8
    1d7e:	1c5d      	adds	r5, r3, #1
    1d80:	2044      	movs	r0, #68	; 0x44
    1d82:	5215      	strh	r5, [r2, r0]
    1d84:	5cc9      	ldrb	r1, [r1, r3]
    1d86:	0020      	movs	r0, r4
    1d88:	4b04      	ldr	r3, [pc, #16]	; (1d9c <usart_process_byte_sent+0x38>)
    1d8a:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
    1d8c:	0020      	movs	r0, r4
    1d8e:	4b04      	ldr	r3, [pc, #16]	; (1da0 <usart_process_byte_sent+0x3c>)
    1d90:	4798      	blx	r3
}
    1d92:	bd70      	pop	{r4, r5, r6, pc}
		_usart_async_enable_tx_done_irq(&descr->device);
    1d94:	4b03      	ldr	r3, [pc, #12]	; (1da4 <usart_process_byte_sent+0x40>)
    1d96:	4798      	blx	r3
}
    1d98:	e7fb      	b.n	1d92 <usart_process_byte_sent+0x2e>
    1d9a:	46c0      	nop			; (mov r8, r8)
    1d9c:	00003991 	.word	0x00003991
    1da0:	000039cd 	.word	0x000039cd
    1da4:	000039d5 	.word	0x000039d5

00001da8 <usart_async_read>:
{
    1da8:	b5f0      	push	{r4, r5, r6, r7, lr}
    1daa:	b085      	sub	sp, #20
    1dac:	0004      	movs	r4, r0
    1dae:	000d      	movs	r5, r1
    1db0:	0016      	movs	r6, r2
	ASSERT(descr && buf && length);
    1db2:	2800      	cmp	r0, #0
    1db4:	d017      	beq.n	1de6 <usart_async_read+0x3e>
    1db6:	2900      	cmp	r1, #0
    1db8:	d017      	beq.n	1dea <usart_async_read+0x42>
    1dba:	2a00      	cmp	r2, #0
    1dbc:	d117      	bne.n	1dee <usart_async_read+0x46>
    1dbe:	2000      	movs	r0, #0
    1dc0:	22ac      	movs	r2, #172	; 0xac
    1dc2:	0052      	lsls	r2, r2, #1
    1dc4:	4912      	ldr	r1, [pc, #72]	; (1e10 <usart_async_read+0x68>)
    1dc6:	4b13      	ldr	r3, [pc, #76]	; (1e14 <usart_async_read+0x6c>)
    1dc8:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
    1dca:	a803      	add	r0, sp, #12
    1dcc:	4b12      	ldr	r3, [pc, #72]	; (1e18 <usart_async_read+0x70>)
    1dce:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
    1dd0:	3434      	adds	r4, #52	; 0x34
    1dd2:	0020      	movs	r0, r4
    1dd4:	9401      	str	r4, [sp, #4]
    1dd6:	4b11      	ldr	r3, [pc, #68]	; (1e1c <usart_async_read+0x74>)
    1dd8:	4798      	blx	r3
    1dda:	0007      	movs	r7, r0
	CRITICAL_SECTION_LEAVE()
    1ddc:	a803      	add	r0, sp, #12
    1dde:	4b10      	ldr	r3, [pc, #64]	; (1e20 <usart_async_read+0x78>)
    1de0:	4798      	blx	r3
	uint16_t                       was_read = 0;
    1de2:	2400      	movs	r4, #0
	while ((was_read < num) && (was_read < length)) {
    1de4:	e00b      	b.n	1dfe <usart_async_read+0x56>
	ASSERT(descr && buf && length);
    1de6:	2000      	movs	r0, #0
    1de8:	e7ea      	b.n	1dc0 <usart_async_read+0x18>
    1dea:	2000      	movs	r0, #0
    1dec:	e7e8      	b.n	1dc0 <usart_async_read+0x18>
    1dee:	2001      	movs	r0, #1
    1df0:	e7e6      	b.n	1dc0 <usart_async_read+0x18>
		ringbuffer_get(&descr->rx, &buf[was_read++]);
    1df2:	3401      	adds	r4, #1
    1df4:	b2a4      	uxth	r4, r4
    1df6:	1869      	adds	r1, r5, r1
    1df8:	9801      	ldr	r0, [sp, #4]
    1dfa:	4b0a      	ldr	r3, [pc, #40]	; (1e24 <usart_async_read+0x7c>)
    1dfc:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
    1dfe:	0021      	movs	r1, r4
    1e00:	42a7      	cmp	r7, r4
    1e02:	d901      	bls.n	1e08 <usart_async_read+0x60>
    1e04:	42b4      	cmp	r4, r6
    1e06:	d3f4      	bcc.n	1df2 <usart_async_read+0x4a>
}
    1e08:	0020      	movs	r0, r4
    1e0a:	b005      	add	sp, #20
    1e0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1e0e:	46c0      	nop			; (mov r8, r8)
    1e10:	0000aab4 	.word	0x0000aab4
    1e14:	000026c1 	.word	0x000026c1
    1e18:	00001271 	.word	0x00001271
    1e1c:	00002841 	.word	0x00002841
    1e20:	0000127f 	.word	0x0000127f
    1e24:	000027b5 	.word	0x000027b5

00001e28 <usart_async_init>:
{
    1e28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1e2a:	0004      	movs	r4, r0
    1e2c:	000d      	movs	r5, r1
    1e2e:	0016      	movs	r6, r2
    1e30:	001f      	movs	r7, r3
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
    1e32:	2800      	cmp	r0, #0
    1e34:	d026      	beq.n	1e84 <usart_async_init+0x5c>
    1e36:	2900      	cmp	r1, #0
    1e38:	d026      	beq.n	1e88 <usart_async_init+0x60>
    1e3a:	2a00      	cmp	r2, #0
    1e3c:	d026      	beq.n	1e8c <usart_async_init+0x64>
    1e3e:	2b00      	cmp	r3, #0
    1e40:	d126      	bne.n	1e90 <usart_async_init+0x68>
    1e42:	2000      	movs	r0, #0
    1e44:	223a      	movs	r2, #58	; 0x3a
    1e46:	4915      	ldr	r1, [pc, #84]	; (1e9c <usart_async_init+0x74>)
    1e48:	4b15      	ldr	r3, [pc, #84]	; (1ea0 <usart_async_init+0x78>)
    1e4a:	4798      	blx	r3
	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
    1e4c:	0020      	movs	r0, r4
    1e4e:	3034      	adds	r0, #52	; 0x34
    1e50:	003a      	movs	r2, r7
    1e52:	0031      	movs	r1, r6
    1e54:	4b13      	ldr	r3, [pc, #76]	; (1ea4 <usart_async_init+0x7c>)
    1e56:	4798      	blx	r3
    1e58:	2800      	cmp	r0, #0
    1e5a:	d11b      	bne.n	1e94 <usart_async_init+0x6c>
	init_status = _usart_async_init(&descr->device, hw);
    1e5c:	0020      	movs	r0, r4
    1e5e:	3008      	adds	r0, #8
    1e60:	0029      	movs	r1, r5
    1e62:	4b11      	ldr	r3, [pc, #68]	; (1ea8 <usart_async_init+0x80>)
    1e64:	4798      	blx	r3
	if (init_status) {
    1e66:	2800      	cmp	r0, #0
    1e68:	d10b      	bne.n	1e82 <usart_async_init+0x5a>
	descr->io.read  = usart_async_read;
    1e6a:	4b10      	ldr	r3, [pc, #64]	; (1eac <usart_async_init+0x84>)
    1e6c:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_async_write;
    1e6e:	4b10      	ldr	r3, [pc, #64]	; (1eb0 <usart_async_init+0x88>)
    1e70:	6023      	str	r3, [r4, #0]
	descr->device.usart_cb.tx_byte_sent = usart_process_byte_sent;
    1e72:	4b10      	ldr	r3, [pc, #64]	; (1eb4 <usart_async_init+0x8c>)
    1e74:	60a3      	str	r3, [r4, #8]
	descr->device.usart_cb.rx_done_cb   = usart_fill_rx_buffer;
    1e76:	4b10      	ldr	r3, [pc, #64]	; (1eb8 <usart_async_init+0x90>)
    1e78:	60e3      	str	r3, [r4, #12]
	descr->device.usart_cb.tx_done_cb   = usart_transmission_complete;
    1e7a:	4b10      	ldr	r3, [pc, #64]	; (1ebc <usart_async_init+0x94>)
    1e7c:	6123      	str	r3, [r4, #16]
	descr->device.usart_cb.error_cb     = usart_error;
    1e7e:	4b10      	ldr	r3, [pc, #64]	; (1ec0 <usart_async_init+0x98>)
    1e80:	6163      	str	r3, [r4, #20]
}
    1e82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
    1e84:	2000      	movs	r0, #0
    1e86:	e7dd      	b.n	1e44 <usart_async_init+0x1c>
    1e88:	2000      	movs	r0, #0
    1e8a:	e7db      	b.n	1e44 <usart_async_init+0x1c>
    1e8c:	2000      	movs	r0, #0
    1e8e:	e7d9      	b.n	1e44 <usart_async_init+0x1c>
    1e90:	2001      	movs	r0, #1
    1e92:	e7d7      	b.n	1e44 <usart_async_init+0x1c>
		return ERR_INVALID_ARG;
    1e94:	200d      	movs	r0, #13
    1e96:	4240      	negs	r0, r0
    1e98:	e7f3      	b.n	1e82 <usart_async_init+0x5a>
    1e9a:	46c0      	nop			; (mov r8, r8)
    1e9c:	0000aab4 	.word	0x0000aab4
    1ea0:	000026c1 	.word	0x000026c1
    1ea4:	00002769 	.word	0x00002769
    1ea8:	000038d9 	.word	0x000038d9
    1eac:	00001da9 	.word	0x00001da9
    1eb0:	00001cfd 	.word	0x00001cfd
    1eb4:	00001d65 	.word	0x00001d65
    1eb8:	00001ce1 	.word	0x00001ce1
    1ebc:	00001cbd 	.word	0x00001cbd
    1ec0:	00001ccf 	.word	0x00001ccf

00001ec4 <usart_async_enable>:
{
    1ec4:	b510      	push	{r4, lr}
    1ec6:	0004      	movs	r4, r0
	ASSERT(descr);
    1ec8:	1e43      	subs	r3, r0, #1
    1eca:	4198      	sbcs	r0, r3
    1ecc:	b2c0      	uxtb	r0, r0
    1ece:	2261      	movs	r2, #97	; 0x61
    1ed0:	4904      	ldr	r1, [pc, #16]	; (1ee4 <usart_async_enable+0x20>)
    1ed2:	4b05      	ldr	r3, [pc, #20]	; (1ee8 <usart_async_enable+0x24>)
    1ed4:	4798      	blx	r3
	_usart_async_enable(&descr->device);
    1ed6:	0020      	movs	r0, r4
    1ed8:	3008      	adds	r0, #8
    1eda:	4b04      	ldr	r3, [pc, #16]	; (1eec <usart_async_enable+0x28>)
    1edc:	4798      	blx	r3
}
    1ede:	2000      	movs	r0, #0
    1ee0:	bd10      	pop	{r4, pc}
    1ee2:	46c0      	nop			; (mov r8, r8)
    1ee4:	0000aab4 	.word	0x0000aab4
    1ee8:	000026c1 	.word	0x000026c1
    1eec:	00003977 	.word	0x00003977

00001ef0 <usart_async_get_io_descriptor>:
{
    1ef0:	b570      	push	{r4, r5, r6, lr}
    1ef2:	0004      	movs	r4, r0
    1ef4:	000d      	movs	r5, r1
	ASSERT(descr && io);
    1ef6:	2800      	cmp	r0, #0
    1ef8:	d00b      	beq.n	1f12 <usart_async_get_io_descriptor+0x22>
    1efa:	2900      	cmp	r1, #0
    1efc:	d007      	beq.n	1f0e <usart_async_get_io_descriptor+0x1e>
    1efe:	2001      	movs	r0, #1
    1f00:	2277      	movs	r2, #119	; 0x77
    1f02:	4905      	ldr	r1, [pc, #20]	; (1f18 <usart_async_get_io_descriptor+0x28>)
    1f04:	4b05      	ldr	r3, [pc, #20]	; (1f1c <usart_async_get_io_descriptor+0x2c>)
    1f06:	4798      	blx	r3
	*io = &descr->io;
    1f08:	602c      	str	r4, [r5, #0]
}
    1f0a:	2000      	movs	r0, #0
    1f0c:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && io);
    1f0e:	2000      	movs	r0, #0
    1f10:	e7f6      	b.n	1f00 <usart_async_get_io_descriptor+0x10>
    1f12:	2000      	movs	r0, #0
    1f14:	e7f4      	b.n	1f00 <usart_async_get_io_descriptor+0x10>
    1f16:	46c0      	nop			; (mov r8, r8)
    1f18:	0000aab4 	.word	0x0000aab4
    1f1c:	000026c1 	.word	0x000026c1

00001f20 <usart_async_register_callback>:
{
    1f20:	b570      	push	{r4, r5, r6, lr}
    1f22:	0005      	movs	r5, r0
    1f24:	000e      	movs	r6, r1
    1f26:	0014      	movs	r4, r2
	ASSERT(descr);
    1f28:	1e43      	subs	r3, r0, #1
    1f2a:	4198      	sbcs	r0, r3
    1f2c:	b2c0      	uxtb	r0, r0
    1f2e:	2283      	movs	r2, #131	; 0x83
    1f30:	4916      	ldr	r1, [pc, #88]	; (1f8c <usart_async_register_callback+0x6c>)
    1f32:	4b17      	ldr	r3, [pc, #92]	; (1f90 <usart_async_register_callback+0x70>)
    1f34:	4798      	blx	r3
	switch (type) {
    1f36:	2e01      	cmp	r6, #1
    1f38:	d011      	beq.n	1f5e <usart_async_register_callback+0x3e>
    1f3a:	2e00      	cmp	r6, #0
    1f3c:	d004      	beq.n	1f48 <usart_async_register_callback+0x28>
    1f3e:	2e02      	cmp	r6, #2
    1f40:	d018      	beq.n	1f74 <usart_async_register_callback+0x54>
		return ERR_INVALID_ARG;
    1f42:	200d      	movs	r0, #13
    1f44:	4240      	negs	r0, r0
    1f46:	e009      	b.n	1f5c <usart_async_register_callback+0x3c>
		descr->usart_cb.rx_done = cb;
    1f48:	62ac      	str	r4, [r5, #40]	; 0x28
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
    1f4a:	1e62      	subs	r2, r4, #1
    1f4c:	4194      	sbcs	r4, r2
    1f4e:	b2e2      	uxtb	r2, r4
    1f50:	0028      	movs	r0, r5
    1f52:	3008      	adds	r0, #8
    1f54:	2101      	movs	r1, #1
    1f56:	4b0f      	ldr	r3, [pc, #60]	; (1f94 <usart_async_register_callback+0x74>)
    1f58:	4798      	blx	r3
	return ERR_NONE;
    1f5a:	2000      	movs	r0, #0
}
    1f5c:	bd70      	pop	{r4, r5, r6, pc}
		descr->usart_cb.tx_done = cb;
    1f5e:	626c      	str	r4, [r5, #36]	; 0x24
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
    1f60:	1e62      	subs	r2, r4, #1
    1f62:	4194      	sbcs	r4, r2
    1f64:	b2e2      	uxtb	r2, r4
    1f66:	0028      	movs	r0, r5
    1f68:	3008      	adds	r0, #8
    1f6a:	2102      	movs	r1, #2
    1f6c:	4b09      	ldr	r3, [pc, #36]	; (1f94 <usart_async_register_callback+0x74>)
    1f6e:	4798      	blx	r3
	return ERR_NONE;
    1f70:	2000      	movs	r0, #0
		break;
    1f72:	e7f3      	b.n	1f5c <usart_async_register_callback+0x3c>
		descr->usart_cb.error = cb;
    1f74:	62ec      	str	r4, [r5, #44]	; 0x2c
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
    1f76:	1e62      	subs	r2, r4, #1
    1f78:	4194      	sbcs	r4, r2
    1f7a:	b2e2      	uxtb	r2, r4
    1f7c:	0028      	movs	r0, r5
    1f7e:	3008      	adds	r0, #8
    1f80:	2103      	movs	r1, #3
    1f82:	4b04      	ldr	r3, [pc, #16]	; (1f94 <usart_async_register_callback+0x74>)
    1f84:	4798      	blx	r3
	return ERR_NONE;
    1f86:	2000      	movs	r0, #0
		break;
    1f88:	e7e8      	b.n	1f5c <usart_async_register_callback+0x3c>
    1f8a:	46c0      	nop			; (mov r8, r8)
    1f8c:	0000aab4 	.word	0x0000aab4
    1f90:	000026c1 	.word	0x000026c1
    1f94:	000039dd 	.word	0x000039dd

00001f98 <usart_async_is_tx_empty>:
{
    1f98:	b510      	push	{r4, lr}
    1f9a:	0004      	movs	r4, r0
	ASSERT(descr);
    1f9c:	1e43      	subs	r3, r0, #1
    1f9e:	4198      	sbcs	r0, r3
    1fa0:	b2c0      	uxtb	r0, r0
    1fa2:	22f8      	movs	r2, #248	; 0xf8
    1fa4:	4903      	ldr	r1, [pc, #12]	; (1fb4 <usart_async_is_tx_empty+0x1c>)
    1fa6:	4b04      	ldr	r3, [pc, #16]	; (1fb8 <usart_async_is_tx_empty+0x20>)
    1fa8:	4798      	blx	r3
	return _usart_async_is_byte_sent(&descr->device);
    1faa:	0020      	movs	r0, r4
    1fac:	3008      	adds	r0, #8
    1fae:	4b03      	ldr	r3, [pc, #12]	; (1fbc <usart_async_is_tx_empty+0x24>)
    1fb0:	4798      	blx	r3
}
    1fb2:	bd10      	pop	{r4, pc}
    1fb4:	0000aab4 	.word	0x0000aab4
    1fb8:	000026c1 	.word	0x000026c1
    1fbc:	000039b7 	.word	0x000039b7

00001fc0 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    1fc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1fc2:	0005      	movs	r5, r0
    1fc4:	000e      	movs	r6, r1
    1fc6:	0017      	movs	r7, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    1fc8:	2800      	cmp	r0, #0
    1fca:	d023      	beq.n	2014 <STACK_SIZE+0x14>
    1fcc:	2900      	cmp	r1, #0
    1fce:	d023      	beq.n	2018 <STACK_SIZE+0x18>
    1fd0:	2a00      	cmp	r2, #0
    1fd2:	d123      	bne.n	201c <STACK_SIZE+0x1c>
    1fd4:	2000      	movs	r0, #0
    1fd6:	22f1      	movs	r2, #241	; 0xf1
    1fd8:	4911      	ldr	r1, [pc, #68]	; (2020 <STACK_SIZE+0x20>)
    1fda:	4b12      	ldr	r3, [pc, #72]	; (2024 <STACK_SIZE+0x24>)
    1fdc:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
    1fde:	002c      	movs	r4, r5
    1fe0:	3408      	adds	r4, #8
    1fe2:	0020      	movs	r0, r4
    1fe4:	4b10      	ldr	r3, [pc, #64]	; (2028 <STACK_SIZE+0x28>)
    1fe6:	4798      	blx	r3
    1fe8:	2800      	cmp	r0, #0
    1fea:	d0f8      	beq.n	1fde <usart_sync_write+0x1e>
    1fec:	2500      	movs	r5, #0
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    1fee:	5d71      	ldrb	r1, [r6, r5]
    1ff0:	0020      	movs	r0, r4
    1ff2:	4b0e      	ldr	r3, [pc, #56]	; (202c <STACK_SIZE+0x2c>)
    1ff4:	4798      	blx	r3
		while (!_usart_sync_is_ready_to_send(&descr->device))
    1ff6:	0020      	movs	r0, r4
    1ff8:	4b0b      	ldr	r3, [pc, #44]	; (2028 <STACK_SIZE+0x28>)
    1ffa:	4798      	blx	r3
    1ffc:	2800      	cmp	r0, #0
    1ffe:	d0fa      	beq.n	1ff6 <usart_sync_write+0x36>
			;
	} while (++offset < length);
    2000:	3501      	adds	r5, #1
    2002:	42bd      	cmp	r5, r7
    2004:	d3f3      	bcc.n	1fee <usart_sync_write+0x2e>
	while (!_usart_sync_is_transmit_done(&descr->device))
    2006:	0020      	movs	r0, r4
    2008:	4b09      	ldr	r3, [pc, #36]	; (2030 <STACK_SIZE+0x30>)
    200a:	4798      	blx	r3
    200c:	2800      	cmp	r0, #0
    200e:	d0fa      	beq.n	2006 <STACK_SIZE+0x6>
		;
	return (int32_t)offset;
}
    2010:	0028      	movs	r0, r5
    2012:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(io_descr && buf && length);
    2014:	2000      	movs	r0, #0
    2016:	e7de      	b.n	1fd6 <usart_sync_write+0x16>
    2018:	2000      	movs	r0, #0
    201a:	e7dc      	b.n	1fd6 <usart_sync_write+0x16>
    201c:	2001      	movs	r0, #1
    201e:	e7da      	b.n	1fd6 <usart_sync_write+0x16>
    2020:	0000aad4 	.word	0x0000aad4
    2024:	000026c1 	.word	0x000026c1
    2028:	000039a1 	.word	0x000039a1
    202c:	00003989 	.word	0x00003989
    2030:	000039ab 	.word	0x000039ab

00002034 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    2034:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2036:	46ce      	mov	lr, r9
    2038:	4647      	mov	r7, r8
    203a:	b580      	push	{r7, lr}
    203c:	1e05      	subs	r5, r0, #0
    203e:	4688      	mov	r8, r1
    2040:	4691      	mov	r9, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    2042:	d01f      	beq.n	2084 <usart_sync_read+0x50>
    2044:	2900      	cmp	r1, #0
    2046:	d01f      	beq.n	2088 <usart_sync_read+0x54>
    2048:	2a00      	cmp	r2, #0
    204a:	d11f      	bne.n	208c <usart_sync_read+0x58>
    204c:	2000      	movs	r0, #0
    204e:	2286      	movs	r2, #134	; 0x86
    2050:	0052      	lsls	r2, r2, #1
    2052:	490f      	ldr	r1, [pc, #60]	; (2090 <usart_sync_read+0x5c>)
    2054:	4b0f      	ldr	r3, [pc, #60]	; (2094 <usart_sync_read+0x60>)
    2056:	4798      	blx	r3
	uint32_t                      offset = 0;
    2058:	2600      	movs	r6, #0
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    205a:	002c      	movs	r4, r5
    205c:	3408      	adds	r4, #8
    205e:	0020      	movs	r0, r4
    2060:	4b0d      	ldr	r3, [pc, #52]	; (2098 <usart_sync_read+0x64>)
    2062:	4798      	blx	r3
    2064:	2800      	cmp	r0, #0
    2066:	d0f8      	beq.n	205a <usart_sync_read+0x26>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    2068:	4643      	mov	r3, r8
    206a:	199f      	adds	r7, r3, r6
    206c:	0020      	movs	r0, r4
    206e:	4b0b      	ldr	r3, [pc, #44]	; (209c <usart_sync_read+0x68>)
    2070:	4798      	blx	r3
    2072:	7038      	strb	r0, [r7, #0]
	} while (++offset < length);
    2074:	3601      	adds	r6, #1
    2076:	454e      	cmp	r6, r9
    2078:	d3ef      	bcc.n	205a <usart_sync_read+0x26>

	return (int32_t)offset;
}
    207a:	0030      	movs	r0, r6
    207c:	bc0c      	pop	{r2, r3}
    207e:	4690      	mov	r8, r2
    2080:	4699      	mov	r9, r3
    2082:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(io_descr && buf && length);
    2084:	2000      	movs	r0, #0
    2086:	e7e2      	b.n	204e <usart_sync_read+0x1a>
    2088:	2000      	movs	r0, #0
    208a:	e7e0      	b.n	204e <usart_sync_read+0x1a>
    208c:	2001      	movs	r0, #1
    208e:	e7de      	b.n	204e <usart_sync_read+0x1a>
    2090:	0000aad4 	.word	0x0000aad4
    2094:	000026c1 	.word	0x000026c1
    2098:	000039c1 	.word	0x000039c1
    209c:	00003999 	.word	0x00003999

000020a0 <usart_sync_init>:
{
    20a0:	b570      	push	{r4, r5, r6, lr}
    20a2:	0004      	movs	r4, r0
    20a4:	000d      	movs	r5, r1
	ASSERT(descr && hw);
    20a6:	2800      	cmp	r0, #0
    20a8:	d014      	beq.n	20d4 <usart_sync_init+0x34>
    20aa:	2900      	cmp	r1, #0
    20ac:	d010      	beq.n	20d0 <usart_sync_init+0x30>
    20ae:	2001      	movs	r0, #1
    20b0:	2234      	movs	r2, #52	; 0x34
    20b2:	4909      	ldr	r1, [pc, #36]	; (20d8 <usart_sync_init+0x38>)
    20b4:	4b09      	ldr	r3, [pc, #36]	; (20dc <usart_sync_init+0x3c>)
    20b6:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
    20b8:	0020      	movs	r0, r4
    20ba:	3008      	adds	r0, #8
    20bc:	0029      	movs	r1, r5
    20be:	4b08      	ldr	r3, [pc, #32]	; (20e0 <usart_sync_init+0x40>)
    20c0:	4798      	blx	r3
	if (init_status) {
    20c2:	2800      	cmp	r0, #0
    20c4:	d103      	bne.n	20ce <usart_sync_init+0x2e>
	descr->io.read  = usart_sync_read;
    20c6:	4b07      	ldr	r3, [pc, #28]	; (20e4 <usart_sync_init+0x44>)
    20c8:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_sync_write;
    20ca:	4b07      	ldr	r3, [pc, #28]	; (20e8 <usart_sync_init+0x48>)
    20cc:	6023      	str	r3, [r4, #0]
}
    20ce:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw);
    20d0:	2000      	movs	r0, #0
    20d2:	e7ed      	b.n	20b0 <usart_sync_init+0x10>
    20d4:	2000      	movs	r0, #0
    20d6:	e7eb      	b.n	20b0 <usart_sync_init+0x10>
    20d8:	0000aad4 	.word	0x0000aad4
    20dc:	000026c1 	.word	0x000026c1
    20e0:	000038ad 	.word	0x000038ad
    20e4:	00002035 	.word	0x00002035
    20e8:	00001fc1 	.word	0x00001fc1

000020ec <usart_sync_enable>:
{
    20ec:	b510      	push	{r4, lr}
    20ee:	0004      	movs	r4, r0
	ASSERT(descr);
    20f0:	1e43      	subs	r3, r0, #1
    20f2:	4198      	sbcs	r0, r3
    20f4:	b2c0      	uxtb	r0, r0
    20f6:	2253      	movs	r2, #83	; 0x53
    20f8:	4904      	ldr	r1, [pc, #16]	; (210c <usart_sync_enable+0x20>)
    20fa:	4b05      	ldr	r3, [pc, #20]	; (2110 <usart_sync_enable+0x24>)
    20fc:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
    20fe:	0020      	movs	r0, r4
    2100:	3008      	adds	r0, #8
    2102:	4b04      	ldr	r3, [pc, #16]	; (2114 <usart_sync_enable+0x28>)
    2104:	4798      	blx	r3
}
    2106:	2000      	movs	r0, #0
    2108:	bd10      	pop	{r4, pc}
    210a:	46c0      	nop			; (mov r8, r8)
    210c:	0000aad4 	.word	0x0000aad4
    2110:	000026c1 	.word	0x000026c1
    2114:	00003965 	.word	0x00003965

00002118 <_usb_d_find_ep>:
 * \return Index of endpoint descriptor.
 * \retval >=0 The index.
 * \retval <0 Not found (endpoint is not initialized).
 */
static int8_t _usb_d_find_ep(const uint8_t ep)
{
    2118:	b510      	push	{r4, lr}
    211a:	0001      	movs	r1, r0
	int8_t i;
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    211c:	2000      	movs	r0, #0
    211e:	e001      	b.n	2124 <_usb_d_find_ep+0xc>
    2120:	3001      	adds	r0, #1
    2122:	b240      	sxtb	r0, r0
    2124:	280c      	cmp	r0, #12
    2126:	dc0f      	bgt.n	2148 <_usb_d_find_ep+0x30>
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
    2128:	0142      	lsls	r2, r0, #5
    212a:	4b09      	ldr	r3, [pc, #36]	; (2150 <_usb_d_find_ep+0x38>)
    212c:	189b      	adds	r3, r3, r2
    212e:	785a      	ldrb	r2, [r3, #1]
    2130:	428a      	cmp	r2, r1
    2132:	d00b      	beq.n	214c <_usb_d_find_ep+0x34>
			return i;
		}
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
    2134:	0143      	lsls	r3, r0, #5
    2136:	4c06      	ldr	r4, [pc, #24]	; (2150 <_usb_d_find_ep+0x38>)
    2138:	5d1b      	ldrb	r3, [r3, r4]
    213a:	2b00      	cmp	r3, #0
    213c:	d1f0      	bne.n	2120 <_usb_d_find_ep+0x8>
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    213e:	330f      	adds	r3, #15
    2140:	400b      	ands	r3, r1
    2142:	4293      	cmp	r3, r2
    2144:	d1ec      	bne.n	2120 <_usb_d_find_ep+0x8>
    2146:	e001      	b.n	214c <_usb_d_find_ep+0x34>
			return i;
		}
	}
	return -1;
    2148:	2001      	movs	r0, #1
    214a:	4240      	negs	r0, r0
}
    214c:	bd10      	pop	{r4, pc}
    214e:	46c0      	nop			; (mov r8, r8)
    2150:	2000020c 	.word	0x2000020c

00002154 <usb_d_dummy_cb_false>:
{
	(void)unused0;
	(void)unused1;
	(void)unused2;
	return false;
}
    2154:	2000      	movs	r0, #0
    2156:	4770      	bx	lr

00002158 <usb_d_cb_trans_more>:
 * \brief Callback invoked when request more data
 * \param[in] ep Endpoint number with transfer direction on bit 8.
 * \param[in] transfered Number of bytes transfered.
 */
static bool usb_d_cb_trans_more(const uint8_t ep, const uint32_t transfered)
{
    2158:	b570      	push	{r4, r5, r6, lr}
    215a:	0004      	movs	r4, r0
    215c:	000d      	movs	r5, r1
	int8_t           ep_index = _usb_d_find_ep(ep);
    215e:	4b08      	ldr	r3, [pc, #32]	; (2180 <usb_d_cb_trans_more+0x28>)
    2160:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ept->xfer.hdr.state == USB_EP_S_X_DATA) {
    2162:	0142      	lsls	r2, r0, #5
    2164:	4b07      	ldr	r3, [pc, #28]	; (2184 <usb_d_cb_trans_more+0x2c>)
    2166:	189b      	adds	r3, r3, r2
    2168:	789b      	ldrb	r3, [r3, #2]
    216a:	2b03      	cmp	r3, #3
    216c:	d001      	beq.n	2172 <usb_d_cb_trans_more+0x1a>
		return ept->callbacks.more(ep, transfered);
	}
	return false;
    216e:	2000      	movs	r0, #0
}
    2170:	bd70      	pop	{r4, r5, r6, pc}
		return ept->callbacks.more(ep, transfered);
    2172:	4b04      	ldr	r3, [pc, #16]	; (2184 <usb_d_cb_trans_more+0x2c>)
    2174:	1898      	adds	r0, r3, r2
    2176:	6983      	ldr	r3, [r0, #24]
    2178:	0029      	movs	r1, r5
    217a:	0020      	movs	r0, r4
    217c:	4798      	blx	r3
    217e:	e7f7      	b.n	2170 <usb_d_cb_trans_more+0x18>
    2180:	00002119 	.word	0x00002119
    2184:	2000020c 	.word	0x2000020c

00002188 <_usb_d_cb_trans_done>:

/**
 * Callback when USB transactions are finished.
 */
static void _usb_d_cb_trans_done(const uint8_t ep, const int32_t code, const uint32_t transferred)
{
    2188:	b5f0      	push	{r4, r5, r6, r7, lr}
    218a:	b087      	sub	sp, #28
    218c:	0005      	movs	r5, r0
    218e:	000f      	movs	r7, r1
    2190:	9201      	str	r2, [sp, #4]
	int8_t           ep_index = _usb_d_find_ep(ep);
    2192:	4b4a      	ldr	r3, [pc, #296]	; (22bc <_usb_d_cb_trans_done+0x134>)
    2194:	4798      	blx	r3
    2196:	0004      	movs	r4, r0
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
    2198:	0146      	lsls	r6, r0, #5
    219a:	4a49      	ldr	r2, [pc, #292]	; (22c0 <_usb_d_cb_trans_done+0x138>)
    219c:	1996      	adds	r6, r2, r6

	if (code == USB_TRANS_DONE) {
    219e:	2f00      	cmp	r7, #0
    21a0:	d151      	bne.n	2246 <_usb_d_cb_trans_done+0xbe>
		ept->xfer.hdr.status = USB_XFER_DONE;
    21a2:	0013      	movs	r3, r2
    21a4:	0142      	lsls	r2, r0, #5
    21a6:	2000      	movs	r0, #0
    21a8:	70f0      	strb	r0, [r6, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    21aa:	5cd3      	ldrb	r3, [r2, r3]
    21ac:	2b00      	cmp	r3, #0
    21ae:	d00e      	beq.n	21ce <_usb_d_cb_trans_done+0x46>
			usb_d_ctrl_trans_done(ept);
			return;
		}
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    21b0:	0162      	lsls	r2, r4, #5
    21b2:	4b43      	ldr	r3, [pc, #268]	; (22c0 <_usb_d_cb_trans_done+0x138>)
    21b4:	189b      	adds	r3, r3, r2
    21b6:	2201      	movs	r2, #1
    21b8:	709a      	strb	r2, [r3, #2]
	} else {
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
		ept->xfer.hdr.status = USB_XFER_ERROR;
	}

	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
    21ba:	0164      	lsls	r4, r4, #5
    21bc:	4b40      	ldr	r3, [pc, #256]	; (22c0 <_usb_d_cb_trans_done+0x138>)
    21be:	191c      	adds	r4, r3, r4
    21c0:	69e3      	ldr	r3, [r4, #28]
    21c2:	78e1      	ldrb	r1, [r4, #3]
    21c4:	9a01      	ldr	r2, [sp, #4]
    21c6:	0028      	movs	r0, r5
    21c8:	4798      	blx	r3
}
    21ca:	b007      	add	sp, #28
    21cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint8_t state   = ept->xfer.hdr.state;
    21ce:	78b3      	ldrb	r3, [r6, #2]
    21d0:	240c      	movs	r4, #12
    21d2:	5734      	ldrsb	r4, [r6, r4]
	if (state == USB_EP_S_X_DATA) {
    21d4:	2b03      	cmp	r3, #3
    21d6:	d008      	beq.n	21ea <_usb_d_cb_trans_done+0x62>
		ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DONE, ept->xfer.req);
    21d8:	0032      	movs	r2, r6
    21da:	320c      	adds	r2, #12
    21dc:	7870      	ldrb	r0, [r6, #1]
    21de:	2100      	movs	r1, #0
    21e0:	69f3      	ldr	r3, [r6, #28]
    21e2:	4798      	blx	r3
		ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    21e4:	2302      	movs	r3, #2
    21e6:	70b3      	strb	r3, [r6, #2]
    21e8:	e7ef      	b.n	21ca <_usb_d_cb_trans_done+0x42>
		bool err = ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DATA, ept->xfer.req);
    21ea:	7870      	ldrb	r0, [r6, #1]
    21ec:	0032      	movs	r2, r6
    21ee:	320c      	adds	r2, #12
    21f0:	2101      	movs	r1, #1
    21f2:	69f3      	ldr	r3, [r6, #28]
    21f4:	4798      	blx	r3
		if (err) {
    21f6:	2800      	cmp	r0, #0
    21f8:	d010      	beq.n	221c <_usb_d_cb_trans_done+0x94>
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
    21fa:	2305      	movs	r3, #5
    21fc:	70b3      	strb	r3, [r6, #2]
			ept->xfer.hdr.status = USB_XFER_HALT;
    21fe:	3b03      	subs	r3, #3
    2200:	70f3      	strb	r3, [r6, #3]
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    2202:	2c00      	cmp	r4, #0
    2204:	db08      	blt.n	2218 <_usb_d_cb_trans_done+0x90>
    2206:	7873      	ldrb	r3, [r6, #1]
    2208:	2080      	movs	r0, #128	; 0x80
    220a:	4240      	negs	r0, r0
    220c:	4318      	orrs	r0, r3
    220e:	b2c0      	uxtb	r0, r0
    2210:	2101      	movs	r1, #1
    2212:	4b2c      	ldr	r3, [pc, #176]	; (22c4 <_usb_d_cb_trans_done+0x13c>)
    2214:	4798      	blx	r3
    2216:	e7d8      	b.n	21ca <_usb_d_cb_trans_done+0x42>
    2218:	7870      	ldrb	r0, [r6, #1]
    221a:	e7f9      	b.n	2210 <_usb_d_cb_trans_done+0x88>
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    221c:	2304      	movs	r3, #4
    221e:	70b3      	strb	r3, [r6, #2]
			_usb_d_trans(ept->xfer.hdr.ep, !req_dir, NULL, 0, 1);
    2220:	7871      	ldrb	r1, [r6, #1]
	struct usb_d_transfer trans
    2222:	2200      	movs	r2, #0
    2224:	9203      	str	r2, [sp, #12]
    2226:	9204      	str	r2, [sp, #16]
    2228:	2c00      	cmp	r4, #0
    222a:	db09      	blt.n	2240 <_usb_d_cb_trans_done+0xb8>
    222c:	3b84      	subs	r3, #132	; 0x84
    222e:	430b      	orrs	r3, r1
    2230:	b2da      	uxtb	r2, r3
    2232:	a803      	add	r0, sp, #12
    2234:	7202      	strb	r2, [r0, #8]
    2236:	2301      	movs	r3, #1
    2238:	7243      	strb	r3, [r0, #9]
	return _usb_d_dev_ep_trans(&trans);
    223a:	4b23      	ldr	r3, [pc, #140]	; (22c8 <_usb_d_cb_trans_done+0x140>)
    223c:	4798      	blx	r3
    223e:	e7c4      	b.n	21ca <_usb_d_cb_trans_done+0x42>
	struct usb_d_transfer trans
    2240:	220f      	movs	r2, #15
    2242:	400a      	ands	r2, r1
    2244:	e7f5      	b.n	2232 <_usb_d_cb_trans_done+0xaa>
	} else if (code == USB_TRANS_STALL) {
    2246:	2f01      	cmp	r7, #1
    2248:	d00a      	beq.n	2260 <_usb_d_cb_trans_done+0xd8>
	} else if (code == USB_TRANS_ABORT) {
    224a:	2f02      	cmp	r7, #2
    224c:	d01d      	beq.n	228a <_usb_d_cb_trans_done+0x102>
	} else if (code == USB_TRANS_RESET) {
    224e:	2f03      	cmp	r7, #3
    2250:	d02c      	beq.n	22ac <_usb_d_cb_trans_done+0x124>
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
    2252:	0142      	lsls	r2, r0, #5
    2254:	4b1a      	ldr	r3, [pc, #104]	; (22c0 <_usb_d_cb_trans_done+0x138>)
    2256:	189b      	adds	r3, r3, r2
    2258:	2206      	movs	r2, #6
    225a:	709a      	strb	r2, [r3, #2]
		ept->xfer.hdr.status = USB_XFER_ERROR;
    225c:	70da      	strb	r2, [r3, #3]
    225e:	e7ac      	b.n	21ba <_usb_d_cb_trans_done+0x32>
		ept->xfer.hdr.status = USB_XFER_HALT;
    2260:	4b17      	ldr	r3, [pc, #92]	; (22c0 <_usb_d_cb_trans_done+0x138>)
    2262:	0142      	lsls	r2, r0, #5
    2264:	1899      	adds	r1, r3, r2
    2266:	2002      	movs	r0, #2
    2268:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    226a:	5cd3      	ldrb	r3, [r2, r3]
    226c:	2b00      	cmp	r3, #0
    226e:	d005      	beq.n	227c <_usb_d_cb_trans_done+0xf4>
			ept->xfer.hdr.state = USB_EP_S_HALTED;
    2270:	0162      	lsls	r2, r4, #5
    2272:	4b13      	ldr	r3, [pc, #76]	; (22c0 <_usb_d_cb_trans_done+0x138>)
    2274:	189b      	adds	r3, r3, r2
    2276:	2205      	movs	r2, #5
    2278:	709a      	strb	r2, [r3, #2]
    227a:	e79e      	b.n	21ba <_usb_d_cb_trans_done+0x32>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    227c:	2202      	movs	r2, #2
    227e:	708a      	strb	r2, [r1, #2]
			_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    2280:	2100      	movs	r1, #0
    2282:	0028      	movs	r0, r5
    2284:	4b0f      	ldr	r3, [pc, #60]	; (22c4 <_usb_d_cb_trans_done+0x13c>)
    2286:	4798      	blx	r3
    2288:	e797      	b.n	21ba <_usb_d_cb_trans_done+0x32>
		ept->xfer.hdr.status = USB_XFER_ABORT;
    228a:	4b0d      	ldr	r3, [pc, #52]	; (22c0 <_usb_d_cb_trans_done+0x138>)
    228c:	0142      	lsls	r2, r0, #5
    228e:	1899      	adds	r1, r3, r2
    2290:	2004      	movs	r0, #4
    2292:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    2294:	5cd3      	ldrb	r3, [r2, r3]
    2296:	2b00      	cmp	r3, #0
    2298:	d005      	beq.n	22a6 <_usb_d_cb_trans_done+0x11e>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    229a:	0162      	lsls	r2, r4, #5
    229c:	4b08      	ldr	r3, [pc, #32]	; (22c0 <_usb_d_cb_trans_done+0x138>)
    229e:	189b      	adds	r3, r3, r2
    22a0:	2201      	movs	r2, #1
    22a2:	709a      	strb	r2, [r3, #2]
    22a4:	e789      	b.n	21ba <_usb_d_cb_trans_done+0x32>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    22a6:	2302      	movs	r3, #2
    22a8:	708b      	strb	r3, [r1, #2]
			return;
    22aa:	e78e      	b.n	21ca <_usb_d_cb_trans_done+0x42>
		ept->xfer.hdr.state  = USB_EP_S_DISABLED;
    22ac:	0142      	lsls	r2, r0, #5
    22ae:	4b04      	ldr	r3, [pc, #16]	; (22c0 <_usb_d_cb_trans_done+0x138>)
    22b0:	189b      	adds	r3, r3, r2
    22b2:	2200      	movs	r2, #0
    22b4:	709a      	strb	r2, [r3, #2]
		ept->xfer.hdr.status = USB_XFER_RESET;
    22b6:	3205      	adds	r2, #5
    22b8:	70da      	strb	r2, [r3, #3]
    22ba:	e77e      	b.n	21ba <_usb_d_cb_trans_done+0x32>
    22bc:	00002119 	.word	0x00002119
    22c0:	2000020c 	.word	0x2000020c
    22c4:	00005021 	.word	0x00005021
    22c8:	000051f1 	.word	0x000051f1

000022cc <usb_d_cb_trans_setup>:
{
    22cc:	b5f0      	push	{r4, r5, r6, r7, lr}
    22ce:	46c6      	mov	lr, r8
    22d0:	b500      	push	{lr}
    22d2:	0005      	movs	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    22d4:	4b1f      	ldr	r3, [pc, #124]	; (2354 <usb_d_cb_trans_setup+0x88>)
    22d6:	4798      	blx	r3
    22d8:	0006      	movs	r6, r0
	uint8_t *        req      = ept->xfer.req;
    22da:	0143      	lsls	r3, r0, #5
    22dc:	3308      	adds	r3, #8
    22de:	4c1e      	ldr	r4, [pc, #120]	; (2358 <usb_d_cb_trans_setup+0x8c>)
    22e0:	18e4      	adds	r4, r4, r3
    22e2:	3404      	adds	r4, #4
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
    22e4:	0021      	movs	r1, r4
    22e6:	0028      	movs	r0, r5
    22e8:	4b1c      	ldr	r3, [pc, #112]	; (235c <usb_d_cb_trans_setup+0x90>)
    22ea:	4798      	blx	r3
    22ec:	b2c0      	uxtb	r0, r0
	if (n != 8) {
    22ee:	2808      	cmp	r0, #8
    22f0:	d00c      	beq.n	230c <usb_d_cb_trans_setup+0x40>
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    22f2:	2101      	movs	r1, #1
    22f4:	0028      	movs	r0, r5
    22f6:	4c1a      	ldr	r4, [pc, #104]	; (2360 <usb_d_cb_trans_setup+0x94>)
    22f8:	47a0      	blx	r4
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    22fa:	2080      	movs	r0, #128	; 0x80
    22fc:	4240      	negs	r0, r0
    22fe:	4328      	orrs	r0, r5
    2300:	b2c0      	uxtb	r0, r0
    2302:	2101      	movs	r1, #1
    2304:	47a0      	blx	r4
}
    2306:	bc04      	pop	{r2}
    2308:	4690      	mov	r8, r2
    230a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    230c:	2100      	movs	r1, #0
    230e:	0028      	movs	r0, r5
    2310:	4b13      	ldr	r3, [pc, #76]	; (2360 <usb_d_cb_trans_setup+0x94>)
    2312:	4698      	mov	r8, r3
    2314:	4798      	blx	r3
	_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_CLR);
    2316:	2780      	movs	r7, #128	; 0x80
    2318:	427f      	negs	r7, r7
    231a:	432f      	orrs	r7, r5
    231c:	b2ff      	uxtb	r7, r7
    231e:	2100      	movs	r1, #0
    2320:	0038      	movs	r0, r7
    2322:	47c0      	blx	r8
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    2324:	0172      	lsls	r2, r6, #5
    2326:	4b0c      	ldr	r3, [pc, #48]	; (2358 <usb_d_cb_trans_setup+0x8c>)
    2328:	189b      	adds	r3, r3, r2
    232a:	2201      	movs	r2, #1
    232c:	709a      	strb	r2, [r3, #2]
	if (!ept->callbacks.req(ep, req)) {
    232e:	695b      	ldr	r3, [r3, #20]
    2330:	0021      	movs	r1, r4
    2332:	0028      	movs	r0, r5
    2334:	4798      	blx	r3
    2336:	2800      	cmp	r0, #0
    2338:	d1e5      	bne.n	2306 <usb_d_cb_trans_setup+0x3a>
		ept->xfer.hdr.state = USB_EP_S_HALTED;
    233a:	0176      	lsls	r6, r6, #5
    233c:	4b06      	ldr	r3, [pc, #24]	; (2358 <usb_d_cb_trans_setup+0x8c>)
    233e:	199e      	adds	r6, r3, r6
    2340:	2305      	movs	r3, #5
    2342:	70b3      	strb	r3, [r6, #2]
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    2344:	2101      	movs	r1, #1
    2346:	0028      	movs	r0, r5
    2348:	4c05      	ldr	r4, [pc, #20]	; (2360 <usb_d_cb_trans_setup+0x94>)
    234a:	47a0      	blx	r4
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    234c:	2101      	movs	r1, #1
    234e:	0038      	movs	r0, r7
    2350:	47a0      	blx	r4
    2352:	e7d8      	b.n	2306 <usb_d_cb_trans_setup+0x3a>
    2354:	00002119 	.word	0x00002119
    2358:	2000020c 	.word	0x2000020c
    235c:	00005179 	.word	0x00005179
    2360:	00005021 	.word	0x00005021

00002364 <usb_d_init>:

int32_t usb_d_init(void)
{
    2364:	b510      	push	{r4, lr}
	int32_t rc = _usb_d_dev_init();
    2366:	4b12      	ldr	r3, [pc, #72]	; (23b0 <usb_d_init+0x4c>)
    2368:	4798      	blx	r3
	uint8_t i;
	if (rc < 0) {
    236a:	2800      	cmp	r0, #0
    236c:	db1f      	blt.n	23ae <usb_d_init+0x4a>
		return rc;
	}
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
    236e:	22d0      	movs	r2, #208	; 0xd0
    2370:	0052      	lsls	r2, r2, #1
    2372:	2100      	movs	r1, #0
    2374:	480f      	ldr	r0, [pc, #60]	; (23b4 <usb_d_init+0x50>)
    2376:	4b10      	ldr	r3, [pc, #64]	; (23b8 <usb_d_init+0x54>)
    2378:	4798      	blx	r3
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    237a:	2200      	movs	r2, #0
    237c:	e00a      	b.n	2394 <usb_d_init+0x30>
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    237e:	0151      	lsls	r1, r2, #5
    2380:	4b0c      	ldr	r3, [pc, #48]	; (23b4 <usb_d_init+0x50>)
    2382:	185b      	adds	r3, r3, r1
    2384:	21ff      	movs	r1, #255	; 0xff
    2386:	7059      	strb	r1, [r3, #1]
		usb_d_inst.ep[i].callbacks.req  = (usb_d_ep_cb_setup_t)usb_d_dummy_cb_false;
    2388:	490c      	ldr	r1, [pc, #48]	; (23bc <usb_d_init+0x58>)
    238a:	6159      	str	r1, [r3, #20]
		usb_d_inst.ep[i].callbacks.more = (usb_d_ep_cb_more_t)usb_d_dummy_cb_false;
    238c:	6199      	str	r1, [r3, #24]
		usb_d_inst.ep[i].callbacks.xfer = (usb_d_ep_cb_xfer_t)usb_d_dummy_cb_false;
    238e:	61d9      	str	r1, [r3, #28]
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    2390:	3201      	adds	r2, #1
    2392:	b2d2      	uxtb	r2, r2
    2394:	2a0c      	cmp	r2, #12
    2396:	d9f2      	bls.n	237e <usb_d_init+0x1a>
	}
	/* Handles device driver endpoint callbacks to build transfer. */
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_SETUP, (FUNC_PTR)usb_d_cb_trans_setup);
    2398:	4909      	ldr	r1, [pc, #36]	; (23c0 <usb_d_init+0x5c>)
    239a:	2000      	movs	r0, #0
    239c:	4c09      	ldr	r4, [pc, #36]	; (23c4 <usb_d_init+0x60>)
    239e:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_MORE, (FUNC_PTR)usb_d_cb_trans_more);
    23a0:	4909      	ldr	r1, [pc, #36]	; (23c8 <usb_d_init+0x64>)
    23a2:	2001      	movs	r0, #1
    23a4:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_DONE, (FUNC_PTR)_usb_d_cb_trans_done);
    23a6:	4909      	ldr	r1, [pc, #36]	; (23cc <usb_d_init+0x68>)
    23a8:	2002      	movs	r0, #2
    23aa:	47a0      	blx	r4
	return ERR_NONE;
    23ac:	2000      	movs	r0, #0
}
    23ae:	bd10      	pop	{r4, pc}
    23b0:	000049ed 	.word	0x000049ed
    23b4:	2000020c 	.word	0x2000020c
    23b8:	00009555 	.word	0x00009555
    23bc:	00002155 	.word	0x00002155
    23c0:	000022cd 	.word	0x000022cd
    23c4:	000053e9 	.word	0x000053e9
    23c8:	00002159 	.word	0x00002159
    23cc:	00002189 	.word	0x00002189

000023d0 <usb_d_register_callback>:
{
	_usb_d_dev_deinit();
}

void usb_d_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
    23d0:	b510      	push	{r4, lr}
	/* Directly uses device driver callback. */
	_usb_d_dev_register_callback(type, func);
    23d2:	4b01      	ldr	r3, [pc, #4]	; (23d8 <usb_d_register_callback+0x8>)
    23d4:	4798      	blx	r3
}
    23d6:	bd10      	pop	{r4, pc}
    23d8:	000053c5 	.word	0x000053c5

000023dc <usb_d_enable>:

int32_t usb_d_enable(void)
{
    23dc:	b510      	push	{r4, lr}
	return _usb_d_dev_enable();
    23de:	4b01      	ldr	r3, [pc, #4]	; (23e4 <usb_d_enable+0x8>)
    23e0:	4798      	blx	r3
}
    23e2:	bd10      	pop	{r4, pc}
    23e4:	00004a95 	.word	0x00004a95

000023e8 <usb_d_attach>:
{
	_usb_d_dev_disable();
}

void usb_d_attach(void)
{
    23e8:	b510      	push	{r4, lr}
	_usb_d_dev_attach();
    23ea:	4b01      	ldr	r3, [pc, #4]	; (23f0 <usb_d_attach+0x8>)
    23ec:	4798      	blx	r3
}
    23ee:	bd10      	pop	{r4, pc}
    23f0:	00004ae5 	.word	0x00004ae5

000023f4 <usb_d_set_address>:
{
	return _usb_d_dev_get_uframe_n();
}

void usb_d_set_address(const uint8_t addr)
{
    23f4:	b510      	push	{r4, lr}
	_usb_d_dev_set_address(addr);
    23f6:	4b01      	ldr	r3, [pc, #4]	; (23fc <usb_d_set_address+0x8>)
    23f8:	4798      	blx	r3
}
    23fa:	bd10      	pop	{r4, pc}
    23fc:	00004af5 	.word	0x00004af5

00002400 <usb_d_ep_init>:
{
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
}

int32_t usb_d_ep_init(const uint8_t ep, const uint8_t attr, const uint16_t max_pkt_size)
{
    2400:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2402:	0005      	movs	r5, r0
    2404:	000e      	movs	r6, r1
    2406:	0017      	movs	r7, r2
	int32_t          rc;
	int8_t           ep_index = _usb_d_find_ep(ep);
    2408:	4b0f      	ldr	r3, [pc, #60]	; (2448 <usb_d_ep_init+0x48>)
    240a:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index >= 0) {
    240c:	2800      	cmp	r0, #0
    240e:	da14      	bge.n	243a <usb_d_ep_init+0x3a>
		return -USB_ERR_REDO;
	} else {
		ep_index = _usb_d_find_ep(0xFF);
    2410:	20ff      	movs	r0, #255	; 0xff
    2412:	4b0d      	ldr	r3, [pc, #52]	; (2448 <usb_d_ep_init+0x48>)
    2414:	4798      	blx	r3
    2416:	1e04      	subs	r4, r0, #0
		if (ep_index < 0) {
    2418:	db12      	blt.n	2440 <usb_d_ep_init+0x40>
			return -USB_ERR_ALLOC_FAIL;
		}
		ept = &usb_d_inst.ep[ep_index];
	}
	rc = _usb_d_dev_ep_init(ep, attr, max_pkt_size);
    241a:	003a      	movs	r2, r7
    241c:	0031      	movs	r1, r6
    241e:	0028      	movs	r0, r5
    2420:	4b0a      	ldr	r3, [pc, #40]	; (244c <usb_d_ep_init+0x4c>)
    2422:	4798      	blx	r3
	if (rc < 0) {
    2424:	2800      	cmp	r0, #0
    2426:	db07      	blt.n	2438 <usb_d_ep_init+0x38>
		return rc;
	}
	ept->xfer.hdr.ep   = ep;
    2428:	4a09      	ldr	r2, [pc, #36]	; (2450 <usb_d_ep_init+0x50>)
    242a:	0164      	lsls	r4, r4, #5
    242c:	1913      	adds	r3, r2, r4
    242e:	705d      	strb	r5, [r3, #1]
	ept->xfer.hdr.type = attr & USB_EP_XTYPE_MASK;
    2430:	2303      	movs	r3, #3
    2432:	401e      	ands	r6, r3
    2434:	54a6      	strb	r6, [r4, r2]
	return ERR_NONE;
    2436:	2000      	movs	r0, #0
}
    2438:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -USB_ERR_REDO;
    243a:	2014      	movs	r0, #20
    243c:	4240      	negs	r0, r0
    243e:	e7fb      	b.n	2438 <usb_d_ep_init+0x38>
			return -USB_ERR_ALLOC_FAIL;
    2440:	2015      	movs	r0, #21
    2442:	4240      	negs	r0, r0
    2444:	e7f8      	b.n	2438 <usb_d_ep_init+0x38>
    2446:	46c0      	nop			; (mov r8, r8)
    2448:	00002119 	.word	0x00002119
    244c:	00004b09 	.word	0x00004b09
    2450:	2000020c 	.word	0x2000020c

00002454 <usb_d_ep0_init>:
{
    2454:	b510      	push	{r4, lr}
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
    2456:	b282      	uxth	r2, r0
    2458:	2100      	movs	r1, #0
    245a:	2000      	movs	r0, #0
    245c:	4b01      	ldr	r3, [pc, #4]	; (2464 <usb_d_ep0_init+0x10>)
    245e:	4798      	blx	r3
}
    2460:	bd10      	pop	{r4, pc}
    2462:	46c0      	nop			; (mov r8, r8)
    2464:	00002401 	.word	0x00002401

00002468 <usb_d_ep_deinit>:

void usb_d_ep_deinit(const uint8_t ep)
{
    2468:	b570      	push	{r4, r5, r6, lr}
    246a:	0005      	movs	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    246c:	4b06      	ldr	r3, [pc, #24]	; (2488 <usb_d_ep_deinit+0x20>)
    246e:	4798      	blx	r3
    2470:	1e04      	subs	r4, r0, #0
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index < 0) {
    2472:	db07      	blt.n	2484 <usb_d_ep_deinit+0x1c>
		return;
	}
	_usb_d_dev_ep_deinit(ep);
    2474:	0028      	movs	r0, r5
    2476:	4b05      	ldr	r3, [pc, #20]	; (248c <usb_d_ep_deinit+0x24>)
    2478:	4798      	blx	r3
	ept->xfer.hdr.ep = 0xFF;
    247a:	0164      	lsls	r4, r4, #5
    247c:	4b04      	ldr	r3, [pc, #16]	; (2490 <usb_d_ep_deinit+0x28>)
    247e:	191c      	adds	r4, r3, r4
    2480:	23ff      	movs	r3, #255	; 0xff
    2482:	7063      	strb	r3, [r4, #1]
}
    2484:	bd70      	pop	{r4, r5, r6, pc}
    2486:	46c0      	nop			; (mov r8, r8)
    2488:	00002119 	.word	0x00002119
    248c:	00004c51 	.word	0x00004c51
    2490:	2000020c 	.word	0x2000020c

00002494 <usb_d_ep_enable>:

int32_t usb_d_ep_enable(const uint8_t ep)
{
    2494:	b570      	push	{r4, r5, r6, lr}
    2496:	0005      	movs	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    2498:	4b0f      	ldr	r3, [pc, #60]	; (24d8 <usb_d_ep_enable+0x44>)
    249a:	4798      	blx	r3
    249c:	1e04      	subs	r4, r0, #0
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	int32_t          rc;
	if (ep_index < 0) {
    249e:	db17      	blt.n	24d0 <usb_d_ep_enable+0x3c>
		return -USB_ERR_PARAM;
	}
	ept->xfer.hdr.state = (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) ? USB_EP_S_X_SETUP : USB_EP_S_IDLE;
    24a0:	0143      	lsls	r3, r0, #5
    24a2:	4a0e      	ldr	r2, [pc, #56]	; (24dc <usb_d_ep_enable+0x48>)
    24a4:	5c9b      	ldrb	r3, [r3, r2]
    24a6:	2b00      	cmp	r3, #0
    24a8:	d10a      	bne.n	24c0 <usb_d_ep_enable+0x2c>
    24aa:	2102      	movs	r1, #2
    24ac:	0162      	lsls	r2, r4, #5
    24ae:	4b0b      	ldr	r3, [pc, #44]	; (24dc <usb_d_ep_enable+0x48>)
    24b0:	189b      	adds	r3, r3, r2
    24b2:	7099      	strb	r1, [r3, #2]
	rc                  = _usb_d_dev_ep_enable(ep);
    24b4:	0028      	movs	r0, r5
    24b6:	4b0a      	ldr	r3, [pc, #40]	; (24e0 <usb_d_ep_enable+0x4c>)
    24b8:	4798      	blx	r3
	if (rc < 0) {
    24ba:	2800      	cmp	r0, #0
    24bc:	db02      	blt.n	24c4 <usb_d_ep_enable+0x30>
		ept->xfer.hdr.state = USB_EP_S_DISABLED;
	}
	return rc;
}
    24be:	bd70      	pop	{r4, r5, r6, pc}
	ept->xfer.hdr.state = (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) ? USB_EP_S_X_SETUP : USB_EP_S_IDLE;
    24c0:	2101      	movs	r1, #1
    24c2:	e7f3      	b.n	24ac <usb_d_ep_enable+0x18>
		ept->xfer.hdr.state = USB_EP_S_DISABLED;
    24c4:	0164      	lsls	r4, r4, #5
    24c6:	4b05      	ldr	r3, [pc, #20]	; (24dc <usb_d_ep_enable+0x48>)
    24c8:	191c      	adds	r4, r3, r4
    24ca:	2300      	movs	r3, #0
    24cc:	70a3      	strb	r3, [r4, #2]
    24ce:	e7f6      	b.n	24be <usb_d_ep_enable+0x2a>
		return -USB_ERR_PARAM;
    24d0:	2012      	movs	r0, #18
    24d2:	4240      	negs	r0, r0
    24d4:	e7f3      	b.n	24be <usb_d_ep_enable+0x2a>
    24d6:	46c0      	nop			; (mov r8, r8)
    24d8:	00002119 	.word	0x00002119
    24dc:	2000020c 	.word	0x2000020c
    24e0:	00004d15 	.word	0x00004d15

000024e4 <usb_d_ep_transfer>:
	}
	return usb_d_inst.ep[ep_index].xfer.req;
}

int32_t usb_d_ep_transfer(const struct usb_d_transfer *xfer)
{
    24e4:	b5f0      	push	{r4, r5, r6, r7, lr}
    24e6:	46d6      	mov	lr, sl
    24e8:	464f      	mov	r7, r9
    24ea:	4646      	mov	r6, r8
    24ec:	b5c0      	push	{r6, r7, lr}
    24ee:	b086      	sub	sp, #24
    24f0:	0005      	movs	r5, r0
	int8_t                ep_index = _usb_d_find_ep(xfer->ep);
    24f2:	7a06      	ldrb	r6, [r0, #8]
    24f4:	0030      	movs	r0, r6
    24f6:	4b3f      	ldr	r3, [pc, #252]	; (25f4 <usb_d_ep_transfer+0x110>)
    24f8:	4798      	blx	r3
    24fa:	0007      	movs	r7, r0
	struct usb_d_ep *     ept      = &usb_d_inst.ep[ep_index];
	bool                  dir = USB_EP_GET_DIR(xfer->ep), zlp = xfer->zlp;
    24fc:	09f6      	lsrs	r6, r6, #7
    24fe:	7a6b      	ldrb	r3, [r5, #9]
    2500:	1e5a      	subs	r2, r3, #1
    2502:	4193      	sbcs	r3, r2
    2504:	b2dc      	uxtb	r4, r3
	uint32_t              len = xfer->size;
    2506:	686b      	ldr	r3, [r5, #4]
    2508:	4698      	mov	r8, r3
	int32_t               rc;
	volatile uint8_t      state;
	volatile hal_atomic_t flags;

	if (ep_index < 0) {
    250a:	2800      	cmp	r0, #0
    250c:	db6b      	blt.n	25e6 <usb_d_ep_transfer+0x102>
		return -USB_ERR_PARAM;
	}

	atomic_enter_critical(&flags);
    250e:	a804      	add	r0, sp, #16
    2510:	4b39      	ldr	r3, [pc, #228]	; (25f8 <usb_d_ep_transfer+0x114>)
    2512:	4798      	blx	r3
	state = ept->xfer.hdr.state;
    2514:	017a      	lsls	r2, r7, #5
    2516:	4b39      	ldr	r3, [pc, #228]	; (25fc <usb_d_ep_transfer+0x118>)
    2518:	189b      	adds	r3, r3, r2
    251a:	789a      	ldrb	r2, [r3, #2]
    251c:	2317      	movs	r3, #23
    251e:	446b      	add	r3, sp
    2520:	701a      	strb	r2, [r3, #0]
	if (state == USB_EP_S_IDLE) {
    2522:	781b      	ldrb	r3, [r3, #0]
    2524:	2b01      	cmp	r3, #1
    2526:	d00e      	beq.n	2546 <usb_d_ep_transfer+0x62>
		ept->xfer.hdr.state = USB_EP_S_X_DATA;
		atomic_leave_critical(&flags);
	} else {
		atomic_leave_critical(&flags);
    2528:	a804      	add	r0, sp, #16
    252a:	4b35      	ldr	r3, [pc, #212]	; (2600 <usb_d_ep_transfer+0x11c>)
    252c:	4798      	blx	r3
		switch (state) {
    252e:	2317      	movs	r3, #23
    2530:	446b      	add	r3, sp
    2532:	781b      	ldrb	r3, [r3, #0]
    2534:	b2db      	uxtb	r3, r3
    2536:	2b05      	cmp	r3, #5
    2538:	d02b      	beq.n	2592 <usb_d_ep_transfer+0xae>
    253a:	2b06      	cmp	r3, #6
    253c:	d056      	beq.n	25ec <usb_d_ep_transfer+0x108>
    253e:	2b00      	cmp	r3, #0
    2540:	d029      	beq.n	2596 <usb_d_ep_transfer+0xb2>
		case USB_EP_S_ERROR:
			return -USB_ERROR;
		case USB_EP_S_DISABLED:
			return -USB_ERR_FUNC;
		default: /* USB_EP_S_X_xxxx  */
			return USB_BUSY;
    2542:	2001      	movs	r0, #1
    2544:	e01f      	b.n	2586 <usb_d_ep_transfer+0xa2>
		ept->xfer.hdr.state = USB_EP_S_X_DATA;
    2546:	4b2d      	ldr	r3, [pc, #180]	; (25fc <usb_d_ep_transfer+0x118>)
    2548:	4699      	mov	r9, r3
    254a:	017b      	lsls	r3, r7, #5
    254c:	469a      	mov	sl, r3
    254e:	464b      	mov	r3, r9
    2550:	4453      	add	r3, sl
    2552:	2203      	movs	r2, #3
    2554:	709a      	strb	r2, [r3, #2]
		atomic_leave_critical(&flags);
    2556:	a804      	add	r0, sp, #16
    2558:	4b29      	ldr	r3, [pc, #164]	; (2600 <usb_d_ep_transfer+0x11c>)
    255a:	4798      	blx	r3
		}
	}

	if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    255c:	464b      	mov	r3, r9
    255e:	4652      	mov	r2, sl
    2560:	5cd3      	ldrb	r3, [r2, r3]
    2562:	2b00      	cmp	r3, #0
    2564:	d01a      	beq.n	259c <usb_d_ep_transfer+0xb8>
				zlp = false;
			}
		}
	}

	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
    2566:	7a29      	ldrb	r1, [r5, #8]
    2568:	682b      	ldr	r3, [r5, #0]
    256a:	9301      	str	r3, [sp, #4]
	struct usb_d_transfer trans
    256c:	4643      	mov	r3, r8
    256e:	9302      	str	r3, [sp, #8]
    2570:	2e00      	cmp	r6, #0
    2572:	d035      	beq.n	25e0 <usb_d_ep_transfer+0xfc>
    2574:	2280      	movs	r2, #128	; 0x80
    2576:	4252      	negs	r2, r2
    2578:	430a      	orrs	r2, r1
    257a:	b2d2      	uxtb	r2, r2
    257c:	a801      	add	r0, sp, #4
    257e:	7202      	strb	r2, [r0, #8]
    2580:	7244      	strb	r4, [r0, #9]
	return _usb_d_dev_ep_trans(&trans);
    2582:	4b20      	ldr	r3, [pc, #128]	; (2604 <usb_d_ep_transfer+0x120>)
    2584:	4798      	blx	r3
	return rc;
}
    2586:	b006      	add	sp, #24
    2588:	bc1c      	pop	{r2, r3, r4}
    258a:	4690      	mov	r8, r2
    258c:	4699      	mov	r9, r3
    258e:	46a2      	mov	sl, r4
    2590:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return USB_HALTED;
    2592:	2002      	movs	r0, #2
    2594:	e7f7      	b.n	2586 <usb_d_ep_transfer+0xa2>
			return -USB_ERR_FUNC;
    2596:	2013      	movs	r0, #19
    2598:	4240      	negs	r0, r0
    259a:	e7f4      	b.n	2586 <usb_d_ep_transfer+0xa2>
		uint16_t req_len = USB_GET_wLength(ept->xfer.req);
    259c:	017b      	lsls	r3, r7, #5
    259e:	4a17      	ldr	r2, [pc, #92]	; (25fc <usb_d_ep_transfer+0x118>)
    25a0:	18d2      	adds	r2, r2, r3
    25a2:	7c93      	ldrb	r3, [r2, #18]
    25a4:	7cd4      	ldrb	r4, [r2, #19]
    25a6:	0224      	lsls	r4, r4, #8
    25a8:	191b      	adds	r3, r3, r4
    25aa:	b29b      	uxth	r3, r3
		if (req_len == 0) {
    25ac:	2b00      	cmp	r3, #0
    25ae:	d106      	bne.n	25be <usb_d_ep_transfer+0xda>
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    25b0:	2304      	movs	r3, #4
    25b2:	7093      	strb	r3, [r2, #2]
			len                 = 0;
    25b4:	2300      	movs	r3, #0
    25b6:	4698      	mov	r8, r3
			zlp                 = true;
    25b8:	2401      	movs	r4, #1
			dir                 = true;
    25ba:	2601      	movs	r6, #1
    25bc:	e7d3      	b.n	2566 <usb_d_ep_transfer+0x82>
			dir = (USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN);
    25be:	017f      	lsls	r7, r7, #5
    25c0:	4a0e      	ldr	r2, [pc, #56]	; (25fc <usb_d_ep_transfer+0x118>)
    25c2:	19d7      	adds	r7, r2, r7
    25c4:	220c      	movs	r2, #12
    25c6:	56ba      	ldrsb	r2, [r7, r2]
    25c8:	0fd6      	lsrs	r6, r2, #31
			if (len > req_len) {
    25ca:	4598      	cmp	r8, r3
    25cc:	d900      	bls.n	25d0 <usb_d_ep_transfer+0xec>
				len = req_len;
    25ce:	4698      	mov	r8, r3
			if (dir) {
    25d0:	2a00      	cmp	r2, #0
    25d2:	db01      	blt.n	25d8 <usb_d_ep_transfer+0xf4>
				zlp = false;
    25d4:	2400      	movs	r4, #0
    25d6:	e7c6      	b.n	2566 <usb_d_ep_transfer+0x82>
				zlp = (req_len > len);
    25d8:	4598      	cmp	r8, r3
    25da:	419b      	sbcs	r3, r3
    25dc:	425c      	negs	r4, r3
    25de:	e7c2      	b.n	2566 <usb_d_ep_transfer+0x82>
	struct usb_d_transfer trans
    25e0:	220f      	movs	r2, #15
    25e2:	400a      	ands	r2, r1
    25e4:	e7ca      	b.n	257c <usb_d_ep_transfer+0x98>
		return -USB_ERR_PARAM;
    25e6:	2012      	movs	r0, #18
    25e8:	4240      	negs	r0, r0
    25ea:	e7cc      	b.n	2586 <usb_d_ep_transfer+0xa2>
			return -USB_ERROR;
    25ec:	2010      	movs	r0, #16
    25ee:	4240      	negs	r0, r0
    25f0:	e7c9      	b.n	2586 <usb_d_ep_transfer+0xa2>
    25f2:	46c0      	nop			; (mov r8, r8)
    25f4:	00002119 	.word	0x00002119
    25f8:	00001271 	.word	0x00001271
    25fc:	2000020c 	.word	0x2000020c
    2600:	0000127f 	.word	0x0000127f
    2604:	000051f1 	.word	0x000051f1

00002608 <usb_d_ep_halt>:
	}
	return ERR_NONE;
}

int32_t usb_d_ep_halt(const uint8_t ep, const enum usb_ep_halt_ctrl ctrl)
{
    2608:	b570      	push	{r4, r5, r6, lr}
    260a:	0004      	movs	r4, r0
	if (ctrl == USB_EP_HALT_CLR) {
    260c:	2900      	cmp	r1, #0
    260e:	d005      	beq.n	261c <usb_d_ep_halt+0x14>
		return _usb_d_ep_halt_clr(ep);
	} else if (ctrl == USB_EP_HALT_SET) {
    2610:	2901      	cmp	r1, #1
    2612:	d024      	beq.n	265e <usb_d_ep_halt+0x56>
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
	} else {
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_GET);
    2614:	2102      	movs	r1, #2
    2616:	4b13      	ldr	r3, [pc, #76]	; (2664 <usb_d_ep_halt+0x5c>)
    2618:	4798      	blx	r3
	}
}
    261a:	bd70      	pop	{r4, r5, r6, pc}
	int8_t           ep_index = _usb_d_find_ep(ep);
    261c:	4b12      	ldr	r3, [pc, #72]	; (2668 <usb_d_ep_halt+0x60>)
    261e:	4798      	blx	r3
    2620:	1e05      	subs	r5, r0, #0
	if (ep_index < 0) {
    2622:	db19      	blt.n	2658 <usb_d_ep_halt+0x50>
	if (_usb_d_dev_ep_stall(ep, USB_EP_STALL_GET)) {
    2624:	2102      	movs	r1, #2
    2626:	0020      	movs	r0, r4
    2628:	4b0e      	ldr	r3, [pc, #56]	; (2664 <usb_d_ep_halt+0x5c>)
    262a:	4798      	blx	r3
    262c:	2800      	cmp	r0, #0
    262e:	d0f4      	beq.n	261a <usb_d_ep_halt+0x12>
		rc = _usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    2630:	2100      	movs	r1, #0
    2632:	0020      	movs	r0, r4
    2634:	4b0b      	ldr	r3, [pc, #44]	; (2664 <usb_d_ep_halt+0x5c>)
    2636:	4798      	blx	r3
		if (rc < 0) {
    2638:	2800      	cmp	r0, #0
    263a:	dbee      	blt.n	261a <usb_d_ep_halt+0x12>
		ept->xfer.hdr.state  = USB_EP_S_IDLE;
    263c:	016d      	lsls	r5, r5, #5
    263e:	4b0b      	ldr	r3, [pc, #44]	; (266c <usb_d_ep_halt+0x64>)
    2640:	195d      	adds	r5, r3, r5
    2642:	2301      	movs	r3, #1
    2644:	70ab      	strb	r3, [r5, #2]
		ept->xfer.hdr.status = USB_XFER_UNHALT;
    2646:	3302      	adds	r3, #2
    2648:	70eb      	strb	r3, [r5, #3]
		ept->callbacks.xfer(ep, USB_XFER_UNHALT, NULL);
    264a:	69eb      	ldr	r3, [r5, #28]
    264c:	2200      	movs	r2, #0
    264e:	2103      	movs	r1, #3
    2650:	0020      	movs	r0, r4
    2652:	4798      	blx	r3
	return ERR_NONE;
    2654:	2000      	movs	r0, #0
    2656:	e7e0      	b.n	261a <usb_d_ep_halt+0x12>
		return -USB_ERR_PARAM;
    2658:	2012      	movs	r0, #18
    265a:	4240      	negs	r0, r0
		return _usb_d_ep_halt_clr(ep);
    265c:	e7dd      	b.n	261a <usb_d_ep_halt+0x12>
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    265e:	4b01      	ldr	r3, [pc, #4]	; (2664 <usb_d_ep_halt+0x5c>)
    2660:	4798      	blx	r3
    2662:	e7da      	b.n	261a <usb_d_ep_halt+0x12>
    2664:	00005021 	.word	0x00005021
    2668:	00002119 	.word	0x00002119
    266c:	2000020c 	.word	0x2000020c

00002670 <usb_d_ep_register_callback>:

void usb_d_ep_register_callback(const uint8_t ep, const enum usb_d_ep_cb_type type, const FUNC_PTR func)
{
    2670:	b570      	push	{r4, r5, r6, lr}
    2672:	000d      	movs	r5, r1
    2674:	0014      	movs	r4, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
    2676:	4b0f      	ldr	r3, [pc, #60]	; (26b4 <usb_d_ep_register_callback+0x44>)
    2678:	4798      	blx	r3
    267a:	0003      	movs	r3, r0
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	FUNC_PTR         f        = func ? (FUNC_PTR)func : (FUNC_PTR)usb_d_dummy_cb_false;
    267c:	2c00      	cmp	r4, #0
    267e:	d008      	beq.n	2692 <usb_d_ep_register_callback+0x22>
	if (ep_index < 0) {
    2680:	2b00      	cmp	r3, #0
    2682:	db05      	blt.n	2690 <usb_d_ep_register_callback+0x20>
		return;
	}
	switch (type) {
    2684:	2d01      	cmp	r5, #1
    2686:	d00b      	beq.n	26a0 <usb_d_ep_register_callback+0x30>
    2688:	2d00      	cmp	r5, #0
    268a:	d004      	beq.n	2696 <usb_d_ep_register_callback+0x26>
    268c:	2d02      	cmp	r5, #2
    268e:	d00c      	beq.n	26aa <usb_d_ep_register_callback+0x3a>
		ept->callbacks.xfer = (usb_d_ep_cb_xfer_t)f;
		break;
	default:
		break;
	}
}
    2690:	bd70      	pop	{r4, r5, r6, pc}
	FUNC_PTR         f        = func ? (FUNC_PTR)func : (FUNC_PTR)usb_d_dummy_cb_false;
    2692:	4c09      	ldr	r4, [pc, #36]	; (26b8 <usb_d_ep_register_callback+0x48>)
    2694:	e7f4      	b.n	2680 <usb_d_ep_register_callback+0x10>
		ept->callbacks.req = (usb_d_ep_cb_setup_t)f;
    2696:	0140      	lsls	r0, r0, #5
    2698:	4b08      	ldr	r3, [pc, #32]	; (26bc <usb_d_ep_register_callback+0x4c>)
    269a:	1818      	adds	r0, r3, r0
    269c:	6144      	str	r4, [r0, #20]
		break;
    269e:	e7f7      	b.n	2690 <usb_d_ep_register_callback+0x20>
		ept->callbacks.more = (usb_d_ep_cb_more_t)f;
    26a0:	0140      	lsls	r0, r0, #5
    26a2:	4b06      	ldr	r3, [pc, #24]	; (26bc <usb_d_ep_register_callback+0x4c>)
    26a4:	1818      	adds	r0, r3, r0
    26a6:	6184      	str	r4, [r0, #24]
		break;
    26a8:	e7f2      	b.n	2690 <usb_d_ep_register_callback+0x20>
		ept->callbacks.xfer = (usb_d_ep_cb_xfer_t)f;
    26aa:	0140      	lsls	r0, r0, #5
    26ac:	4b03      	ldr	r3, [pc, #12]	; (26bc <usb_d_ep_register_callback+0x4c>)
    26ae:	1818      	adds	r0, r3, r0
    26b0:	61c4      	str	r4, [r0, #28]
		break;
    26b2:	e7ed      	b.n	2690 <usb_d_ep_register_callback+0x20>
    26b4:	00002119 	.word	0x00002119
    26b8:	00002155 	.word	0x00002155
    26bc:	2000020c 	.word	0x2000020c

000026c0 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    26c0:	2800      	cmp	r0, #0
    26c2:	d100      	bne.n	26c6 <assert+0x6>
		__asm("BKPT #0");
    26c4:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    26c6:	4770      	bx	lr

000026c8 <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
    26c8:	6803      	ldr	r3, [r0, #0]
    26ca:	2b00      	cmp	r3, #0
    26cc:	d003      	beq.n	26d6 <is_list_element+0xe>
		if (it == element) {
    26ce:	428b      	cmp	r3, r1
    26d0:	d003      	beq.n	26da <is_list_element+0x12>
	for (it = list->head; it; it = it->next) {
    26d2:	681b      	ldr	r3, [r3, #0]
    26d4:	e7f9      	b.n	26ca <is_list_element+0x2>
			return true;
		}
	}

	return false;
    26d6:	2000      	movs	r0, #0
}
    26d8:	4770      	bx	lr
			return true;
    26da:	2001      	movs	r0, #1
    26dc:	e7fc      	b.n	26d8 <is_list_element+0x10>
	...

000026e0 <list_insert_as_head>:

/**
 * \brief Insert an element as list head
 */
void list_insert_as_head(struct list_descriptor *const list, void *const element)
{
    26e0:	b570      	push	{r4, r5, r6, lr}
    26e2:	0004      	movs	r4, r0
    26e4:	000d      	movs	r5, r1
	ASSERT(!is_list_element(list, element));
    26e6:	4b06      	ldr	r3, [pc, #24]	; (2700 <list_insert_as_head+0x20>)
    26e8:	4798      	blx	r3
    26ea:	2301      	movs	r3, #1
    26ec:	4058      	eors	r0, r3
    26ee:	b2c0      	uxtb	r0, r0
    26f0:	2239      	movs	r2, #57	; 0x39
    26f2:	4904      	ldr	r1, [pc, #16]	; (2704 <list_insert_as_head+0x24>)
    26f4:	4b04      	ldr	r3, [pc, #16]	; (2708 <list_insert_as_head+0x28>)
    26f6:	4798      	blx	r3

	((struct list_element *)element)->next = list->head;
    26f8:	6823      	ldr	r3, [r4, #0]
    26fa:	602b      	str	r3, [r5, #0]
	list->head                             = (struct list_element *)element;
    26fc:	6025      	str	r5, [r4, #0]
}
    26fe:	bd70      	pop	{r4, r5, r6, pc}
    2700:	000026c9 	.word	0x000026c9
    2704:	0000aaf0 	.word	0x0000aaf0
    2708:	000026c1 	.word	0x000026c1

0000270c <list_insert_after>:
/**
 * \brief Insert an element after the given list element
 */
void list_insert_after(void *const after, void *const element)
{
	((struct list_element *)element)->next = ((struct list_element *)after)->next;
    270c:	6803      	ldr	r3, [r0, #0]
    270e:	600b      	str	r3, [r1, #0]
	((struct list_element *)after)->next   = (struct list_element *)element;
    2710:	6001      	str	r1, [r0, #0]
}
    2712:	4770      	bx	lr

00002714 <list_insert_at_end>:

/**
 * \brief Insert an element at list end
 */
void list_insert_at_end(struct list_descriptor *const list, void *const element)
{
    2714:	b570      	push	{r4, r5, r6, lr}
    2716:	0005      	movs	r5, r0
    2718:	000e      	movs	r6, r1
	struct list_element *it = list->head;
    271a:	6804      	ldr	r4, [r0, #0]

	ASSERT(!is_list_element(list, element));
    271c:	4b0a      	ldr	r3, [pc, #40]	; (2748 <list_insert_at_end+0x34>)
    271e:	4798      	blx	r3
    2720:	2301      	movs	r3, #1
    2722:	4058      	eors	r0, r3
    2724:	b2c0      	uxtb	r0, r0
    2726:	224f      	movs	r2, #79	; 0x4f
    2728:	4908      	ldr	r1, [pc, #32]	; (274c <list_insert_at_end+0x38>)
    272a:	4b09      	ldr	r3, [pc, #36]	; (2750 <list_insert_at_end+0x3c>)
    272c:	4798      	blx	r3

	if (!list->head) {
    272e:	682b      	ldr	r3, [r5, #0]
    2730:	2b00      	cmp	r3, #0
    2732:	d103      	bne.n	273c <list_insert_at_end+0x28>
		list->head                             = (struct list_element *)element;
    2734:	602e      	str	r6, [r5, #0]
		((struct list_element *)element)->next = NULL;
    2736:	6033      	str	r3, [r6, #0]
		return;
    2738:	e005      	b.n	2746 <list_insert_at_end+0x32>
	}

	while (it->next) {
		it = it->next;
    273a:	001c      	movs	r4, r3
	while (it->next) {
    273c:	6823      	ldr	r3, [r4, #0]
    273e:	2b00      	cmp	r3, #0
    2740:	d1fb      	bne.n	273a <list_insert_at_end+0x26>
	}
	it->next                               = (struct list_element *)element;
    2742:	6026      	str	r6, [r4, #0]
	((struct list_element *)element)->next = NULL;
    2744:	6033      	str	r3, [r6, #0]
}
    2746:	bd70      	pop	{r4, r5, r6, pc}
    2748:	000026c9 	.word	0x000026c9
    274c:	0000aaf0 	.word	0x0000aaf0
    2750:	000026c1 	.word	0x000026c1

00002754 <list_remove_head>:
/**
 * \brief Removes list head
 */
void *list_remove_head(struct list_descriptor *const list)
{
	if (list->head) {
    2754:	6803      	ldr	r3, [r0, #0]
    2756:	2b00      	cmp	r3, #0
    2758:	d003      	beq.n	2762 <list_remove_head+0xe>
		struct list_element *tmp = list->head;

		list->head = list->head->next;
    275a:	681a      	ldr	r2, [r3, #0]
    275c:	6002      	str	r2, [r0, #0]
		return (void *)tmp;
    275e:	0018      	movs	r0, r3
	}

	return NULL;
}
    2760:	4770      	bx	lr
	return NULL;
    2762:	2000      	movs	r0, #0
    2764:	e7fc      	b.n	2760 <list_remove_head+0xc>
	...

00002768 <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
    2768:	b570      	push	{r4, r5, r6, lr}
    276a:	0004      	movs	r4, r0
    276c:	000e      	movs	r6, r1
    276e:	0015      	movs	r5, r2
	ASSERT(rb && buf && size);
    2770:	2800      	cmp	r0, #0
    2772:	d012      	beq.n	279a <ringbuffer_init+0x32>
    2774:	2900      	cmp	r1, #0
    2776:	d012      	beq.n	279e <ringbuffer_init+0x36>
    2778:	2a00      	cmp	r2, #0
    277a:	d112      	bne.n	27a2 <ringbuffer_init+0x3a>
    277c:	2000      	movs	r0, #0
    277e:	2228      	movs	r2, #40	; 0x28
    2780:	490a      	ldr	r1, [pc, #40]	; (27ac <ringbuffer_init+0x44>)
    2782:	4b0b      	ldr	r3, [pc, #44]	; (27b0 <ringbuffer_init+0x48>)
    2784:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
    2786:	1e6b      	subs	r3, r5, #1
    2788:	422b      	tst	r3, r5
    278a:	d10c      	bne.n	27a6 <ringbuffer_init+0x3e>
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
    278c:	6063      	str	r3, [r4, #4]
	rb->read_index  = 0;
    278e:	2300      	movs	r3, #0
    2790:	60a3      	str	r3, [r4, #8]
	rb->write_index = rb->read_index;
    2792:	60e3      	str	r3, [r4, #12]
	rb->buf         = (uint8_t *)buf;
    2794:	6026      	str	r6, [r4, #0]

	return ERR_NONE;
    2796:	2000      	movs	r0, #0
}
    2798:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
    279a:	2000      	movs	r0, #0
    279c:	e7ef      	b.n	277e <ringbuffer_init+0x16>
    279e:	2000      	movs	r0, #0
    27a0:	e7ed      	b.n	277e <ringbuffer_init+0x16>
    27a2:	2001      	movs	r0, #1
    27a4:	e7eb      	b.n	277e <ringbuffer_init+0x16>
		return ERR_INVALID_ARG;
    27a6:	200d      	movs	r0, #13
    27a8:	4240      	negs	r0, r0
    27aa:	e7f5      	b.n	2798 <ringbuffer_init+0x30>
    27ac:	0000ab10 	.word	0x0000ab10
    27b0:	000026c1 	.word	0x000026c1

000027b4 <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
    27b4:	b570      	push	{r4, r5, r6, lr}
    27b6:	0004      	movs	r4, r0
    27b8:	000d      	movs	r5, r1
	ASSERT(rb && data);
    27ba:	2800      	cmp	r0, #0
    27bc:	d016      	beq.n	27ec <ringbuffer_get+0x38>
    27be:	2900      	cmp	r1, #0
    27c0:	d012      	beq.n	27e8 <ringbuffer_get+0x34>
    27c2:	2001      	movs	r0, #1
    27c4:	2240      	movs	r2, #64	; 0x40
    27c6:	490c      	ldr	r1, [pc, #48]	; (27f8 <ringbuffer_get+0x44>)
    27c8:	4b0c      	ldr	r3, [pc, #48]	; (27fc <ringbuffer_get+0x48>)
    27ca:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
    27cc:	68a3      	ldr	r3, [r4, #8]
    27ce:	68e2      	ldr	r2, [r4, #12]
    27d0:	429a      	cmp	r2, r3
    27d2:	d00d      	beq.n	27f0 <ringbuffer_get+0x3c>
		*data = rb->buf[rb->read_index & rb->size];
    27d4:	6862      	ldr	r2, [r4, #4]
    27d6:	4013      	ands	r3, r2
    27d8:	6822      	ldr	r2, [r4, #0]
    27da:	5cd3      	ldrb	r3, [r2, r3]
    27dc:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
    27de:	68a3      	ldr	r3, [r4, #8]
    27e0:	3301      	adds	r3, #1
    27e2:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
    27e4:	2000      	movs	r0, #0
	}

	return ERR_NOT_FOUND;
}
    27e6:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && data);
    27e8:	2000      	movs	r0, #0
    27ea:	e7eb      	b.n	27c4 <ringbuffer_get+0x10>
    27ec:	2000      	movs	r0, #0
    27ee:	e7e9      	b.n	27c4 <ringbuffer_get+0x10>
	return ERR_NOT_FOUND;
    27f0:	200a      	movs	r0, #10
    27f2:	4240      	negs	r0, r0
    27f4:	e7f7      	b.n	27e6 <ringbuffer_get+0x32>
    27f6:	46c0      	nop			; (mov r8, r8)
    27f8:	0000ab10 	.word	0x0000ab10
    27fc:	000026c1 	.word	0x000026c1

00002800 <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
    2800:	b570      	push	{r4, r5, r6, lr}
    2802:	0004      	movs	r4, r0
    2804:	000d      	movs	r5, r1
	ASSERT(rb);
    2806:	1e43      	subs	r3, r0, #1
    2808:	4198      	sbcs	r0, r3
    280a:	b2c0      	uxtb	r0, r0
    280c:	2251      	movs	r2, #81	; 0x51
    280e:	490a      	ldr	r1, [pc, #40]	; (2838 <ringbuffer_put+0x38>)
    2810:	4b0a      	ldr	r3, [pc, #40]	; (283c <ringbuffer_put+0x3c>)
    2812:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
    2814:	6863      	ldr	r3, [r4, #4]
    2816:	68e2      	ldr	r2, [r4, #12]
    2818:	4013      	ands	r3, r2
    281a:	6822      	ldr	r2, [r4, #0]
    281c:	54d5      	strb	r5, [r2, r3]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
    281e:	68e3      	ldr	r3, [r4, #12]
    2820:	68a2      	ldr	r2, [r4, #8]
    2822:	1a9a      	subs	r2, r3, r2
    2824:	6861      	ldr	r1, [r4, #4]
    2826:	428a      	cmp	r2, r1
    2828:	d901      	bls.n	282e <ringbuffer_put+0x2e>
		rb->read_index = rb->write_index - rb->size;
    282a:	1a59      	subs	r1, r3, r1
    282c:	60a1      	str	r1, [r4, #8]
	}

	rb->write_index++;
    282e:	3301      	adds	r3, #1
    2830:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
}
    2832:	2000      	movs	r0, #0
    2834:	bd70      	pop	{r4, r5, r6, pc}
    2836:	46c0      	nop			; (mov r8, r8)
    2838:	0000ab10 	.word	0x0000ab10
    283c:	000026c1 	.word	0x000026c1

00002840 <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
    2840:	b510      	push	{r4, lr}
    2842:	0004      	movs	r4, r0
	ASSERT(rb);
    2844:	1e43      	subs	r3, r0, #1
    2846:	4198      	sbcs	r0, r3
    2848:	b2c0      	uxtb	r0, r0
    284a:	2267      	movs	r2, #103	; 0x67
    284c:	4903      	ldr	r1, [pc, #12]	; (285c <ringbuffer_num+0x1c>)
    284e:	4b04      	ldr	r3, [pc, #16]	; (2860 <ringbuffer_num+0x20>)
    2850:	4798      	blx	r3

	return rb->write_index - rb->read_index;
    2852:	68e0      	ldr	r0, [r4, #12]
    2854:	68a3      	ldr	r3, [r4, #8]
    2856:	1ac0      	subs	r0, r0, r3
}
    2858:	bd10      	pop	{r4, pc}
    285a:	46c0      	nop			; (mov r8, r8)
    285c:	0000ab10 	.word	0x0000ab10
    2860:	000026c1 	.word	0x000026c1

00002864 <_sbrk>:

/**
 * \brief Replacement of C library of _sbrk
 */
extern caddr_t _sbrk(int incr)
{
    2864:	0003      	movs	r3, r0
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
    2866:	4a06      	ldr	r2, [pc, #24]	; (2880 <_sbrk+0x1c>)
    2868:	6812      	ldr	r2, [r2, #0]
    286a:	2a00      	cmp	r2, #0
    286c:	d004      	beq.n	2878 <_sbrk+0x14>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;
    286e:	4a04      	ldr	r2, [pc, #16]	; (2880 <_sbrk+0x1c>)
    2870:	6810      	ldr	r0, [r2, #0]

	heap += incr;
    2872:	18c3      	adds	r3, r0, r3
    2874:	6013      	str	r3, [r2, #0]

	return (caddr_t)prev_heap;
}
    2876:	4770      	bx	lr
		heap = (unsigned char *)&_end;
    2878:	4902      	ldr	r1, [pc, #8]	; (2884 <_sbrk+0x20>)
    287a:	4a01      	ldr	r2, [pc, #4]	; (2880 <_sbrk+0x1c>)
    287c:	6011      	str	r1, [r2, #0]
    287e:	e7f6      	b.n	286e <_sbrk+0xa>
    2880:	200003ac 	.word	0x200003ac
    2884:	20002ad0 	.word	0x20002ad0

00002888 <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
    2888:	2001      	movs	r0, #1
    288a:	4240      	negs	r0, r0
    288c:	4770      	bx	lr

0000288e <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
    288e:	2380      	movs	r3, #128	; 0x80
    2890:	019b      	lsls	r3, r3, #6
    2892:	604b      	str	r3, [r1, #4]

	return 0;
}
    2894:	2000      	movs	r0, #0
    2896:	4770      	bx	lr

00002898 <_isatty>:
 */
extern int _isatty(int file)
{
	(void)file;
	return 1;
}
    2898:	2001      	movs	r0, #1
    289a:	4770      	bx	lr

0000289c <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
    289c:	2000      	movs	r0, #0
    289e:	4770      	bx	lr

000028a0 <_adc_get_hardware_index>:
 */
static uint8_t _adc_get_hardware_index(const void *const hw)
{
	(void)hw;
	return 0;
}
    28a0:	2000      	movs	r0, #0
    28a2:	4770      	bx	lr

000028a4 <_adc_get_regs>:
/** \brief Return the pointer to register settings of specific ADC
 *  \param[in] hw_addr The hardware register base address.
 *  \return Pointer to register settings of specific ADC.
 */
static uint8_t _adc_get_regs(const uint32_t hw_addr)
{
    28a4:	b510      	push	{r4, lr}
	uint8_t n = _adc_get_hardware_index((const void *)hw_addr);
    28a6:	4b0b      	ldr	r3, [pc, #44]	; (28d4 <_adc_get_regs+0x30>)
    28a8:	4798      	blx	r3
    28aa:	0002      	movs	r2, r0
	uint8_t i;

	for (i = 0; i < sizeof(_adcs) / sizeof(struct adc_configuration); i++) {
    28ac:	2000      	movs	r0, #0
    28ae:	2800      	cmp	r0, #0
    28b0:	d006      	beq.n	28c0 <_adc_get_regs+0x1c>
		if (_adcs[i].number == n) {
			return i;
		}
	}

	ASSERT(false);
    28b2:	227f      	movs	r2, #127	; 0x7f
    28b4:	4908      	ldr	r1, [pc, #32]	; (28d8 <_adc_get_regs+0x34>)
    28b6:	2000      	movs	r0, #0
    28b8:	4b08      	ldr	r3, [pc, #32]	; (28dc <_adc_get_regs+0x38>)
    28ba:	4798      	blx	r3
	return 0;
    28bc:	2000      	movs	r0, #0
}
    28be:	bd10      	pop	{r4, pc}
		if (_adcs[i].number == n) {
    28c0:	00c3      	lsls	r3, r0, #3
    28c2:	1a1b      	subs	r3, r3, r0
    28c4:	0099      	lsls	r1, r3, #2
    28c6:	4b06      	ldr	r3, [pc, #24]	; (28e0 <_adc_get_regs+0x3c>)
    28c8:	5ccb      	ldrb	r3, [r1, r3]
    28ca:	429a      	cmp	r2, r3
    28cc:	d0f7      	beq.n	28be <_adc_get_regs+0x1a>
	for (i = 0; i < sizeof(_adcs) / sizeof(struct adc_configuration); i++) {
    28ce:	3001      	adds	r0, #1
    28d0:	b2c0      	uxtb	r0, r0
    28d2:	e7ec      	b.n	28ae <_adc_get_regs+0xa>
    28d4:	000028a1 	.word	0x000028a1
    28d8:	0000ab50 	.word	0x0000ab50
    28dc:	000026c1 	.word	0x000026c1
    28e0:	0000ab34 	.word	0x0000ab34

000028e4 <_adc_init>:
 *
 * \param[in] hw The pointer to hardware instance
 * \param[in] i  The number of hardware instance
 */
static int32_t _adc_init(void *const hw, const uint8_t i)
{
    28e4:	b570      	push	{r4, r5, r6, lr}
    28e6:	0004      	movs	r4, r0
    28e8:	000d      	movs	r5, r1
	ASSERT(hw == ADC);
    28ea:	4b3a      	ldr	r3, [pc, #232]	; (29d4 <_adc_init+0xf0>)
    28ec:	18c0      	adds	r0, r0, r3
    28ee:	4243      	negs	r3, r0
    28f0:	4158      	adcs	r0, r3
    28f2:	b2c0      	uxtb	r0, r0
    28f4:	2294      	movs	r2, #148	; 0x94
    28f6:	4938      	ldr	r1, [pc, #224]	; (29d8 <_adc_init+0xf4>)
    28f8:	4b38      	ldr	r3, [pc, #224]	; (29dc <_adc_init+0xf8>)
    28fa:	4798      	blx	r3

	uint16_t calib_reg;

	calib_reg = ADC_CALIB_BIAS_CAL((*(uint32_t *)ADC_FUSES_BIASCAL_ADDR >> ADC_FUSES_BIASCAL_Pos))
    28fc:	4b38      	ldr	r3, [pc, #224]	; (29e0 <_adc_init+0xfc>)
    28fe:	681a      	ldr	r2, [r3, #0]
    2900:	08d2      	lsrs	r2, r2, #3
    2902:	0212      	lsls	r2, r2, #8
    2904:	23e0      	movs	r3, #224	; 0xe0
    2906:	00db      	lsls	r3, r3, #3
    2908:	401a      	ands	r2, r3
	            | ADC_CALIB_LINEARITY_CAL((*(uint64_t *)ADC_FUSES_LINEARITY_0_ADDR >> ADC_FUSES_LINEARITY_0_Pos));
    290a:	4936      	ldr	r1, [pc, #216]	; (29e4 <_adc_init+0x100>)
    290c:	680b      	ldr	r3, [r1, #0]
    290e:	6849      	ldr	r1, [r1, #4]
    2910:	0149      	lsls	r1, r1, #5
    2912:	0edb      	lsrs	r3, r3, #27
    2914:	430b      	orrs	r3, r1
    2916:	21ff      	movs	r1, #255	; 0xff
    2918:	400b      	ands	r3, r1
	calib_reg = ADC_CALIB_BIAS_CAL((*(uint32_t *)ADC_FUSES_BIASCAL_ADDR >> ADC_FUSES_BIASCAL_Pos))
    291a:	431a      	orrs	r2, r3
typedef uint8_t  hri_adc_swtrig_reg_t;
typedef uint8_t  hri_adc_winctrl_reg_t;

static inline void hri_adc_wait_for_sync(const void *const hw)
{
	while (((const Adc *)hw)->STATUS.bit.SYNCBUSY)
    291c:	7e63      	ldrb	r3, [r4, #25]
    291e:	09db      	lsrs	r3, r3, #7
    2920:	d1fc      	bne.n	291c <_adc_init+0x38>
}

static inline hri_adc_ctrla_reg_t hri_adc_get_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t mask)
{
	uint8_t tmp;
	tmp = ((Adc *)hw)->CTRLA.reg;
    2922:	7823      	ldrb	r3, [r4, #0]

	hri_adc_wait_for_sync(hw);
	if (hri_adc_get_CTRLA_reg(hw, ADC_CTRLA_ENABLE)) {
    2924:	079b      	lsls	r3, r3, #30
    2926:	d504      	bpl.n	2932 <_adc_init+0x4e>
}

static inline void hri_adc_write_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg = data;
    2928:	2300      	movs	r3, #0
    292a:	7023      	strb	r3, [r4, #0]
	while (((const Adc *)hw)->STATUS.bit.SYNCBUSY)
    292c:	7e63      	ldrb	r3, [r4, #25]
    292e:	09db      	lsrs	r3, r3, #7
    2930:	d1fc      	bne.n	292c <_adc_init+0x48>
	((Adc *)hw)->CTRLA.reg = data;
    2932:	2301      	movs	r3, #1
    2934:	7023      	strb	r3, [r4, #0]
	while (((const Adc *)hw)->STATUS.bit.SYNCBUSY)
    2936:	7e63      	ldrb	r3, [r4, #25]
    2938:	09db      	lsrs	r3, r3, #7
    293a:	d1fc      	bne.n	2936 <_adc_init+0x52>
}

static inline void hri_adc_write_CALIB_reg(const void *const hw, hri_adc_calib_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CALIB.reg = data;
    293c:	8522      	strh	r2, [r4, #40]	; 0x28
	}
	hri_adc_write_CTRLA_reg(hw, ADC_CTRLA_SWRST);
	hri_adc_wait_for_sync(hw);

	hri_adc_write_CALIB_reg(hw, calib_reg);
	hri_adc_write_REFCTRL_reg(hw, _adcs[i].ref_ctrl);
    293e:	00ea      	lsls	r2, r5, #3
    2940:	1b52      	subs	r2, r2, r5
    2942:	0091      	lsls	r1, r2, #2
    2944:	4b28      	ldr	r3, [pc, #160]	; (29e8 <_adc_init+0x104>)
    2946:	185b      	adds	r3, r3, r1
    2948:	789a      	ldrb	r2, [r3, #2]
	((Adc *)hw)->REFCTRL.reg = data;
    294a:	7062      	strb	r2, [r4, #1]
	hri_adc_write_AVGCTRL_reg(hw, _adcs[i].avg_ctrl);
    294c:	78da      	ldrb	r2, [r3, #3]
	((Adc *)hw)->AVGCTRL.reg = data;
    294e:	70a2      	strb	r2, [r4, #2]
	hri_adc_write_SAMPCTRL_reg(hw, _adcs[i].samp_ctrl);
    2950:	791a      	ldrb	r2, [r3, #4]
	((Adc *)hw)->SAMPCTRL.reg = data;
    2952:	70e2      	strb	r2, [r4, #3]
	hri_adc_write_EVCTRL_reg(hw, _adcs[i].ev_ctrl);
    2954:	7c1a      	ldrb	r2, [r3, #16]
	((Adc *)hw)->EVCTRL.reg = data;
    2956:	7522      	strb	r2, [r4, #20]
	hri_adc_write_GAINCORR_reg(hw, _adcs[i].gain_corr);
    2958:	8ada      	ldrh	r2, [r3, #22]
	((Adc *)hw)->GAINCORR.reg = data;
    295a:	84a2      	strh	r2, [r4, #36]	; 0x24
	hri_adc_write_OFFSETCORR_reg(hw, _adcs[i].offset_corr);
    295c:	8b1a      	ldrh	r2, [r3, #24]
	((Adc *)hw)->OFFSETCORR.reg = data;
    295e:	84e2      	strh	r2, [r4, #38]	; 0x26
	hri_adc_write_DBGCTRL_reg(hw, _adcs[i].dbg_ctrl);
    2960:	7e99      	ldrb	r1, [r3, #26]
}

static inline void hri_adc_write_DBGCTRL_reg(const void *const hw, hri_adc_dbgctrl_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->DBGCTRL.reg = data;
    2962:	222a      	movs	r2, #42	; 0x2a
    2964:	54a1      	strb	r1, [r4, r2]
	hri_adc_write_CTRLB_reg(hw, _adcs[i].ctrl_b);
    2966:	88db      	ldrh	r3, [r3, #6]
	((Adc *)hw)->CTRLB.reg = data;
    2968:	80a3      	strh	r3, [r4, #4]
	while (((const Adc *)hw)->STATUS.bit.SYNCBUSY)
    296a:	7e63      	ldrb	r3, [r4, #25]
    296c:	09db      	lsrs	r3, r3, #7
    296e:	d1fc      	bne.n	296a <_adc_init+0x86>
	hri_adc_write_INPUTCTRL_reg(hw, _adcs[i].input_ctrl);
    2970:	00eb      	lsls	r3, r5, #3
    2972:	1b5b      	subs	r3, r3, r5
    2974:	009a      	lsls	r2, r3, #2
    2976:	4b1c      	ldr	r3, [pc, #112]	; (29e8 <_adc_init+0x104>)
    2978:	189b      	adds	r3, r3, r2
    297a:	68db      	ldr	r3, [r3, #12]
	((Adc *)hw)->INPUTCTRL.reg = data;
    297c:	6123      	str	r3, [r4, #16]
	while (((const Adc *)hw)->STATUS.bit.SYNCBUSY)
    297e:	7e63      	ldrb	r3, [r4, #25]
    2980:	09db      	lsrs	r3, r3, #7
    2982:	d1fc      	bne.n	297e <_adc_init+0x9a>
	hri_adc_write_WINCTRL_reg(hw, _adcs[i].win_ctrl);
    2984:	00eb      	lsls	r3, r5, #3
    2986:	1b5b      	subs	r3, r3, r5
    2988:	009a      	lsls	r2, r3, #2
    298a:	4b17      	ldr	r3, [pc, #92]	; (29e8 <_adc_init+0x104>)
    298c:	189b      	adds	r3, r3, r2
    298e:	7a1b      	ldrb	r3, [r3, #8]
	((Adc *)hw)->WINCTRL.reg = data;
    2990:	7223      	strb	r3, [r4, #8]
	while (((const Adc *)hw)->STATUS.bit.SYNCBUSY)
    2992:	7e63      	ldrb	r3, [r4, #25]
    2994:	09db      	lsrs	r3, r3, #7
    2996:	d1fc      	bne.n	2992 <_adc_init+0xae>
	hri_adc_write_WINLT_reg(hw, _adcs[i].win_lt);
    2998:	00eb      	lsls	r3, r5, #3
    299a:	1b5b      	subs	r3, r3, r5
    299c:	009a      	lsls	r2, r3, #2
    299e:	4b12      	ldr	r3, [pc, #72]	; (29e8 <_adc_init+0x104>)
    29a0:	189b      	adds	r3, r3, r2
    29a2:	8a5b      	ldrh	r3, [r3, #18]
	((Adc *)hw)->WINLT.reg = data;
    29a4:	83a3      	strh	r3, [r4, #28]
	while (((const Adc *)hw)->STATUS.bit.SYNCBUSY)
    29a6:	7e63      	ldrb	r3, [r4, #25]
    29a8:	09db      	lsrs	r3, r3, #7
    29aa:	d1fc      	bne.n	29a6 <_adc_init+0xc2>
	hri_adc_write_WINUT_reg(hw, _adcs[i].win_ut);
    29ac:	00eb      	lsls	r3, r5, #3
    29ae:	1b5b      	subs	r3, r3, r5
    29b0:	009a      	lsls	r2, r3, #2
    29b2:	4b0d      	ldr	r3, [pc, #52]	; (29e8 <_adc_init+0x104>)
    29b4:	189b      	adds	r3, r3, r2
    29b6:	8a9b      	ldrh	r3, [r3, #20]
	((Adc *)hw)->WINUT.reg = data;
    29b8:	8423      	strh	r3, [r4, #32]
	while (((const Adc *)hw)->STATUS.bit.SYNCBUSY)
    29ba:	7e63      	ldrb	r3, [r4, #25]
    29bc:	09db      	lsrs	r3, r3, #7
    29be:	d1fc      	bne.n	29ba <_adc_init+0xd6>
	hri_adc_write_CTRLA_reg(hw, _adcs[i].ctrl_a);
    29c0:	00eb      	lsls	r3, r5, #3
    29c2:	1b5d      	subs	r5, r3, r5
    29c4:	00aa      	lsls	r2, r5, #2
    29c6:	4b08      	ldr	r3, [pc, #32]	; (29e8 <_adc_init+0x104>)
    29c8:	189b      	adds	r3, r3, r2
    29ca:	785b      	ldrb	r3, [r3, #1]
	((Adc *)hw)->CTRLA.reg = data;
    29cc:	7023      	strb	r3, [r4, #0]

	return ERR_NONE;
}
    29ce:	2000      	movs	r0, #0
    29d0:	bd70      	pop	{r4, r5, r6, pc}
    29d2:	46c0      	nop			; (mov r8, r8)
    29d4:	bdffc000 	.word	0xbdffc000
    29d8:	0000ab50 	.word	0x0000ab50
    29dc:	000026c1 	.word	0x000026c1
    29e0:	00806024 	.word	0x00806024
    29e4:	00806020 	.word	0x00806020
    29e8:	0000ab34 	.word	0x0000ab34

000029ec <_adc_async_init>:

/**
 * \brief Initialize ADC
 */
int32_t _adc_async_init(struct _adc_async_device *const device, void *const hw)
{
    29ec:	b570      	push	{r4, r5, r6, lr}
    29ee:	0005      	movs	r5, r0
    29f0:	000c      	movs	r4, r1
	int32_t init_status;

	ASSERT(device);
    29f2:	1e43      	subs	r3, r0, #1
    29f4:	4198      	sbcs	r0, r3
    29f6:	b2c0      	uxtb	r0, r0
    29f8:	22d3      	movs	r2, #211	; 0xd3
    29fa:	490e      	ldr	r1, [pc, #56]	; (2a34 <_adc_async_init+0x48>)
    29fc:	4b0e      	ldr	r3, [pc, #56]	; (2a38 <_adc_async_init+0x4c>)
    29fe:	4798      	blx	r3

	init_status = _adc_init(hw, _adc_get_regs((uint32_t)hw));
    2a00:	0020      	movs	r0, r4
    2a02:	4b0e      	ldr	r3, [pc, #56]	; (2a3c <_adc_async_init+0x50>)
    2a04:	4798      	blx	r3
    2a06:	0001      	movs	r1, r0
    2a08:	0020      	movs	r0, r4
    2a0a:	4b0d      	ldr	r3, [pc, #52]	; (2a40 <_adc_async_init+0x54>)
    2a0c:	4798      	blx	r3
	if (init_status) {
    2a0e:	2800      	cmp	r0, #0
    2a10:	d10f      	bne.n	2a32 <_adc_async_init+0x46>
		return init_status;
	}
	device->hw = hw;
    2a12:	616c      	str	r4, [r5, #20]
	_adc_dev   = device;
    2a14:	4b0b      	ldr	r3, [pc, #44]	; (2a44 <_adc_async_init+0x58>)
    2a16:	601d      	str	r5, [r3, #0]
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2a18:	4b0b      	ldr	r3, [pc, #44]	; (2a48 <_adc_async_init+0x5c>)
    2a1a:	2280      	movs	r2, #128	; 0x80
    2a1c:	0412      	lsls	r2, r2, #16
    2a1e:	2180      	movs	r1, #128	; 0x80
    2a20:	505a      	str	r2, [r3, r1]
  __ASM volatile ("dsb 0xF":::"memory");
    2a22:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2a26:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2a2a:	3101      	adds	r1, #1
    2a2c:	31ff      	adds	r1, #255	; 0xff
    2a2e:	505a      	str	r2, [r3, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2a30:	601a      	str	r2, [r3, #0]
	NVIC_DisableIRQ(ADC_IRQn);
	NVIC_ClearPendingIRQ(ADC_IRQn);
	NVIC_EnableIRQ(ADC_IRQn);

	return ERR_NONE;
}
    2a32:	bd70      	pop	{r4, r5, r6, pc}
    2a34:	0000ab50 	.word	0x0000ab50
    2a38:	000026c1 	.word	0x000026c1
    2a3c:	000028a5 	.word	0x000028a5
    2a40:	000028e5 	.word	0x000028e5
    2a44:	200003b0 	.word	0x200003b0
    2a48:	e000e100 	.word	0xe000e100

00002a4c <_adc_async_enable_channel>:
 */
void _adc_async_enable_channel(struct _adc_async_device *const device, const uint8_t channel)
{
	(void)channel;

	hri_adc_set_CTRLA_ENABLE_bit(device->hw);
    2a4c:	6942      	ldr	r2, [r0, #20]
	((Adc *)hw)->CTRLA.reg |= ADC_CTRLA_ENABLE;
    2a4e:	7813      	ldrb	r3, [r2, #0]
    2a50:	2102      	movs	r1, #2
    2a52:	430b      	orrs	r3, r1
    2a54:	b2db      	uxtb	r3, r3
    2a56:	7013      	strb	r3, [r2, #0]
}
    2a58:	4770      	bx	lr

00002a5a <_adc_async_get_data_size>:
/**
 * \brief Retrieve ADC conversion data size
 */
uint8_t _adc_async_get_data_size(const struct _adc_async_device *const device)
{
	return hri_adc_read_CTRLB_RESSEL_bf(device->hw) == ADC_CTRLB_RESSEL_8BIT_Val ? 1 : 2;
    2a5a:	6942      	ldr	r2, [r0, #20]
	while (((const Adc *)hw)->STATUS.bit.SYNCBUSY)
    2a5c:	7e53      	ldrb	r3, [r2, #25]
    2a5e:	09db      	lsrs	r3, r3, #7
    2a60:	d1fc      	bne.n	2a5c <_adc_async_get_data_size+0x2>
	tmp = ((Adc *)hw)->CTRLB.reg;
    2a62:	8892      	ldrh	r2, [r2, #4]
	tmp = (tmp & ADC_CTRLB_RESSEL_Msk) >> ADC_CTRLB_RESSEL_Pos;
    2a64:	0912      	lsrs	r2, r2, #4
    2a66:	3303      	adds	r3, #3
    2a68:	4013      	ands	r3, r2
    2a6a:	2b03      	cmp	r3, #3
    2a6c:	d001      	beq.n	2a72 <_adc_async_get_data_size+0x18>
    2a6e:	2002      	movs	r0, #2
}
    2a70:	4770      	bx	lr
	return hri_adc_read_CTRLB_RESSEL_bf(device->hw) == ADC_CTRLB_RESSEL_8BIT_Val ? 1 : 2;
    2a72:	2001      	movs	r0, #1
    2a74:	e7fc      	b.n	2a70 <_adc_async_get_data_size+0x16>

00002a76 <_adc_async_convert>:
/**
 * \brief Make conversion
 */
void _adc_async_convert(struct _adc_async_device *const device)
{
	hri_adc_set_SWTRIG_START_bit(device->hw);
    2a76:	6942      	ldr	r2, [r0, #20]
	((Adc *)hw)->SWTRIG.reg |= ADC_SWTRIG_START;
    2a78:	7b13      	ldrb	r3, [r2, #12]
    2a7a:	2102      	movs	r1, #2
    2a7c:	430b      	orrs	r3, r1
    2a7e:	b2db      	uxtb	r3, r3
    2a80:	7313      	strb	r3, [r2, #12]
	while (((const Adc *)hw)->STATUS.bit.SYNCBUSY)
    2a82:	7e53      	ldrb	r3, [r2, #25]
    2a84:	09db      	lsrs	r3, r3, #7
    2a86:	d1fc      	bne.n	2a82 <_adc_async_convert+0xc>
}
    2a88:	4770      	bx	lr

00002a8a <_adc_async_set_irq_state>:
void _adc_async_set_irq_state(struct _adc_async_device *const device, const uint8_t channel,
                              const enum _adc_async_callback_type type, const bool state)
{
	(void)channel;

	void *const hw = device->hw;
    2a8a:	6941      	ldr	r1, [r0, #20]

	if (ADC_ASYNC_DEVICE_MONITOR_CB == type) {
    2a8c:	2a01      	cmp	r2, #1
    2a8e:	d008      	beq.n	2aa2 <_adc_async_set_irq_state+0x18>
		hri_adc_write_INTEN_WINMON_bit(hw, state);
	} else if (ADC_ASYNC_DEVICE_ERROR_CB == type) {
    2a90:	2a02      	cmp	r2, #2
    2a92:	d00e      	beq.n	2ab2 <_adc_async_set_irq_state+0x28>
		hri_adc_write_INTEN_OVERRUN_bit(hw, state);
	} else if (ADC_ASYNC_DEVICE_CONVERT_CB == type) {
    2a94:	2a00      	cmp	r2, #0
    2a96:	d103      	bne.n	2aa0 <_adc_async_set_irq_state+0x16>
	if (value == 0x0) {
    2a98:	2b00      	cmp	r3, #0
    2a9a:	d012      	beq.n	2ac2 <_adc_async_set_irq_state+0x38>
		((Adc *)hw)->INTENSET.reg = ADC_INTENSET_RESRDY;
    2a9c:	2301      	movs	r3, #1
    2a9e:	75cb      	strb	r3, [r1, #23]
		hri_adc_write_INTEN_RESRDY_bit(hw, state);
	}
}
    2aa0:	4770      	bx	lr
	if (value == 0x0) {
    2aa2:	2b00      	cmp	r3, #0
    2aa4:	d102      	bne.n	2aac <_adc_async_set_irq_state+0x22>
		((Adc *)hw)->INTENCLR.reg = ADC_INTENSET_WINMON;
    2aa6:	3304      	adds	r3, #4
    2aa8:	758b      	strb	r3, [r1, #22]
    2aaa:	e7f9      	b.n	2aa0 <_adc_async_set_irq_state+0x16>
		((Adc *)hw)->INTENSET.reg = ADC_INTENSET_WINMON;
    2aac:	2304      	movs	r3, #4
    2aae:	75cb      	strb	r3, [r1, #23]
    2ab0:	e7f6      	b.n	2aa0 <_adc_async_set_irq_state+0x16>
	if (value == 0x0) {
    2ab2:	2b00      	cmp	r3, #0
    2ab4:	d102      	bne.n	2abc <_adc_async_set_irq_state+0x32>
		((Adc *)hw)->INTENCLR.reg = ADC_INTENSET_OVERRUN;
    2ab6:	3302      	adds	r3, #2
    2ab8:	758b      	strb	r3, [r1, #22]
    2aba:	e7f1      	b.n	2aa0 <_adc_async_set_irq_state+0x16>
		((Adc *)hw)->INTENSET.reg = ADC_INTENSET_OVERRUN;
    2abc:	2302      	movs	r3, #2
    2abe:	75cb      	strb	r3, [r1, #23]
    2ac0:	e7ee      	b.n	2aa0 <_adc_async_set_irq_state+0x16>
		((Adc *)hw)->INTENCLR.reg = ADC_INTENSET_RESRDY;
    2ac2:	3301      	adds	r3, #1
    2ac4:	758b      	strb	r3, [r1, #22]
    2ac6:	e7eb      	b.n	2aa0 <_adc_async_set_irq_state+0x16>

00002ac8 <ADC_Handler>:

/**
 * \internal ADC interrupt handler
 */
void ADC_Handler(void)
{
    2ac8:	b510      	push	{r4, lr}
	void *const hw      = _adc_dev->hw;
    2aca:	4b11      	ldr	r3, [pc, #68]	; (2b10 <ADC_Handler+0x48>)
    2acc:	6818      	ldr	r0, [r3, #0]
    2ace:	6942      	ldr	r2, [r0, #20]
	return ((Adc *)hw)->INTFLAG.reg;
    2ad0:	7e11      	ldrb	r1, [r2, #24]
	return ((Adc *)hw)->INTENSET.reg;
    2ad2:	7dd3      	ldrb	r3, [r2, #23]
	uint8_t     intflag = hri_adc_read_INTFLAG_reg(hw);
	intflag &= hri_adc_read_INTEN_reg(hw);
    2ad4:	400b      	ands	r3, r1
	if (intflag & ADC_INTFLAG_RESRDY) {
    2ad6:	07d9      	lsls	r1, r3, #31
    2ad8:	d50a      	bpl.n	2af0 <ADC_Handler+0x28>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_RESRDY;
    2ada:	2301      	movs	r3, #1
    2adc:	7613      	strb	r3, [r2, #24]
		hri_adc_clear_interrupt_RESRDY_bit(hw);
		_adc_dev->adc_async_ch_cb.convert_done(_adc_dev, 0, hri_adc_read_RESULT_reg(hw));
    2ade:	6884      	ldr	r4, [r0, #8]
	while (((const Adc *)hw)->STATUS.bit.SYNCBUSY)
    2ae0:	7e53      	ldrb	r3, [r2, #25]
    2ae2:	09db      	lsrs	r3, r3, #7
    2ae4:	d1fc      	bne.n	2ae0 <ADC_Handler+0x18>
	return ((Adc *)hw)->RESULT.reg;
    2ae6:	8b52      	ldrh	r2, [r2, #26]
    2ae8:	b292      	uxth	r2, r2
    2aea:	2100      	movs	r1, #0
    2aec:	47a0      	blx	r4
		_adc_dev->adc_async_cb.error_cb(_adc_dev, 0);
	} else if (intflag & ADC_INTFLAG_WINMON) {
		hri_adc_clear_interrupt_WINMON_bit(hw);
		_adc_dev->adc_async_cb.window_cb(_adc_dev, 0);
	}
}
    2aee:	bd10      	pop	{r4, pc}
	} else if (intflag & ADC_INTFLAG_OVERRUN) {
    2af0:	0799      	lsls	r1, r3, #30
    2af2:	d407      	bmi.n	2b04 <ADC_Handler+0x3c>
	} else if (intflag & ADC_INTFLAG_WINMON) {
    2af4:	075b      	lsls	r3, r3, #29
    2af6:	d5fa      	bpl.n	2aee <ADC_Handler+0x26>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_WINMON;
    2af8:	2304      	movs	r3, #4
    2afa:	7613      	strb	r3, [r2, #24]
		_adc_dev->adc_async_cb.window_cb(_adc_dev, 0);
    2afc:	6803      	ldr	r3, [r0, #0]
    2afe:	2100      	movs	r1, #0
    2b00:	4798      	blx	r3
}
    2b02:	e7f4      	b.n	2aee <ADC_Handler+0x26>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_OVERRUN;
    2b04:	2302      	movs	r3, #2
    2b06:	7613      	strb	r3, [r2, #24]
		_adc_dev->adc_async_cb.error_cb(_adc_dev, 0);
    2b08:	6843      	ldr	r3, [r0, #4]
    2b0a:	2100      	movs	r1, #0
    2b0c:	4798      	blx	r3
    2b0e:	e7ee      	b.n	2aee <ADC_Handler+0x26>
    2b10:	200003b0 	.word	0x200003b0

00002b14 <_get_cycles_for_us>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of us
 */
uint32_t _get_cycles_for_us(const uint16_t us)
{
    2b14:	b510      	push	{r4, lr}
    2b16:	0003      	movs	r3, r0
		return (us * (freq / 10000) + 299) / 300;
    2b18:	20c8      	movs	r0, #200	; 0xc8
    2b1a:	0080      	lsls	r0, r0, #2
    2b1c:	4358      	muls	r0, r3
    2b1e:	302c      	adds	r0, #44	; 0x2c
    2b20:	30ff      	adds	r0, #255	; 0xff
    2b22:	2196      	movs	r1, #150	; 0x96
    2b24:	0049      	lsls	r1, r1, #1
    2b26:	4b01      	ldr	r3, [pc, #4]	; (2b2c <_get_cycles_for_us+0x18>)
    2b28:	4798      	blx	r3
	return _get_cycles_for_us_internal(us, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
    2b2a:	bd10      	pop	{r4, pc}
    2b2c:	0000919d 	.word	0x0000919d

00002b30 <_get_cycles_for_ms>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
    2b30:	b510      	push	{r4, lr}
    2b32:	0003      	movs	r3, r0
		return (ms * (freq / 10000) + 2) / 3 * 10;
    2b34:	20c8      	movs	r0, #200	; 0xc8
    2b36:	0080      	lsls	r0, r0, #2
    2b38:	4358      	muls	r0, r3
    2b3a:	3002      	adds	r0, #2
    2b3c:	2103      	movs	r1, #3
    2b3e:	4b03      	ldr	r3, [pc, #12]	; (2b4c <_get_cycles_for_ms+0x1c>)
    2b40:	4798      	blx	r3
    2b42:	0083      	lsls	r3, r0, #2
    2b44:	181b      	adds	r3, r3, r0
    2b46:	0058      	lsls	r0, r3, #1
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
    2b48:	bd10      	pop	{r4, pc}
    2b4a:	46c0      	nop			; (mov r8, r8)
    2b4c:	0000919d 	.word	0x0000919d

00002b50 <_delay_cycles>:
{
#ifndef _UNIT_TEST_
	(void)hw;
	(void)cycles;
#if defined __GNUC__
	__asm(".syntax unified\n"
    2b50:	3901      	subs	r1, #1
    2b52:	d8fd      	bhi.n	2b50 <_delay_cycles>
	__asm("__delay:\n"
	      "subs r1, r1, #1\n"
	      "bhi __delay\n");
#endif
#endif
}
    2b54:	4770      	bx	lr
	...

00002b58 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    2b58:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
    2b5a:	4b06      	ldr	r3, [pc, #24]	; (2b74 <_init_chip+0x1c>)
    2b5c:	685a      	ldr	r2, [r3, #4]
    2b5e:	605a      	str	r2, [r3, #4]
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_pm_init();
    2b60:	4b05      	ldr	r3, [pc, #20]	; (2b78 <_init_chip+0x20>)
    2b62:	4798      	blx	r3
	_sysctrl_init_sources();
    2b64:	4b05      	ldr	r3, [pc, #20]	; (2b7c <_init_chip+0x24>)
    2b66:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_sysctrl_init_referenced_generators();
    2b68:	4b05      	ldr	r3, [pc, #20]	; (2b80 <_init_chip+0x28>)
    2b6a:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    2b6c:	20ff      	movs	r0, #255	; 0xff
    2b6e:	4b05      	ldr	r3, [pc, #20]	; (2b84 <_init_chip+0x2c>)
    2b70:	4798      	blx	r3
#if CONF_DMAC_ENABLE
	_pm_enable_bus_clock(PM_BUS_AHB, DMAC);
	_pm_enable_bus_clock(PM_BUS_APBB, DMAC);
	_dma_init();
#endif
}
    2b72:	bd10      	pop	{r4, pc}
    2b74:	41004000 	.word	0x41004000
    2b78:	00003235 	.word	0x00003235
    2b7c:	00004025 	.word	0x00004025
    2b80:	00004069 	.word	0x00004069
    2b84:	00002e41 	.word	0x00002e41

00002b88 <_dac_init>:
typedef uint8_t  hri_dac_intflag_reg_t;
typedef uint8_t  hri_dac_status_reg_t;

static inline void hri_dac_wait_for_sync(const void *const hw)
{
	while (((const Dac *)hw)->STATUS.bit.SYNCBUSY)
    2b88:	79c3      	ldrb	r3, [r0, #7]
    2b8a:	09db      	lsrs	r3, r3, #7
    2b8c:	d1fc      	bne.n	2b88 <_dac_init>
    2b8e:	79c3      	ldrb	r3, [r0, #7]
    2b90:	09db      	lsrs	r3, r3, #7
    2b92:	d1fc      	bne.n	2b8e <_dac_init+0x6>

static inline hri_dac_ctrla_reg_t hri_dac_get_CTRLA_reg(const void *const hw, hri_dac_ctrla_reg_t mask)
{
	uint8_t tmp;
	hri_dac_wait_for_sync(hw);
	tmp = ((Dac *)hw)->CTRLA.reg;
    2b94:	7803      	ldrb	r3, [r0, #0]
 * param[in] hw The pointer to DAC hardware instance
 */
static int32_t _dac_init(void *const hw)
{
	hri_dac_wait_for_sync(hw);
	if (hri_dac_get_CTRLA_reg(hw, DAC_CTRLA_ENABLE)) {
    2b96:	079b      	lsls	r3, r3, #30
    2b98:	d507      	bpl.n	2baa <_dac_init+0x22>
}

static inline void hri_dac_write_CTRLA_reg(const void *const hw, hri_dac_ctrla_reg_t data)
{
	DAC_CRITICAL_SECTION_ENTER();
	((Dac *)hw)->CTRLA.reg = data;
    2b9a:	2300      	movs	r3, #0
    2b9c:	7003      	strb	r3, [r0, #0]
	while (((const Dac *)hw)->STATUS.bit.SYNCBUSY)
    2b9e:	79c3      	ldrb	r3, [r0, #7]
    2ba0:	09db      	lsrs	r3, r3, #7
    2ba2:	d1fc      	bne.n	2b9e <_dac_init+0x16>
    2ba4:	79c3      	ldrb	r3, [r0, #7]
    2ba6:	09db      	lsrs	r3, r3, #7
    2ba8:	d1fc      	bne.n	2ba4 <_dac_init+0x1c>
	((Dac *)hw)->CTRLA.reg = data;
    2baa:	2301      	movs	r3, #1
    2bac:	7003      	strb	r3, [r0, #0]
	while (((const Dac *)hw)->STATUS.bit.SYNCBUSY)
    2bae:	79c3      	ldrb	r3, [r0, #7]
    2bb0:	09db      	lsrs	r3, r3, #7
    2bb2:	d1fc      	bne.n	2bae <_dac_init+0x26>
    2bb4:	79c3      	ldrb	r3, [r0, #7]
    2bb6:	09db      	lsrs	r3, r3, #7
    2bb8:	d1fc      	bne.n	2bb4 <_dac_init+0x2c>
}

static inline void hri_dac_write_EVCTRL_reg(const void *const hw, hri_dac_evctrl_reg_t data)
{
	DAC_CRITICAL_SECTION_ENTER();
	((Dac *)hw)->EVCTRL.reg = data;
    2bba:	7083      	strb	r3, [r0, #2]
	((Dac *)hw)->CTRLB.reg = data;
    2bbc:	2241      	movs	r2, #65	; 0x41
    2bbe:	7042      	strb	r2, [r0, #1]
	((Dac *)hw)->CTRLA.reg = data;
    2bc0:	7003      	strb	r3, [r0, #0]
	while (((const Dac *)hw)->STATUS.bit.SYNCBUSY)
    2bc2:	79c3      	ldrb	r3, [r0, #7]
    2bc4:	09db      	lsrs	r3, r3, #7
    2bc6:	d1fc      	bne.n	2bc2 <_dac_init+0x3a>

	hri_dac_write_EVCTRL_reg(hw, _dac.ev_ctrl);
	hri_dac_write_CTRLB_reg(hw, _dac.ctrlb);
	hri_dac_write_CTRLA_reg(hw, _dac.ctrla);
	return ERR_NONE;
}
    2bc8:	2000      	movs	r0, #0
    2bca:	4770      	bx	lr

00002bcc <DAC_Handler>:
{
    2bcc:	b510      	push	{r4, lr}
	void *const hw = _dac_dev->hw;
    2bce:	4b0f      	ldr	r3, [pc, #60]	; (2c0c <DAC_Handler+0x40>)
    2bd0:	6818      	ldr	r0, [r3, #0]
    2bd2:	6903      	ldr	r3, [r0, #16]
	return (((Dac *)hw)->INTFLAG.reg & DAC_INTFLAG_UNDERRUN) >> DAC_INTFLAG_UNDERRUN_Pos;
    2bd4:	799a      	ldrb	r2, [r3, #6]
	if (hri_dac_get_interrupt_UNDERRUN_bit(hw)) {
    2bd6:	07d2      	lsls	r2, r2, #31
    2bd8:	d507      	bpl.n	2bea <DAC_Handler+0x1e>
	((Dac *)hw)->INTFLAG.reg = DAC_INTFLAG_UNDERRUN;
    2bda:	2201      	movs	r2, #1
    2bdc:	719a      	strb	r2, [r3, #6]
		if (NULL != _dac_dev->dac_cb.tx_error_cb) {
    2bde:	6843      	ldr	r3, [r0, #4]
    2be0:	2b00      	cmp	r3, #0
    2be2:	d001      	beq.n	2be8 <DAC_Handler+0x1c>
			_dac_dev->dac_cb.tx_error_cb(_dac_dev, 0);
    2be4:	2100      	movs	r1, #0
    2be6:	4798      	blx	r3
}
    2be8:	bd10      	pop	{r4, pc}
	return (((Dac *)hw)->INTFLAG.reg & DAC_INTFLAG_EMPTY) >> DAC_INTFLAG_EMPTY_Pos;
    2bea:	799a      	ldrb	r2, [r3, #6]
	} else if (hri_dac_get_interrupt_EMPTY_bit(hw)) {
    2bec:	0792      	lsls	r2, r2, #30
    2bee:	d507      	bpl.n	2c00 <DAC_Handler+0x34>
	((Dac *)hw)->INTFLAG.reg = DAC_INTFLAG_EMPTY;
    2bf0:	2202      	movs	r2, #2
    2bf2:	719a      	strb	r2, [r3, #6]
		if (NULL != _dac_dev->dac_cb.tx_ready_cb) {
    2bf4:	6803      	ldr	r3, [r0, #0]
    2bf6:	2b00      	cmp	r3, #0
    2bf8:	d0f6      	beq.n	2be8 <DAC_Handler+0x1c>
			_dac_dev->dac_cb.tx_ready_cb(_dac_dev, 0);
    2bfa:	2100      	movs	r1, #0
    2bfc:	4798      	blx	r3
    2bfe:	e7f3      	b.n	2be8 <DAC_Handler+0x1c>
	return (((Dac *)hw)->INTFLAG.reg & DAC_INTFLAG_SYNCRDY) >> DAC_INTFLAG_SYNCRDY_Pos;
    2c00:	799a      	ldrb	r2, [r3, #6]
	} else if (hri_dac_get_interrupt_SYNCRDY_bit(hw)) {
    2c02:	0752      	lsls	r2, r2, #29
    2c04:	d5f0      	bpl.n	2be8 <DAC_Handler+0x1c>
	((Dac *)hw)->INTFLAG.reg = DAC_INTFLAG_SYNCRDY;
    2c06:	2204      	movs	r2, #4
    2c08:	719a      	strb	r2, [r3, #6]
}
    2c0a:	e7ed      	b.n	2be8 <DAC_Handler+0x1c>
    2c0c:	200003b4 	.word	0x200003b4

00002c10 <_dac_async_init>:

/**
 * \brief Initialize DAC
 */
int32_t _dac_async_init(struct _dac_async_device *const device, void *const hw)
{
    2c10:	b570      	push	{r4, r5, r6, lr}
    2c12:	0004      	movs	r4, r0
    2c14:	000d      	movs	r5, r1
	int32_t init_status;

	ASSERT(device);
    2c16:	1e43      	subs	r3, r0, #1
    2c18:	4198      	sbcs	r0, r3
    2c1a:	b2c0      	uxtb	r0, r0
    2c1c:	228e      	movs	r2, #142	; 0x8e
    2c1e:	490c      	ldr	r1, [pc, #48]	; (2c50 <_dac_async_init+0x40>)
    2c20:	4b0c      	ldr	r3, [pc, #48]	; (2c54 <_dac_async_init+0x44>)
    2c22:	4798      	blx	r3

	init_status = _dac_init(hw);
    2c24:	0028      	movs	r0, r5
    2c26:	4b0c      	ldr	r3, [pc, #48]	; (2c58 <_dac_async_init+0x48>)
    2c28:	4798      	blx	r3
	if (init_status) {
    2c2a:	2800      	cmp	r0, #0
    2c2c:	d10f      	bne.n	2c4e <_dac_async_init+0x3e>
		return init_status;
	}
	device->hw = hw;
    2c2e:	6125      	str	r5, [r4, #16]

	_dac_dev = device;
    2c30:	4b0a      	ldr	r3, [pc, #40]	; (2c5c <_dac_async_init+0x4c>)
    2c32:	601c      	str	r4, [r3, #0]
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2c34:	4b0a      	ldr	r3, [pc, #40]	; (2c60 <_dac_async_init+0x50>)
    2c36:	2280      	movs	r2, #128	; 0x80
    2c38:	0492      	lsls	r2, r2, #18
    2c3a:	2180      	movs	r1, #128	; 0x80
    2c3c:	505a      	str	r2, [r3, r1]
  __ASM volatile ("dsb 0xF":::"memory");
    2c3e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2c42:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2c46:	3101      	adds	r1, #1
    2c48:	31ff      	adds	r1, #255	; 0xff
    2c4a:	505a      	str	r2, [r3, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2c4c:	601a      	str	r2, [r3, #0]
	NVIC_DisableIRQ(DAC_IRQn);
	NVIC_ClearPendingIRQ(DAC_IRQn);
	NVIC_EnableIRQ(DAC_IRQn);

	return ERR_NONE;
}
    2c4e:	bd70      	pop	{r4, r5, r6, pc}
    2c50:	0000ab68 	.word	0x0000ab68
    2c54:	000026c1 	.word	0x000026c1
    2c58:	00002b89 	.word	0x00002b89
    2c5c:	200003b4 	.word	0x200003b4
    2c60:	e000e100 	.word	0xe000e100

00002c64 <_dac_async_enable_channel>:
 * \brief Enable DAC Channel
 */
void _dac_async_enable_channel(struct _dac_async_device *const device, const uint8_t ch)
{
	(void)ch;
	hri_dac_set_CTRLA_ENABLE_bit(device->hw);
    2c64:	6902      	ldr	r2, [r0, #16]
	((Dac *)hw)->CTRLA.reg |= DAC_CTRLA_ENABLE;
    2c66:	7813      	ldrb	r3, [r2, #0]
    2c68:	2102      	movs	r1, #2
    2c6a:	430b      	orrs	r3, r1
    2c6c:	b2db      	uxtb	r3, r3
    2c6e:	7013      	strb	r3, [r2, #0]
	while (((const Dac *)hw)->STATUS.bit.SYNCBUSY)
    2c70:	79d3      	ldrb	r3, [r2, #7]
    2c72:	09db      	lsrs	r3, r3, #7
    2c74:	d1fc      	bne.n	2c70 <_dac_async_enable_channel+0xc>
}
    2c76:	4770      	bx	lr

00002c78 <_dac_async_is_channel_enable>:
}

bool _dac_async_is_channel_enable(struct _dac_async_device *const device, const uint8_t ch)
{
	(void)ch;
	return hri_dac_get_CTRLA_ENABLE_bit(device->hw);
    2c78:	6902      	ldr	r2, [r0, #16]
    2c7a:	79d3      	ldrb	r3, [r2, #7]
    2c7c:	09db      	lsrs	r3, r3, #7
    2c7e:	d1fc      	bne.n	2c7a <_dac_async_is_channel_enable+0x2>
	tmp = ((Dac *)hw)->CTRLA.reg;
    2c80:	7813      	ldrb	r3, [r2, #0]
	tmp = (tmp & DAC_CTRLA_ENABLE) >> DAC_CTRLA_ENABLE_Pos;
    2c82:	085b      	lsrs	r3, r3, #1
	return (bool)tmp;
    2c84:	2001      	movs	r0, #1
    2c86:	4018      	ands	r0, r3
}
    2c88:	4770      	bx	lr

00002c8a <_dac_async_write_data>:
 * \brief write DAC data for output
 */
void _dac_async_write_data(struct _dac_async_device *const device, const uint16_t data, const uint8_t ch)
{
	(void)ch;
	hri_dac_write_DATABUF_reg(device->hw, data);
    2c8a:	6902      	ldr	r2, [r0, #16]
}

static inline void hri_dac_write_DATABUF_reg(const void *const hw, hri_dac_databuf_reg_t data)
{
	DAC_CRITICAL_SECTION_ENTER();
	((Dac *)hw)->DATABUF.reg = data;
    2c8c:	8191      	strh	r1, [r2, #12]
	while (((const Dac *)hw)->STATUS.bit.SYNCBUSY)
    2c8e:	79d3      	ldrb	r3, [r2, #7]
    2c90:	09db      	lsrs	r3, r3, #7
    2c92:	d1fc      	bne.n	2c8e <_dac_async_write_data+0x4>
}
    2c94:	4770      	bx	lr
	...

00002c98 <_ext_irq_init>:
typedef uint8_t  hri_eic_nmiflag_reg_t;
typedef uint8_t  hri_eic_status_reg_t;

static inline void hri_eic_wait_for_sync(const void *const hw)
{
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
    2c98:	4b21      	ldr	r3, [pc, #132]	; (2d20 <_ext_irq_init+0x88>)
    2c9a:	785b      	ldrb	r3, [r3, #1]
    2c9c:	09db      	lsrs	r3, r3, #7
    2c9e:	d1fb      	bne.n	2c98 <_ext_irq_init>
    2ca0:	4b1f      	ldr	r3, [pc, #124]	; (2d20 <_ext_irq_init+0x88>)
    2ca2:	785b      	ldrb	r3, [r3, #1]
    2ca4:	09db      	lsrs	r3, r3, #7
    2ca6:	d1fb      	bne.n	2ca0 <_ext_irq_init+0x8>

static inline hri_eic_ctrl_reg_t hri_eic_get_CTRL_reg(const void *const hw, hri_eic_ctrl_reg_t mask)
{
	uint8_t tmp;
	hri_eic_wait_for_sync(hw);
	tmp = ((Eic *)hw)->CTRL.reg;
    2ca8:	4b1d      	ldr	r3, [pc, #116]	; (2d20 <_ext_irq_init+0x88>)
    2caa:	781b      	ldrb	r3, [r3, #0]
 * \brief Initialize external interrupt module
 */
int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
	hri_eic_wait_for_sync(EIC);
	if (hri_eic_get_CTRL_reg(EIC, EIC_CTRL_ENABLE)) {
    2cac:	079b      	lsls	r3, r3, #30
    2cae:	d50a      	bpl.n	2cc6 <_ext_irq_init+0x2e>
}

static inline void hri_eic_write_CTRL_reg(const void *const hw, hri_eic_ctrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CTRL.reg = data;
    2cb0:	2200      	movs	r2, #0
    2cb2:	4b1b      	ldr	r3, [pc, #108]	; (2d20 <_ext_irq_init+0x88>)
    2cb4:	701a      	strb	r2, [r3, #0]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
    2cb6:	4b1a      	ldr	r3, [pc, #104]	; (2d20 <_ext_irq_init+0x88>)
    2cb8:	785b      	ldrb	r3, [r3, #1]
    2cba:	09db      	lsrs	r3, r3, #7
    2cbc:	d1fb      	bne.n	2cb6 <_ext_irq_init+0x1e>
    2cbe:	4b18      	ldr	r3, [pc, #96]	; (2d20 <_ext_irq_init+0x88>)
    2cc0:	785b      	ldrb	r3, [r3, #1]
    2cc2:	09db      	lsrs	r3, r3, #7
    2cc4:	d1fb      	bne.n	2cbe <_ext_irq_init+0x26>
	((Eic *)hw)->CTRL.reg = data;
    2cc6:	2201      	movs	r2, #1
    2cc8:	4b15      	ldr	r3, [pc, #84]	; (2d20 <_ext_irq_init+0x88>)
    2cca:	701a      	strb	r2, [r3, #0]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
    2ccc:	4b14      	ldr	r3, [pc, #80]	; (2d20 <_ext_irq_init+0x88>)
    2cce:	785b      	ldrb	r3, [r3, #1]
    2cd0:	09db      	lsrs	r3, r3, #7
    2cd2:	d1fb      	bne.n	2ccc <_ext_irq_init+0x34>
    2cd4:	4b12      	ldr	r3, [pc, #72]	; (2d20 <_ext_irq_init+0x88>)
    2cd6:	785b      	ldrb	r3, [r3, #1]
    2cd8:	09db      	lsrs	r3, r3, #7
    2cda:	d1fb      	bne.n	2cd4 <_ext_irq_init+0x3c>
}

static inline void hri_eic_write_NMICTRL_reg(const void *const hw, hri_eic_nmictrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->NMICTRL.reg = data;
    2cdc:	4b10      	ldr	r3, [pc, #64]	; (2d20 <_ext_irq_init+0x88>)
    2cde:	2200      	movs	r2, #0
    2ce0:	709a      	strb	r2, [r3, #2]
}

static inline void hri_eic_write_EVCTRL_reg(const void *const hw, hri_eic_evctrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->EVCTRL.reg = data;
    2ce2:	605a      	str	r2, [r3, #4]
}

static inline void hri_eic_write_WAKEUP_reg(const void *const hw, hri_eic_wakeup_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->WAKEUP.reg = data;
    2ce4:	615a      	str	r2, [r3, #20]
}

static inline void hri_eic_write_CONFIG_reg(const void *const hw, uint8_t index, hri_eic_config_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CONFIG[index].reg = data;
    2ce6:	4a0f      	ldr	r2, [pc, #60]	; (2d24 <_ext_irq_init+0x8c>)
    2ce8:	619a      	str	r2, [r3, #24]
    2cea:	61da      	str	r2, [r3, #28]
	((Eic *)hw)->CTRL.reg |= EIC_CTRL_ENABLE;
    2cec:	781a      	ldrb	r2, [r3, #0]
    2cee:	2102      	movs	r1, #2
    2cf0:	430a      	orrs	r2, r1
    2cf2:	b2d2      	uxtb	r2, r2
    2cf4:	701a      	strb	r2, [r3, #0]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
    2cf6:	4b0a      	ldr	r3, [pc, #40]	; (2d20 <_ext_irq_init+0x88>)
    2cf8:	785b      	ldrb	r3, [r3, #1]
    2cfa:	09db      	lsrs	r3, r3, #7
    2cfc:	d1fb      	bne.n	2cf6 <_ext_irq_init+0x5e>
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2cfe:	4b0a      	ldr	r3, [pc, #40]	; (2d28 <_ext_irq_init+0x90>)
    2d00:	2210      	movs	r2, #16
    2d02:	2180      	movs	r1, #128	; 0x80
    2d04:	505a      	str	r2, [r3, r1]
  __ASM volatile ("dsb 0xF":::"memory");
    2d06:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2d0a:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2d0e:	3101      	adds	r1, #1
    2d10:	31ff      	adds	r1, #255	; 0xff
    2d12:	505a      	str	r2, [r3, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2d14:	601a      	str	r2, [r3, #0]

	NVIC_DisableIRQ(EIC_IRQn);
	NVIC_ClearPendingIRQ(EIC_IRQn);
	NVIC_EnableIRQ(EIC_IRQn);

	callback = cb;
    2d16:	4b05      	ldr	r3, [pc, #20]	; (2d2c <_ext_irq_init+0x94>)
    2d18:	6018      	str	r0, [r3, #0]

	return ERR_NONE;
}
    2d1a:	2000      	movs	r0, #0
    2d1c:	4770      	bx	lr
    2d1e:	46c0      	nop			; (mov r8, r8)
    2d20:	40001800 	.word	0x40001800
    2d24:	22222222 	.word	0x22222222
    2d28:	e000e100 	.word	0xe000e100
    2d2c:	200003b8 	.word	0x200003b8

00002d30 <_ext_irq_enable>:

/**
 * \brief Enable / disable external irq
 */
int32_t _ext_irq_enable(const uint32_t pin, const bool enable)
{
    2d30:	b530      	push	{r4, r5, lr}
	uint8_t extint = INVALID_EXTINT_NUMBER;
	uint8_t i      = 0;
    2d32:	2300      	movs	r3, #0

	for (; i < ARRAY_SIZE(_map); i++) {
    2d34:	2b0f      	cmp	r3, #15
    2d36:	d80b      	bhi.n	2d50 <_ext_irq_enable+0x20>
		if (_map[i].pin == pin) {
    2d38:	00dc      	lsls	r4, r3, #3
    2d3a:	4a10      	ldr	r2, [pc, #64]	; (2d7c <_ext_irq_enable+0x4c>)
    2d3c:	1912      	adds	r2, r2, r4
    2d3e:	6852      	ldr	r2, [r2, #4]
    2d40:	4282      	cmp	r2, r0
    2d42:	d002      	beq.n	2d4a <_ext_irq_enable+0x1a>
	for (; i < ARRAY_SIZE(_map); i++) {
    2d44:	3301      	adds	r3, #1
    2d46:	b2db      	uxtb	r3, r3
    2d48:	e7f4      	b.n	2d34 <_ext_irq_enable+0x4>
			extint = _map[i].extint;
    2d4a:	4b0c      	ldr	r3, [pc, #48]	; (2d7c <_ext_irq_enable+0x4c>)
    2d4c:	5ce2      	ldrb	r2, [r4, r3]
			break;
    2d4e:	e000      	b.n	2d52 <_ext_irq_enable+0x22>
	uint8_t extint = INVALID_EXTINT_NUMBER;
    2d50:	22ff      	movs	r2, #255	; 0xff
		}
	}
	if (INVALID_EXTINT_NUMBER == extint) {
    2d52:	2aff      	cmp	r2, #255	; 0xff
    2d54:	d00e      	beq.n	2d74 <_ext_irq_enable+0x44>
		return ERR_INVALID_ARG;
	}

	if (enable) {
    2d56:	2900      	cmp	r1, #0
    2d58:	d106      	bne.n	2d68 <_ext_irq_enable+0x38>
		hri_eic_set_INTEN_reg(EIC, 1ul << extint);
	} else {
		hri_eic_clear_INTEN_reg(EIC, 1ul << extint);
    2d5a:	2301      	movs	r3, #1
    2d5c:	4093      	lsls	r3, r2
	((Eic *)hw)->INTENCLR.reg = mask;
    2d5e:	4a08      	ldr	r2, [pc, #32]	; (2d80 <_ext_irq_enable+0x50>)
    2d60:	6093      	str	r3, [r2, #8]
	((Eic *)hw)->INTFLAG.reg = mask;
    2d62:	6113      	str	r3, [r2, #16]
		hri_eic_clear_INTFLAG_reg(EIC, 1ul << extint);
	}

	return ERR_NONE;
    2d64:	2000      	movs	r0, #0
}
    2d66:	bd30      	pop	{r4, r5, pc}
		hri_eic_set_INTEN_reg(EIC, 1ul << extint);
    2d68:	2301      	movs	r3, #1
    2d6a:	4093      	lsls	r3, r2
	((Eic *)hw)->INTENSET.reg = mask;
    2d6c:	4a04      	ldr	r2, [pc, #16]	; (2d80 <_ext_irq_enable+0x50>)
    2d6e:	60d3      	str	r3, [r2, #12]
	return ERR_NONE;
    2d70:	2000      	movs	r0, #0
    2d72:	e7f8      	b.n	2d66 <_ext_irq_enable+0x36>
		return ERR_INVALID_ARG;
    2d74:	200d      	movs	r0, #13
    2d76:	4240      	negs	r0, r0
    2d78:	e7f5      	b.n	2d66 <_ext_irq_enable+0x36>
    2d7a:	46c0      	nop			; (mov r8, r8)
    2d7c:	0000ab80 	.word	0x0000ab80
    2d80:	40001800 	.word	0x40001800

00002d84 <EIC_Handler>:

/**
 * \brief EIC interrupt handler
 */
void EIC_Handler(void)
{
    2d84:	b5f0      	push	{r4, r5, r6, r7, lr}
    2d86:	b083      	sub	sp, #12
	return ((Eic *)hw)->INTFLAG.reg;
    2d88:	4b27      	ldr	r3, [pc, #156]	; (2e28 <EIC_Handler+0xa4>)
    2d8a:	691a      	ldr	r2, [r3, #16]
	return ((Eic *)hw)->INTENSET.reg;
    2d8c:	68d9      	ldr	r1, [r3, #12]
	volatile uint32_t flags = hri_eic_read_INTFLAG_reg(EIC) & hri_eic_read_INTEN_reg(EIC);
    2d8e:	400a      	ands	r2, r1
    2d90:	9201      	str	r2, [sp, #4]
	int8_t            pos;
	uint32_t          pin = INVALID_PIN_NUMBER;

	hri_eic_clear_INTFLAG_reg(EIC, flags);
    2d92:	9a01      	ldr	r2, [sp, #4]
	((Eic *)hw)->INTFLAG.reg = mask;
    2d94:	611a      	str	r2, [r3, #16]

	ASSERT(callback);
    2d96:	4b25      	ldr	r3, [pc, #148]	; (2e2c <EIC_Handler+0xa8>)
    2d98:	6818      	ldr	r0, [r3, #0]
    2d9a:	1e43      	subs	r3, r0, #1
    2d9c:	4198      	sbcs	r0, r3
    2d9e:	b2c0      	uxtb	r0, r0
    2da0:	22d2      	movs	r2, #210	; 0xd2
    2da2:	4923      	ldr	r1, [pc, #140]	; (2e30 <EIC_Handler+0xac>)
    2da4:	4b23      	ldr	r3, [pc, #140]	; (2e34 <EIC_Handler+0xb0>)
    2da6:	4798      	blx	r3
	uint32_t          pin = INVALID_PIN_NUMBER;
    2da8:	2501      	movs	r5, #1
    2daa:	426d      	negs	r5, r5

	while (flags) {
    2dac:	e031      	b.n	2e12 <EIC_Handler+0x8e>
			uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;

			while (upper >= lower) {
				middle = (upper + lower) >> 1;
				if (_map[middle].extint == pos) {
					pin = _map[middle].pin;
    2dae:	00db      	lsls	r3, r3, #3
    2db0:	4a21      	ldr	r2, [pc, #132]	; (2e38 <EIC_Handler+0xb4>)
    2db2:	18d3      	adds	r3, r2, r3
    2db4:	685d      	ldr	r5, [r3, #4]
				} else {
					upper = middle - 1;
				}
			}

			if (INVALID_PIN_NUMBER != pin) {
    2db6:	1c6b      	adds	r3, r5, #1
    2db8:	d003      	beq.n	2dc2 <EIC_Handler+0x3e>
				callback(pin);
    2dba:	4b1c      	ldr	r3, [pc, #112]	; (2e2c <EIC_Handler+0xa8>)
    2dbc:	681b      	ldr	r3, [r3, #0]
    2dbe:	0028      	movs	r0, r5
    2dc0:	4798      	blx	r3
			}
			flags &= ~(1ul << pos);
    2dc2:	2201      	movs	r2, #1
    2dc4:	40a2      	lsls	r2, r4
    2dc6:	9b01      	ldr	r3, [sp, #4]
    2dc8:	4393      	bics	r3, r2
    2dca:	9301      	str	r3, [sp, #4]
			pos = ffs(flags) - 1;
    2dcc:	9801      	ldr	r0, [sp, #4]
    2dce:	4b1b      	ldr	r3, [pc, #108]	; (2e3c <EIC_Handler+0xb8>)
    2dd0:	4798      	blx	r3
    2dd2:	3801      	subs	r0, #1
    2dd4:	b244      	sxtb	r4, r0
		while (-1 != pos) {
    2dd6:	1c63      	adds	r3, r4, #1
    2dd8:	d014      	beq.n	2e04 <EIC_Handler+0x80>
    2dda:	2610      	movs	r6, #16
    2ddc:	2000      	movs	r0, #0
    2dde:	e001      	b.n	2de4 <EIC_Handler+0x60>
					upper = middle - 1;
    2de0:	3901      	subs	r1, #1
    2de2:	b2ce      	uxtb	r6, r1
			while (upper >= lower) {
    2de4:	42b0      	cmp	r0, r6
    2de6:	d8e6      	bhi.n	2db6 <EIC_Handler+0x32>
				middle = (upper + lower) >> 1;
    2de8:	1833      	adds	r3, r6, r0
    2dea:	105b      	asrs	r3, r3, #1
    2dec:	b2d9      	uxtb	r1, r3
    2dee:	22ff      	movs	r2, #255	; 0xff
    2df0:	4013      	ands	r3, r2
				if (_map[middle].extint == pos) {
    2df2:	00df      	lsls	r7, r3, #3
    2df4:	4a10      	ldr	r2, [pc, #64]	; (2e38 <EIC_Handler+0xb4>)
    2df6:	5cba      	ldrb	r2, [r7, r2]
    2df8:	42a2      	cmp	r2, r4
    2dfa:	d0d8      	beq.n	2dae <EIC_Handler+0x2a>
				if (_map[middle].extint < pos) {
    2dfc:	daf0      	bge.n	2de0 <EIC_Handler+0x5c>
					lower = middle + 1;
    2dfe:	3101      	adds	r1, #1
    2e00:	b2c8      	uxtb	r0, r1
    2e02:	e7ef      	b.n	2de4 <EIC_Handler+0x60>
	return ((Eic *)hw)->INTFLAG.reg;
    2e04:	4b08      	ldr	r3, [pc, #32]	; (2e28 <EIC_Handler+0xa4>)
    2e06:	691a      	ldr	r2, [r3, #16]
	return ((Eic *)hw)->INTENSET.reg;
    2e08:	68d9      	ldr	r1, [r3, #12]
		}
		flags = hri_eic_read_INTFLAG_reg(EIC) & hri_eic_read_INTEN_reg(EIC);
    2e0a:	400a      	ands	r2, r1
    2e0c:	9201      	str	r2, [sp, #4]
		hri_eic_clear_INTFLAG_reg(EIC, flags);
    2e0e:	9a01      	ldr	r2, [sp, #4]
	((Eic *)hw)->INTFLAG.reg = mask;
    2e10:	611a      	str	r2, [r3, #16]
	while (flags) {
    2e12:	9b01      	ldr	r3, [sp, #4]
    2e14:	2b00      	cmp	r3, #0
    2e16:	d005      	beq.n	2e24 <EIC_Handler+0xa0>
		pos = ffs(flags) - 1;
    2e18:	9801      	ldr	r0, [sp, #4]
    2e1a:	4b08      	ldr	r3, [pc, #32]	; (2e3c <EIC_Handler+0xb8>)
    2e1c:	4798      	blx	r3
    2e1e:	3801      	subs	r0, #1
    2e20:	b244      	sxtb	r4, r0
		while (-1 != pos) {
    2e22:	e7d8      	b.n	2dd6 <EIC_Handler+0x52>
	}
}
    2e24:	b003      	add	sp, #12
    2e26:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2e28:	40001800 	.word	0x40001800
    2e2c:	200003b8 	.word	0x200003b8
    2e30:	0000ac00 	.word	0x0000ac00
    2e34:	000026c1 	.word	0x000026c1
    2e38:	0000ab80 	.word	0x0000ab80
    2e3c:	00009489 	.word	0x00009489

00002e40 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    2e40:	07c3      	lsls	r3, r0, #31
    2e42:	d50a      	bpl.n	2e5a <_gclk_init_generators_by_fref+0x1a>
}

static inline void hri_gclk_write_GENDIV_reg(const void *const hw, hri_gclk_gendiv_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENDIV.reg = data;
    2e44:	4b11      	ldr	r3, [pc, #68]	; (2e8c <_gclk_init_generators_by_fref+0x4c>)
    2e46:	2280      	movs	r2, #128	; 0x80
    2e48:	0052      	lsls	r2, r2, #1
    2e4a:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
    2e4c:	2283      	movs	r2, #131	; 0x83
    2e4e:	0252      	lsls	r2, r2, #9
    2e50:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
    2e52:	4b0e      	ldr	r3, [pc, #56]	; (2e8c <_gclk_init_generators_by_fref+0x4c>)
    2e54:	785b      	ldrb	r3, [r3, #1]
    2e56:	09db      	lsrs	r3, r3, #7
    2e58:	d1fb      	bne.n	2e52 <_gclk_init_generators_by_fref+0x12>
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SRC | GCLK_GENCTRL_ID(2));
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    2e5a:	0703      	lsls	r3, r0, #28
    2e5c:	d509      	bpl.n	2e72 <_gclk_init_generators_by_fref+0x32>
	((Gclk *)hw)->GENDIV.reg = data;
    2e5e:	4b0b      	ldr	r3, [pc, #44]	; (2e8c <_gclk_init_generators_by_fref+0x4c>)
    2e60:	2204      	movs	r2, #4
    2e62:	32ff      	adds	r2, #255	; 0xff
    2e64:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
    2e66:	4a0a      	ldr	r2, [pc, #40]	; (2e90 <_gclk_init_generators_by_fref+0x50>)
    2e68:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
    2e6a:	4b08      	ldr	r3, [pc, #32]	; (2e8c <_gclk_init_generators_by_fref+0x4c>)
    2e6c:	785b      	ldrb	r3, [r3, #1]
    2e6e:	09db      	lsrs	r3, r3, #7
    2e70:	d1fb      	bne.n	2e6a <_gclk_init_generators_by_fref+0x2a>
		        | (CONF_GCLK_GENERATOR_6_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_6_SRC | GCLK_GENCTRL_ID(6));
	}
#endif

#if CONF_GCLK_GENERATOR_7_CONFIG == 1
	if (bm & (1ul << 7)) {
    2e72:	0603      	lsls	r3, r0, #24
    2e74:	d509      	bpl.n	2e8a <_gclk_init_generators_by_fref+0x4a>
	((Gclk *)hw)->GENDIV.reg = data;
    2e76:	4b05      	ldr	r3, [pc, #20]	; (2e8c <_gclk_init_generators_by_fref+0x4c>)
    2e78:	2208      	movs	r2, #8
    2e7a:	32ff      	adds	r2, #255	; 0xff
    2e7c:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
    2e7e:	4a05      	ldr	r2, [pc, #20]	; (2e94 <_gclk_init_generators_by_fref+0x54>)
    2e80:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
    2e82:	4b02      	ldr	r3, [pc, #8]	; (2e8c <_gclk_init_generators_by_fref+0x4c>)
    2e84:	785b      	ldrb	r3, [r3, #1]
    2e86:	09db      	lsrs	r3, r3, #7
    2e88:	d1fb      	bne.n	2e82 <_gclk_init_generators_by_fref+0x42>
		        | (CONF_GCLK_GEN_8_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_8_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_8_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_8_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_8_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_8_SRC | GCLK_GENCTRL_ID(8));
	}
#endif
}
    2e8a:	4770      	bx	lr
    2e8c:	40000c00 	.word	0x40000c00
    2e90:	00010303 	.word	0x00010303
    2e94:	00010707 	.word	0x00010707

00002e98 <_flash_erase_row>:
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_READY) >> NVMCTRL_INTFLAG_READY_Pos;
    2e98:	7d03      	ldrb	r3, [r0, #20]
 * \param[in]  hw            The pointer to hardware instance
 * \param[in]  dst_addr      Destination page address to erase
 */
static void _flash_erase_row(void *const hw, const uint32_t dst_addr, uint32_t nvmctrl_cmd)
{
	while (!hri_nvmctrl_get_interrupt_READY_bit(hw)) {
    2e9a:	07db      	lsls	r3, r3, #31
    2e9c:	d5fc      	bpl.n	2e98 <_flash_erase_row>
}

static inline void hri_nvmctrl_clear_STATUS_reg(const void *const hw, hri_nvmctrl_status_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->STATUS.reg = mask;
    2e9e:	2320      	movs	r3, #32
    2ea0:	33ff      	adds	r3, #255	; 0xff
    2ea2:	8303      	strh	r3, [r0, #24]

	/* Clear flags */
	hri_nvmctrl_clear_STATUS_reg(hw, NVMCTRL_STATUS_MASK);

	/* Set address and command */
	hri_nvmctrl_write_ADDR_reg(hw, dst_addr / 2);
    2ea4:	0849      	lsrs	r1, r1, #1
	((Nvmctrl *)hw)->ADDR.reg = data;
    2ea6:	61c1      	str	r1, [r0, #28]
	hri_nvmctrl_write_CTRLA_reg(hw, nvmctrl_cmd | NVMCTRL_CTRLA_CMDEX_KEY);
    2ea8:	4b02      	ldr	r3, [pc, #8]	; (2eb4 <_flash_erase_row+0x1c>)
    2eaa:	431a      	orrs	r2, r3
    2eac:	b292      	uxth	r2, r2
	((Nvmctrl *)hw)->CTRLA.reg = data;
    2eae:	8002      	strh	r2, [r0, #0]
}
    2eb0:	4770      	bx	lr
    2eb2:	46c0      	nop			; (mov r8, r8)
    2eb4:	ffffa500 	.word	0xffffa500

00002eb8 <_flash_program>:
 *                           write is stored
 * \param[in] size           The size of data to write to a page
 */
static void _flash_program(void *const hw, const uint32_t dst_addr, const uint8_t *buffer, const uint16_t size,
                           uint32_t nvmctrl_cmd)
{
    2eb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2eba:	0004      	movs	r4, r0
    2ebc:	000f      	movs	r7, r1
    2ebe:	0016      	movs	r6, r2
    2ec0:	001d      	movs	r5, r3
	ASSERT(!(dst_addr % 2));
    2ec2:	2001      	movs	r0, #1
    2ec4:	4008      	ands	r0, r1
    2ec6:	4243      	negs	r3, r0
    2ec8:	4158      	adcs	r0, r3
    2eca:	b2c0      	uxtb	r0, r0
    2ecc:	22c5      	movs	r2, #197	; 0xc5
    2ece:	0052      	lsls	r2, r2, #1
    2ed0:	4915      	ldr	r1, [pc, #84]	; (2f28 <_flash_program+0x70>)
    2ed2:	4b16      	ldr	r3, [pc, #88]	; (2f2c <_flash_program+0x74>)
    2ed4:	4798      	blx	r3

	uint32_t nvm_address = dst_addr / 2;
    2ed6:	0879      	lsrs	r1, r7, #1
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_READY) >> NVMCTRL_INTFLAG_READY_Pos;
    2ed8:	7d23      	ldrb	r3, [r4, #20]
	uint16_t i, data;

	while (!hri_nvmctrl_get_interrupt_READY_bit(hw)) {
    2eda:	07db      	lsls	r3, r3, #31
    2edc:	d5fc      	bpl.n	2ed8 <_flash_program+0x20>
	((Nvmctrl *)hw)->CTRLA.reg = data;
    2ede:	4b14      	ldr	r3, [pc, #80]	; (2f30 <_flash_program+0x78>)
    2ee0:	8023      	strh	r3, [r4, #0]
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_READY) >> NVMCTRL_INTFLAG_READY_Pos;
    2ee2:	7d23      	ldrb	r3, [r4, #20]
		/* Wait until this module isn't busy */
	}

	hri_nvmctrl_write_CTRLA_reg(hw, NVMCTRL_CTRLA_CMD_PBC | NVMCTRL_CTRLA_CMDEX_KEY);

	while (!hri_nvmctrl_get_interrupt_READY_bit(hw)) {
    2ee4:	07db      	lsls	r3, r3, #31
    2ee6:	d5fc      	bpl.n	2ee2 <_flash_program+0x2a>
	((Nvmctrl *)hw)->STATUS.reg = mask;
    2ee8:	2320      	movs	r3, #32
    2eea:	33ff      	adds	r3, #255	; 0xff
    2eec:	8323      	strh	r3, [r4, #24]
	uint32_t nvm_address = dst_addr / 2;
    2eee:	000a      	movs	r2, r1
	}

	/* Clear flags */
	hri_nvmctrl_clear_STATUS_reg(hw, NVMCTRL_STATUS_MASK);

	for (i = 0; i < size; i += 2) {
    2ef0:	2300      	movs	r3, #0
    2ef2:	e004      	b.n	2efe <_flash_program+0x46>
		data = buffer[i];
		if (i < NVMCTRL_PAGE_SIZE - 1) {
			data |= (buffer[i + 1] << 8);
		}
		NVM_MEMORY[nvm_address++] = data;
    2ef4:	0057      	lsls	r7, r2, #1
    2ef6:	8038      	strh	r0, [r7, #0]
	for (i = 0; i < size; i += 2) {
    2ef8:	3302      	adds	r3, #2
    2efa:	b29b      	uxth	r3, r3
		NVM_MEMORY[nvm_address++] = data;
    2efc:	3201      	adds	r2, #1
	for (i = 0; i < size; i += 2) {
    2efe:	42ab      	cmp	r3, r5
    2f00:	d208      	bcs.n	2f14 <_flash_program+0x5c>
		data = buffer[i];
    2f02:	5cf7      	ldrb	r7, [r6, r3]
    2f04:	b2b8      	uxth	r0, r7
		if (i < NVMCTRL_PAGE_SIZE - 1) {
    2f06:	2b3e      	cmp	r3, #62	; 0x3e
    2f08:	d8f4      	bhi.n	2ef4 <_flash_program+0x3c>
			data |= (buffer[i + 1] << 8);
    2f0a:	18f0      	adds	r0, r6, r3
    2f0c:	7840      	ldrb	r0, [r0, #1]
    2f0e:	0200      	lsls	r0, r0, #8
    2f10:	4338      	orrs	r0, r7
    2f12:	e7ef      	b.n	2ef4 <_flash_program+0x3c>
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_READY) >> NVMCTRL_INTFLAG_READY_Pos;
    2f14:	7d23      	ldrb	r3, [r4, #20]
	}

	while (!hri_nvmctrl_get_interrupt_READY_bit(hw)) {
    2f16:	07db      	lsls	r3, r3, #31
    2f18:	d5fc      	bpl.n	2f14 <_flash_program+0x5c>
	((Nvmctrl *)hw)->ADDR.reg = data;
    2f1a:	61e1      	str	r1, [r4, #28]
		/* Wait until this module isn't busy */
	}

	hri_nvmctrl_write_ADDR_reg(hw, dst_addr / 2);
	hri_nvmctrl_write_CTRLA_reg(hw, nvmctrl_cmd | NVMCTRL_CTRLA_CMDEX_KEY);
    2f1c:	4b05      	ldr	r3, [pc, #20]	; (2f34 <_flash_program+0x7c>)
    2f1e:	9a06      	ldr	r2, [sp, #24]
    2f20:	4313      	orrs	r3, r2
    2f22:	b29b      	uxth	r3, r3
	((Nvmctrl *)hw)->CTRLA.reg = data;
    2f24:	8023      	strh	r3, [r4, #0]
}
    2f26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2f28:	0000ac18 	.word	0x0000ac18
    2f2c:	000026c1 	.word	0x000026c1
    2f30:	ffffa544 	.word	0xffffa544
    2f34:	ffffa500 	.word	0xffffa500

00002f38 <_flash_init>:
{
    2f38:	b570      	push	{r4, r5, r6, lr}
    2f3a:	0005      	movs	r5, r0
    2f3c:	000c      	movs	r4, r1
	ASSERT(device && (hw == NVMCTRL));
    2f3e:	2800      	cmp	r0, #0
    2f40:	d01c      	beq.n	2f7c <_flash_init+0x44>
    2f42:	4b10      	ldr	r3, [pc, #64]	; (2f84 <_flash_init+0x4c>)
    2f44:	4299      	cmp	r1, r3
    2f46:	d01b      	beq.n	2f80 <_flash_init+0x48>
    2f48:	2000      	movs	r0, #0
    2f4a:	2246      	movs	r2, #70	; 0x46
    2f4c:	490e      	ldr	r1, [pc, #56]	; (2f88 <_flash_init+0x50>)
    2f4e:	4b0f      	ldr	r3, [pc, #60]	; (2f8c <_flash_init+0x54>)
    2f50:	4798      	blx	r3
	device->hw = hw;
    2f52:	612c      	str	r4, [r5, #16]
	tmp = ((Nvmctrl *)hw)->CTRLB.reg;
    2f54:	6862      	ldr	r2, [r4, #4]
	tmp &= mask;
    2f56:	239e      	movs	r3, #158	; 0x9e
    2f58:	4013      	ands	r3, r2
	((Nvmctrl *)hw)->CTRLB.reg = data;
    2f5a:	6063      	str	r3, [r4, #4]
	_nvm_dev = device;
    2f5c:	4b0c      	ldr	r3, [pc, #48]	; (2f90 <_flash_init+0x58>)
    2f5e:	601d      	str	r5, [r3, #0]
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2f60:	4b0c      	ldr	r3, [pc, #48]	; (2f94 <_flash_init+0x5c>)
    2f62:	2220      	movs	r2, #32
    2f64:	2180      	movs	r1, #128	; 0x80
    2f66:	505a      	str	r2, [r3, r1]
  __ASM volatile ("dsb 0xF":::"memory");
    2f68:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2f6c:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2f70:	3101      	adds	r1, #1
    2f72:	31ff      	adds	r1, #255	; 0xff
    2f74:	505a      	str	r2, [r3, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2f76:	601a      	str	r2, [r3, #0]
}
    2f78:	2000      	movs	r0, #0
    2f7a:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(device && (hw == NVMCTRL));
    2f7c:	2000      	movs	r0, #0
    2f7e:	e7e4      	b.n	2f4a <_flash_init+0x12>
    2f80:	2001      	movs	r0, #1
    2f82:	e7e2      	b.n	2f4a <_flash_init+0x12>
    2f84:	41004000 	.word	0x41004000
    2f88:	0000ac18 	.word	0x0000ac18
    2f8c:	000026c1 	.word	0x000026c1
    2f90:	200003bc 	.word	0x200003bc
    2f94:	e000e100 	.word	0xe000e100

00002f98 <_flash_get_page_size>:
}
    2f98:	2040      	movs	r0, #64	; 0x40
    2f9a:	4770      	bx	lr

00002f9c <_flash_get_total_pages>:
}
    2f9c:	2080      	movs	r0, #128	; 0x80
    2f9e:	0140      	lsls	r0, r0, #5
    2fa0:	4770      	bx	lr

00002fa2 <_flash_read>:
{
    2fa2:	b570      	push	{r4, r5, r6, lr}
	uint32_t nvm_address = src_addr / 2;
    2fa4:	084c      	lsrs	r4, r1, #1
	while (!hri_nvmctrl_get_interrupt_READY_bit(device->hw)) {
    2fa6:	6905      	ldr	r5, [r0, #16]
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_READY) >> NVMCTRL_INTFLAG_READY_Pos;
    2fa8:	7d2e      	ldrb	r6, [r5, #20]
    2faa:	07f6      	lsls	r6, r6, #31
    2fac:	d5fb      	bpl.n	2fa6 <_flash_read+0x4>
	((Nvmctrl *)hw)->STATUS.reg = mask;
    2fae:	2020      	movs	r0, #32
    2fb0:	30ff      	adds	r0, #255	; 0xff
    2fb2:	8328      	strh	r0, [r5, #24]
	if (src_addr % 2) {
    2fb4:	07c8      	lsls	r0, r1, #31
    2fb6:	d507      	bpl.n	2fc8 <_flash_read+0x26>
		data      = NVM_MEMORY[nvm_address++];
    2fb8:	3401      	adds	r4, #1
    2fba:	2001      	movs	r0, #1
    2fbc:	4381      	bics	r1, r0
    2fbe:	8809      	ldrh	r1, [r1, #0]
		buffer[0] = data >> 8;
    2fc0:	0a09      	lsrs	r1, r1, #8
    2fc2:	7011      	strb	r1, [r2, #0]
		i         = 1;
    2fc4:	2101      	movs	r1, #1
    2fc6:	e003      	b.n	2fd0 <_flash_read+0x2e>
		i = 0;
    2fc8:	2100      	movs	r1, #0
    2fca:	e001      	b.n	2fd0 <_flash_read+0x2e>
		i += 2;
    2fcc:	3102      	adds	r1, #2
		data      = NVM_MEMORY[nvm_address++];
    2fce:	002c      	movs	r4, r5
	while (i < length) {
    2fd0:	4299      	cmp	r1, r3
    2fd2:	d20b      	bcs.n	2fec <_flash_read+0x4a>
		data      = NVM_MEMORY[nvm_address++];
    2fd4:	1c65      	adds	r5, r4, #1
    2fd6:	0064      	lsls	r4, r4, #1
    2fd8:	8820      	ldrh	r0, [r4, #0]
    2fda:	b280      	uxth	r0, r0
		buffer[i] = (data & 0xFF);
    2fdc:	5450      	strb	r0, [r2, r1]
		if (i < (length - 1)) {
    2fde:	1e5c      	subs	r4, r3, #1
    2fe0:	42a1      	cmp	r1, r4
    2fe2:	d2f3      	bcs.n	2fcc <_flash_read+0x2a>
			buffer[i + 1] = (data >> 8);
    2fe4:	1c4c      	adds	r4, r1, #1
    2fe6:	0a00      	lsrs	r0, r0, #8
    2fe8:	5510      	strb	r0, [r2, r4]
    2fea:	e7ef      	b.n	2fcc <_flash_read+0x2a>
}
    2fec:	bd70      	pop	{r4, r5, r6, pc}
	...

00002ff0 <_flash_write>:
{
    2ff0:	b5f0      	push	{r4, r5, r6, r7, lr}
    2ff2:	46de      	mov	lr, fp
    2ff4:	4657      	mov	r7, sl
    2ff6:	464e      	mov	r6, r9
    2ff8:	4645      	mov	r5, r8
    2ffa:	b5e0      	push	{r5, r6, r7, lr}
    2ffc:	b0c5      	sub	sp, #276	; 0x114
    2ffe:	4681      	mov	r9, r0
    3000:	0016      	movs	r6, r2
    3002:	001d      	movs	r5, r3
	uint32_t wr_start_addr = dst_addr;
    3004:	000c      	movs	r4, r1
    3006:	e048      	b.n	309a <_flash_write+0xaa>
			_flash_read(device, row_start_addr + i * NVMCTRL_PAGE_SIZE, tmp_buffer[i], NVMCTRL_PAGE_SIZE);
    3008:	4653      	mov	r3, sl
    300a:	0199      	lsls	r1, r3, #6
    300c:	ab04      	add	r3, sp, #16
    300e:	185a      	adds	r2, r3, r1
    3010:	4441      	add	r1, r8
    3012:	2340      	movs	r3, #64	; 0x40
    3014:	4648      	mov	r0, r9
    3016:	4f29      	ldr	r7, [pc, #164]	; (30bc <_flash_write+0xcc>)
    3018:	47b8      	blx	r7
		for (i = 0; i < NVMCTRL_ROW_PAGES; i++) {
    301a:	2301      	movs	r3, #1
    301c:	469c      	mov	ip, r3
    301e:	44e2      	add	sl, ip
    3020:	4653      	mov	r3, sl
    3022:	2b03      	cmp	r3, #3
    3024:	d9f0      	bls.n	3008 <_flash_write+0x18>
		j = (wr_start_addr - row_start_addr) / NVMCTRL_PAGE_SIZE;
    3026:	4643      	mov	r3, r8
    3028:	1ae3      	subs	r3, r4, r3
    302a:	0999      	lsrs	r1, r3, #6
		k = wr_start_addr - row_start_addr - j * NVMCTRL_PAGE_SIZE;
    302c:	223f      	movs	r2, #63	; 0x3f
    302e:	4013      	ands	r3, r2
		while ((wr_start_addr <= row_end_addr) && (length > 0)) {
    3030:	e002      	b.n	3038 <_flash_write+0x48>
			wr_start_addr++;
    3032:	3401      	adds	r4, #1
			buffer++;
    3034:	3601      	adds	r6, #1
			length--;
    3036:	3d01      	subs	r5, #1
		while ((wr_start_addr <= row_end_addr) && (length > 0)) {
    3038:	9a03      	ldr	r2, [sp, #12]
    303a:	4294      	cmp	r4, r2
    303c:	d80d      	bhi.n	305a <_flash_write+0x6a>
    303e:	2d00      	cmp	r5, #0
    3040:	d00b      	beq.n	305a <_flash_write+0x6a>
			tmp_buffer[j][k] = *buffer;
    3042:	7830      	ldrb	r0, [r6, #0]
    3044:	018a      	lsls	r2, r1, #6
    3046:	af04      	add	r7, sp, #16
    3048:	46bc      	mov	ip, r7
    304a:	4462      	add	r2, ip
    304c:	54d0      	strb	r0, [r2, r3]
			k                = (k + 1) % NVMCTRL_PAGE_SIZE;
    304e:	3301      	adds	r3, #1
    3050:	223f      	movs	r2, #63	; 0x3f
    3052:	4013      	ands	r3, r2
			if (0 == k) {
    3054:	d1ed      	bne.n	3032 <_flash_write+0x42>
				j++;
    3056:	3101      	adds	r1, #1
    3058:	e7eb      	b.n	3032 <_flash_write+0x42>
		_flash_erase_row(device->hw, row_start_addr, NVMCTRL_CTRLA_CMD_ER);
    305a:	2202      	movs	r2, #2
    305c:	4641      	mov	r1, r8
    305e:	464b      	mov	r3, r9
    3060:	6918      	ldr	r0, [r3, #16]
    3062:	4b17      	ldr	r3, [pc, #92]	; (30c0 <_flash_write+0xd0>)
    3064:	4798      	blx	r3
		for (i = 0; i < NVMCTRL_ROW_PAGES; i++) {
    3066:	2300      	movs	r3, #0
    3068:	469a      	mov	sl, r3
    306a:	e00e      	b.n	308a <_flash_write+0x9a>
			               row_start_addr + i * NVMCTRL_PAGE_SIZE,
    306c:	4653      	mov	r3, sl
    306e:	0199      	lsls	r1, r3, #6
			               tmp_buffer[i],
    3070:	ab04      	add	r3, sp, #16
    3072:	185a      	adds	r2, r3, r1
			_flash_program(device->hw,
    3074:	4441      	add	r1, r8
    3076:	2304      	movs	r3, #4
    3078:	9300      	str	r3, [sp, #0]
    307a:	333c      	adds	r3, #60	; 0x3c
    307c:	4648      	mov	r0, r9
    307e:	6900      	ldr	r0, [r0, #16]
    3080:	4f10      	ldr	r7, [pc, #64]	; (30c4 <_flash_write+0xd4>)
    3082:	47b8      	blx	r7
		for (i = 0; i < NVMCTRL_ROW_PAGES; i++) {
    3084:	2301      	movs	r3, #1
    3086:	469c      	mov	ip, r3
    3088:	44e2      	add	sl, ip
    308a:	4653      	mov	r3, sl
    308c:	2b03      	cmp	r3, #3
    308e:	d9ed      	bls.n	306c <_flash_write+0x7c>
	} while (row_end_addr < (wr_start_addr + length - 1));
    3090:	192b      	adds	r3, r5, r4
    3092:	3b01      	subs	r3, #1
    3094:	9a03      	ldr	r2, [sp, #12]
    3096:	429a      	cmp	r2, r3
    3098:	d209      	bcs.n	30ae <_flash_write+0xbe>
		row_start_addr = wr_start_addr & ~((NVMCTRL_PAGE_SIZE * NVMCTRL_ROW_PAGES) - 1);
    309a:	23ff      	movs	r3, #255	; 0xff
    309c:	0022      	movs	r2, r4
    309e:	439a      	bics	r2, r3
    30a0:	4690      	mov	r8, r2
		row_end_addr   = row_start_addr + NVMCTRL_ROW_PAGES * NVMCTRL_PAGE_SIZE - 1;
    30a2:	0017      	movs	r7, r2
    30a4:	37ff      	adds	r7, #255	; 0xff
    30a6:	9703      	str	r7, [sp, #12]
		for (i = 0; i < NVMCTRL_ROW_PAGES; i++) {
    30a8:	2300      	movs	r3, #0
    30aa:	469a      	mov	sl, r3
    30ac:	e7b8      	b.n	3020 <_flash_write+0x30>
}
    30ae:	b045      	add	sp, #276	; 0x114
    30b0:	bc3c      	pop	{r2, r3, r4, r5}
    30b2:	4690      	mov	r8, r2
    30b4:	4699      	mov	r9, r3
    30b6:	46a2      	mov	sl, r4
    30b8:	46ab      	mov	fp, r5
    30ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
    30bc:	00002fa3 	.word	0x00002fa3
    30c0:	00002e99 	.word	0x00002e99
    30c4:	00002eb9 	.word	0x00002eb9

000030c8 <_flash_append>:
{
    30c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    30ca:	46de      	mov	lr, fp
    30cc:	4657      	mov	r7, sl
    30ce:	464e      	mov	r6, r9
    30d0:	4645      	mov	r5, r8
    30d2:	b5e0      	push	{r5, r6, r7, lr}
    30d4:	b083      	sub	sp, #12
    30d6:	4681      	mov	r9, r0
    30d8:	4692      	mov	sl, r2
    30da:	469b      	mov	fp, r3
	uint32_t page_start_addr = dst_addr & ~(NVMCTRL_PAGE_SIZE - 1);
    30dc:	233f      	movs	r3, #63	; 0x3f
    30de:	000e      	movs	r6, r1
    30e0:	439e      	bics	r6, r3
	if (dst_addr != page_start_addr) {
    30e2:	42b1      	cmp	r1, r6
    30e4:	d00e      	beq.n	3104 <_flash_append+0x3c>
		size = min(length, NVMCTRL_PAGE_SIZE - (dst_addr - page_start_addr));
    30e6:	1a74      	subs	r4, r6, r1
    30e8:	3440      	adds	r4, #64	; 0x40
    30ea:	455c      	cmp	r4, fp
    30ec:	d900      	bls.n	30f0 <_flash_append+0x28>
    30ee:	465c      	mov	r4, fp
		_flash_program(device->hw, dst_addr, buffer, size, NVMCTRL_CTRLA_CMD_WP);
    30f0:	b2a3      	uxth	r3, r4
    30f2:	2204      	movs	r2, #4
    30f4:	9200      	str	r2, [sp, #0]
    30f6:	4652      	mov	r2, sl
    30f8:	4648      	mov	r0, r9
    30fa:	6900      	ldr	r0, [r0, #16]
    30fc:	4d10      	ldr	r5, [pc, #64]	; (3140 <_flash_append+0x78>)
    30fe:	47a8      	blx	r5
		page_start_addr += NVMCTRL_PAGE_SIZE;
    3100:	3640      	adds	r6, #64	; 0x40
    3102:	e00d      	b.n	3120 <_flash_append+0x58>
	uint32_t offset = 0;
    3104:	2400      	movs	r4, #0
    3106:	e00b      	b.n	3120 <_flash_append+0x58>
		_flash_program(device->hw, page_start_addr, buffer + offset, size, NVMCTRL_CTRLA_CMD_WP);
    3108:	4653      	mov	r3, sl
    310a:	191a      	adds	r2, r3, r4
    310c:	b2ab      	uxth	r3, r5
    310e:	2104      	movs	r1, #4
    3110:	9100      	str	r1, [sp, #0]
    3112:	0031      	movs	r1, r6
    3114:	4648      	mov	r0, r9
    3116:	6900      	ldr	r0, [r0, #16]
    3118:	4f09      	ldr	r7, [pc, #36]	; (3140 <_flash_append+0x78>)
    311a:	47b8      	blx	r7
		page_start_addr += NVMCTRL_PAGE_SIZE;
    311c:	3640      	adds	r6, #64	; 0x40
		offset += size;
    311e:	1964      	adds	r4, r4, r5
	while (offset < length) {
    3120:	455c      	cmp	r4, fp
    3122:	d205      	bcs.n	3130 <_flash_append+0x68>
		size = min(length - offset, NVMCTRL_PAGE_SIZE);
    3124:	465b      	mov	r3, fp
    3126:	1b1d      	subs	r5, r3, r4
    3128:	2d40      	cmp	r5, #64	; 0x40
    312a:	d9ed      	bls.n	3108 <_flash_append+0x40>
    312c:	2540      	movs	r5, #64	; 0x40
    312e:	e7eb      	b.n	3108 <_flash_append+0x40>
}
    3130:	b003      	add	sp, #12
    3132:	bc3c      	pop	{r2, r3, r4, r5}
    3134:	4690      	mov	r8, r2
    3136:	4699      	mov	r9, r3
    3138:	46a2      	mov	sl, r4
    313a:	46ab      	mov	fp, r5
    313c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    313e:	46c0      	nop			; (mov r8, r8)
    3140:	00002eb9 	.word	0x00002eb9

00003144 <_flash_erase>:
{
    3144:	b5f0      	push	{r4, r5, r6, r7, lr}
    3146:	46d6      	mov	lr, sl
    3148:	464f      	mov	r7, r9
    314a:	4646      	mov	r6, r8
    314c:	b5c0      	push	{r6, r7, lr}
    314e:	b090      	sub	sp, #64	; 0x40
    3150:	0007      	movs	r7, r0
    3152:	468a      	mov	sl, r1
    3154:	0015      	movs	r5, r2
	row_start_addr = dst_addr & ~((NVMCTRL_PAGE_SIZE * NVMCTRL_ROW_PAGES) - 1);
    3156:	23ff      	movs	r3, #255	; 0xff
    3158:	000c      	movs	r4, r1
    315a:	439c      	bics	r4, r3
	memset(tmp_buffer, 0xFF, NVMCTRL_PAGE_SIZE);
    315c:	2240      	movs	r2, #64	; 0x40
    315e:	21ff      	movs	r1, #255	; 0xff
    3160:	4668      	mov	r0, sp
    3162:	4b1f      	ldr	r3, [pc, #124]	; (31e0 <_flash_erase+0x9c>)
    3164:	4798      	blx	r3
	if (dst_addr != row_start_addr) {
    3166:	45a2      	cmp	sl, r4
    3168:	d020      	beq.n	31ac <_flash_erase+0x68>
		row_start_addr += NVMCTRL_ROW_PAGES * NVMCTRL_PAGE_SIZE;
    316a:	3401      	adds	r4, #1
    316c:	34ff      	adds	r4, #255	; 0xff
		for (i = 0; i < NVMCTRL_ROW_PAGES - 1; i++) {
    316e:	2300      	movs	r3, #0
    3170:	4698      	mov	r8, r3
    3172:	4643      	mov	r3, r8
    3174:	2b02      	cmp	r3, #2
    3176:	d819      	bhi.n	31ac <_flash_erase+0x68>
			_flash_write(device, dst_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    3178:	2340      	movs	r3, #64	; 0x40
    317a:	466a      	mov	r2, sp
    317c:	4651      	mov	r1, sl
    317e:	0038      	movs	r0, r7
    3180:	4e18      	ldr	r6, [pc, #96]	; (31e4 <_flash_erase+0xa0>)
    3182:	47b0      	blx	r6
			if (--page_nums == 0) {
    3184:	3d01      	subs	r5, #1
    3186:	2d00      	cmp	r5, #0
    3188:	d023      	beq.n	31d2 <_flash_erase+0x8e>
			dst_addr += NVMCTRL_PAGE_SIZE;
    318a:	2340      	movs	r3, #64	; 0x40
    318c:	469c      	mov	ip, r3
    318e:	44e2      	add	sl, ip
			if (dst_addr == row_start_addr) {
    3190:	4554      	cmp	r4, sl
    3192:	d00b      	beq.n	31ac <_flash_erase+0x68>
		for (i = 0; i < NVMCTRL_ROW_PAGES - 1; i++) {
    3194:	3b3f      	subs	r3, #63	; 0x3f
    3196:	469c      	mov	ip, r3
    3198:	44e0      	add	r8, ip
    319a:	e7ea      	b.n	3172 <_flash_erase+0x2e>
		_flash_erase_row(device->hw, row_start_addr, NVMCTRL_CTRLA_CMD_ER);
    319c:	2202      	movs	r2, #2
    319e:	0021      	movs	r1, r4
    31a0:	6938      	ldr	r0, [r7, #16]
    31a2:	4b11      	ldr	r3, [pc, #68]	; (31e8 <_flash_erase+0xa4>)
    31a4:	4798      	blx	r3
		row_start_addr += NVMCTRL_ROW_PAGES * NVMCTRL_PAGE_SIZE;
    31a6:	3401      	adds	r4, #1
    31a8:	34ff      	adds	r4, #255	; 0xff
		page_nums -= NVMCTRL_ROW_PAGES;
    31aa:	3d04      	subs	r5, #4
	while (page_nums >= NVMCTRL_ROW_PAGES) {
    31ac:	2d03      	cmp	r5, #3
    31ae:	d8f5      	bhi.n	319c <_flash_erase+0x58>
	if (page_nums != 0) {
    31b0:	2d00      	cmp	r5, #0
    31b2:	d00e      	beq.n	31d2 <_flash_erase+0x8e>
    31b4:	2300      	movs	r3, #0
    31b6:	4699      	mov	r9, r3
    31b8:	e009      	b.n	31ce <_flash_erase+0x8a>
			_flash_write(device, row_start_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    31ba:	2340      	movs	r3, #64	; 0x40
    31bc:	466a      	mov	r2, sp
    31be:	0021      	movs	r1, r4
    31c0:	0038      	movs	r0, r7
    31c2:	4e08      	ldr	r6, [pc, #32]	; (31e4 <_flash_erase+0xa0>)
    31c4:	47b0      	blx	r6
			row_start_addr += NVMCTRL_PAGE_SIZE;
    31c6:	3440      	adds	r4, #64	; 0x40
		for (i = 0; i < page_nums; i++) {
    31c8:	2301      	movs	r3, #1
    31ca:	469c      	mov	ip, r3
    31cc:	44e1      	add	r9, ip
    31ce:	454d      	cmp	r5, r9
    31d0:	d8f3      	bhi.n	31ba <_flash_erase+0x76>
}
    31d2:	b010      	add	sp, #64	; 0x40
    31d4:	bc1c      	pop	{r2, r3, r4}
    31d6:	4690      	mov	r8, r2
    31d8:	4699      	mov	r9, r3
    31da:	46a2      	mov	sl, r4
    31dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    31de:	46c0      	nop			; (mov r8, r8)
    31e0:	00009555 	.word	0x00009555
    31e4:	00002ff1 	.word	0x00002ff1
    31e8:	00002e99 	.word	0x00002e99

000031ec <_flash_is_locked>:
	region_id = dst_addr / (NVMCTRL_FLASH_SIZE / 16);
    31ec:	0b89      	lsrs	r1, r1, #14
	return !(hri_nvmctrl_get_LOCK_reg(device->hw, 1 << region_id));
    31ee:	6902      	ldr	r2, [r0, #16]
    31f0:	0409      	lsls	r1, r1, #16
    31f2:	0c09      	lsrs	r1, r1, #16
    31f4:	2301      	movs	r3, #1
    31f6:	408b      	lsls	r3, r1
	tmp = ((Nvmctrl *)hw)->LOCK.reg;
    31f8:	8c10      	ldrh	r0, [r2, #32]
	tmp &= mask;
    31fa:	4018      	ands	r0, r3
    31fc:	4243      	negs	r3, r0
    31fe:	4158      	adcs	r0, r3
    3200:	b2c0      	uxtb	r0, r0
}
    3202:	4770      	bx	lr

00003204 <NVMCTRL_Handler>:

/**
 * \internal NVM interrupt handler
 */
void NVMCTRL_Handler(void)
{
    3204:	b510      	push	{r4, lr}
	void *const hw = _nvm_dev->hw;
    3206:	4b0a      	ldr	r3, [pc, #40]	; (3230 <NVMCTRL_Handler+0x2c>)
    3208:	6818      	ldr	r0, [r3, #0]
    320a:	6903      	ldr	r3, [r0, #16]
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_READY) >> NVMCTRL_INTFLAG_READY_Pos;
    320c:	7d1a      	ldrb	r2, [r3, #20]

	if (hri_nvmctrl_get_interrupt_READY_bit(hw)) {
    320e:	07d2      	lsls	r2, r2, #31
    3210:	d504      	bpl.n	321c <NVMCTRL_Handler+0x18>
		if (NULL != _nvm_dev->flash_cb.ready_cb) {
    3212:	6803      	ldr	r3, [r0, #0]
    3214:	2b00      	cmp	r3, #0
    3216:	d000      	beq.n	321a <NVMCTRL_Handler+0x16>
			_nvm_dev->flash_cb.ready_cb(_nvm_dev);
    3218:	4798      	blx	r3
		hri_nvmctrl_clear_interrupt_ERROR_bit(hw);
		if (NULL != _nvm_dev->flash_cb.error_cb) {
			_nvm_dev->flash_cb.error_cb(_nvm_dev);
		}
	}
}
    321a:	bd10      	pop	{r4, pc}
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_ERROR) >> NVMCTRL_INTFLAG_ERROR_Pos;
    321c:	7d1a      	ldrb	r2, [r3, #20]
	} else if (hri_nvmctrl_get_interrupt_ERROR_bit(hw)) {
    321e:	0792      	lsls	r2, r2, #30
    3220:	d5fb      	bpl.n	321a <NVMCTRL_Handler+0x16>
	((Nvmctrl *)hw)->INTFLAG.reg = NVMCTRL_INTFLAG_ERROR;
    3222:	2202      	movs	r2, #2
    3224:	751a      	strb	r2, [r3, #20]
		if (NULL != _nvm_dev->flash_cb.error_cb) {
    3226:	6843      	ldr	r3, [r0, #4]
    3228:	2b00      	cmp	r3, #0
    322a:	d0f6      	beq.n	321a <NVMCTRL_Handler+0x16>
			_nvm_dev->flash_cb.error_cb(_nvm_dev);
    322c:	4798      	blx	r3
}
    322e:	e7f4      	b.n	321a <NVMCTRL_Handler+0x16>
    3230:	200003bc 	.word	0x200003bc

00003234 <_pm_init>:
}

static inline void hri_pm_set_CPUSEL_CPUDIV_bf(const void *const hw, hri_pm_cpusel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->CPUSEL.reg |= PM_CPUSEL_CPUDIV(mask);
    3234:	4b06      	ldr	r3, [pc, #24]	; (3250 <_pm_init+0x1c>)
    3236:	7a1a      	ldrb	r2, [r3, #8]
    3238:	b2d2      	uxtb	r2, r2
    323a:	721a      	strb	r2, [r3, #8]
}

static inline void hri_pm_set_APBASEL_APBADIV_bf(const void *const hw, hri_pm_apbasel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBASEL.reg |= PM_APBASEL_APBADIV(mask);
    323c:	7a5a      	ldrb	r2, [r3, #9]
    323e:	b2d2      	uxtb	r2, r2
    3240:	725a      	strb	r2, [r3, #9]
}

static inline void hri_pm_set_APBBSEL_APBBDIV_bf(const void *const hw, hri_pm_apbbsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBBSEL.reg |= PM_APBBSEL_APBBDIV(mask);
    3242:	7a9a      	ldrb	r2, [r3, #10]
    3244:	b2d2      	uxtb	r2, r2
    3246:	729a      	strb	r2, [r3, #10]
}

static inline void hri_pm_set_APBCSEL_APBCDIV_bf(const void *const hw, hri_pm_apbcsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBCSEL.reg |= PM_APBCSEL_APBCDIV(mask);
    3248:	7ada      	ldrb	r2, [r3, #11]
    324a:	b2d2      	uxtb	r2, r2
    324c:	72da      	strb	r2, [r3, #11]
{
	hri_pm_set_CPUSEL_CPUDIV_bf(PM, CONF_CPU_DIV);
	hri_pm_set_APBASEL_APBADIV_bf(PM, CONF_APBA_DIV);
	hri_pm_set_APBBSEL_APBBDIV_bf(PM, CONF_APBB_DIV);
	hri_pm_set_APBCSEL_APBCDIV_bf(PM, CONF_APBC_DIV);
}
    324e:	4770      	bx	lr
    3250:	40000400 	.word	0x40000400

00003254 <_rtc_timer_interrupt_handler>:
 * \brief RTC Timer interrupt handler
 *
 * \param[in] p The pointer to calendar device struct
 */
static void _rtc_timer_interrupt_handler(struct _timer_device *dev)
{
    3254:	b510      	push	{r4, lr}
    3256:	0004      	movs	r4, r0
	return tmp;
}

static inline hri_rtcmode0_intflag_reg_t hri_rtcmode0_read_INTFLAG_reg(const void *const hw)
{
	return ((Rtc *)hw)->MODE0.INTFLAG.reg;
    3258:	68c3      	ldr	r3, [r0, #12]
    325a:	7a1b      	ldrb	r3, [r3, #8]
	/* Read and mask interrupt flag register */
	uint16_t flag = hri_rtcmode0_read_INTFLAG_reg(dev->hw);

	if (flag & RTC_MODE0_INTFLAG_CMP0) {
    325c:	07db      	lsls	r3, r3, #31
    325e:	d506      	bpl.n	326e <_rtc_timer_interrupt_handler+0x1a>
		if (dev->timer_cb.period_expired) {
    3260:	6803      	ldr	r3, [r0, #0]
    3262:	2b00      	cmp	r3, #0
    3264:	d000      	beq.n	3268 <_rtc_timer_interrupt_handler+0x14>
			dev->timer_cb.period_expired(dev);
    3266:	4798      	blx	r3
		}

		/* Clear interrupt flag */
		hri_rtcmode0_clear_interrupt_CMP0_bit(dev->hw);
    3268:	68e3      	ldr	r3, [r4, #12]
	((Rtc *)hw)->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_CMP0;
    326a:	2201      	movs	r2, #1
    326c:	721a      	strb	r2, [r3, #8]
	}
}
    326e:	bd10      	pop	{r4, pc}

00003270 <_timer_init>:
{
    3270:	b570      	push	{r4, r5, r6, lr}
    3272:	0004      	movs	r4, r0
    3274:	000d      	movs	r5, r1
	ASSERT(dev);
    3276:	1e43      	subs	r3, r0, #1
    3278:	4198      	sbcs	r0, r3
    327a:	b2c0      	uxtb	r0, r0
    327c:	2233      	movs	r2, #51	; 0x33
    327e:	4910      	ldr	r1, [pc, #64]	; (32c0 <_timer_init+0x50>)
    3280:	4b10      	ldr	r3, [pc, #64]	; (32c4 <_timer_init+0x54>)
    3282:	4798      	blx	r3
	dev->hw = hw;
    3284:	60e5      	str	r5, [r4, #12]
}

static inline void hri_rtcmode0_write_CTRL_reg(const void *const hw, hri_rtcmode0_ctrl_reg_t data)
{
	RTC_CRITICAL_SECTION_ENTER();
	((Rtc *)hw)->MODE0.CTRL.reg = data;
    3286:	2301      	movs	r3, #1
    3288:	802b      	strh	r3, [r5, #0]
	while (((const Rtc *)hw)->MODE0.STATUS.bit.SYNCBUSY)
    328a:	7aab      	ldrb	r3, [r5, #10]
    328c:	09db      	lsrs	r3, r3, #7
    328e:	d1fc      	bne.n	328a <_timer_init+0x1a>
	hri_rtcmode0_wait_for_sync(dev->hw);
    3290:	68e2      	ldr	r2, [r4, #12]
    3292:	7a93      	ldrb	r3, [r2, #10]
    3294:	09db      	lsrs	r3, r3, #7
    3296:	d1fc      	bne.n	3292 <_timer_init+0x22>
	((Rtc *)hw)->MODE0.CTRL.reg = data;
    3298:	3380      	adds	r3, #128	; 0x80
    329a:	8013      	strh	r3, [r2, #0]
	while (((const Rtc *)hw)->MODE0.STATUS.bit.SYNCBUSY)
    329c:	7a93      	ldrb	r3, [r2, #10]
    329e:	09db      	lsrs	r3, r3, #7
    32a0:	d1fc      	bne.n	329c <_timer_init+0x2c>
	hri_rtcmode0_write_COMP_COMP_bf(dev->hw, 0, CONF_RTC_COMP_VAL);
    32a2:	68e2      	ldr	r2, [r4, #12]

static inline void hri_rtcmode0_write_COMP_COMP_bf(const void *const hw, uint8_t index, hri_rtcmode0_comp_reg_t data)
{
	uint32_t tmp;
	RTC_CRITICAL_SECTION_ENTER();
	tmp = ((Rtc *)hw)->MODE0.COMP[index].reg;
    32a4:	6993      	ldr	r3, [r2, #24]
	tmp &= ~RTC_MODE0_COMP_COMP_Msk;
	tmp |= RTC_MODE0_COMP_COMP(data);
	((Rtc *)hw)->MODE0.COMP[index].reg = tmp;
    32a6:	23fa      	movs	r3, #250	; 0xfa
    32a8:	009b      	lsls	r3, r3, #2
    32aa:	6193      	str	r3, [r2, #24]
	while (((const Rtc *)hw)->MODE0.STATUS.bit.SYNCBUSY)
    32ac:	7a93      	ldrb	r3, [r2, #10]
    32ae:	09db      	lsrs	r3, r3, #7
    32b0:	d1fc      	bne.n	32ac <_timer_init+0x3c>
	((Rtc *)hw)->MODE0.INTENSET.reg = RTC_MODE0_INTENSET_CMP0;
    32b2:	3301      	adds	r3, #1
    32b4:	68e2      	ldr	r2, [r4, #12]
    32b6:	71d3      	strb	r3, [r2, #7]
	_rtc_dev = dev;
    32b8:	4b03      	ldr	r3, [pc, #12]	; (32c8 <_timer_init+0x58>)
    32ba:	601c      	str	r4, [r3, #0]
}
    32bc:	2000      	movs	r0, #0
    32be:	bd70      	pop	{r4, r5, r6, pc}
    32c0:	0000ac38 	.word	0x0000ac38
    32c4:	000026c1 	.word	0x000026c1
    32c8:	200003c0 	.word	0x200003c0

000032cc <_timer_start>:
{
    32cc:	b510      	push	{r4, lr}
    32ce:	1e04      	subs	r4, r0, #0
	ASSERT(dev && dev->hw);
    32d0:	d020      	beq.n	3314 <_timer_start+0x48>
    32d2:	68c3      	ldr	r3, [r0, #12]
    32d4:	2b00      	cmp	r3, #0
    32d6:	d01b      	beq.n	3310 <_timer_start+0x44>
    32d8:	2001      	movs	r0, #1
    32da:	226a      	movs	r2, #106	; 0x6a
    32dc:	490e      	ldr	r1, [pc, #56]	; (3318 <_timer_start+0x4c>)
    32de:	4b0f      	ldr	r3, [pc, #60]	; (331c <_timer_start+0x50>)
    32e0:	4798      	blx	r3
    32e2:	2208      	movs	r2, #8
    32e4:	4b0e      	ldr	r3, [pc, #56]	; (3320 <_timer_start+0x54>)
    32e6:	601a      	str	r2, [r3, #0]
	hri_rtcmode0_write_COUNT_COUNT_bf(dev->hw, 0);
    32e8:	68e2      	ldr	r2, [r4, #12]
	tmp = ((Rtc *)hw)->MODE0.COUNT.reg;
    32ea:	6913      	ldr	r3, [r2, #16]
	((Rtc *)hw)->MODE0.COUNT.reg = tmp;
    32ec:	2300      	movs	r3, #0
    32ee:	6113      	str	r3, [r2, #16]
	while (((const Rtc *)hw)->MODE0.STATUS.bit.SYNCBUSY)
    32f0:	7a93      	ldrb	r3, [r2, #10]
    32f2:	09db      	lsrs	r3, r3, #7
    32f4:	d1fc      	bne.n	32f0 <_timer_start+0x24>
	hri_rtcmode0_wait_for_sync(dev->hw);
    32f6:	68e2      	ldr	r2, [r4, #12]
    32f8:	7a93      	ldrb	r3, [r2, #10]
    32fa:	09db      	lsrs	r3, r3, #7
    32fc:	d1fc      	bne.n	32f8 <_timer_start+0x2c>
	((Rtc *)hw)->MODE0.CTRL.reg |= RTC_MODE0_CTRL_ENABLE;
    32fe:	8813      	ldrh	r3, [r2, #0]
    3300:	2102      	movs	r1, #2
    3302:	430b      	orrs	r3, r1
    3304:	b29b      	uxth	r3, r3
    3306:	8013      	strh	r3, [r2, #0]
	while (((const Rtc *)hw)->MODE0.STATUS.bit.SYNCBUSY)
    3308:	7a93      	ldrb	r3, [r2, #10]
    330a:	09db      	lsrs	r3, r3, #7
    330c:	d1fc      	bne.n	3308 <_timer_start+0x3c>
}
    330e:	bd10      	pop	{r4, pc}
	ASSERT(dev && dev->hw);
    3310:	2000      	movs	r0, #0
    3312:	e7e2      	b.n	32da <_timer_start+0xe>
    3314:	2000      	movs	r0, #0
    3316:	e7e0      	b.n	32da <_timer_start+0xe>
    3318:	0000ac38 	.word	0x0000ac38
    331c:	000026c1 	.word	0x000026c1
    3320:	e000e100 	.word	0xe000e100

00003324 <_timer_is_started>:
	return hri_rtcmode0_get_CTRL_ENABLE_bit(dev->hw);
    3324:	68c2      	ldr	r2, [r0, #12]
    3326:	7a93      	ldrb	r3, [r2, #10]
    3328:	09db      	lsrs	r3, r3, #7
    332a:	d1fc      	bne.n	3326 <_timer_is_started+0x2>
	tmp = ((Rtc *)hw)->MODE0.CTRL.reg;
    332c:	8813      	ldrh	r3, [r2, #0]
	tmp = (tmp & RTC_MODE0_CTRL_ENABLE) >> RTC_MODE0_CTRL_ENABLE_Pos;
    332e:	085b      	lsrs	r3, r3, #1
	return (bool)tmp;
    3330:	2001      	movs	r0, #1
    3332:	4018      	ands	r0, r3
}
    3334:	4770      	bx	lr

00003336 <_timer_set_irq>:
}
    3336:	4770      	bx	lr

00003338 <_rtc_get_timer>:
 * \brief Retrieve timer helper functions
 */
struct _timer_hpl_interface *_rtc_get_timer(void)
{
	return NULL;
}
    3338:	2000      	movs	r0, #0
    333a:	4770      	bx	lr

0000333c <RTC_Handler>:

/**
 * \brief Rtc interrupt handler
 */
void RTC_Handler(void)
{
    333c:	b510      	push	{r4, lr}
	_rtc_timer_interrupt_handler(_rtc_dev);
    333e:	4b02      	ldr	r3, [pc, #8]	; (3348 <RTC_Handler+0xc>)
    3340:	6818      	ldr	r0, [r3, #0]
    3342:	4b02      	ldr	r3, [pc, #8]	; (334c <RTC_Handler+0x10>)
    3344:	4798      	blx	r3
}
    3346:	bd10      	pop	{r4, pc}
    3348:	200003c0 	.word	0x200003c0
    334c:	00003255 	.word	0x00003255

00003350 <_sercom_get_hardware_index>:
{
#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)SERCOM0) / sizeof(Sercom);
#endif

	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
    3350:	4b02      	ldr	r3, [pc, #8]	; (335c <_sercom_get_hardware_index+0xc>)
    3352:	469c      	mov	ip, r3
    3354:	4460      	add	r0, ip
    3356:	0a80      	lsrs	r0, r0, #10
    3358:	b2c0      	uxtb	r0, r0
}
    335a:	4770      	bx	lr
    335c:	bdfff800 	.word	0xbdfff800

00003360 <_sercom_usart_interrupt_handler>:
 * \internal Sercom interrupt handler
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _sercom_usart_interrupt_handler(struct _usart_async_device *device)
{
    3360:	b510      	push	{r4, lr}
	void *hw = device->hw;
    3362:	6984      	ldr	r4, [r0, #24]
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
}

static inline bool hri_sercomusart_get_interrupt_DRE_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    3364:	7e23      	ldrb	r3, [r4, #24]

	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
    3366:	07db      	lsls	r3, r3, #31
    3368:	d502      	bpl.n	3370 <_sercom_usart_interrupt_handler+0x10>
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
}

static inline bool hri_sercomusart_get_INTEN_DRE_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_DRE) >> SERCOM_USART_INTENSET_DRE_Pos;
    336a:	7da3      	ldrb	r3, [r4, #22]
    336c:	07db      	lsls	r3, r3, #31
    336e:	d40f      	bmi.n	3390 <_sercom_usart_interrupt_handler+0x30>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    3370:	7e23      	ldrb	r3, [r4, #24]
		hri_sercomusart_clear_INTEN_DRE_bit(hw);
		device->usart_cb.tx_byte_sent(device);
	} else if (hri_sercomusart_get_interrupt_TXC_bit(hw) && hri_sercomusart_get_INTEN_TXC_bit(hw)) {
    3372:	079b      	lsls	r3, r3, #30
    3374:	d502      	bpl.n	337c <_sercom_usart_interrupt_handler+0x1c>
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
}

static inline bool hri_sercomusart_get_INTEN_TXC_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_TXC) >> SERCOM_USART_INTENSET_TXC_Pos;
    3376:	7da3      	ldrb	r3, [r4, #22]
    3378:	079b      	lsls	r3, r3, #30
    337a:	d40e      	bmi.n	339a <_sercom_usart_interrupt_handler+0x3a>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    337c:	7e23      	ldrb	r3, [r4, #24]
		hri_sercomusart_clear_INTEN_TXC_bit(hw);
		device->usart_cb.tx_done_cb(device);
	} else if (hri_sercomusart_get_interrupt_RXC_bit(hw)) {
    337e:	075b      	lsls	r3, r3, #29
    3380:	d515      	bpl.n	33ae <_sercom_usart_interrupt_handler+0x4e>
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_status_reg_t hri_sercomusart_read_STATUS_reg(const void *const hw)
{
	return ((Sercom *)hw)->USART.STATUS.reg;
    3382:	8b62      	ldrh	r2, [r4, #26]
		if (hri_sercomusart_read_STATUS_reg(hw)
    3384:	2337      	movs	r3, #55	; 0x37
    3386:	421a      	tst	r2, r3
    3388:	d00c      	beq.n	33a4 <_sercom_usart_interrupt_handler+0x44>
	((Sercom *)hw)->USART.STATUS.reg = mask;
    338a:	3308      	adds	r3, #8
    338c:	8363      	strh	r3, [r4, #26]
		hri_sercomusart_clear_interrupt_ERROR_bit(hw);
		device->usart_cb.error_cb(device);
		status = hri_sercomusart_read_STATUS_reg(hw);
		hri_sercomusart_clear_STATUS_reg(hw, status);
	}
}
    338e:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
    3390:	2301      	movs	r3, #1
    3392:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_byte_sent(device);
    3394:	6803      	ldr	r3, [r0, #0]
    3396:	4798      	blx	r3
    3398:	e7f9      	b.n	338e <_sercom_usart_interrupt_handler+0x2e>
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
    339a:	2302      	movs	r3, #2
    339c:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_done_cb(device);
    339e:	6883      	ldr	r3, [r0, #8]
    33a0:	4798      	blx	r3
    33a2:	e7f4      	b.n	338e <_sercom_usart_interrupt_handler+0x2e>
		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
    33a4:	6843      	ldr	r3, [r0, #4]
	return ((Sercom *)hw)->USART.DATA.reg;
    33a6:	8d21      	ldrh	r1, [r4, #40]	; 0x28
    33a8:	b2c9      	uxtb	r1, r1
    33aa:	4798      	blx	r3
    33ac:	e7ef      	b.n	338e <_sercom_usart_interrupt_handler+0x2e>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_ERROR) >> SERCOM_USART_INTFLAG_ERROR_Pos;
    33ae:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_ERROR_bit(hw)) {
    33b0:	09db      	lsrs	r3, r3, #7
    33b2:	d0ec      	beq.n	338e <_sercom_usart_interrupt_handler+0x2e>
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
    33b4:	2380      	movs	r3, #128	; 0x80
    33b6:	7623      	strb	r3, [r4, #24]
		device->usart_cb.error_cb(device);
    33b8:	68c3      	ldr	r3, [r0, #12]
    33ba:	4798      	blx	r3
	return ((Sercom *)hw)->USART.STATUS.reg;
    33bc:	8b63      	ldrh	r3, [r4, #26]
    33be:	b29b      	uxth	r3, r3
	((Sercom *)hw)->USART.STATUS.reg = mask;
    33c0:	8363      	strh	r3, [r4, #26]
    33c2:	e7e4      	b.n	338e <_sercom_usart_interrupt_handler+0x2e>

000033c4 <_sercom_init_irq_param>:
 * \brief Init irq param with the given sercom hardware instance
 */
static void _sercom_init_irq_param(const void *const hw, void *dev)
{

	if (hw == SERCOM1) {
    33c4:	4b03      	ldr	r3, [pc, #12]	; (33d4 <_sercom_init_irq_param+0x10>)
    33c6:	4298      	cmp	r0, r3
    33c8:	d000      	beq.n	33cc <_sercom_init_irq_param+0x8>
		_sercom1_dev = (struct _usart_async_device *)dev;
	}
}
    33ca:	4770      	bx	lr
		_sercom1_dev = (struct _usart_async_device *)dev;
    33cc:	4b02      	ldr	r3, [pc, #8]	; (33d8 <_sercom_init_irq_param+0x14>)
    33ce:	6019      	str	r1, [r3, #0]
}
    33d0:	e7fb      	b.n	33ca <_sercom_init_irq_param+0x6>
    33d2:	46c0      	nop			; (mov r8, r8)
    33d4:	42000c00 	.word	0x42000c00
    33d8:	200003c4 	.word	0x200003c4

000033dc <_sercom_get_irq_num>:

/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
    33dc:	b510      	push	{r4, lr}
	return SERCOM0_IRQn + _sercom_get_hardware_index(hw);
    33de:	4b02      	ldr	r3, [pc, #8]	; (33e8 <_sercom_get_irq_num+0xc>)
    33e0:	4798      	blx	r3
    33e2:	3009      	adds	r0, #9
    33e4:	b2c0      	uxtb	r0, r0
}
    33e6:	bd10      	pop	{r4, pc}
    33e8:	00003351 	.word	0x00003351

000033ec <_get_sercom_index>:
{
    33ec:	b510      	push	{r4, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    33ee:	4b0b      	ldr	r3, [pc, #44]	; (341c <_get_sercom_index+0x30>)
    33f0:	4798      	blx	r3
    33f2:	0001      	movs	r1, r0
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    33f4:	2000      	movs	r0, #0
    33f6:	2801      	cmp	r0, #1
    33f8:	d809      	bhi.n	340e <_get_sercom_index+0x22>
		if (_usarts[i].number == sercom_offset) {
    33fa:	0083      	lsls	r3, r0, #2
    33fc:	181b      	adds	r3, r3, r0
    33fe:	009a      	lsls	r2, r3, #2
    3400:	4b07      	ldr	r3, [pc, #28]	; (3420 <_get_sercom_index+0x34>)
    3402:	5cd3      	ldrb	r3, [r2, r3]
    3404:	4299      	cmp	r1, r3
    3406:	d008      	beq.n	341a <_get_sercom_index+0x2e>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    3408:	3001      	adds	r0, #1
    340a:	b2c0      	uxtb	r0, r0
    340c:	e7f3      	b.n	33f6 <_get_sercom_index+0xa>
	ASSERT(false);
    340e:	4a05      	ldr	r2, [pc, #20]	; (3424 <_get_sercom_index+0x38>)
    3410:	4905      	ldr	r1, [pc, #20]	; (3428 <_get_sercom_index+0x3c>)
    3412:	2000      	movs	r0, #0
    3414:	4b05      	ldr	r3, [pc, #20]	; (342c <_get_sercom_index+0x40>)
    3416:	4798      	blx	r3
	return 0;
    3418:	2000      	movs	r0, #0
}
    341a:	bd10      	pop	{r4, pc}
    341c:	00003351 	.word	0x00003351
    3420:	0000ac50 	.word	0x0000ac50
    3424:	0000025e 	.word	0x0000025e
    3428:	0000acb4 	.word	0x0000acb4
    342c:	000026c1 	.word	0x000026c1

00003430 <_usart_init>:
{
    3430:	b570      	push	{r4, r5, r6, lr}
    3432:	0004      	movs	r4, r0
	uint8_t i = _get_sercom_index(hw);
    3434:	4b38      	ldr	r3, [pc, #224]	; (3518 <_usart_init+0xe8>)
    3436:	4798      	blx	r3
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
    3438:	69e3      	ldr	r3, [r4, #28]
	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
    343a:	07db      	lsls	r3, r3, #31
    343c:	d41d      	bmi.n	347a <_usart_init+0x4a>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
    343e:	0083      	lsls	r3, r0, #2
    3440:	181b      	adds	r3, r3, r0
    3442:	009a      	lsls	r2, r3, #2
    3444:	4b35      	ldr	r3, [pc, #212]	; (351c <_usart_init+0xec>)
    3446:	189b      	adds	r3, r3, r2
    3448:	685a      	ldr	r2, [r3, #4]
    344a:	231c      	movs	r3, #28
    344c:	401a      	ands	r2, r3
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    344e:	69e3      	ldr	r3, [r4, #28]
    3450:	079b      	lsls	r3, r3, #30
    3452:	d1fc      	bne.n	344e <_usart_init+0x1e>
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
    3454:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    3456:	079b      	lsls	r3, r3, #30
    3458:	d509      	bpl.n	346e <_usart_init+0x3e>
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    345a:	6823      	ldr	r3, [r4, #0]
    345c:	2102      	movs	r1, #2
    345e:	438b      	bics	r3, r1
    3460:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    3462:	69e3      	ldr	r3, [r4, #28]
    3464:	079b      	lsls	r3, r3, #30
    3466:	d1fc      	bne.n	3462 <_usart_init+0x32>
    3468:	69e3      	ldr	r3, [r4, #28]
    346a:	079b      	lsls	r3, r3, #30
    346c:	d4fc      	bmi.n	3468 <_usart_init+0x38>
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
    346e:	2301      	movs	r3, #1
    3470:	4313      	orrs	r3, r2
	((Sercom *)hw)->USART.CTRLA.reg = data;
    3472:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    3474:	69e3      	ldr	r3, [r4, #28]
    3476:	079b      	lsls	r3, r3, #30
    3478:	d1fc      	bne.n	3474 <_usart_init+0x44>
    347a:	69e3      	ldr	r3, [r4, #28]
    347c:	07db      	lsls	r3, r3, #31
    347e:	d4fc      	bmi.n	347a <_usart_init+0x4a>
	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
    3480:	0083      	lsls	r3, r0, #2
    3482:	181b      	adds	r3, r3, r0
    3484:	009a      	lsls	r2, r3, #2
    3486:	4b25      	ldr	r3, [pc, #148]	; (351c <_usart_init+0xec>)
    3488:	189b      	adds	r3, r3, r2
    348a:	685b      	ldr	r3, [r3, #4]
	((Sercom *)hw)->USART.CTRLA.reg = data;
    348c:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    348e:	69e3      	ldr	r3, [r4, #28]
    3490:	079b      	lsls	r3, r3, #30
    3492:	d1fc      	bne.n	348e <_usart_init+0x5e>
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
    3494:	0083      	lsls	r3, r0, #2
    3496:	181b      	adds	r3, r3, r0
    3498:	009a      	lsls	r2, r3, #2
    349a:	4b20      	ldr	r3, [pc, #128]	; (351c <_usart_init+0xec>)
    349c:	189b      	adds	r3, r3, r2
    349e:	689b      	ldr	r3, [r3, #8]
	((Sercom *)hw)->USART.CTRLB.reg = data;
    34a0:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    34a2:	69e3      	ldr	r3, [r4, #28]
    34a4:	075b      	lsls	r3, r3, #29
    34a6:	d1fc      	bne.n	34a2 <_usart_init+0x72>
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
    34a8:	0083      	lsls	r3, r0, #2
    34aa:	181b      	adds	r3, r3, r0
    34ac:	009a      	lsls	r2, r3, #2
    34ae:	4b1b      	ldr	r3, [pc, #108]	; (351c <_usart_init+0xec>)
    34b0:	189b      	adds	r3, r3, r2
    34b2:	685b      	ldr	r3, [r3, #4]
    34b4:	049a      	lsls	r2, r3, #18
    34b6:	d40b      	bmi.n	34d0 <_usart_init+0xa0>
    34b8:	22c0      	movs	r2, #192	; 0xc0
    34ba:	01d2      	lsls	r2, r2, #7
    34bc:	4213      	tst	r3, r2
    34be:	d107      	bne.n	34d0 <_usart_init+0xa0>
		hri_sercomusart_write_BAUD_reg(hw, _usarts[i].baud);
    34c0:	0083      	lsls	r3, r0, #2
    34c2:	181b      	adds	r3, r3, r0
    34c4:	009a      	lsls	r2, r3, #2
    34c6:	4b15      	ldr	r3, [pc, #84]	; (351c <_usart_init+0xec>)
    34c8:	189b      	adds	r3, r3, r2
    34ca:	899b      	ldrh	r3, [r3, #12]
	((Sercom *)hw)->USART.BAUD.reg = data;
    34cc:	81a3      	strh	r3, [r4, #12]
    34ce:	e015      	b.n	34fc <_usart_init+0xcc>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
    34d0:	0083      	lsls	r3, r0, #2
    34d2:	181b      	adds	r3, r3, r0
    34d4:	009a      	lsls	r2, r3, #2
    34d6:	4911      	ldr	r1, [pc, #68]	; (351c <_usart_init+0xec>)
    34d8:	1889      	adds	r1, r1, r2
    34da:	898a      	ldrh	r2, [r1, #12]
    34dc:	89a3      	ldrh	r3, [r4, #12]
    34de:	04d2      	lsls	r2, r2, #19
    34e0:	0cd2      	lsrs	r2, r2, #19
    34e2:	0b5b      	lsrs	r3, r3, #13
    34e4:	035b      	lsls	r3, r3, #13
    34e6:	4313      	orrs	r3, r2
    34e8:	81a3      	strh	r3, [r4, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
    34ea:	7b8b      	ldrb	r3, [r1, #14]
    34ec:	2207      	movs	r2, #7
    34ee:	401a      	ands	r2, r3
    34f0:	89a3      	ldrh	r3, [r4, #12]
    34f2:	0352      	lsls	r2, r2, #13
    34f4:	04db      	lsls	r3, r3, #19
    34f6:	0cdb      	lsrs	r3, r3, #19
    34f8:	4313      	orrs	r3, r2
    34fa:	81a3      	strh	r3, [r4, #12]
	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
    34fc:	4a07      	ldr	r2, [pc, #28]	; (351c <_usart_init+0xec>)
    34fe:	0083      	lsls	r3, r0, #2
    3500:	181d      	adds	r5, r3, r0
    3502:	00a9      	lsls	r1, r5, #2
    3504:	000d      	movs	r5, r1
    3506:	1851      	adds	r1, r2, r1
    3508:	7bc9      	ldrb	r1, [r1, #15]
	((Sercom *)hw)->USART.RXPL.reg = data;
    350a:	73a1      	strb	r1, [r4, #14]
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);
    350c:	1952      	adds	r2, r2, r5
    350e:	7c12      	ldrb	r2, [r2, #16]
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    3510:	2330      	movs	r3, #48	; 0x30
    3512:	54e2      	strb	r2, [r4, r3]
}
    3514:	2000      	movs	r0, #0
    3516:	bd70      	pop	{r4, r5, r6, pc}
    3518:	000033ed 	.word	0x000033ed
    351c:	0000ac50 	.word	0x0000ac50

00003520 <_get_i2cm_index>:
{
    3520:	b510      	push	{r4, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    3522:	4b0e      	ldr	r3, [pc, #56]	; (355c <_get_i2cm_index+0x3c>)
    3524:	4798      	blx	r3
	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
    3526:	2300      	movs	r3, #0
    3528:	2b00      	cmp	r3, #0
    352a:	d008      	beq.n	353e <_get_i2cm_index+0x1e>
	ASSERT(false);
    352c:	22f0      	movs	r2, #240	; 0xf0
    352e:	0092      	lsls	r2, r2, #2
    3530:	490b      	ldr	r1, [pc, #44]	; (3560 <_get_i2cm_index+0x40>)
    3532:	2000      	movs	r0, #0
    3534:	4b0b      	ldr	r3, [pc, #44]	; (3564 <_get_i2cm_index+0x44>)
    3536:	4798      	blx	r3
	return -1;
    3538:	2001      	movs	r0, #1
    353a:	4240      	negs	r0, r0
}
    353c:	bd10      	pop	{r4, pc}
		if (_i2cms[i].number == sercom_offset) {
    353e:	005a      	lsls	r2, r3, #1
    3540:	18d2      	adds	r2, r2, r3
    3542:	00d1      	lsls	r1, r2, #3
    3544:	4a08      	ldr	r2, [pc, #32]	; (3568 <_get_i2cm_index+0x48>)
    3546:	1852      	adds	r2, r2, r1
    3548:	2128      	movs	r1, #40	; 0x28
    354a:	5c52      	ldrb	r2, [r2, r1]
    354c:	4290      	cmp	r0, r2
    354e:	d002      	beq.n	3556 <_get_i2cm_index+0x36>
	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
    3550:	3301      	adds	r3, #1
    3552:	b2db      	uxtb	r3, r3
    3554:	e7e8      	b.n	3528 <_get_i2cm_index+0x8>
			return i;
    3556:	b258      	sxtb	r0, r3
    3558:	e7f0      	b.n	353c <_get_i2cm_index+0x1c>
    355a:	46c0      	nop			; (mov r8, r8)
    355c:	00003351 	.word	0x00003351
    3560:	0000acb4 	.word	0x0000acb4
    3564:	000026c1 	.word	0x000026c1
    3568:	0000ac50 	.word	0x0000ac50

0000356c <_i2c_m_sync_init_impl>:
	}
	return ERR_NONE;
}

static int32_t _i2c_m_sync_init_impl(struct _i2c_m_service *const service, void *const hw)
{
    356c:	b570      	push	{r4, r5, r6, lr}
    356e:	0005      	movs	r5, r0
    3570:	000c      	movs	r4, r1
	uint8_t i = _get_i2cm_index(hw);
    3572:	0008      	movs	r0, r1
    3574:	4b2e      	ldr	r3, [pc, #184]	; (3630 <_i2c_m_sync_init_impl+0xc4>)
    3576:	4798      	blx	r3
    3578:	b2c0      	uxtb	r0, r0
	return ((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg;
    357a:	69e3      	ldr	r3, [r4, #28]

	if (!hri_sercomi2cm_is_syncing(hw, SERCOM_I2CM_SYNCBUSY_SWRST)) {
    357c:	07db      	lsls	r3, r3, #31
    357e:	d41d      	bmi.n	35bc <_i2c_m_sync_init_impl+0x50>
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
    3580:	0043      	lsls	r3, r0, #1
    3582:	181b      	adds	r3, r3, r0
    3584:	00da      	lsls	r2, r3, #3
    3586:	4b2b      	ldr	r3, [pc, #172]	; (3634 <_i2c_m_sync_init_impl+0xc8>)
    3588:	189b      	adds	r3, r3, r2
    358a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    358c:	231c      	movs	r3, #28
    358e:	401a      	ands	r2, r3
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3590:	69e3      	ldr	r3, [r4, #28]
    3592:	079b      	lsls	r3, r3, #30
    3594:	d1fc      	bne.n	3590 <_i2c_m_sync_init_impl+0x24>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    3596:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
    3598:	079b      	lsls	r3, r3, #30
    359a:	d509      	bpl.n	35b0 <_i2c_m_sync_init_impl+0x44>
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
    359c:	6823      	ldr	r3, [r4, #0]
    359e:	2102      	movs	r1, #2
    35a0:	438b      	bics	r3, r1
    35a2:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    35a4:	69e3      	ldr	r3, [r4, #28]
    35a6:	079b      	lsls	r3, r3, #30
    35a8:	d1fc      	bne.n	35a4 <_i2c_m_sync_init_impl+0x38>
    35aa:	69e3      	ldr	r3, [r4, #28]
    35ac:	079b      	lsls	r3, r3, #30
    35ae:	d4fc      	bmi.n	35aa <_i2c_m_sync_init_impl+0x3e>
			hri_sercomi2cm_clear_CTRLA_ENABLE_bit(hw);
			hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_ENABLE);
		}
		hri_sercomi2cm_write_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_SWRST | mode);
    35b0:	2301      	movs	r3, #1
    35b2:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
    35b4:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    35b6:	69e3      	ldr	r3, [r4, #28]
    35b8:	079b      	lsls	r3, r3, #30
    35ba:	d1fc      	bne.n	35b6 <_i2c_m_sync_init_impl+0x4a>
    35bc:	69e3      	ldr	r3, [r4, #28]
    35be:	07db      	lsls	r3, r3, #31
    35c0:	d4fc      	bmi.n	35bc <_i2c_m_sync_init_impl+0x50>
	}
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST);

	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a);
    35c2:	0043      	lsls	r3, r0, #1
    35c4:	181b      	adds	r3, r3, r0
    35c6:	00da      	lsls	r2, r3, #3
    35c8:	4b1a      	ldr	r3, [pc, #104]	; (3634 <_i2c_m_sync_init_impl+0xc8>)
    35ca:	189b      	adds	r3, r3, r2
    35cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
    35ce:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    35d0:	69e3      	ldr	r3, [r4, #28]
    35d2:	079b      	lsls	r3, r3, #30
    35d4:	d1fc      	bne.n	35d0 <_i2c_m_sync_init_impl+0x64>
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
    35d6:	0043      	lsls	r3, r0, #1
    35d8:	181b      	adds	r3, r3, r0
    35da:	00da      	lsls	r2, r3, #3
    35dc:	4b15      	ldr	r3, [pc, #84]	; (3634 <_i2c_m_sync_init_impl+0xc8>)
    35de:	189b      	adds	r3, r3, r2
    35e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
    35e2:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    35e4:	69e3      	ldr	r3, [r4, #28]
    35e6:	075b      	lsls	r3, r3, #29
    35e8:	d4fc      	bmi.n	35e4 <_i2c_m_sync_init_impl+0x78>
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
    35ea:	0042      	lsls	r2, r0, #1
    35ec:	1812      	adds	r2, r2, r0
    35ee:	00d1      	lsls	r1, r2, #3
    35f0:	4b10      	ldr	r3, [pc, #64]	; (3634 <_i2c_m_sync_init_impl+0xc8>)
    35f2:	185b      	adds	r3, r3, r1
	((Sercom *)hw)->I2CM.BAUD.reg = data;
    35f4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    35f6:	60e2      	str	r2, [r4, #12]

	service->mode = (_i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_SPEED_Msk) >> SERCOM_I2CM_CTRLA_SPEED_Pos;
    35f8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    35fa:	0e12      	lsrs	r2, r2, #24
    35fc:	2303      	movs	r3, #3
    35fe:	401a      	ands	r2, r3
    3600:	81aa      	strh	r2, [r5, #12]
	hri_sercomi2cm_write_ADDR_HS_bit(hw, service->mode < I2C_HS ? 0 : 1);
    3602:	3b02      	subs	r3, #2
    3604:	4293      	cmp	r3, r2
    3606:	419b      	sbcs	r3, r3
    3608:	425b      	negs	r3, r3
	tmp = ((Sercom *)hw)->I2CM.ADDR.reg;
    360a:	6a62      	ldr	r2, [r4, #36]	; 0x24
	tmp &= ~SERCOM_I2CM_ADDR_HS;
    360c:	490a      	ldr	r1, [pc, #40]	; (3638 <_i2c_m_sync_init_impl+0xcc>)
    360e:	400a      	ands	r2, r1
	tmp |= value << SERCOM_I2CM_ADDR_HS_Pos;
    3610:	039b      	lsls	r3, r3, #14
    3612:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = tmp;
    3614:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3616:	69e3      	ldr	r3, [r4, #28]
    3618:	075b      	lsls	r3, r3, #29
    361a:	d4fc      	bmi.n	3616 <_i2c_m_sync_init_impl+0xaa>

	service->trise = _i2cms[i].trise;
    361c:	0043      	lsls	r3, r0, #1
    361e:	1818      	adds	r0, r3, r0
    3620:	00c2      	lsls	r2, r0, #3
    3622:	4b04      	ldr	r3, [pc, #16]	; (3634 <_i2c_m_sync_init_impl+0xc8>)
    3624:	189b      	adds	r3, r3, r2
    3626:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
    3628:	81eb      	strh	r3, [r5, #14]

	return ERR_NONE;
}
    362a:	2000      	movs	r0, #0
    362c:	bd70      	pop	{r4, r5, r6, pc}
    362e:	46c0      	nop			; (mov r8, r8)
    3630:	00003521 	.word	0x00003521
    3634:	0000ac50 	.word	0x0000ac50
    3638:	ffffbfff 	.word	0xffffbfff

0000363c <_sercom_i2c_sync_send_address>:
{
    363c:	b570      	push	{r4, r5, r6, lr}
    363e:	0005      	movs	r5, r0
	void *             hw    = i2c_dev->hw;
    3640:	6904      	ldr	r4, [r0, #16]
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    3642:	6823      	ldr	r3, [r4, #0]
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
    3644:	0edb      	lsrs	r3, r3, #27
    3646:	2601      	movs	r6, #1
    3648:	401e      	ands	r6, r3
	ASSERT(i2c_dev);
    364a:	1e43      	subs	r3, r0, #1
    364c:	4198      	sbcs	r0, r3
    364e:	b2c0      	uxtb	r0, r0
    3650:	4a8e      	ldr	r2, [pc, #568]	; (388c <_sercom_i2c_sync_send_address+0x250>)
    3652:	498f      	ldr	r1, [pc, #572]	; (3890 <_sercom_i2c_sync_send_address+0x254>)
    3654:	4b8f      	ldr	r3, [pc, #572]	; (3894 <_sercom_i2c_sync_send_address+0x258>)
    3656:	4798      	blx	r3
	if (msg->len == 1 && sclsm) {
    3658:	686b      	ldr	r3, [r5, #4]
    365a:	2b01      	cmp	r3, #1
    365c:	d04d      	beq.n	36fa <_sercom_i2c_sync_send_address+0xbe>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    365e:	6863      	ldr	r3, [r4, #4]
    3660:	4a8d      	ldr	r2, [pc, #564]	; (3898 <_sercom_i2c_sync_send_address+0x25c>)
    3662:	4013      	ands	r3, r2
    3664:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3666:	69e3      	ldr	r3, [r4, #28]
    3668:	075b      	lsls	r3, r3, #29
    366a:	d4fc      	bmi.n	3666 <_sercom_i2c_sync_send_address+0x2a>
	if (msg->addr & I2C_M_TEN) {
    366c:	882b      	ldrh	r3, [r5, #0]
    366e:	055a      	lsls	r2, r3, #21
    3670:	d54e      	bpl.n	3710 <_sercom_i2c_sync_send_address+0xd4>
		if (msg->flags & I2C_M_RD) {
    3672:	886a      	ldrh	r2, [r5, #2]
    3674:	07d2      	lsls	r2, r2, #31
    3676:	d504      	bpl.n	3682 <_sercom_i2c_sync_send_address+0x46>
			msg->flags |= I2C_M_TEN;
    3678:	886a      	ldrh	r2, [r5, #2]
    367a:	2180      	movs	r1, #128	; 0x80
    367c:	00c9      	lsls	r1, r1, #3
    367e:	430a      	orrs	r2, r1
    3680:	806a      	strh	r2, [r5, #2]
		                              ((msg->addr & TEN_ADDR_MASK) << 1) | SERCOM_I2CM_ADDR_TENBITEN
    3682:	005b      	lsls	r3, r3, #1
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    3684:	4a85      	ldr	r2, [pc, #532]	; (389c <_sercom_i2c_sync_send_address+0x260>)
    3686:	401a      	ands	r2, r3
    3688:	69e3      	ldr	r3, [r4, #28]
    368a:	075b      	lsls	r3, r3, #29
    368c:	d4fc      	bmi.n	3688 <_sercom_i2c_sync_send_address+0x4c>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    368e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    3690:	2180      	movs	r1, #128	; 0x80
    3692:	01c9      	lsls	r1, r1, #7
    3694:	400b      	ands	r3, r1
    3696:	4313      	orrs	r3, r2
		hri_sercomi2cm_write_ADDR_reg(hw,
    3698:	2280      	movs	r2, #128	; 0x80
    369a:	0212      	lsls	r2, r2, #8
    369c:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    369e:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    36a0:	69e3      	ldr	r3, [r4, #28]
    36a2:	075b      	lsls	r3, r3, #29
    36a4:	d4fc      	bmi.n	36a0 <_sercom_i2c_sync_send_address+0x64>
	void *   hw      = i2c_dev->hw;
    36a6:	692e      	ldr	r6, [r5, #16]
	uint32_t timeout = 65535;
    36a8:	4a7d      	ldr	r2, [pc, #500]	; (38a0 <_sercom_i2c_sync_send_address+0x264>)
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
    36aa:	7e33      	ldrb	r3, [r6, #24]
    36ac:	b2db      	uxtb	r3, r3
		*flags = hri_sercomi2cm_read_INTFLAG_reg(hw);
    36ae:	0018      	movs	r0, r3
		if (timeout-- == 0) {
    36b0:	1e51      	subs	r1, r2, #1
    36b2:	2a00      	cmp	r2, #0
    36b4:	d002      	beq.n	36bc <_sercom_i2c_sync_send_address+0x80>
    36b6:	000a      	movs	r2, r1
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
    36b8:	079b      	lsls	r3, r3, #30
    36ba:	d0f6      	beq.n	36aa <_sercom_i2c_sync_send_address+0x6e>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    36bc:	6823      	ldr	r3, [r4, #0]
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
    36be:	0edb      	lsrs	r3, r3, #27
    36c0:	2201      	movs	r2, #1
    36c2:	401a      	ands	r2, r3
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    36c4:	69e3      	ldr	r3, [r4, #28]
    36c6:	075b      	lsls	r3, r3, #29
    36c8:	d4fc      	bmi.n	36c4 <_sercom_i2c_sync_send_address+0x88>
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	return ((Sercom *)hw)->I2CM.STATUS.reg;
    36ca:	8b63      	ldrh	r3, [r4, #26]
    36cc:	b29b      	uxth	r3, r3
	if (flags & MB_FLAG) {
    36ce:	07c1      	lsls	r1, r0, #31
    36d0:	d400      	bmi.n	36d4 <_sercom_i2c_sync_send_address+0x98>
    36d2:	e08f      	b.n	37f4 <_sercom_i2c_sync_send_address+0x1b8>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
    36d4:	079a      	lsls	r2, r3, #30
    36d6:	d52f      	bpl.n	3738 <_sercom_i2c_sync_send_address+0xfc>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    36d8:	2201      	movs	r2, #1
    36da:	7622      	strb	r2, [r4, #24]
			msg->flags |= I2C_M_FAIL;
    36dc:	886a      	ldrh	r2, [r5, #2]
    36de:	2180      	movs	r1, #128	; 0x80
    36e0:	0149      	lsls	r1, r1, #5
    36e2:	430a      	orrs	r2, r1
    36e4:	806a      	strh	r2, [r5, #2]
			msg->flags &= ~I2C_M_BUSY;
    36e6:	886a      	ldrh	r2, [r5, #2]
    36e8:	496e      	ldr	r1, [pc, #440]	; (38a4 <_sercom_i2c_sync_send_address+0x268>)
    36ea:	400a      	ands	r2, r1
    36ec:	806a      	strh	r2, [r5, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
    36ee:	07db      	lsls	r3, r3, #31
    36f0:	d400      	bmi.n	36f4 <_sercom_i2c_sync_send_address+0xb8>
    36f2:	e0c6      	b.n	3882 <_sercom_i2c_sync_send_address+0x246>
				return I2C_ERR_BUS;
    36f4:	2005      	movs	r0, #5
    36f6:	4240      	negs	r0, r0
    36f8:	e0a2      	b.n	3840 <_sercom_i2c_sync_send_address+0x204>
	if (msg->len == 1 && sclsm) {
    36fa:	2e00      	cmp	r6, #0
    36fc:	d0af      	beq.n	365e <_sercom_i2c_sync_send_address+0x22>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    36fe:	6862      	ldr	r2, [r4, #4]
    3700:	2380      	movs	r3, #128	; 0x80
    3702:	02db      	lsls	r3, r3, #11
    3704:	4313      	orrs	r3, r2
    3706:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3708:	69e3      	ldr	r3, [r4, #28]
    370a:	075b      	lsls	r3, r3, #29
    370c:	d4fc      	bmi.n	3708 <_sercom_i2c_sync_send_address+0xcc>
    370e:	e7ad      	b.n	366c <_sercom_i2c_sync_send_address+0x30>
		                              ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0)
    3710:	005b      	lsls	r3, r3, #1
    3712:	22ff      	movs	r2, #255	; 0xff
    3714:	4013      	ands	r3, r2
    3716:	886a      	ldrh	r2, [r5, #2]
    3718:	2101      	movs	r1, #1
    371a:	400a      	ands	r2, r1
    371c:	431a      	orrs	r2, r3
    371e:	69e3      	ldr	r3, [r4, #28]
    3720:	075b      	lsls	r3, r3, #29
    3722:	d4fc      	bmi.n	371e <_sercom_i2c_sync_send_address+0xe2>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    3724:	6a63      	ldr	r3, [r4, #36]	; 0x24
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    3726:	2180      	movs	r1, #128	; 0x80
    3728:	01c9      	lsls	r1, r1, #7
    372a:	400b      	ands	r3, r1
		hri_sercomi2cm_write_ADDR_reg(hw,
    372c:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    372e:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3730:	69e3      	ldr	r3, [r4, #28]
    3732:	075b      	lsls	r3, r3, #29
    3734:	d4fc      	bmi.n	3730 <_sercom_i2c_sync_send_address+0xf4>
    3736:	e7b6      	b.n	36a6 <_sercom_i2c_sync_send_address+0x6a>
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
    3738:	075b      	lsls	r3, r3, #29
    373a:	d41b      	bmi.n	3774 <_sercom_i2c_sync_send_address+0x138>
			if (msg->flags & I2C_M_TEN) {
    373c:	886b      	ldrh	r3, [r5, #2]
    373e:	055b      	lsls	r3, r3, #21
    3740:	d534      	bpl.n	37ac <_sercom_i2c_sync_send_address+0x170>
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
    3742:	882a      	ldrh	r2, [r5, #0]
    3744:	1212      	asrs	r2, r2, #8
    3746:	0052      	lsls	r2, r2, #1
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    3748:	2306      	movs	r3, #6
    374a:	401a      	ands	r2, r3
    374c:	69e3      	ldr	r3, [r4, #28]
    374e:	075b      	lsls	r3, r3, #29
    3750:	d4fc      	bmi.n	374c <_sercom_i2c_sync_send_address+0x110>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    3752:	6a63      	ldr	r3, [r4, #36]	; 0x24
    3754:	2180      	movs	r1, #128	; 0x80
    3756:	01c9      	lsls	r1, r1, #7
    3758:	400b      	ands	r3, r1
    375a:	4313      	orrs	r3, r2
				hri_sercomi2cm_write_ADDR_reg(hw,
    375c:	22f1      	movs	r2, #241	; 0xf1
    375e:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    3760:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3762:	69e3      	ldr	r3, [r4, #28]
    3764:	075b      	lsls	r3, r3, #29
    3766:	d4fc      	bmi.n	3762 <_sercom_i2c_sync_send_address+0x126>
				msg->flags &= ~I2C_M_TEN;
    3768:	886b      	ldrh	r3, [r5, #2]
    376a:	4a4f      	ldr	r2, [pc, #316]	; (38a8 <_sercom_i2c_sync_send_address+0x26c>)
    376c:	4013      	ands	r3, r2
    376e:	806b      	strh	r3, [r5, #2]
				return I2C_OK;
    3770:	2000      	movs	r0, #0
    3772:	e065      	b.n	3840 <_sercom_i2c_sync_send_address+0x204>
				if (msg->len > 0) {
    3774:	686b      	ldr	r3, [r5, #4]
    3776:	2b00      	cmp	r3, #0
    3778:	dd04      	ble.n	3784 <_sercom_i2c_sync_send_address+0x148>
					msg->flags |= I2C_M_FAIL;
    377a:	886b      	ldrh	r3, [r5, #2]
    377c:	2280      	movs	r2, #128	; 0x80
    377e:	0152      	lsls	r2, r2, #5
    3780:	4313      	orrs	r3, r2
    3782:	806b      	strh	r3, [r5, #2]
				if (msg->flags & I2C_M_STOP) {
    3784:	886b      	ldrh	r3, [r5, #2]
    3786:	b21b      	sxth	r3, r3
    3788:	2b00      	cmp	r3, #0
    378a:	db06      	blt.n	379a <_sercom_i2c_sync_send_address+0x15e>
				msg->flags &= ~I2C_M_BUSY;
    378c:	886b      	ldrh	r3, [r5, #2]
    378e:	4a45      	ldr	r2, [pc, #276]	; (38a4 <_sercom_i2c_sync_send_address+0x268>)
    3790:	4013      	ands	r3, r2
    3792:	806b      	strh	r3, [r5, #2]
				return I2C_NACK;
    3794:	2002      	movs	r0, #2
    3796:	4240      	negs	r0, r0
    3798:	e052      	b.n	3840 <_sercom_i2c_sync_send_address+0x204>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    379a:	6862      	ldr	r2, [r4, #4]
    379c:	23c0      	movs	r3, #192	; 0xc0
    379e:	029b      	lsls	r3, r3, #10
    37a0:	4313      	orrs	r3, r2
    37a2:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    37a4:	69e3      	ldr	r3, [r4, #28]
    37a6:	075b      	lsls	r3, r3, #29
    37a8:	d4fc      	bmi.n	37a4 <_sercom_i2c_sync_send_address+0x168>
    37aa:	e7ef      	b.n	378c <_sercom_i2c_sync_send_address+0x150>
			if (msg->len == 0) {
    37ac:	6868      	ldr	r0, [r5, #4]
    37ae:	2800      	cmp	r0, #0
    37b0:	d111      	bne.n	37d6 <_sercom_i2c_sync_send_address+0x19a>
				if (msg->flags & I2C_M_STOP) {
    37b2:	886b      	ldrh	r3, [r5, #2]
    37b4:	b21b      	sxth	r3, r3
    37b6:	2b00      	cmp	r3, #0
    37b8:	db04      	blt.n	37c4 <_sercom_i2c_sync_send_address+0x188>
				msg->flags &= ~I2C_M_BUSY;
    37ba:	886b      	ldrh	r3, [r5, #2]
    37bc:	4a39      	ldr	r2, [pc, #228]	; (38a4 <_sercom_i2c_sync_send_address+0x268>)
    37be:	4013      	ands	r3, r2
    37c0:	806b      	strh	r3, [r5, #2]
    37c2:	e03d      	b.n	3840 <_sercom_i2c_sync_send_address+0x204>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    37c4:	6862      	ldr	r2, [r4, #4]
    37c6:	23c0      	movs	r3, #192	; 0xc0
    37c8:	029b      	lsls	r3, r3, #10
    37ca:	4313      	orrs	r3, r2
    37cc:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    37ce:	69e3      	ldr	r3, [r4, #28]
    37d0:	075b      	lsls	r3, r3, #29
    37d2:	d4fc      	bmi.n	37ce <_sercom_i2c_sync_send_address+0x192>
    37d4:	e7f1      	b.n	37ba <_sercom_i2c_sync_send_address+0x17e>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
    37d6:	68ab      	ldr	r3, [r5, #8]
    37d8:	781a      	ldrb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
    37da:	2328      	movs	r3, #40	; 0x28
    37dc:	54e2      	strb	r2, [r4, r3]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    37de:	69e3      	ldr	r3, [r4, #28]
    37e0:	075b      	lsls	r3, r3, #29
    37e2:	d4fc      	bmi.n	37de <_sercom_i2c_sync_send_address+0x1a2>
				msg->buffer++;
    37e4:	68ab      	ldr	r3, [r5, #8]
    37e6:	3301      	adds	r3, #1
    37e8:	60ab      	str	r3, [r5, #8]
				msg->len--;
    37ea:	686b      	ldr	r3, [r5, #4]
    37ec:	3b01      	subs	r3, #1
    37ee:	606b      	str	r3, [r5, #4]
			return I2C_OK;
    37f0:	2000      	movs	r0, #0
    37f2:	e025      	b.n	3840 <_sercom_i2c_sync_send_address+0x204>
	} else if (flags & SB_FLAG) {
    37f4:	0781      	lsls	r1, r0, #30
    37f6:	d547      	bpl.n	3888 <_sercom_i2c_sync_send_address+0x24c>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
    37f8:	6869      	ldr	r1, [r5, #4]
    37fa:	2900      	cmp	r1, #0
    37fc:	d03c      	beq.n	3878 <_sercom_i2c_sync_send_address+0x23c>
    37fe:	075b      	lsls	r3, r3, #29
    3800:	d43a      	bmi.n	3878 <_sercom_i2c_sync_send_address+0x23c>
			msg->len--;
    3802:	3901      	subs	r1, #1
    3804:	6069      	str	r1, [r5, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    3806:	2900      	cmp	r1, #0
    3808:	d101      	bne.n	380e <_sercom_i2c_sync_send_address+0x1d2>
    380a:	2a00      	cmp	r2, #0
    380c:	d01b      	beq.n	3846 <_sercom_i2c_sync_send_address+0x20a>
    380e:	2901      	cmp	r1, #1
    3810:	d017      	beq.n	3842 <_sercom_i2c_sync_send_address+0x206>
			if (msg->len == 0) {
    3812:	686b      	ldr	r3, [r5, #4]
    3814:	2b00      	cmp	r3, #0
    3816:	d107      	bne.n	3828 <_sercom_i2c_sync_send_address+0x1ec>
				if (msg->flags & I2C_M_STOP) {
    3818:	886b      	ldrh	r3, [r5, #2]
    381a:	b21b      	sxth	r3, r3
    381c:	2b00      	cmp	r3, #0
    381e:	db1b      	blt.n	3858 <_sercom_i2c_sync_send_address+0x21c>
				msg->flags &= ~I2C_M_BUSY;
    3820:	886b      	ldrh	r3, [r5, #2]
    3822:	4a20      	ldr	r2, [pc, #128]	; (38a4 <_sercom_i2c_sync_send_address+0x268>)
    3824:	4013      	ands	r3, r2
    3826:	806b      	strh	r3, [r5, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
    3828:	68aa      	ldr	r2, [r5, #8]
    382a:	1c53      	adds	r3, r2, #1
    382c:	60ab      	str	r3, [r5, #8]
    382e:	69e3      	ldr	r3, [r4, #28]
    3830:	075b      	lsls	r3, r3, #29
    3832:	d4fc      	bmi.n	382e <_sercom_i2c_sync_send_address+0x1f2>
	return ((Sercom *)hw)->I2CM.DATA.reg;
    3834:	2328      	movs	r3, #40	; 0x28
    3836:	5ce3      	ldrb	r3, [r4, r3]
    3838:	7013      	strb	r3, [r2, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    383a:	2302      	movs	r3, #2
    383c:	7623      	strb	r3, [r4, #24]
	return I2C_OK;
    383e:	2000      	movs	r0, #0
}
    3840:	bd70      	pop	{r4, r5, r6, pc}
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    3842:	2a00      	cmp	r2, #0
    3844:	d0e5      	beq.n	3812 <_sercom_i2c_sync_send_address+0x1d6>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    3846:	6862      	ldr	r2, [r4, #4]
    3848:	2380      	movs	r3, #128	; 0x80
    384a:	02db      	lsls	r3, r3, #11
    384c:	4313      	orrs	r3, r2
    384e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3850:	69e3      	ldr	r3, [r4, #28]
    3852:	075b      	lsls	r3, r3, #29
    3854:	d4fc      	bmi.n	3850 <_sercom_i2c_sync_send_address+0x214>
    3856:	e7dc      	b.n	3812 <_sercom_i2c_sync_send_address+0x1d6>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
    3858:	6863      	ldr	r3, [r4, #4]
    385a:	4a12      	ldr	r2, [pc, #72]	; (38a4 <_sercom_i2c_sync_send_address+0x268>)
    385c:	4013      	ands	r3, r2
    385e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3860:	69e3      	ldr	r3, [r4, #28]
    3862:	075b      	lsls	r3, r3, #29
    3864:	d4fc      	bmi.n	3860 <_sercom_i2c_sync_send_address+0x224>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    3866:	6862      	ldr	r2, [r4, #4]
    3868:	23c0      	movs	r3, #192	; 0xc0
    386a:	029b      	lsls	r3, r3, #10
    386c:	4313      	orrs	r3, r2
    386e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3870:	69e3      	ldr	r3, [r4, #28]
    3872:	075b      	lsls	r3, r3, #29
    3874:	d4fc      	bmi.n	3870 <_sercom_i2c_sync_send_address+0x234>
    3876:	e7d3      	b.n	3820 <_sercom_i2c_sync_send_address+0x1e4>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    3878:	2302      	movs	r3, #2
    387a:	7623      	strb	r3, [r4, #24]
			return I2C_NACK;
    387c:	2002      	movs	r0, #2
    387e:	4240      	negs	r0, r0
    3880:	e7de      	b.n	3840 <_sercom_i2c_sync_send_address+0x204>
			return I2C_ERR_BAD_ADDRESS;
    3882:	2004      	movs	r0, #4
    3884:	4240      	negs	r0, r0
    3886:	e7db      	b.n	3840 <_sercom_i2c_sync_send_address+0x204>
	return I2C_OK;
    3888:	2000      	movs	r0, #0
	return _sercom_i2c_sync_analyse_flags(hw, flags, msg);
    388a:	e7d9      	b.n	3840 <_sercom_i2c_sync_send_address+0x204>
    388c:	000005bc 	.word	0x000005bc
    3890:	0000acb4 	.word	0x0000acb4
    3894:	000026c1 	.word	0x000026c1
    3898:	fffbffff 	.word	0xfffbffff
    389c:	000007fe 	.word	0x000007fe
    38a0:	0000ffff 	.word	0x0000ffff
    38a4:	fffffeff 	.word	0xfffffeff
    38a8:	fffffbff 	.word	0xfffffbff

000038ac <_usart_sync_init>:
{
    38ac:	b570      	push	{r4, r5, r6, lr}
    38ae:	0005      	movs	r5, r0
    38b0:	000c      	movs	r4, r1
	ASSERT(device);
    38b2:	1e43      	subs	r3, r0, #1
    38b4:	4198      	sbcs	r0, r3
    38b6:	b2c0      	uxtb	r0, r0
    38b8:	22b6      	movs	r2, #182	; 0xb6
    38ba:	4904      	ldr	r1, [pc, #16]	; (38cc <_usart_sync_init+0x20>)
    38bc:	4b04      	ldr	r3, [pc, #16]	; (38d0 <_usart_sync_init+0x24>)
    38be:	4798      	blx	r3
	device->hw = hw;
    38c0:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
    38c2:	0020      	movs	r0, r4
    38c4:	4b03      	ldr	r3, [pc, #12]	; (38d4 <_usart_sync_init+0x28>)
    38c6:	4798      	blx	r3
}
    38c8:	bd70      	pop	{r4, r5, r6, pc}
    38ca:	46c0      	nop			; (mov r8, r8)
    38cc:	0000acb4 	.word	0x0000acb4
    38d0:	000026c1 	.word	0x000026c1
    38d4:	00003431 	.word	0x00003431

000038d8 <_usart_async_init>:
{
    38d8:	b570      	push	{r4, r5, r6, lr}
    38da:	0006      	movs	r6, r0
    38dc:	000c      	movs	r4, r1
	ASSERT(device);
    38de:	1e43      	subs	r3, r0, #1
    38e0:	4198      	sbcs	r0, r3
    38e2:	b2c0      	uxtb	r0, r0
    38e4:	22c4      	movs	r2, #196	; 0xc4
    38e6:	4919      	ldr	r1, [pc, #100]	; (394c <_usart_async_init+0x74>)
    38e8:	4b19      	ldr	r3, [pc, #100]	; (3950 <_usart_async_init+0x78>)
    38ea:	4798      	blx	r3
	init_status = _usart_init(hw);
    38ec:	0020      	movs	r0, r4
    38ee:	4b19      	ldr	r3, [pc, #100]	; (3954 <_usart_async_init+0x7c>)
    38f0:	4798      	blx	r3
    38f2:	1e05      	subs	r5, r0, #0
	if (init_status) {
    38f4:	d001      	beq.n	38fa <_usart_async_init+0x22>
}
    38f6:	0028      	movs	r0, r5
    38f8:	bd70      	pop	{r4, r5, r6, pc}
	device->hw = hw;
    38fa:	61b4      	str	r4, [r6, #24]
	_sercom_init_irq_param(hw, (void *)device);
    38fc:	0031      	movs	r1, r6
    38fe:	0020      	movs	r0, r4
    3900:	4b15      	ldr	r3, [pc, #84]	; (3958 <_usart_async_init+0x80>)
    3902:	4798      	blx	r3
	NVIC_DisableIRQ((IRQn_Type)_sercom_get_irq_num(hw));
    3904:	0020      	movs	r0, r4
    3906:	4b15      	ldr	r3, [pc, #84]	; (395c <_usart_async_init+0x84>)
    3908:	4798      	blx	r3
    390a:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    390c:	2b00      	cmp	r3, #0
    390e:	db0a      	blt.n	3926 <_usart_async_init+0x4e>
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    3910:	211f      	movs	r1, #31
    3912:	4001      	ands	r1, r0
    3914:	2201      	movs	r2, #1
    3916:	408a      	lsls	r2, r1
    3918:	2180      	movs	r1, #128	; 0x80
    391a:	4c11      	ldr	r4, [pc, #68]	; (3960 <_usart_async_init+0x88>)
    391c:	5062      	str	r2, [r4, r1]
  __ASM volatile ("dsb 0xF":::"memory");
    391e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    3922:	f3bf 8f6f 	isb	sy
  if ((int32_t)(IRQn) >= 0)
    3926:	2b00      	cmp	r3, #0
    3928:	db07      	blt.n	393a <_usart_async_init+0x62>
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    392a:	211f      	movs	r1, #31
    392c:	4001      	ands	r1, r0
    392e:	2201      	movs	r2, #1
    3930:	408a      	lsls	r2, r1
    3932:	21c0      	movs	r1, #192	; 0xc0
    3934:	0049      	lsls	r1, r1, #1
    3936:	4c0a      	ldr	r4, [pc, #40]	; (3960 <_usart_async_init+0x88>)
    3938:	5062      	str	r2, [r4, r1]
  if ((int32_t)(IRQn) >= 0)
    393a:	2b00      	cmp	r3, #0
    393c:	dbdb      	blt.n	38f6 <_usart_async_init+0x1e>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    393e:	231f      	movs	r3, #31
    3940:	4018      	ands	r0, r3
    3942:	3b1e      	subs	r3, #30
    3944:	4083      	lsls	r3, r0
    3946:	4a06      	ldr	r2, [pc, #24]	; (3960 <_usart_async_init+0x88>)
    3948:	6013      	str	r3, [r2, #0]
    394a:	e7d4      	b.n	38f6 <_usart_async_init+0x1e>
    394c:	0000acb4 	.word	0x0000acb4
    3950:	000026c1 	.word	0x000026c1
    3954:	00003431 	.word	0x00003431
    3958:	000033c5 	.word	0x000033c5
    395c:	000033dd 	.word	0x000033dd
    3960:	e000e100 	.word	0xe000e100

00003964 <_usart_sync_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    3964:	6802      	ldr	r2, [r0, #0]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    3966:	6813      	ldr	r3, [r2, #0]
    3968:	2102      	movs	r1, #2
    396a:	430b      	orrs	r3, r1
    396c:	6013      	str	r3, [r2, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    396e:	69d3      	ldr	r3, [r2, #28]
    3970:	079b      	lsls	r3, r3, #30
    3972:	d1fc      	bne.n	396e <_usart_sync_enable+0xa>
}
    3974:	4770      	bx	lr

00003976 <_usart_async_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    3976:	6982      	ldr	r2, [r0, #24]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    3978:	6813      	ldr	r3, [r2, #0]
    397a:	2102      	movs	r1, #2
    397c:	430b      	orrs	r3, r1
    397e:	6013      	str	r3, [r2, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    3980:	69d3      	ldr	r3, [r2, #28]
    3982:	079b      	lsls	r3, r3, #30
    3984:	d1fc      	bne.n	3980 <_usart_async_enable+0xa>
}
    3986:	4770      	bx	lr

00003988 <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    3988:	6803      	ldr	r3, [r0, #0]
    398a:	b289      	uxth	r1, r1
	((Sercom *)hw)->USART.DATA.reg = data;
    398c:	8519      	strh	r1, [r3, #40]	; 0x28
}
    398e:	4770      	bx	lr

00003990 <_usart_async_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    3990:	6983      	ldr	r3, [r0, #24]
    3992:	b289      	uxth	r1, r1
    3994:	8519      	strh	r1, [r3, #40]	; 0x28
}
    3996:	4770      	bx	lr

00003998 <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
    3998:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
    399a:	8d18      	ldrh	r0, [r3, #40]	; 0x28
    399c:	b2c0      	uxtb	r0, r0
}
    399e:	4770      	bx	lr

000039a0 <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    39a0:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    39a2:	7e18      	ldrb	r0, [r3, #24]
    39a4:	2301      	movs	r3, #1
    39a6:	4018      	ands	r0, r3
}
    39a8:	4770      	bx	lr

000039aa <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    39aa:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    39ac:	7e1b      	ldrb	r3, [r3, #24]
    39ae:	085b      	lsrs	r3, r3, #1
    39b0:	2001      	movs	r0, #1
    39b2:	4018      	ands	r0, r3
}
    39b4:	4770      	bx	lr

000039b6 <_usart_async_is_byte_sent>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    39b6:	6983      	ldr	r3, [r0, #24]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    39b8:	7e18      	ldrb	r0, [r3, #24]
    39ba:	2301      	movs	r3, #1
    39bc:	4018      	ands	r0, r3
}
    39be:	4770      	bx	lr

000039c0 <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    39c0:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    39c2:	7e1b      	ldrb	r3, [r3, #24]
    39c4:	089b      	lsrs	r3, r3, #2
    39c6:	2001      	movs	r0, #1
    39c8:	4018      	ands	r0, r3
}
    39ca:	4770      	bx	lr

000039cc <_usart_async_enable_byte_sent_irq>:
	hri_sercomusart_set_INTEN_DRE_bit(device->hw);
    39cc:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
    39ce:	2201      	movs	r2, #1
    39d0:	759a      	strb	r2, [r3, #22]
}
    39d2:	4770      	bx	lr

000039d4 <_usart_async_enable_tx_done_irq>:
	hri_sercomusart_set_INTEN_TXC_bit(device->hw);
    39d4:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
    39d6:	2202      	movs	r2, #2
    39d8:	759a      	strb	r2, [r3, #22]
}
    39da:	4770      	bx	lr

000039dc <_usart_async_set_irq_state>:
{
    39dc:	b570      	push	{r4, r5, r6, lr}
    39de:	0004      	movs	r4, r0
    39e0:	000d      	movs	r5, r1
    39e2:	0016      	movs	r6, r2
	ASSERT(device);
    39e4:	1e43      	subs	r3, r0, #1
    39e6:	4198      	sbcs	r0, r3
    39e8:	b2c0      	uxtb	r0, r0
    39ea:	4a17      	ldr	r2, [pc, #92]	; (3a48 <_usart_async_set_irq_state+0x6c>)
    39ec:	4917      	ldr	r1, [pc, #92]	; (3a4c <_usart_async_set_irq_state+0x70>)
    39ee:	4b18      	ldr	r3, [pc, #96]	; (3a50 <_usart_async_set_irq_state+0x74>)
    39f0:	4798      	blx	r3
	if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
    39f2:	2d00      	cmp	r5, #0
    39f4:	d00b      	beq.n	3a0e <_usart_async_set_irq_state+0x32>
    39f6:	2d02      	cmp	r5, #2
    39f8:	d009      	beq.n	3a0e <_usart_async_set_irq_state+0x32>
	} else if (USART_ASYNC_RX_DONE == type) {
    39fa:	2d01      	cmp	r5, #1
    39fc:	d018      	beq.n	3a30 <_usart_async_set_irq_state+0x54>
	} else if (USART_ASYNC_ERROR == type) {
    39fe:	2d03      	cmp	r5, #3
    3a00:	d10f      	bne.n	3a22 <_usart_async_set_irq_state+0x46>
		hri_sercomusart_write_INTEN_ERROR_bit(device->hw, state);
    3a02:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
    3a04:	2e00      	cmp	r6, #0
    3a06:	d01c      	beq.n	3a42 <_usart_async_set_irq_state+0x66>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_ERROR;
    3a08:	2280      	movs	r2, #128	; 0x80
    3a0a:	759a      	strb	r2, [r3, #22]
}
    3a0c:	e009      	b.n	3a22 <_usart_async_set_irq_state+0x46>
		hri_sercomusart_write_INTEN_DRE_bit(device->hw, state);
    3a0e:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
    3a10:	2e00      	cmp	r6, #0
    3a12:	d107      	bne.n	3a24 <_usart_async_set_irq_state+0x48>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
    3a14:	2201      	movs	r2, #1
    3a16:	751a      	strb	r2, [r3, #20]
		hri_sercomusart_write_INTEN_TXC_bit(device->hw, state);
    3a18:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
    3a1a:	2e00      	cmp	r6, #0
    3a1c:	d105      	bne.n	3a2a <_usart_async_set_irq_state+0x4e>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
    3a1e:	2202      	movs	r2, #2
    3a20:	751a      	strb	r2, [r3, #20]
}
    3a22:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
    3a24:	2201      	movs	r2, #1
    3a26:	759a      	strb	r2, [r3, #22]
    3a28:	e7f6      	b.n	3a18 <_usart_async_set_irq_state+0x3c>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
    3a2a:	2202      	movs	r2, #2
    3a2c:	759a      	strb	r2, [r3, #22]
    3a2e:	e7f8      	b.n	3a22 <_usart_async_set_irq_state+0x46>
		hri_sercomusart_write_INTEN_RXC_bit(device->hw, state);
    3a30:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
    3a32:	2e00      	cmp	r6, #0
    3a34:	d102      	bne.n	3a3c <_usart_async_set_irq_state+0x60>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_RXC;
    3a36:	2204      	movs	r2, #4
    3a38:	751a      	strb	r2, [r3, #20]
    3a3a:	e7f2      	b.n	3a22 <_usart_async_set_irq_state+0x46>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_RXC;
    3a3c:	2204      	movs	r2, #4
    3a3e:	759a      	strb	r2, [r3, #22]
    3a40:	e7ef      	b.n	3a22 <_usart_async_set_irq_state+0x46>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_ERROR;
    3a42:	2280      	movs	r2, #128	; 0x80
    3a44:	751a      	strb	r2, [r3, #20]
    3a46:	e7ec      	b.n	3a22 <_usart_async_set_irq_state+0x46>
    3a48:	0000021e 	.word	0x0000021e
    3a4c:	0000acb4 	.word	0x0000acb4
    3a50:	000026c1 	.word	0x000026c1

00003a54 <_i2c_m_sync_init>:
{
    3a54:	b570      	push	{r4, r5, r6, lr}
    3a56:	0004      	movs	r4, r0
    3a58:	000d      	movs	r5, r1
	ASSERT(i2c_dev);
    3a5a:	1e43      	subs	r3, r0, #1
    3a5c:	4198      	sbcs	r0, r3
    3a5e:	b2c0      	uxtb	r0, r0
    3a60:	4a04      	ldr	r2, [pc, #16]	; (3a74 <_i2c_m_sync_init+0x20>)
    3a62:	4905      	ldr	r1, [pc, #20]	; (3a78 <_i2c_m_sync_init+0x24>)
    3a64:	4b05      	ldr	r3, [pc, #20]	; (3a7c <_i2c_m_sync_init+0x28>)
    3a66:	4798      	blx	r3
	i2c_dev->hw = hw;
    3a68:	6125      	str	r5, [r4, #16]
	return _i2c_m_sync_init_impl(&i2c_dev->service, hw);
    3a6a:	0029      	movs	r1, r5
    3a6c:	0020      	movs	r0, r4
    3a6e:	4b04      	ldr	r3, [pc, #16]	; (3a80 <_i2c_m_sync_init+0x2c>)
    3a70:	4798      	blx	r3
}
    3a72:	bd70      	pop	{r4, r5, r6, pc}
    3a74:	0000052f 	.word	0x0000052f
    3a78:	0000acb4 	.word	0x0000acb4
    3a7c:	000026c1 	.word	0x000026c1
    3a80:	0000356d 	.word	0x0000356d

00003a84 <_i2c_m_sync_transfer>:
{
    3a84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3a86:	0005      	movs	r5, r0
    3a88:	000e      	movs	r6, r1
	void *   hw = i2c_dev->hw;
    3a8a:	6904      	ldr	r4, [r0, #16]
	ASSERT(i2c_dev);
    3a8c:	1e43      	subs	r3, r0, #1
    3a8e:	4198      	sbcs	r0, r3
    3a90:	b2c0      	uxtb	r0, r0
    3a92:	4a93      	ldr	r2, [pc, #588]	; (3ce0 <_i2c_m_sync_transfer+0x25c>)
    3a94:	4993      	ldr	r1, [pc, #588]	; (3ce4 <_i2c_m_sync_transfer+0x260>)
    3a96:	4f94      	ldr	r7, [pc, #592]	; (3ce8 <_i2c_m_sync_transfer+0x264>)
    3a98:	47b8      	blx	r7
	ASSERT(i2c_dev->hw);
    3a9a:	6928      	ldr	r0, [r5, #16]
    3a9c:	1e43      	subs	r3, r0, #1
    3a9e:	4198      	sbcs	r0, r3
    3aa0:	b2c0      	uxtb	r0, r0
    3aa2:	22bd      	movs	r2, #189	; 0xbd
    3aa4:	00d2      	lsls	r2, r2, #3
    3aa6:	498f      	ldr	r1, [pc, #572]	; (3ce4 <_i2c_m_sync_transfer+0x260>)
    3aa8:	47b8      	blx	r7
	ASSERT(msg);
    3aaa:	0030      	movs	r0, r6
    3aac:	1e43      	subs	r3, r0, #1
    3aae:	4198      	sbcs	r0, r3
    3ab0:	b2c0      	uxtb	r0, r0
    3ab2:	4a8e      	ldr	r2, [pc, #568]	; (3cec <_i2c_m_sync_transfer+0x268>)
    3ab4:	498b      	ldr	r1, [pc, #556]	; (3ce4 <_i2c_m_sync_transfer+0x260>)
    3ab6:	47b8      	blx	r7
	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    3ab8:	886b      	ldrh	r3, [r5, #2]
    3aba:	05db      	lsls	r3, r3, #23
    3abc:	d500      	bpl.n	3ac0 <_i2c_m_sync_transfer+0x3c>
    3abe:	e10b      	b.n	3cd8 <_i2c_m_sync_transfer+0x254>
	msg->flags |= I2C_M_BUSY;
    3ac0:	8872      	ldrh	r2, [r6, #2]
    3ac2:	2380      	movs	r3, #128	; 0x80
    3ac4:	005b      	lsls	r3, r3, #1
    3ac6:	469c      	mov	ip, r3
    3ac8:	431a      	orrs	r2, r3
    3aca:	8072      	strh	r2, [r6, #2]
	i2c_dev->service.msg = *msg;
    3acc:	002a      	movs	r2, r5
    3ace:	0031      	movs	r1, r6
    3ad0:	c989      	ldmia	r1!, {r0, r3, r7}
    3ad2:	c289      	stmia	r2!, {r0, r3, r7}
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
    3ad4:	6862      	ldr	r2, [r4, #4]
    3ad6:	4663      	mov	r3, ip
    3ad8:	4313      	orrs	r3, r2
    3ada:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3adc:	69e3      	ldr	r3, [r4, #28]
    3ade:	075b      	lsls	r3, r3, #29
    3ae0:	d4fc      	bmi.n	3adc <_i2c_m_sync_transfer+0x58>
	ret = _sercom_i2c_sync_send_address(i2c_dev);
    3ae2:	0028      	movs	r0, r5
    3ae4:	4b82      	ldr	r3, [pc, #520]	; (3cf0 <_i2c_m_sync_transfer+0x26c>)
    3ae6:	4798      	blx	r3
	if (ret) {
    3ae8:	2800      	cmp	r0, #0
    3aea:	d100      	bne.n	3aee <_i2c_m_sync_transfer+0x6a>
    3aec:	e09d      	b.n	3c2a <_i2c_m_sync_transfer+0x1a6>
		i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    3aee:	886b      	ldrh	r3, [r5, #2]
    3af0:	4a80      	ldr	r2, [pc, #512]	; (3cf4 <_i2c_m_sync_transfer+0x270>)
    3af2:	4013      	ands	r3, r2
    3af4:	806b      	strh	r3, [r5, #2]
}
    3af6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return I2C_ERR_BUS;
    3af8:	2005      	movs	r0, #5
    3afa:	4240      	negs	r0, r0
    3afc:	e0a6      	b.n	3c4c <_i2c_m_sync_transfer+0x1c8>
			if (msg->flags & I2C_M_STOP) {
    3afe:	8873      	ldrh	r3, [r6, #2]
    3b00:	b21b      	sxth	r3, r3
    3b02:	2b00      	cmp	r3, #0
    3b04:	db04      	blt.n	3b10 <_i2c_m_sync_transfer+0x8c>
			i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    3b06:	886b      	ldrh	r3, [r5, #2]
    3b08:	4a7a      	ldr	r2, [pc, #488]	; (3cf4 <_i2c_m_sync_transfer+0x270>)
    3b0a:	4013      	ands	r3, r2
    3b0c:	806b      	strh	r3, [r5, #2]
			return ret;
    3b0e:	e7f2      	b.n	3af6 <_i2c_m_sync_transfer+0x72>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    3b10:	6862      	ldr	r2, [r4, #4]
    3b12:	23c0      	movs	r3, #192	; 0xc0
    3b14:	029b      	lsls	r3, r3, #10
    3b16:	4313      	orrs	r3, r2
    3b18:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3b1a:	69e3      	ldr	r3, [r4, #28]
    3b1c:	075b      	lsls	r3, r3, #29
    3b1e:	d4fc      	bmi.n	3b1a <_i2c_m_sync_transfer+0x96>
    3b20:	e7f1      	b.n	3b06 <_i2c_m_sync_transfer+0x82>
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
    3b22:	0753      	lsls	r3, r2, #29
    3b24:	d41b      	bmi.n	3b5e <_i2c_m_sync_transfer+0xda>
			if (msg->flags & I2C_M_TEN) {
    3b26:	886b      	ldrh	r3, [r5, #2]
    3b28:	055b      	lsls	r3, r3, #21
    3b2a:	d534      	bpl.n	3b96 <_i2c_m_sync_transfer+0x112>
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
    3b2c:	882a      	ldrh	r2, [r5, #0]
    3b2e:	1212      	asrs	r2, r2, #8
    3b30:	0052      	lsls	r2, r2, #1
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    3b32:	2306      	movs	r3, #6
    3b34:	401a      	ands	r2, r3
    3b36:	69e3      	ldr	r3, [r4, #28]
    3b38:	075b      	lsls	r3, r3, #29
    3b3a:	d4fc      	bmi.n	3b36 <_i2c_m_sync_transfer+0xb2>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    3b3c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    3b3e:	2180      	movs	r1, #128	; 0x80
    3b40:	01c9      	lsls	r1, r1, #7
    3b42:	400b      	ands	r3, r1
    3b44:	4313      	orrs	r3, r2
				hri_sercomi2cm_write_ADDR_reg(hw,
    3b46:	22f1      	movs	r2, #241	; 0xf1
    3b48:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    3b4a:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3b4c:	69e3      	ldr	r3, [r4, #28]
    3b4e:	075b      	lsls	r3, r3, #29
    3b50:	d4fc      	bmi.n	3b4c <_i2c_m_sync_transfer+0xc8>
				msg->flags &= ~I2C_M_TEN;
    3b52:	886b      	ldrh	r3, [r5, #2]
    3b54:	4a68      	ldr	r2, [pc, #416]	; (3cf8 <_i2c_m_sync_transfer+0x274>)
    3b56:	4013      	ands	r3, r2
    3b58:	806b      	strh	r3, [r5, #2]
				return I2C_OK;
    3b5a:	2000      	movs	r0, #0
    3b5c:	e065      	b.n	3c2a <_i2c_m_sync_transfer+0x1a6>
				if (msg->len > 0) {
    3b5e:	686b      	ldr	r3, [r5, #4]
    3b60:	2b00      	cmp	r3, #0
    3b62:	dd04      	ble.n	3b6e <_i2c_m_sync_transfer+0xea>
					msg->flags |= I2C_M_FAIL;
    3b64:	886b      	ldrh	r3, [r5, #2]
    3b66:	2280      	movs	r2, #128	; 0x80
    3b68:	0152      	lsls	r2, r2, #5
    3b6a:	4313      	orrs	r3, r2
    3b6c:	806b      	strh	r3, [r5, #2]
				if (msg->flags & I2C_M_STOP) {
    3b6e:	886b      	ldrh	r3, [r5, #2]
    3b70:	b21b      	sxth	r3, r3
    3b72:	2b00      	cmp	r3, #0
    3b74:	db06      	blt.n	3b84 <_i2c_m_sync_transfer+0x100>
				msg->flags &= ~I2C_M_BUSY;
    3b76:	886b      	ldrh	r3, [r5, #2]
    3b78:	4a5e      	ldr	r2, [pc, #376]	; (3cf4 <_i2c_m_sync_transfer+0x270>)
    3b7a:	4013      	ands	r3, r2
    3b7c:	806b      	strh	r3, [r5, #2]
				return I2C_NACK;
    3b7e:	2002      	movs	r0, #2
    3b80:	4240      	negs	r0, r0
    3b82:	e052      	b.n	3c2a <_i2c_m_sync_transfer+0x1a6>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    3b84:	6862      	ldr	r2, [r4, #4]
    3b86:	23c0      	movs	r3, #192	; 0xc0
    3b88:	029b      	lsls	r3, r3, #10
    3b8a:	4313      	orrs	r3, r2
    3b8c:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3b8e:	69e3      	ldr	r3, [r4, #28]
    3b90:	075b      	lsls	r3, r3, #29
    3b92:	d4fc      	bmi.n	3b8e <_i2c_m_sync_transfer+0x10a>
    3b94:	e7ef      	b.n	3b76 <_i2c_m_sync_transfer+0xf2>
			if (msg->len == 0) {
    3b96:	6868      	ldr	r0, [r5, #4]
    3b98:	2800      	cmp	r0, #0
    3b9a:	d111      	bne.n	3bc0 <_i2c_m_sync_transfer+0x13c>
				if (msg->flags & I2C_M_STOP) {
    3b9c:	886b      	ldrh	r3, [r5, #2]
    3b9e:	b21b      	sxth	r3, r3
    3ba0:	2b00      	cmp	r3, #0
    3ba2:	db04      	blt.n	3bae <_i2c_m_sync_transfer+0x12a>
				msg->flags &= ~I2C_M_BUSY;
    3ba4:	886b      	ldrh	r3, [r5, #2]
    3ba6:	4a53      	ldr	r2, [pc, #332]	; (3cf4 <_i2c_m_sync_transfer+0x270>)
    3ba8:	4013      	ands	r3, r2
    3baa:	806b      	strh	r3, [r5, #2]
    3bac:	e03d      	b.n	3c2a <_i2c_m_sync_transfer+0x1a6>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    3bae:	6862      	ldr	r2, [r4, #4]
    3bb0:	23c0      	movs	r3, #192	; 0xc0
    3bb2:	029b      	lsls	r3, r3, #10
    3bb4:	4313      	orrs	r3, r2
    3bb6:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3bb8:	69e3      	ldr	r3, [r4, #28]
    3bba:	075b      	lsls	r3, r3, #29
    3bbc:	d4fc      	bmi.n	3bb8 <_i2c_m_sync_transfer+0x134>
    3bbe:	e7f1      	b.n	3ba4 <_i2c_m_sync_transfer+0x120>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
    3bc0:	68ab      	ldr	r3, [r5, #8]
    3bc2:	781a      	ldrb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
    3bc4:	2328      	movs	r3, #40	; 0x28
    3bc6:	54e2      	strb	r2, [r4, r3]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3bc8:	69e3      	ldr	r3, [r4, #28]
    3bca:	075b      	lsls	r3, r3, #29
    3bcc:	d4fc      	bmi.n	3bc8 <_i2c_m_sync_transfer+0x144>
				msg->buffer++;
    3bce:	68ab      	ldr	r3, [r5, #8]
    3bd0:	3301      	adds	r3, #1
    3bd2:	60ab      	str	r3, [r5, #8]
				msg->len--;
    3bd4:	686b      	ldr	r3, [r5, #4]
    3bd6:	3b01      	subs	r3, #1
    3bd8:	606b      	str	r3, [r5, #4]
			return I2C_OK;
    3bda:	2000      	movs	r0, #0
    3bdc:	e025      	b.n	3c2a <_i2c_m_sync_transfer+0x1a6>
	} else if (flags & SB_FLAG) {
    3bde:	07bb      	lsls	r3, r7, #30
    3be0:	d578      	bpl.n	3cd4 <_i2c_m_sync_transfer+0x250>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
    3be2:	686b      	ldr	r3, [r5, #4]
    3be4:	2b00      	cmp	r3, #0
    3be6:	d06d      	beq.n	3cc4 <_i2c_m_sync_transfer+0x240>
    3be8:	0752      	lsls	r2, r2, #29
    3bea:	d46b      	bmi.n	3cc4 <_i2c_m_sync_transfer+0x240>
			msg->len--;
    3bec:	3b01      	subs	r3, #1
    3bee:	606b      	str	r3, [r5, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    3bf0:	2b00      	cmp	r3, #0
    3bf2:	d101      	bne.n	3bf8 <_i2c_m_sync_transfer+0x174>
    3bf4:	2900      	cmp	r1, #0
    3bf6:	d04c      	beq.n	3c92 <_i2c_m_sync_transfer+0x20e>
    3bf8:	2b01      	cmp	r3, #1
    3bfa:	d048      	beq.n	3c8e <_i2c_m_sync_transfer+0x20a>
			if (msg->len == 0) {
    3bfc:	686b      	ldr	r3, [r5, #4]
    3bfe:	2b00      	cmp	r3, #0
    3c00:	d107      	bne.n	3c12 <_i2c_m_sync_transfer+0x18e>
				if (msg->flags & I2C_M_STOP) {
    3c02:	886b      	ldrh	r3, [r5, #2]
    3c04:	b21b      	sxth	r3, r3
    3c06:	2b00      	cmp	r3, #0
    3c08:	db4c      	blt.n	3ca4 <_i2c_m_sync_transfer+0x220>
				msg->flags &= ~I2C_M_BUSY;
    3c0a:	886b      	ldrh	r3, [r5, #2]
    3c0c:	4a39      	ldr	r2, [pc, #228]	; (3cf4 <_i2c_m_sync_transfer+0x270>)
    3c0e:	4013      	ands	r3, r2
    3c10:	806b      	strh	r3, [r5, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
    3c12:	68aa      	ldr	r2, [r5, #8]
    3c14:	1c53      	adds	r3, r2, #1
    3c16:	60ab      	str	r3, [r5, #8]
    3c18:	69e3      	ldr	r3, [r4, #28]
    3c1a:	075b      	lsls	r3, r3, #29
    3c1c:	d4fc      	bmi.n	3c18 <_i2c_m_sync_transfer+0x194>
	return ((Sercom *)hw)->I2CM.DATA.reg;
    3c1e:	2328      	movs	r3, #40	; 0x28
    3c20:	5ce3      	ldrb	r3, [r4, r3]
    3c22:	7013      	strb	r3, [r2, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    3c24:	2302      	movs	r3, #2
    3c26:	7623      	strb	r3, [r4, #24]
	return I2C_OK;
    3c28:	2000      	movs	r0, #0
	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    3c2a:	886b      	ldrh	r3, [r5, #2]
    3c2c:	05db      	lsls	r3, r3, #23
    3c2e:	d400      	bmi.n	3c32 <_i2c_m_sync_transfer+0x1ae>
    3c30:	e761      	b.n	3af6 <_i2c_m_sync_transfer+0x72>
	void *   hw      = i2c_dev->hw;
    3c32:	6928      	ldr	r0, [r5, #16]
	uint32_t timeout = 65535;
    3c34:	4a31      	ldr	r2, [pc, #196]	; (3cfc <_i2c_m_sync_transfer+0x278>)
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
    3c36:	7e03      	ldrb	r3, [r0, #24]
    3c38:	b2db      	uxtb	r3, r3
		*flags = hri_sercomi2cm_read_INTFLAG_reg(hw);
    3c3a:	001f      	movs	r7, r3
		if (timeout-- == 0) {
    3c3c:	1e51      	subs	r1, r2, #1
    3c3e:	2a00      	cmp	r2, #0
    3c40:	d100      	bne.n	3c44 <_i2c_m_sync_transfer+0x1c0>
    3c42:	e759      	b.n	3af8 <_i2c_m_sync_transfer+0x74>
    3c44:	000a      	movs	r2, r1
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
    3c46:	079b      	lsls	r3, r3, #30
    3c48:	d0f5      	beq.n	3c36 <_i2c_m_sync_transfer+0x1b2>
	return I2C_OK;
    3c4a:	2000      	movs	r0, #0
		if (ret) {
    3c4c:	2800      	cmp	r0, #0
    3c4e:	d000      	beq.n	3c52 <_i2c_m_sync_transfer+0x1ce>
    3c50:	e755      	b.n	3afe <_i2c_m_sync_transfer+0x7a>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    3c52:	6823      	ldr	r3, [r4, #0]
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
    3c54:	0edb      	lsrs	r3, r3, #27
    3c56:	2101      	movs	r1, #1
    3c58:	4019      	ands	r1, r3
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3c5a:	69e3      	ldr	r3, [r4, #28]
    3c5c:	075b      	lsls	r3, r3, #29
    3c5e:	d4fc      	bmi.n	3c5a <_i2c_m_sync_transfer+0x1d6>
	return ((Sercom *)hw)->I2CM.STATUS.reg;
    3c60:	8b62      	ldrh	r2, [r4, #26]
    3c62:	b292      	uxth	r2, r2
	if (flags & MB_FLAG) {
    3c64:	07fb      	lsls	r3, r7, #31
    3c66:	d5ba      	bpl.n	3bde <_i2c_m_sync_transfer+0x15a>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
    3c68:	0793      	lsls	r3, r2, #30
    3c6a:	d400      	bmi.n	3c6e <_i2c_m_sync_transfer+0x1ea>
    3c6c:	e759      	b.n	3b22 <_i2c_m_sync_transfer+0x9e>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    3c6e:	2301      	movs	r3, #1
    3c70:	7623      	strb	r3, [r4, #24]
			msg->flags |= I2C_M_FAIL;
    3c72:	886b      	ldrh	r3, [r5, #2]
    3c74:	2180      	movs	r1, #128	; 0x80
    3c76:	0149      	lsls	r1, r1, #5
    3c78:	430b      	orrs	r3, r1
    3c7a:	806b      	strh	r3, [r5, #2]
			msg->flags &= ~I2C_M_BUSY;
    3c7c:	886b      	ldrh	r3, [r5, #2]
    3c7e:	491d      	ldr	r1, [pc, #116]	; (3cf4 <_i2c_m_sync_transfer+0x270>)
    3c80:	400b      	ands	r3, r1
    3c82:	806b      	strh	r3, [r5, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
    3c84:	07d3      	lsls	r3, r2, #31
    3c86:	d522      	bpl.n	3cce <_i2c_m_sync_transfer+0x24a>
				return I2C_ERR_BUS;
    3c88:	2005      	movs	r0, #5
    3c8a:	4240      	negs	r0, r0
    3c8c:	e7cd      	b.n	3c2a <_i2c_m_sync_transfer+0x1a6>
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    3c8e:	2900      	cmp	r1, #0
    3c90:	d0b4      	beq.n	3bfc <_i2c_m_sync_transfer+0x178>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    3c92:	6862      	ldr	r2, [r4, #4]
    3c94:	2380      	movs	r3, #128	; 0x80
    3c96:	02db      	lsls	r3, r3, #11
    3c98:	4313      	orrs	r3, r2
    3c9a:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3c9c:	69e3      	ldr	r3, [r4, #28]
    3c9e:	075b      	lsls	r3, r3, #29
    3ca0:	d4fc      	bmi.n	3c9c <_i2c_m_sync_transfer+0x218>
    3ca2:	e7ab      	b.n	3bfc <_i2c_m_sync_transfer+0x178>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
    3ca4:	6863      	ldr	r3, [r4, #4]
    3ca6:	4a13      	ldr	r2, [pc, #76]	; (3cf4 <_i2c_m_sync_transfer+0x270>)
    3ca8:	4013      	ands	r3, r2
    3caa:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3cac:	69e3      	ldr	r3, [r4, #28]
    3cae:	075b      	lsls	r3, r3, #29
    3cb0:	d4fc      	bmi.n	3cac <_i2c_m_sync_transfer+0x228>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    3cb2:	6862      	ldr	r2, [r4, #4]
    3cb4:	23c0      	movs	r3, #192	; 0xc0
    3cb6:	029b      	lsls	r3, r3, #10
    3cb8:	4313      	orrs	r3, r2
    3cba:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    3cbc:	69e3      	ldr	r3, [r4, #28]
    3cbe:	075b      	lsls	r3, r3, #29
    3cc0:	d4fc      	bmi.n	3cbc <_i2c_m_sync_transfer+0x238>
    3cc2:	e7a2      	b.n	3c0a <_i2c_m_sync_transfer+0x186>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    3cc4:	2302      	movs	r3, #2
    3cc6:	7623      	strb	r3, [r4, #24]
			return I2C_NACK;
    3cc8:	2002      	movs	r0, #2
    3cca:	4240      	negs	r0, r0
    3ccc:	e7ad      	b.n	3c2a <_i2c_m_sync_transfer+0x1a6>
			return I2C_ERR_BAD_ADDRESS;
    3cce:	2004      	movs	r0, #4
    3cd0:	4240      	negs	r0, r0
    3cd2:	e7aa      	b.n	3c2a <_i2c_m_sync_transfer+0x1a6>
	return I2C_OK;
    3cd4:	2000      	movs	r0, #0
    3cd6:	e7a8      	b.n	3c2a <_i2c_m_sync_transfer+0x1a6>
		return I2C_ERR_BUSY;
    3cd8:	2006      	movs	r0, #6
    3cda:	4240      	negs	r0, r0
    3cdc:	e70b      	b.n	3af6 <_i2c_m_sync_transfer+0x72>
    3cde:	46c0      	nop			; (mov r8, r8)
    3ce0:	000005e7 	.word	0x000005e7
    3ce4:	0000acb4 	.word	0x0000acb4
    3ce8:	000026c1 	.word	0x000026c1
    3cec:	000005e9 	.word	0x000005e9
    3cf0:	0000363d 	.word	0x0000363d
    3cf4:	fffffeff 	.word	0xfffffeff
    3cf8:	fffffbff 	.word	0xfffffbff
    3cfc:	0000ffff 	.word	0x0000ffff

00003d00 <SERCOM1_Handler>:

	return NULL;
}

void SERCOM1_Handler(void)
{
    3d00:	b510      	push	{r4, lr}
	_sercom_usart_interrupt_handler(_sercom1_dev);
    3d02:	4b02      	ldr	r3, [pc, #8]	; (3d0c <SERCOM1_Handler+0xc>)
    3d04:	6818      	ldr	r0, [r3, #0]
    3d06:	4b02      	ldr	r3, [pc, #8]	; (3d10 <SERCOM1_Handler+0x10>)
    3d08:	4798      	blx	r3
}
    3d0a:	bd10      	pop	{r4, pc}
    3d0c:	200003c4 	.word	0x200003c4
    3d10:	00003361 	.word	0x00003361

00003d14 <_spi_m_sync_init>:

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
    3d14:	b570      	push	{r4, r5, r6, lr}
    3d16:	0006      	movs	r6, r0
    3d18:	000c      	movs	r4, r1
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
    3d1a:	0008      	movs	r0, r1
    3d1c:	4b71      	ldr	r3, [pc, #452]	; (3ee4 <_spi_m_sync_init+0x1d0>)
    3d1e:	4798      	blx	r3
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    3d20:	2300      	movs	r3, #0
    3d22:	2b00      	cmp	r3, #0
    3d24:	d100      	bne.n	3d28 <_spi_m_sync_init+0x14>
    3d26:	e084      	b.n	3e32 <_spi_m_sync_init+0x11e>
	return NULL;
    3d28:	2500      	movs	r5, #0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
    3d2a:	2e00      	cmp	r6, #0
    3d2c:	d100      	bne.n	3d30 <_spi_m_sync_init+0x1c>
    3d2e:	e08d      	b.n	3e4c <_spi_m_sync_init+0x138>
    3d30:	2c00      	cmp	r4, #0
    3d32:	d100      	bne.n	3d36 <_spi_m_sync_init+0x22>
    3d34:	e088      	b.n	3e48 <_spi_m_sync_init+0x134>
    3d36:	2001      	movs	r0, #1
    3d38:	4a6b      	ldr	r2, [pc, #428]	; (3ee8 <_spi_m_sync_init+0x1d4>)
    3d3a:	496c      	ldr	r1, [pc, #432]	; (3eec <_spi_m_sync_init+0x1d8>)
    3d3c:	4b6c      	ldr	r3, [pc, #432]	; (3ef0 <_spi_m_sync_init+0x1dc>)
    3d3e:	4798      	blx	r3

	if (regs == NULL) {
    3d40:	2d00      	cmp	r5, #0
    3d42:	d100      	bne.n	3d46 <_spi_m_sync_init+0x32>
    3d44:	e0cb      	b.n	3ede <_spi_m_sync_init+0x1ca>
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    3d46:	69e3      	ldr	r3, [r4, #28]
		return ERR_INVALID_ARG;
	}

	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
    3d48:	07db      	lsls	r3, r3, #31
    3d4a:	d421      	bmi.n	3d90 <_spi_m_sync_init+0x7c>
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
    3d4c:	782a      	ldrb	r2, [r5, #0]
    3d4e:	786b      	ldrb	r3, [r5, #1]
    3d50:	021b      	lsls	r3, r3, #8
    3d52:	4313      	orrs	r3, r2
    3d54:	78aa      	ldrb	r2, [r5, #2]
    3d56:	0412      	lsls	r2, r2, #16
    3d58:	4313      	orrs	r3, r2
    3d5a:	78ea      	ldrb	r2, [r5, #3]
    3d5c:	0612      	lsls	r2, r2, #24
    3d5e:	431a      	orrs	r2, r3
    3d60:	231c      	movs	r3, #28
    3d62:	401a      	ands	r2, r3
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    3d64:	69e3      	ldr	r3, [r4, #28]
    3d66:	079b      	lsls	r3, r3, #30
    3d68:	d1fc      	bne.n	3d64 <_spi_m_sync_init+0x50>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    3d6a:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
    3d6c:	079b      	lsls	r3, r3, #30
    3d6e:	d509      	bpl.n	3d84 <_spi_m_sync_init+0x70>
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
    3d70:	6823      	ldr	r3, [r4, #0]
    3d72:	2102      	movs	r1, #2
    3d74:	438b      	bics	r3, r1
    3d76:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    3d78:	69e3      	ldr	r3, [r4, #28]
    3d7a:	079b      	lsls	r3, r3, #30
    3d7c:	d1fc      	bne.n	3d78 <_spi_m_sync_init+0x64>
    3d7e:	69e3      	ldr	r3, [r4, #28]
    3d80:	079b      	lsls	r3, r3, #30
    3d82:	d4fc      	bmi.n	3d7e <_spi_m_sync_init+0x6a>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
		}
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
    3d84:	2301      	movs	r3, #1
    3d86:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    3d88:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    3d8a:	69e3      	ldr	r3, [r4, #28]
    3d8c:	079b      	lsls	r3, r3, #30
    3d8e:	d1fc      	bne.n	3d8a <_spi_m_sync_init+0x76>
    3d90:	69e3      	ldr	r3, [r4, #28]
    3d92:	07db      	lsls	r3, r3, #31
    3d94:	d4fc      	bmi.n	3d90 <_spi_m_sync_init+0x7c>
	}
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);

	dev->prvt = hw;
    3d96:	6034      	str	r4, [r6, #0]

	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
    3d98:	782b      	ldrb	r3, [r5, #0]
    3d9a:	786a      	ldrb	r2, [r5, #1]
    3d9c:	0212      	lsls	r2, r2, #8
    3d9e:	431a      	orrs	r2, r3
    3da0:	78ab      	ldrb	r3, [r5, #2]
    3da2:	041b      	lsls	r3, r3, #16
    3da4:	431a      	orrs	r2, r3
    3da6:	78eb      	ldrb	r3, [r5, #3]
    3da8:	061b      	lsls	r3, r3, #24
    3daa:	4313      	orrs	r3, r2
    3dac:	221c      	movs	r2, #28
    3dae:	4013      	ands	r3, r2
    3db0:	2b08      	cmp	r3, #8
    3db2:	d04d      	beq.n	3e50 <_spi_m_sync_init+0x13c>
	ASSERT(hw && regs);
    3db4:	2c00      	cmp	r4, #0
    3db6:	d100      	bne.n	3dba <_spi_m_sync_init+0xa6>
    3db8:	e08d      	b.n	3ed6 <_spi_m_sync_init+0x1c2>
    3dba:	2d00      	cmp	r5, #0
    3dbc:	d100      	bne.n	3dc0 <_spi_m_sync_init+0xac>
    3dbe:	e088      	b.n	3ed2 <_spi_m_sync_init+0x1be>
    3dc0:	2001      	movs	r0, #1
    3dc2:	4a4c      	ldr	r2, [pc, #304]	; (3ef4 <_spi_m_sync_init+0x1e0>)
    3dc4:	4949      	ldr	r1, [pc, #292]	; (3eec <_spi_m_sync_init+0x1d8>)
    3dc6:	4b4a      	ldr	r3, [pc, #296]	; (3ef0 <_spi_m_sync_init+0x1dc>)
    3dc8:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    3dca:	782b      	ldrb	r3, [r5, #0]
    3dcc:	786a      	ldrb	r2, [r5, #1]
    3dce:	0212      	lsls	r2, r2, #8
    3dd0:	431a      	orrs	r2, r3
    3dd2:	78ab      	ldrb	r3, [r5, #2]
    3dd4:	041b      	lsls	r3, r3, #16
    3dd6:	431a      	orrs	r2, r3
    3dd8:	78eb      	ldrb	r3, [r5, #3]
    3dda:	061b      	lsls	r3, r3, #24
    3ddc:	4313      	orrs	r3, r2
	hri_sercomspi_write_CTRLA_reg(
    3dde:	4a46      	ldr	r2, [pc, #280]	; (3ef8 <_spi_m_sync_init+0x1e4>)
    3de0:	4013      	ands	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    3de2:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    3de4:	69e3      	ldr	r3, [r4, #28]
    3de6:	079b      	lsls	r3, r3, #30
    3de8:	d1fc      	bne.n	3de4 <_spi_m_sync_init+0xd0>
	    (regs->ctrlb
    3dea:	792b      	ldrb	r3, [r5, #4]
    3dec:	796a      	ldrb	r2, [r5, #5]
    3dee:	0212      	lsls	r2, r2, #8
    3df0:	431a      	orrs	r2, r3
    3df2:	79ab      	ldrb	r3, [r5, #6]
    3df4:	041b      	lsls	r3, r3, #16
    3df6:	431a      	orrs	r2, r3
    3df8:	79eb      	ldrb	r3, [r5, #7]
    3dfa:	061b      	lsls	r3, r3, #24
    3dfc:	4313      	orrs	r3, r2
	        | (SERCOM_SPI_CTRLB_RXEN));
    3dfe:	4a3f      	ldr	r2, [pc, #252]	; (3efc <_spi_m_sync_init+0x1e8>)
    3e00:	4013      	ands	r3, r2
	hri_sercomspi_write_CTRLB_reg(
    3e02:	2280      	movs	r2, #128	; 0x80
    3e04:	0292      	lsls	r2, r2, #10
    3e06:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    3e08:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    3e0a:	69e3      	ldr	r3, [r4, #28]
    3e0c:	075b      	lsls	r3, r3, #29
    3e0e:	d1fc      	bne.n	3e0a <_spi_m_sync_init+0xf6>
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
    3e10:	7b2b      	ldrb	r3, [r5, #12]
	((Sercom *)hw)->SPI.BAUD.reg = data;
    3e12:	7323      	strb	r3, [r4, #12]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    3e14:	7b6a      	ldrb	r2, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    3e16:	2330      	movs	r3, #48	; 0x30
    3e18:	54e2      	strb	r2, [r4, r3]
	} else {
		_spi_load_regs_master(hw, regs);
	}

	/* Load character size from default hardware configuration */
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    3e1a:	792b      	ldrb	r3, [r5, #4]
    3e1c:	075b      	lsls	r3, r3, #29
    3e1e:	d15c      	bne.n	3eda <_spi_m_sync_init+0x1c6>
    3e20:	2301      	movs	r3, #1
    3e22:	7133      	strb	r3, [r6, #4]

	dev->dummy_byte = regs->dummy_byte;
    3e24:	7baa      	ldrb	r2, [r5, #14]
    3e26:	7beb      	ldrb	r3, [r5, #15]
    3e28:	021b      	lsls	r3, r3, #8
    3e2a:	4313      	orrs	r3, r2
    3e2c:	80f3      	strh	r3, [r6, #6]

	return ERR_NONE;
    3e2e:	2000      	movs	r0, #0
}
    3e30:	bd70      	pop	{r4, r5, r6, pc}
		if (sercomspi_regs[i].n == n) {
    3e32:	2800      	cmp	r0, #0
    3e34:	d002      	beq.n	3e3c <_spi_m_sync_init+0x128>
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    3e36:	3301      	adds	r3, #1
    3e38:	b2db      	uxtb	r3, r3
    3e3a:	e772      	b.n	3d22 <_spi_m_sync_init+0xe>
			return &sercomspi_regs[i];
    3e3c:	011d      	lsls	r5, r3, #4
    3e3e:	18ea      	adds	r2, r5, r3
    3e40:	4d2f      	ldr	r5, [pc, #188]	; (3f00 <_spi_m_sync_init+0x1ec>)
    3e42:	3550      	adds	r5, #80	; 0x50
    3e44:	18ad      	adds	r5, r5, r2
    3e46:	e770      	b.n	3d2a <_spi_m_sync_init+0x16>
	ASSERT(dev && hw);
    3e48:	2000      	movs	r0, #0
    3e4a:	e775      	b.n	3d38 <_spi_m_sync_init+0x24>
    3e4c:	2000      	movs	r0, #0
    3e4e:	e773      	b.n	3d38 <_spi_m_sync_init+0x24>
	ASSERT(hw && regs);
    3e50:	2c00      	cmp	r4, #0
    3e52:	d03c      	beq.n	3ece <_spi_m_sync_init+0x1ba>
    3e54:	2d00      	cmp	r5, #0
    3e56:	d038      	beq.n	3eca <_spi_m_sync_init+0x1b6>
    3e58:	2001      	movs	r0, #1
    3e5a:	4a2a      	ldr	r2, [pc, #168]	; (3f04 <_spi_m_sync_init+0x1f0>)
    3e5c:	4923      	ldr	r1, [pc, #140]	; (3eec <_spi_m_sync_init+0x1d8>)
    3e5e:	4b24      	ldr	r3, [pc, #144]	; (3ef0 <_spi_m_sync_init+0x1dc>)
    3e60:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    3e62:	782b      	ldrb	r3, [r5, #0]
    3e64:	786a      	ldrb	r2, [r5, #1]
    3e66:	0212      	lsls	r2, r2, #8
    3e68:	431a      	orrs	r2, r3
    3e6a:	78ab      	ldrb	r3, [r5, #2]
    3e6c:	041b      	lsls	r3, r3, #16
    3e6e:	431a      	orrs	r2, r3
    3e70:	78eb      	ldrb	r3, [r5, #3]
    3e72:	061b      	lsls	r3, r3, #24
    3e74:	4313      	orrs	r3, r2
	hri_sercomspi_write_CTRLA_reg(
    3e76:	4a20      	ldr	r2, [pc, #128]	; (3ef8 <_spi_m_sync_init+0x1e4>)
    3e78:	4013      	ands	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    3e7a:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    3e7c:	69e3      	ldr	r3, [r4, #28]
    3e7e:	079b      	lsls	r3, r3, #30
    3e80:	d1fc      	bne.n	3e7c <_spi_m_sync_init+0x168>
	                              (regs->ctrlb & ~(SERCOM_SPI_CTRLB_MSSEN))
    3e82:	792b      	ldrb	r3, [r5, #4]
    3e84:	796a      	ldrb	r2, [r5, #5]
    3e86:	0212      	lsls	r2, r2, #8
    3e88:	431a      	orrs	r2, r3
    3e8a:	79ab      	ldrb	r3, [r5, #6]
    3e8c:	041b      	lsls	r3, r3, #16
    3e8e:	431a      	orrs	r2, r3
    3e90:	79eb      	ldrb	r3, [r5, #7]
    3e92:	061b      	lsls	r3, r3, #24
    3e94:	4313      	orrs	r3, r2
	                                  | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_SSDE | SERCOM_SPI_CTRLB_PLOADEN));
    3e96:	4a1c      	ldr	r2, [pc, #112]	; (3f08 <_spi_m_sync_init+0x1f4>)
    3e98:	4013      	ands	r3, r2
	hri_sercomspi_write_CTRLB_reg(hw,
    3e9a:	4a1c      	ldr	r2, [pc, #112]	; (3f0c <_spi_m_sync_init+0x1f8>)
    3e9c:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    3e9e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    3ea0:	69e3      	ldr	r3, [r4, #28]
    3ea2:	075b      	lsls	r3, r3, #29
    3ea4:	d1fc      	bne.n	3ea0 <_spi_m_sync_init+0x18c>
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
    3ea6:	7a2b      	ldrb	r3, [r5, #8]
    3ea8:	7a6a      	ldrb	r2, [r5, #9]
    3eaa:	0212      	lsls	r2, r2, #8
    3eac:	431a      	orrs	r2, r3
    3eae:	7aab      	ldrb	r3, [r5, #10]
    3eb0:	041b      	lsls	r3, r3, #16
    3eb2:	431a      	orrs	r2, r3
    3eb4:	7aeb      	ldrb	r3, [r5, #11]
    3eb6:	061b      	lsls	r3, r3, #24
    3eb8:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.ADDR.reg = data;
    3eba:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    3ebc:	7b6a      	ldrb	r2, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    3ebe:	2330      	movs	r3, #48	; 0x30
    3ec0:	54e2      	strb	r2, [r4, r3]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    3ec2:	69e3      	ldr	r3, [r4, #28]
	while (hri_sercomspi_is_syncing(hw, 0xFFFFFFFF))
    3ec4:	2b00      	cmp	r3, #0
    3ec6:	d1fc      	bne.n	3ec2 <_spi_m_sync_init+0x1ae>
    3ec8:	e7a7      	b.n	3e1a <_spi_m_sync_init+0x106>
	ASSERT(hw && regs);
    3eca:	2000      	movs	r0, #0
    3ecc:	e7c5      	b.n	3e5a <_spi_m_sync_init+0x146>
    3ece:	2000      	movs	r0, #0
    3ed0:	e7c3      	b.n	3e5a <_spi_m_sync_init+0x146>
	ASSERT(hw && regs);
    3ed2:	2000      	movs	r0, #0
    3ed4:	e775      	b.n	3dc2 <_spi_m_sync_init+0xae>
    3ed6:	2000      	movs	r0, #0
    3ed8:	e773      	b.n	3dc2 <_spi_m_sync_init+0xae>
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    3eda:	2302      	movs	r3, #2
    3edc:	e7a1      	b.n	3e22 <_spi_m_sync_init+0x10e>
		return ERR_INVALID_ARG;
    3ede:	200d      	movs	r0, #13
    3ee0:	4240      	negs	r0, r0
    3ee2:	e7a5      	b.n	3e30 <_spi_m_sync_init+0x11c>
    3ee4:	00003351 	.word	0x00003351
    3ee8:	00000952 	.word	0x00000952
    3eec:	0000acb4 	.word	0x0000acb4
    3ef0:	000026c1 	.word	0x000026c1
    3ef4:	00000917 	.word	0x00000917
    3ef8:	fffffefc 	.word	0xfffffefc
    3efc:	fffd1dbf 	.word	0xfffd1dbf
    3f00:	0000ac50 	.word	0x0000ac50
    3f04:	0000092b 	.word	0x0000092b
    3f08:	fffdddbf 	.word	0xfffdddbf
    3f0c:	00020240 	.word	0x00020240

00003f10 <_spi_m_sync_trans>:

	return ERR_NONE;
}

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
    3f10:	b5f0      	push	{r4, r5, r6, r7, lr}
    3f12:	46ce      	mov	lr, r9
    3f14:	4647      	mov	r7, r8
    3f16:	b580      	push	{r7, lr}
    3f18:	b089      	sub	sp, #36	; 0x24
    3f1a:	4681      	mov	r9, r0
    3f1c:	000d      	movs	r5, r1
	void *                 hw   = dev->prvt;
    3f1e:	6804      	ldr	r4, [r0, #0]
	int32_t                rc   = 0;
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
    3f20:	680b      	ldr	r3, [r1, #0]
    3f22:	9303      	str	r3, [sp, #12]
    3f24:	684b      	ldr	r3, [r1, #4]
    3f26:	9304      	str	r3, [sp, #16]
    3f28:	2300      	movs	r3, #0
    3f2a:	9305      	str	r3, [sp, #20]
    3f2c:	9306      	str	r3, [sp, #24]
    3f2e:	7906      	ldrb	r6, [r0, #4]

	ASSERT(dev && hw);
    3f30:	2800      	cmp	r0, #0
    3f32:	d014      	beq.n	3f5e <_spi_m_sync_trans+0x4e>
    3f34:	2c00      	cmp	r4, #0
    3f36:	d010      	beq.n	3f5a <_spi_m_sync_trans+0x4a>
    3f38:	2001      	movs	r0, #1
    3f3a:	4a37      	ldr	r2, [pc, #220]	; (4018 <_spi_m_sync_trans+0x108>)
    3f3c:	4937      	ldr	r1, [pc, #220]	; (401c <_spi_m_sync_trans+0x10c>)
    3f3e:	4b38      	ldr	r3, [pc, #224]	; (4020 <_spi_m_sync_trans+0x110>)
    3f40:	4798      	blx	r3
    3f42:	69e3      	ldr	r3, [r4, #28]

	/* If settings are not applied (pending), we can not go on */
	if (hri_sercomspi_is_syncing(
    3f44:	075b      	lsls	r3, r3, #29
    3f46:	d164      	bne.n	4012 <_spi_m_sync_trans+0x102>
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    3f48:	69e3      	ldr	r3, [r4, #28]
    3f4a:	079b      	lsls	r3, r3, #30
    3f4c:	d1fc      	bne.n	3f48 <_spi_m_sync_trans+0x38>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    3f4e:	6823      	ldr	r3, [r4, #0]
	        hw, (SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE | SERCOM_SPI_SYNCBUSY_CTRLB))) {
		return ERR_BUSY;
	}

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_sercomspi_get_CTRLA_ENABLE_bit(hw)) {
    3f50:	079b      	lsls	r3, r3, #30
    3f52:	d420      	bmi.n	3f96 <_spi_m_sync_trans+0x86>
		return ERR_NOT_INITIALIZED;
    3f54:	2014      	movs	r0, #20
    3f56:	4240      	negs	r0, r0
    3f58:	e056      	b.n	4008 <_spi_m_sync_trans+0xf8>
	ASSERT(dev && hw);
    3f5a:	2000      	movs	r0, #0
    3f5c:	e7ed      	b.n	3f3a <_spi_m_sync_trans+0x2a>
    3f5e:	2000      	movs	r0, #0
    3f60:	e7eb      	b.n	3f3a <_spi_m_sync_trans+0x2a>
		return false;
    3f62:	2200      	movs	r2, #0
    3f64:	e02d      	b.n	3fc2 <_spi_m_sync_trans+0xb2>
			data |= (*ctrl->txbuf) << 8;
    3f66:	7848      	ldrb	r0, [r1, #1]
    3f68:	0200      	lsls	r0, r0, #8
    3f6a:	4647      	mov	r7, r8
    3f6c:	4307      	orrs	r7, r0
    3f6e:	46b8      	mov	r8, r7
			ctrl->txbuf++;
    3f70:	3102      	adds	r1, #2
    3f72:	9103      	str	r1, [sp, #12]
	ctrl->txcnt++;
    3f74:	3201      	adds	r2, #1
    3f76:	9205      	str	r2, [sp, #20]
	((Sercom *)hw)->SPI.DATA.reg = data;
    3f78:	4642      	mov	r2, r8
    3f7a:	62a2      	str	r2, [r4, #40]	; 0x28
	if (SERCOM_SPI_INTFLAG_ERROR & iflag) {
    3f7c:	b25b      	sxtb	r3, r3
    3f7e:	2b00      	cmp	r3, #0
    3f80:	db35      	blt.n	3fee <_spi_m_sync_trans+0xde>
	return ERR_NONE;
    3f82:	2000      	movs	r0, #0
			}
		}

		rc = _spi_err_check(iflag, hw);

		if (rc < 0) {
    3f84:	2800      	cmp	r0, #0
    3f86:	db3a      	blt.n	3ffe <_spi_m_sync_trans+0xee>
			break;
		}
		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
    3f88:	9805      	ldr	r0, [sp, #20]
    3f8a:	68ab      	ldr	r3, [r5, #8]
    3f8c:	4298      	cmp	r0, r3
    3f8e:	d302      	bcc.n	3f96 <_spi_m_sync_trans+0x86>
    3f90:	9a06      	ldr	r2, [sp, #24]
    3f92:	4293      	cmp	r3, r2
    3f94:	d933      	bls.n	3ffe <_spi_m_sync_trans+0xee>
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
    3f96:	7e23      	ldrb	r3, [r4, #24]
    3f98:	b2db      	uxtb	r3, r3
	if (!(iflag & SERCOM_SPI_INTFLAG_RXC)) {
    3f9a:	075a      	lsls	r2, r3, #29
    3f9c:	d5e1      	bpl.n	3f62 <_spi_m_sync_trans+0x52>
	return ((Sercom *)hw)->SPI.DATA.reg;
    3f9e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
	if (ctrl->rxbuf) {
    3fa0:	9a04      	ldr	r2, [sp, #16]
    3fa2:	2a00      	cmp	r2, #0
    3fa4:	d008      	beq.n	3fb8 <_spi_m_sync_trans+0xa8>
		*ctrl->rxbuf++ = (uint8_t)data;
    3fa6:	1c50      	adds	r0, r2, #1
    3fa8:	9004      	str	r0, [sp, #16]
    3faa:	7011      	strb	r1, [r2, #0]
		if (ctrl->char_size > 1) {
    3fac:	2e01      	cmp	r6, #1
    3fae:	d903      	bls.n	3fb8 <_spi_m_sync_trans+0xa8>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
    3fb0:	1c90      	adds	r0, r2, #2
    3fb2:	9004      	str	r0, [sp, #16]
    3fb4:	0a09      	lsrs	r1, r1, #8
    3fb6:	7051      	strb	r1, [r2, #1]
	ctrl->rxcnt++;
    3fb8:	9a06      	ldr	r2, [sp, #24]
    3fba:	9201      	str	r2, [sp, #4]
    3fbc:	3201      	adds	r2, #1
    3fbe:	9206      	str	r2, [sp, #24]
	return true;
    3fc0:	2201      	movs	r2, #1
		if (!_spi_rx_check_and_receive(hw, iflag, &ctrl)) {
    3fc2:	2a00      	cmp	r2, #0
    3fc4:	d1da      	bne.n	3f7c <_spi_m_sync_trans+0x6c>
			if (ctrl.rxcnt >= ctrl.txcnt) {
    3fc6:	9906      	ldr	r1, [sp, #24]
    3fc8:	9a05      	ldr	r2, [sp, #20]
    3fca:	4291      	cmp	r1, r2
    3fcc:	d3d6      	bcc.n	3f7c <_spi_m_sync_trans+0x6c>
				_spi_tx_check_and_send(hw, iflag, &ctrl, dev->dummy_byte);
    3fce:	4649      	mov	r1, r9
    3fd0:	88c8      	ldrh	r0, [r1, #6]
	if (!(SERCOM_SPI_INTFLAG_DRE & iflag)) {
    3fd2:	07d9      	lsls	r1, r3, #31
    3fd4:	d5d2      	bpl.n	3f7c <_spi_m_sync_trans+0x6c>
	if (ctrl->txbuf) {
    3fd6:	9903      	ldr	r1, [sp, #12]
    3fd8:	2900      	cmp	r1, #0
    3fda:	d006      	beq.n	3fea <_spi_m_sync_trans+0xda>
		data = *ctrl->txbuf++;
    3fdc:	1c48      	adds	r0, r1, #1
    3fde:	9003      	str	r0, [sp, #12]
    3fe0:	7808      	ldrb	r0, [r1, #0]
    3fe2:	4680      	mov	r8, r0
		if (ctrl->char_size > 1) {
    3fe4:	2e01      	cmp	r6, #1
    3fe6:	d8be      	bhi.n	3f66 <_spi_m_sync_trans+0x56>
    3fe8:	e7c4      	b.n	3f74 <_spi_m_sync_trans+0x64>
		data = dummy;
    3fea:	4680      	mov	r8, r0
    3fec:	e7c2      	b.n	3f74 <_spi_m_sync_trans+0x64>
	((Sercom *)hw)->SPI.STATUS.reg = mask;
    3fee:	2301      	movs	r3, #1
    3ff0:	425b      	negs	r3, r3
    3ff2:	8363      	strh	r3, [r4, #26]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    3ff4:	3381      	adds	r3, #129	; 0x81
    3ff6:	7623      	strb	r3, [r4, #24]
		return ERR_OVERFLOW;
    3ff8:	2013      	movs	r0, #19
    3ffa:	4240      	negs	r0, r0
    3ffc:	e7c2      	b.n	3f84 <_spi_m_sync_trans+0x74>
	tmp = ((Sercom *)hw)->SPI.INTFLAG.reg;
    3ffe:	7e23      	ldrb	r3, [r4, #24]
	while (!(hri_sercomspi_get_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE))) {
    4000:	079b      	lsls	r3, r3, #30
    4002:	d0fc      	beq.n	3ffe <_spi_m_sync_trans+0xee>
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    4004:	2303      	movs	r3, #3
    4006:	7623      	strb	r3, [r4, #24]
	}
	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);

	return rc;
}
    4008:	b009      	add	sp, #36	; 0x24
    400a:	bc0c      	pop	{r2, r3}
    400c:	4690      	mov	r8, r2
    400e:	4699      	mov	r9, r3
    4010:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_BUSY;
    4012:	2004      	movs	r0, #4
    4014:	4240      	negs	r0, r0
    4016:	e7f7      	b.n	4008 <_spi_m_sync_trans+0xf8>
    4018:	00000ab2 	.word	0x00000ab2
    401c:	0000acb4 	.word	0x0000acb4
    4020:	000026c1 	.word	0x000026c1

00004024 <_sysctrl_init_sources>:
}

static inline hri_sysctrl_osc8m_reg_t hri_sysctrl_read_OSC8M_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC8M.reg;
    4024:	4a0e      	ldr	r2, [pc, #56]	; (4060 <_sysctrl_init_sources+0x3c>)
    4026:	6a11      	ldr	r1, [r2, #32]
	tmp = (tmp & SYSCTRL_OSC8M_CALIB_Msk) >> SYSCTRL_OSC8M_CALIB_Pos;
    4028:	0c09      	lsrs	r1, r1, #16
}

static inline hri_sysctrl_osc8m_reg_t hri_sysctrl_read_OSC8M_FRANGE_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC8M.reg;
    402a:	6a13      	ldr	r3, [r2, #32]

#if CONF_OSC8M_CONFIG == 1
	calib = hri_sysctrl_read_OSC8M_CALIB_bf(hw);

	hri_sysctrl_write_OSC8M_reg(hw,
	                            SYSCTRL_OSC8M_FRANGE(hri_sysctrl_read_OSC8M_FRANGE_bf(hw)) |
    402c:	0f9b      	lsrs	r3, r3, #30
    402e:	079b      	lsls	r3, r3, #30
#if CONF_OSC8M_OVERWRITE_CALIBRATION == 1
	                                SYSCTRL_OSC8M_CALIB(CONF_OSC8M_CALIB) |
#else
	                                SYSCTRL_OSC8M_CALIB(calib) |
    4030:	0409      	lsls	r1, r1, #16
    4032:	480c      	ldr	r0, [pc, #48]	; (4064 <_sysctrl_init_sources+0x40>)
    4034:	4001      	ands	r1, r0
#endif
	                                SYSCTRL_OSC8M_PRESC(CONF_OSC8M_PRESC)
	                                | (CONF_OSC8M_RUNSTDBY << SYSCTRL_OSC8M_RUNSTDBY_Pos)
    4036:	430b      	orrs	r3, r1
	hri_sysctrl_write_OSC8M_reg(hw,
    4038:	2102      	movs	r1, #2
    403a:	430b      	orrs	r3, r1
}

static inline void hri_sysctrl_write_OSC8M_reg(const void *const hw, hri_sysctrl_osc8m_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC8M.reg = data;
    403c:	6213      	str	r3, [r2, #32]
	((Sysctrl *)hw)->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    403e:	6993      	ldr	r3, [r2, #24]
    4040:	430b      	orrs	r3, r1
    4042:	6193      	str	r3, [r2, #24]
	tmp = ((Sysctrl *)hw)->OSCULP32K.reg;
    4044:	7f13      	ldrb	r3, [r2, #28]
	tmp = (tmp & SYSCTRL_OSCULP32K_CALIB_Msk) >> SYSCTRL_OSCULP32K_CALIB_Pos;
    4046:	311d      	adds	r1, #29
    4048:	400b      	ands	r3, r1
	((Sysctrl *)hw)->OSCULP32K.reg = data;
    404a:	7713      	strb	r3, [r2, #28]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_OSC8MRDY) >> SYSCTRL_PCLKSR_OSC8MRDY_Pos;
    404c:	4b04      	ldr	r3, [pc, #16]	; (4060 <_sysctrl_init_sources+0x3c>)
    404e:	68db      	ldr	r3, [r3, #12]
#endif
#endif

#if CONF_OSC8M_CONFIG == 1
#if CONF_OSC8M_ENABLE == 1
	while (!hri_sysctrl_get_PCLKSR_OSC8MRDY_bit(hw))
    4050:	071b      	lsls	r3, r3, #28
    4052:	d5fb      	bpl.n	404c <_sysctrl_init_sources+0x28>
	((Sysctrl *)hw)->OSC8M.reg |= SYSCTRL_OSC8M_ONDEMAND;
    4054:	4a02      	ldr	r2, [pc, #8]	; (4060 <_sysctrl_init_sources+0x3c>)
    4056:	6a13      	ldr	r3, [r2, #32]
    4058:	2180      	movs	r1, #128	; 0x80
    405a:	430b      	orrs	r3, r1
    405c:	6213      	str	r3, [r2, #32]
	hri_sysctrl_set_OSC8M_ONDEMAND_bit(hw);
#endif
#endif

	(void)calib, (void)hw;
}
    405e:	4770      	bx	lr
    4060:	40000800 	.word	0x40000800
    4064:	0fff0000 	.word	0x0fff0000

00004068 <_sysctrl_init_referenced_generators>:
}

static inline void hri_sysctrl_write_DFLLCTRL_reg(const void *const hw, hri_sysctrl_dfllctrl_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
    4068:	2202      	movs	r2, #2
    406a:	4b17      	ldr	r3, [pc, #92]	; (40c8 <_sysctrl_init_referenced_generators+0x60>)
    406c:	849a      	strh	r2, [r3, #36]	; 0x24
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
    406e:	4b16      	ldr	r3, [pc, #88]	; (40c8 <_sysctrl_init_referenced_generators+0x60>)
    4070:	68db      	ldr	r3, [r3, #12]
	hri_gclk_write_CLKCTRL_reg(GCLK,
	                           GCLK_CLKCTRL_ID(0) | GCLK_CLKCTRL_GEN(CONF_DFLL_GCLK) | (1 << GCLK_CLKCTRL_CLKEN_Pos));
#endif

	hri_sysctrl_write_DFLLCTRL_reg(hw, SYSCTRL_DFLLCTRL_ENABLE);
	while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    4072:	06db      	lsls	r3, r3, #27
    4074:	d5fb      	bpl.n	406e <_sysctrl_init_referenced_generators+0x6>
}

static inline void hri_sysctrl_write_DFLLMUL_reg(const void *const hw, hri_sysctrl_dfllmul_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLMUL.reg = data;
    4076:	4a15      	ldr	r2, [pc, #84]	; (40cc <_sysctrl_init_referenced_generators+0x64>)
    4078:	4b13      	ldr	r3, [pc, #76]	; (40c8 <_sysctrl_init_referenced_generators+0x60>)
    407a:	62da      	str	r2, [r3, #44]	; 0x2c
		;

	hri_sysctrl_write_DFLLMUL_reg(hw,
	                              SYSCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | SYSCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | SYSCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
    407c:	4b14      	ldr	r3, [pc, #80]	; (40d0 <_sysctrl_init_referenced_generators+0x68>)
    407e:	681b      	ldr	r3, [r3, #0]
    4080:	0e9b      	lsrs	r3, r3, #26
    4082:	2b3f      	cmp	r3, #63	; 0x3f
    4084:	d018      	beq.n	40b8 <_sysctrl_init_referenced_generators+0x50>
    4086:	029b      	lsls	r3, r3, #10
    4088:	2280      	movs	r2, #128	; 0x80
    408a:	0092      	lsls	r2, r2, #2
    408c:	4313      	orrs	r3, r2
	((Sysctrl *)hw)->DFLLVAL.reg = data;
    408e:	4a0e      	ldr	r2, [pc, #56]	; (40c8 <_sysctrl_init_referenced_generators+0x60>)
    4090:	6293      	str	r3, [r2, #40]	; 0x28
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
    4092:	4b10      	ldr	r3, [pc, #64]	; (40d4 <_sysctrl_init_referenced_generators+0x6c>)
    4094:	8493      	strh	r3, [r2, #36]	; 0x24
	tmp = ((Sysctrl *)hw)->DFLLCTRL.reg;
    4096:	8c93      	ldrh	r3, [r2, #36]	; 0x24
	        | SYSCTRL_DPLLCTRLB_FILTER(CONF_DPLL_FILTER));
#endif

#if CONF_DFLL_CONFIG == 1
#if CONF_DFLL_ENABLE == 1
	if (hri_sysctrl_get_DFLLCTRL_MODE_bit(hw)) {
    4098:	075b      	lsls	r3, r3, #29
    409a:	d510      	bpl.n	40be <_sysctrl_init_referenced_generators+0x56>
	tmp = ((Sysctrl *)hw)->PCLKSR.reg;
    409c:	4b0a      	ldr	r3, [pc, #40]	; (40c8 <_sysctrl_init_referenced_generators+0x60>)
    409e:	68db      	ldr	r3, [r3, #12]
		    = SYSCTRL_PCLKSR_DFLLRDY | SYSCTRL_PCLKSR_DFLLLCKF | SYSCTRL_PCLKSR_DFLLLCKC;
#else
		hri_sysctrl_pclksr_reg_t status_mask = SYSCTRL_PCLKSR_DFLLRDY;
#endif

		while (hri_sysctrl_get_PCLKSR_reg(hw, status_mask) != status_mask)
    40a0:	06db      	lsls	r3, r3, #27
    40a2:	d5fb      	bpl.n	409c <_sysctrl_init_referenced_generators+0x34>
	return (((Gclk *)hw)->STATUS.reg & GCLK_STATUS_SYNCBUSY) >> GCLK_STATUS_SYNCBUSY_Pos;
    40a4:	4b0c      	ldr	r3, [pc, #48]	; (40d8 <_sysctrl_init_referenced_generators+0x70>)
    40a6:	785b      	ldrb	r3, [r3, #1]
	hri_sysctrl_set_DPLLCTRLA_ONDEMAND_bit(hw);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_get_STATUS_SYNCBUSY_bit(GCLK))
    40a8:	09db      	lsrs	r3, r3, #7
    40aa:	d1fb      	bne.n	40a4 <_sysctrl_init_referenced_generators+0x3c>
	((Sysctrl *)hw)->OSC32K.reg &= ~SYSCTRL_OSC32K_ENABLE;
    40ac:	4a06      	ldr	r2, [pc, #24]	; (40c8 <_sysctrl_init_referenced_generators+0x60>)
    40ae:	6993      	ldr	r3, [r2, #24]
    40b0:	2102      	movs	r1, #2
    40b2:	438b      	bics	r3, r1
    40b4:	6193      	str	r3, [r2, #24]
	/* Disable after all possible configurations needs sync written. */
	hri_sysctrl_clear_OSC32K_ENABLE_bit(hw);
#endif

	(void)hw;
}
    40b6:	4770      	bx	lr
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
    40b8:	23fc      	movs	r3, #252	; 0xfc
    40ba:	01db      	lsls	r3, r3, #7
    40bc:	e7e7      	b.n	408e <_sysctrl_init_referenced_generators+0x26>
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
    40be:	4b02      	ldr	r3, [pc, #8]	; (40c8 <_sysctrl_init_referenced_generators+0x60>)
    40c0:	68db      	ldr	r3, [r3, #12]
		while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    40c2:	06db      	lsls	r3, r3, #27
    40c4:	d5fb      	bpl.n	40be <_sysctrl_init_referenced_generators+0x56>
    40c6:	e7ed      	b.n	40a4 <_sysctrl_init_referenced_generators+0x3c>
    40c8:	40000800 	.word	0x40000800
    40cc:	0401bb80 	.word	0x0401bb80
    40d0:	00806024 	.word	0x00806024
    40d4:	00000526 	.word	0x00000526
    40d8:	40000c00 	.word	0x40000c00

000040dc <_dummy_func_no_return>:
static bool _dummy_func_no_return(uint32_t unused0, uint32_t unused1)
{
	(void)unused0;
	(void)unused1;
	return false;
}
    40dc:	2000      	movs	r0, #0
    40de:	4770      	bx	lr

000040e0 <_usb_load_calib>:
#define NVM_USB_PAD_TRANSP_SIZE 5
#define NVM_USB_PAD_TRIM_POS 55
#define NVM_USB_PAD_TRIM_SIZE 3
	Usb *    hw = USB;
	uint32_t pad_transn
	    = (*((uint32_t *)(NVMCTRL_OTP4) + (NVM_USB_PAD_TRANSN_POS / 32)) >> (NVM_USB_PAD_TRANSN_POS % 32))
    40e0:	4b12      	ldr	r3, [pc, #72]	; (412c <_usb_load_calib+0x4c>)
    40e2:	681a      	ldr	r2, [r3, #0]
    40e4:	0b53      	lsrs	r3, r2, #13
	uint32_t pad_transn
    40e6:	211f      	movs	r1, #31
    40e8:	400b      	ands	r3, r1
	      & ((1 << NVM_USB_PAD_TRANSN_SIZE) - 1);
	uint32_t pad_transp
	    = (*((uint32_t *)(NVMCTRL_OTP4) + (NVM_USB_PAD_TRANSP_POS / 32)) >> (NVM_USB_PAD_TRANSP_POS % 32))
    40ea:	0c90      	lsrs	r0, r2, #18
	uint32_t pad_transp
    40ec:	4001      	ands	r1, r0
	      & ((1 << NVM_USB_PAD_TRANSP_SIZE) - 1);
	uint32_t pad_trim = (*((uint32_t *)(NVMCTRL_OTP4) + (NVM_USB_PAD_TRIM_POS / 32)) >> (NVM_USB_PAD_TRIM_POS % 32))
    40ee:	0dd0      	lsrs	r0, r2, #23
    40f0:	2207      	movs	r2, #7
    40f2:	4002      	ands	r2, r0
	                    & ((1 << NVM_USB_PAD_TRIM_SIZE) - 1);
	if (pad_transn == 0x1F) {
    40f4:	2b1f      	cmp	r3, #31
    40f6:	d012      	beq.n	411e <_usb_load_calib+0x3e>
		pad_transn = 5;
	}
	if (pad_transp == 0x1F) {
    40f8:	291f      	cmp	r1, #31
    40fa:	d012      	beq.n	4122 <_usb_load_calib+0x42>
		pad_transp = 29;
	}
	if (pad_trim == 0x7) {
    40fc:	2a07      	cmp	r2, #7
    40fe:	d012      	beq.n	4126 <_usb_load_calib+0x46>
		pad_trim = 5;
	}

	hw->DEVICE.PADCAL.reg = USB_PADCAL_TRANSN(pad_transn) | USB_PADCAL_TRANSP(pad_transp) | USB_PADCAL_TRIM(pad_trim);
    4100:	019b      	lsls	r3, r3, #6
    4102:	430b      	orrs	r3, r1
    4104:	0312      	lsls	r2, r2, #12
    4106:	4313      	orrs	r3, r2
    4108:	4a09      	ldr	r2, [pc, #36]	; (4130 <_usb_load_calib+0x50>)
    410a:	8513      	strh	r3, [r2, #40]	; 0x28

	hw->DEVICE.QOSCTRL.bit.CQOS = 3;
    410c:	78d3      	ldrb	r3, [r2, #3]
    410e:	2103      	movs	r1, #3
    4110:	430b      	orrs	r3, r1
    4112:	70d3      	strb	r3, [r2, #3]
	hw->DEVICE.QOSCTRL.bit.DQOS = 3;
    4114:	78d3      	ldrb	r3, [r2, #3]
    4116:	210c      	movs	r1, #12
    4118:	430b      	orrs	r3, r1
    411a:	70d3      	strb	r3, [r2, #3]
}
    411c:	4770      	bx	lr
		pad_transn = 5;
    411e:	3b1a      	subs	r3, #26
    4120:	e7ea      	b.n	40f8 <_usb_load_calib+0x18>
		pad_transp = 29;
    4122:	3902      	subs	r1, #2
    4124:	e7ea      	b.n	40fc <_usb_load_calib+0x1c>
		pad_trim = 5;
    4126:	3a02      	subs	r2, #2
    4128:	e7ea      	b.n	4100 <_usb_load_calib+0x20>
    412a:	46c0      	nop			; (mov r8, r8)
    412c:	00806024 	.word	0x00806024
    4130:	41005000 	.word	0x41005000

00004134 <_usb_d_dev_handle_setup>:
/**
 * \brief Handles setup received interrupt
 * \param[in] ept Pointer to endpoint information.
 */
static void _usb_d_dev_handle_setup(struct _usb_d_dev_ep *ept)
{
    4134:	b510      	push	{r4, lr}
	uint8_t epn     = USB_EP_GET_N(ept->ep);
    4136:	7c83      	ldrb	r3, [r0, #18]
    4138:	220f      	movs	r2, #15
    413a:	4013      	ands	r3, r2
	bool    is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    413c:	7cc1      	ldrb	r1, [r0, #19]
    413e:	3a08      	subs	r2, #8
    4140:	400a      	ands	r2, r1

	if (!is_ctrl) {
    4142:	2a01      	cmp	r2, #1
    4144:	d00d      	beq.n	4162 <_usb_d_dev_handle_setup+0x2e>
}

static inline void hri_usbendpoint_clear_EPINTFLAG_reg(const void *const hw, uint8_t submodule_index,
                                                       hri_usbendpoint_epintflag_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    4146:	001a      	movs	r2, r3
    4148:	3208      	adds	r2, #8
    414a:	0152      	lsls	r2, r2, #5
    414c:	4919      	ldr	r1, [pc, #100]	; (41b4 <_usb_d_dev_handle_setup+0x80>)
    414e:	468c      	mov	ip, r1
    4150:	4462      	add	r2, ip
    4152:	2110      	movs	r1, #16
    4154:	71d1      	strb	r1, [r2, #7]
	}
}

static inline void hri_usbendpoint_clear_EPINTEN_RXSTP_bit(const void *const hw, uint8_t submodule_index)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = USB_DEVICE_EPINTENSET_RXSTP;
    4156:	015b      	lsls	r3, r3, #5
    4158:	4a17      	ldr	r2, [pc, #92]	; (41b8 <_usb_d_dev_handle_setup+0x84>)
    415a:	4694      	mov	ip, r2
    415c:	4463      	add	r3, ip
    415e:	7019      	strb	r1, [r3, #0]
	_usbd_ep_clear_bank_status(epn, 1);
	_usbd_ep_int_ack(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	_usbd_ep_int_dis(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	/* Invoke callback. */
	dev_inst.ep_callbacks.setup(ept->ep);
}
    4160:	bd10      	pop	{r4, pc}
	if (_usb_d_dev_ep_is_busy(ept)) {
    4162:	064a      	lsls	r2, r1, #25
    4164:	d50c      	bpl.n	4180 <_usb_d_dev_handle_setup+0x4c>
		ept->flags.bits.is_busy = 0;
    4166:	7cc2      	ldrb	r2, [r0, #19]
    4168:	2140      	movs	r1, #64	; 0x40
    416a:	438a      	bics	r2, r1
    416c:	74c2      	strb	r2, [r0, #19]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    416e:	001a      	movs	r2, r3
    4170:	3208      	adds	r2, #8
    4172:	0152      	lsls	r2, r2, #5
    4174:	4c0f      	ldr	r4, [pc, #60]	; (41b4 <_usb_d_dev_handle_setup+0x80>)
    4176:	46a4      	mov	ip, r4
    4178:	4462      	add	r2, ip
    417a:	2480      	movs	r4, #128	; 0x80
    417c:	7114      	strb	r4, [r2, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    417e:	7151      	strb	r1, [r2, #5]
	ept->flags.bits.is_stalled = 0;
    4180:	7cc2      	ldrb	r2, [r0, #19]
    4182:	2108      	movs	r1, #8
    4184:	438a      	bics	r2, r1
    4186:	74c2      	strb	r2, [r0, #19]
	bank->STATUS_BK.reg     = 0;
    4188:	015a      	lsls	r2, r3, #5
    418a:	490c      	ldr	r1, [pc, #48]	; (41bc <_usb_d_dev_handle_setup+0x88>)
    418c:	1889      	adds	r1, r1, r2
    418e:	2400      	movs	r4, #0
    4190:	728c      	strb	r4, [r1, #10]
    4192:	768c      	strb	r4, [r1, #26]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    4194:	3308      	adds	r3, #8
    4196:	015b      	lsls	r3, r3, #5
    4198:	4906      	ldr	r1, [pc, #24]	; (41b4 <_usb_d_dev_handle_setup+0x80>)
    419a:	468c      	mov	ip, r1
    419c:	4463      	add	r3, ip
    419e:	216f      	movs	r1, #111	; 0x6f
    41a0:	71d9      	strb	r1, [r3, #7]
}

static inline void hri_usbendpoint_clear_EPINTEN_reg(const void *const hw, uint8_t submodule_index,
                                                     hri_usbendpoint_epintenset_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    41a2:	4b05      	ldr	r3, [pc, #20]	; (41b8 <_usb_d_dev_handle_setup+0x84>)
    41a4:	469c      	mov	ip, r3
    41a6:	4462      	add	r2, ip
    41a8:	7011      	strb	r1, [r2, #0]
	dev_inst.ep_callbacks.setup(ept->ep);
    41aa:	4b05      	ldr	r3, [pc, #20]	; (41c0 <_usb_d_dev_handle_setup+0x8c>)
    41ac:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    41ae:	7c80      	ldrb	r0, [r0, #18]
    41b0:	4798      	blx	r3
    41b2:	e7d5      	b.n	4160 <_usb_d_dev_handle_setup+0x2c>
    41b4:	41005000 	.word	0x41005000
    41b8:	41005108 	.word	0x41005108
    41bc:	200003c8 	.word	0x200003c8
    41c0:	20000448 	.word	0x20000448

000041c4 <_usb_d_dev_handle_stall>:
 * \brief Handles stall sent interrupt
 * \param[in] ept Pointer to endpoint information.
 * \param[in] bank_n Bank number.
 */
static void _usb_d_dev_handle_stall(struct _usb_d_dev_ep *ept, const uint8_t bank_n)
{
    41c4:	b510      	push	{r4, lr}
	uint8_t epn = USB_EP_GET_N(ept->ep);
    41c6:	7c82      	ldrb	r2, [r0, #18]
    41c8:	230f      	movs	r3, #15
    41ca:	4013      	ands	r3, r2
		_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << bank_n);
    41cc:	2220      	movs	r2, #32
    41ce:	408a      	lsls	r2, r1
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    41d0:	b2d2      	uxtb	r2, r2
    41d2:	015b      	lsls	r3, r3, #5
    41d4:	4905      	ldr	r1, [pc, #20]	; (41ec <_usb_d_dev_handle_stall+0x28>)
    41d6:	468c      	mov	ip, r1
    41d8:	4463      	add	r3, ip
    41da:	701a      	strb	r2, [r3, #0]
	/* Clear interrupt enable. Leave status there for status check. */
	_usbd_ep_int_stall_en(epn, bank_n, false);
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    41dc:	4b04      	ldr	r3, [pc, #16]	; (41f0 <_usb_d_dev_handle_stall+0x2c>)
    41de:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    41e0:	6882      	ldr	r2, [r0, #8]
    41e2:	7c80      	ldrb	r0, [r0, #18]
    41e4:	2101      	movs	r1, #1
    41e6:	4798      	blx	r3
}
    41e8:	bd10      	pop	{r4, pc}
    41ea:	46c0      	nop			; (mov r8, r8)
    41ec:	41005108 	.word	0x41005108
    41f0:	20000448 	.word	0x20000448

000041f4 <_usb_d_dev_trans_done>:
 *  \brief Finish the transaction and invoke callback
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_done(struct _usb_d_dev_ep *ept, const int32_t code)
{
    41f4:	b510      	push	{r4, lr}
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    41f6:	7c83      	ldrb	r3, [r0, #18]
    41f8:	2bff      	cmp	r3, #255	; 0xff
    41fa:	d002      	beq.n	4202 <_usb_d_dev_trans_done+0xe>
    41fc:	7cc2      	ldrb	r2, [r0, #19]
    41fe:	0652      	lsls	r2, r2, #25
    4200:	d400      	bmi.n	4204 <_usb_d_dev_trans_done+0x10>
		return;
	}
	ept->flags.bits.is_busy = 0;
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
}
    4202:	bd10      	pop	{r4, pc}
	ept->flags.bits.is_busy = 0;
    4204:	7cc2      	ldrb	r2, [r0, #19]
    4206:	2440      	movs	r4, #64	; 0x40
    4208:	43a2      	bics	r2, r4
    420a:	74c2      	strb	r2, [r0, #19]
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
    420c:	4a02      	ldr	r2, [pc, #8]	; (4218 <_usb_d_dev_trans_done+0x24>)
    420e:	6d14      	ldr	r4, [r2, #80]	; 0x50
    4210:	6882      	ldr	r2, [r0, #8]
    4212:	0018      	movs	r0, r3
    4214:	47a0      	blx	r4
    4216:	e7f4      	b.n	4202 <_usb_d_dev_trans_done+0xe>
    4218:	20000448 	.word	0x20000448

0000421c <_usb_d_dev_trans_stop>:
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] dir Endpoint direction.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_stop(struct _usb_d_dev_ep *ept, bool dir, const int32_t code)
{
    421c:	b5f0      	push	{r4, r5, r6, r7, lr}
    421e:	b083      	sub	sp, #12
	uint8_t epn = USB_EP_GET_N(ept->ep);
    4220:	7c84      	ldrb	r4, [r0, #18]
    4222:	230f      	movs	r3, #15
    4224:	4023      	ands	r3, r4
	;
	const uint8_t intflags[2] = {USB_D_BANK0_INT_FLAGS, USB_D_BANK1_INT_FLAGS};
    4226:	4d18      	ldr	r5, [pc, #96]	; (4288 <_usb_d_dev_trans_stop+0x6c>)
    4228:	882e      	ldrh	r6, [r5, #0]
    422a:	ad01      	add	r5, sp, #4
    422c:	802e      	strh	r6, [r5, #0]
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    422e:	2cff      	cmp	r4, #255	; 0xff
    4230:	d01e      	beq.n	4270 <_usb_d_dev_trans_stop+0x54>
    4232:	7cc4      	ldrb	r4, [r0, #19]
    4234:	0664      	lsls	r4, r4, #25
    4236:	d51b      	bpl.n	4270 <_usb_d_dev_trans_stop+0x54>
		return;
	}
	/* Stop transfer */
	if (dir) {
    4238:	2900      	cmp	r1, #0
    423a:	d01b      	beq.n	4274 <_usb_d_dev_trans_stop+0x58>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    423c:	001c      	movs	r4, r3
    423e:	3408      	adds	r4, #8
    4240:	0164      	lsls	r4, r4, #5
    4242:	4d12      	ldr	r5, [pc, #72]	; (428c <_usb_d_dev_trans_stop+0x70>)
    4244:	46ac      	mov	ip, r5
    4246:	4464      	add	r4, ip
    4248:	2580      	movs	r5, #128	; 0x80
    424a:	7125      	strb	r5, [r4, #4]
		_usbd_ep_set_in_rdy(epn, 1, false);
	} else {
		/* NAK OUT */
		_usbd_ep_set_out_rdy(epn, 0, false);
	}
	_usbd_ep_int_ack(epn, intflags[dir]);
    424c:	ad01      	add	r5, sp, #4
    424e:	5c6e      	ldrb	r6, [r5, r1]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    4250:	001c      	movs	r4, r3
    4252:	3408      	adds	r4, #8
    4254:	0164      	lsls	r4, r4, #5
    4256:	4f0d      	ldr	r7, [pc, #52]	; (428c <_usb_d_dev_trans_stop+0x70>)
    4258:	46bc      	mov	ip, r7
    425a:	4464      	add	r4, ip
    425c:	71e6      	strb	r6, [r4, #7]
	_usbd_ep_int_dis(epn, intflags[dir]);
    425e:	5c69      	ldrb	r1, [r5, r1]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    4260:	015b      	lsls	r3, r3, #5
    4262:	4c0b      	ldr	r4, [pc, #44]	; (4290 <_usb_d_dev_trans_stop+0x74>)
    4264:	46a4      	mov	ip, r4
    4266:	4463      	add	r3, ip
    4268:	7019      	strb	r1, [r3, #0]
	_usb_d_dev_trans_done(ept, code);
    426a:	0011      	movs	r1, r2
    426c:	4b09      	ldr	r3, [pc, #36]	; (4294 <_usb_d_dev_trans_stop+0x78>)
    426e:	4798      	blx	r3
}
    4270:	b003      	add	sp, #12
    4272:	bdf0      	pop	{r4, r5, r6, r7, pc}
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    4274:	001c      	movs	r4, r3
    4276:	3408      	adds	r4, #8
    4278:	0164      	lsls	r4, r4, #5
    427a:	4d04      	ldr	r5, [pc, #16]	; (428c <_usb_d_dev_trans_stop+0x70>)
    427c:	46ac      	mov	ip, r5
    427e:	4464      	add	r4, ip
    4280:	2540      	movs	r5, #64	; 0x40
    4282:	7165      	strb	r5, [r4, #5]
    4284:	e7e2      	b.n	424c <_usb_d_dev_trans_stop+0x30>
    4286:	46c0      	nop			; (mov r8, r8)
    4288:	0000acd0 	.word	0x0000acd0
    428c:	41005000 	.word	0x41005000
    4290:	41005108 	.word	0x41005108
    4294:	000041f5 	.word	0x000041f5

00004298 <_usb_d_dev_handle_trfail>:
{
    4298:	b5f0      	push	{r4, r5, r6, r7, lr}
    429a:	b083      	sub	sp, #12
	uint8_t            epn     = USB_EP_GET_N(ept->ep);
    429c:	7c83      	ldrb	r3, [r0, #18]
    429e:	220f      	movs	r2, #15
    42a0:	4013      	ands	r3, r2
	const uint8_t      fail[2] = {USB_DEVICE_EPINTFLAG_TRFAIL0, USB_DEVICE_EPINTFLAG_TRFAIL1};
    42a2:	4a3c      	ldr	r2, [pc, #240]	; (4394 <_usb_d_dev_handle_trfail+0xfc>)
    42a4:	8894      	ldrh	r4, [r2, #4]
    42a6:	aa01      	add	r2, sp, #4
    42a8:	8014      	strh	r4, [r2, #0]
	UsbDeviceDescBank *bank    = prvt_inst.desc_table[epn].DeviceDescBank;
    42aa:	015a      	lsls	r2, r3, #5
    42ac:	4c3a      	ldr	r4, [pc, #232]	; (4398 <_usb_d_dev_handle_trfail+0x100>)
    42ae:	18a4      	adds	r4, r4, r2
	uint8_t            eptype
    42b0:	2900      	cmp	r1, #0
    42b2:	d033      	beq.n	431c <_usb_d_dev_handle_trfail+0x84>

static inline hri_usbendpoint_epcfg_reg_t hri_usbendpoint_read_EPCFG_EPTYPE1_bf(const void *const hw,
                                                                                uint8_t           submodule_index)
{
	uint8_t tmp;
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    42b4:	001a      	movs	r2, r3
    42b6:	3208      	adds	r2, #8
    42b8:	0152      	lsls	r2, r2, #5
    42ba:	4d38      	ldr	r5, [pc, #224]	; (439c <_usb_d_dev_handle_trfail+0x104>)
    42bc:	5d52      	ldrb	r2, [r2, r5]
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE1_Msk) >> USB_DEVICE_EPCFG_EPTYPE1_Pos;
    42be:	0912      	lsrs	r2, r2, #4
    42c0:	2507      	movs	r5, #7
    42c2:	4015      	ands	r5, r2
	bool                      is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    42c4:	7cc2      	ldrb	r2, [r0, #19]
    42c6:	2607      	movs	r6, #7
    42c8:	4016      	ands	r6, r2
	st.reg = bank[bank_n].STATUS_BK.reg;
    42ca:	010a      	lsls	r2, r1, #4
    42cc:	18a2      	adds	r2, r4, r2
    42ce:	7a94      	ldrb	r4, [r2, #10]
    42d0:	b2e4      	uxtb	r4, r4
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    42d2:	2d02      	cmp	r5, #2
    42d4:	d02a      	beq.n	432c <_usb_d_dev_handle_trfail+0x94>
	} else if (st.bit.ERRORFLOW) {
    42d6:	07a4      	lsls	r4, r4, #30
    42d8:	d544      	bpl.n	4364 <_usb_d_dev_handle_trfail+0xcc>
		bank[bank_n].STATUS_BK.bit.ERRORFLOW = 0;
    42da:	7a94      	ldrb	r4, [r2, #10]
    42dc:	2502      	movs	r5, #2
    42de:	43ac      	bics	r4, r5
    42e0:	7294      	strb	r4, [r2, #10]
		hri_usbendpoint_clear_EPINTFLAG_reg(hw, epn, fail[bank_n]);
    42e2:	ac01      	add	r4, sp, #4
    42e4:	5c65      	ldrb	r5, [r4, r1]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    42e6:	001a      	movs	r2, r3
    42e8:	3208      	adds	r2, #8
    42ea:	0152      	lsls	r2, r2, #5
    42ec:	4f2b      	ldr	r7, [pc, #172]	; (439c <_usb_d_dev_handle_trfail+0x104>)
    42ee:	46bc      	mov	ip, r7
    42f0:	4462      	add	r2, ip
    42f2:	71d5      	strb	r5, [r2, #7]
		hri_usbendpoint_clear_EPINTEN_reg(hw, epn, fail[bank_n]);
    42f4:	5c62      	ldrb	r2, [r4, r1]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    42f6:	015b      	lsls	r3, r3, #5
    42f8:	4c29      	ldr	r4, [pc, #164]	; (43a0 <_usb_d_dev_handle_trfail+0x108>)
    42fa:	46a4      	mov	ip, r4
    42fc:	4463      	add	r3, ip
    42fe:	701a      	strb	r2, [r3, #0]
		if (is_ctrl && _usb_d_dev_ep_is_busy(ept)) {
    4300:	2e01      	cmp	r6, #1
    4302:	d145      	bne.n	4390 <_usb_d_dev_handle_trfail+0xf8>
    4304:	7cc3      	ldrb	r3, [r0, #19]
    4306:	065b      	lsls	r3, r3, #25
    4308:	d542      	bpl.n	4390 <_usb_d_dev_handle_trfail+0xf8>
			if (bank_n != _usb_d_dev_ep_is_in(ept)) {
    430a:	7cc3      	ldrb	r3, [r0, #19]
    430c:	09db      	lsrs	r3, r3, #7
    430e:	4299      	cmp	r1, r3
    4310:	d03e      	beq.n	4390 <_usb_d_dev_handle_trfail+0xf8>
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    4312:	2200      	movs	r2, #0
    4314:	0019      	movs	r1, r3
    4316:	4b23      	ldr	r3, [pc, #140]	; (43a4 <_usb_d_dev_handle_trfail+0x10c>)
    4318:	4798      	blx	r3
    431a:	e039      	b.n	4390 <_usb_d_dev_handle_trfail+0xf8>
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    431c:	001a      	movs	r2, r3
    431e:	3208      	adds	r2, #8
    4320:	0152      	lsls	r2, r2, #5
    4322:	4d1e      	ldr	r5, [pc, #120]	; (439c <_usb_d_dev_handle_trfail+0x104>)
    4324:	5d55      	ldrb	r5, [r2, r5]
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE0_Msk) >> USB_DEVICE_EPCFG_EPTYPE0_Pos;
    4326:	2207      	movs	r2, #7
    4328:	4015      	ands	r5, r2
    432a:	e7cb      	b.n	42c4 <_usb_d_dev_handle_trfail+0x2c>
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    432c:	07e5      	lsls	r5, r4, #31
    432e:	d5d2      	bpl.n	42d6 <_usb_d_dev_handle_trfail+0x3e>
		bank[bank_n].STATUS_BK.bit.CRCERR = 0;
    4330:	7a94      	ldrb	r4, [r2, #10]
    4332:	2501      	movs	r5, #1
    4334:	43ac      	bics	r4, r5
    4336:	7294      	strb	r4, [r2, #10]
		hri_usbendpoint_clear_EPINTFLAG_reg(hw, epn, fail[bank_n]);
    4338:	ac01      	add	r4, sp, #4
    433a:	5c65      	ldrb	r5, [r4, r1]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    433c:	001a      	movs	r2, r3
    433e:	3208      	adds	r2, #8
    4340:	0152      	lsls	r2, r2, #5
    4342:	4e16      	ldr	r6, [pc, #88]	; (439c <_usb_d_dev_handle_trfail+0x104>)
    4344:	46b4      	mov	ip, r6
    4346:	4462      	add	r2, ip
    4348:	71d5      	strb	r5, [r2, #7]
		hri_usbendpoint_clear_EPINTEN_reg(hw, epn, fail[bank_n]);
    434a:	5c62      	ldrb	r2, [r4, r1]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    434c:	015b      	lsls	r3, r3, #5
    434e:	4c14      	ldr	r4, [pc, #80]	; (43a0 <_usb_d_dev_handle_trfail+0x108>)
    4350:	46a4      	mov	ip, r4
    4352:	4463      	add	r3, ip
    4354:	701a      	strb	r2, [r3, #0]
		_usb_d_dev_trans_stop(ept, bank_n, USB_TRANS_ERROR);
    4356:	1e4b      	subs	r3, r1, #1
    4358:	4199      	sbcs	r1, r3
    435a:	b2c9      	uxtb	r1, r1
    435c:	2204      	movs	r2, #4
    435e:	4b11      	ldr	r3, [pc, #68]	; (43a4 <_usb_d_dev_handle_trfail+0x10c>)
    4360:	4798      	blx	r3
    4362:	e015      	b.n	4390 <_usb_d_dev_handle_trfail+0xf8>
	bank->STATUS_BK.reg     = 0;
    4364:	005a      	lsls	r2, r3, #1
    4366:	1852      	adds	r2, r2, r1
    4368:	0112      	lsls	r2, r2, #4
    436a:	480b      	ldr	r0, [pc, #44]	; (4398 <_usb_d_dev_handle_trfail+0x100>)
    436c:	1882      	adds	r2, r0, r2
    436e:	2000      	movs	r0, #0
    4370:	7290      	strb	r0, [r2, #10]
		hri_usbendpoint_clear_EPINTFLAG_reg(hw, epn, fail[bank_n]);
    4372:	a801      	add	r0, sp, #4
    4374:	5c44      	ldrb	r4, [r0, r1]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    4376:	001a      	movs	r2, r3
    4378:	3208      	adds	r2, #8
    437a:	0152      	lsls	r2, r2, #5
    437c:	4d07      	ldr	r5, [pc, #28]	; (439c <_usb_d_dev_handle_trfail+0x104>)
    437e:	46ac      	mov	ip, r5
    4380:	4462      	add	r2, ip
    4382:	71d4      	strb	r4, [r2, #7]
		hri_usbendpoint_clear_EPINTEN_reg(hw, epn, fail[bank_n]);
    4384:	5c42      	ldrb	r2, [r0, r1]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    4386:	015b      	lsls	r3, r3, #5
    4388:	4905      	ldr	r1, [pc, #20]	; (43a0 <_usb_d_dev_handle_trfail+0x108>)
    438a:	468c      	mov	ip, r1
    438c:	4463      	add	r3, ip
    438e:	701a      	strb	r2, [r3, #0]
}
    4390:	b003      	add	sp, #12
    4392:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4394:	0000acd0 	.word	0x0000acd0
    4398:	200003c8 	.word	0x200003c8
    439c:	41005000 	.word	0x41005000
    43a0:	41005108 	.word	0x41005108
    43a4:	0000421d 	.word	0x0000421d

000043a8 <_usb_d_dev_reset_epts>:
{
    43a8:	b570      	push	{r4, r5, r6, lr}
	for (i = 0; i < USB_D_N_EP; i++) {
    43aa:	2500      	movs	r5, #0
    43ac:	e018      	b.n	43e0 <_usb_d_dev_reset_epts+0x38>
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    43ae:	4c10      	ldr	r4, [pc, #64]	; (43f0 <_usb_d_dev_reset_epts+0x48>)
    43b0:	3440      	adds	r4, #64	; 0x40
    43b2:	00ae      	lsls	r6, r5, #2
    43b4:	1973      	adds	r3, r6, r5
    43b6:	0098      	lsls	r0, r3, #2
    43b8:	3010      	adds	r0, #16
    43ba:	1820      	adds	r0, r4, r0
    43bc:	3004      	adds	r0, #4
    43be:	2103      	movs	r1, #3
    43c0:	4b0c      	ldr	r3, [pc, #48]	; (43f4 <_usb_d_dev_reset_epts+0x4c>)
    43c2:	4798      	blx	r3
		dev_inst.ep[i].ep       = 0xFF;
    43c4:	1972      	adds	r2, r6, r5
    43c6:	0093      	lsls	r3, r2, #2
    43c8:	18e3      	adds	r3, r4, r3
    43ca:	3326      	adds	r3, #38	; 0x26
    43cc:	22ff      	movs	r2, #255	; 0xff
    43ce:	701a      	strb	r2, [r3, #0]
		dev_inst.ep[i].flags.u8 = 0;
    43d0:	1976      	adds	r6, r6, r5
    43d2:	00b3      	lsls	r3, r6, #2
    43d4:	18e4      	adds	r4, r4, r3
    43d6:	3427      	adds	r4, #39	; 0x27
    43d8:	2300      	movs	r3, #0
    43da:	7023      	strb	r3, [r4, #0]
	for (i = 0; i < USB_D_N_EP; i++) {
    43dc:	3501      	adds	r5, #1
    43de:	b2ed      	uxtb	r5, r5
    43e0:	2d1a      	cmp	r5, #26
    43e2:	d9e4      	bls.n	43ae <_usb_d_dev_reset_epts+0x6>
	memset(prvt_inst.desc_table, 0, sizeof(UsbDeviceDescriptor) * (CONF_USB_D_MAX_EP_N + 1));
    43e4:	22c0      	movs	r2, #192	; 0xc0
    43e6:	2100      	movs	r1, #0
    43e8:	4803      	ldr	r0, [pc, #12]	; (43f8 <_usb_d_dev_reset_epts+0x50>)
    43ea:	4b04      	ldr	r3, [pc, #16]	; (43fc <_usb_d_dev_reset_epts+0x54>)
    43ec:	4798      	blx	r3
}
    43ee:	bd70      	pop	{r4, r5, r6, pc}
    43f0:	20000448 	.word	0x20000448
    43f4:	000041f5 	.word	0x000041f5
    43f8:	200003c8 	.word	0x200003c8
    43fc:	00009555 	.word	0x00009555

00004400 <_usb_d_dev_in_next>:
{
    4400:	b5f0      	push	{r4, r5, r6, r7, lr}
    4402:	46c6      	mov	lr, r8
    4404:	b500      	push	{lr}
    4406:	0005      	movs	r5, r0
    4408:	000e      	movs	r6, r1
	uint8_t            epn         = USB_EP_GET_N(ept->ep);
    440a:	7c83      	ldrb	r3, [r0, #18]
    440c:	240f      	movs	r4, #15
    440e:	401c      	ands	r4, r3
	UsbDeviceDescBank *bank        = &prvt_inst.desc_table[epn].DeviceDescBank[0];
    4410:	0162      	lsls	r2, r4, #5
    4412:	4b56      	ldr	r3, [pc, #344]	; (456c <_usb_d_dev_in_next+0x16c>)
    4414:	189b      	adds	r3, r3, r2
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    4416:	2900      	cmp	r1, #0
    4418:	d058      	beq.n	44cc <_usb_d_dev_in_next+0xcc>
    441a:	6959      	ldr	r1, [r3, #20]
    441c:	0489      	lsls	r1, r1, #18
    441e:	0c89      	lsrs	r1, r1, #18
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    4420:	8a2b      	ldrh	r3, [r5, #16]
    4422:	4a53      	ldr	r2, [pc, #332]	; (4570 <_usb_d_dev_in_next+0x170>)
    4424:	4293      	cmp	r3, r2
    4426:	d053      	beq.n	44d0 <_usb_d_dev_in_next+0xd0>
    4428:	3b01      	subs	r3, #1
    442a:	b21b      	sxth	r3, r3
    442c:	400b      	ands	r3, r1
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    442e:	7cea      	ldrb	r2, [r5, #19]
    4430:	2707      	movs	r7, #7
    4432:	4017      	ands	r7, r2
	if (isr) {
    4434:	2e00      	cmp	r6, #0
    4436:	d007      	beq.n	4448 <_usb_d_dev_in_next+0x48>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    4438:	0022      	movs	r2, r4
    443a:	3208      	adds	r2, #8
    443c:	0152      	lsls	r2, r2, #5
    443e:	484d      	ldr	r0, [pc, #308]	; (4574 <_usb_d_dev_in_next+0x174>)
    4440:	4684      	mov	ip, r0
    4442:	4462      	add	r2, ip
    4444:	2002      	movs	r0, #2
    4446:	71d0      	strb	r0, [r2, #7]
	ept->trans_count += trans_count;
    4448:	68aa      	ldr	r2, [r5, #8]
    444a:	4694      	mov	ip, r2
    444c:	4461      	add	r1, ip
    444e:	60a9      	str	r1, [r5, #8]
	if (ept->trans_count < ept->trans_size) {
    4450:	686a      	ldr	r2, [r5, #4]
    4452:	4291      	cmp	r1, r2
    4454:	d24e      	bcs.n	44f4 <_usb_d_dev_in_next+0xf4>
		trans_next = ept->trans_size - ept->trans_count;
    4456:	b292      	uxth	r2, r2
    4458:	b28b      	uxth	r3, r1
    445a:	1ad2      	subs	r2, r2, r3
    445c:	b292      	uxth	r2, r2
		if (ept->flags.bits.use_cache) {
    445e:	7ceb      	ldrb	r3, [r5, #19]
    4460:	069b      	lsls	r3, r3, #26
    4462:	d537      	bpl.n	44d4 <_usb_d_dev_in_next+0xd4>
			if (trans_next > ept->size) {
    4464:	8a2b      	ldrh	r3, [r5, #16]
    4466:	4698      	mov	r8, r3
    4468:	429a      	cmp	r2, r3
    446a:	d800      	bhi.n	446e <_usb_d_dev_in_next+0x6e>
		trans_next = ept->trans_size - ept->trans_count;
    446c:	4690      	mov	r8, r2
			memcpy(ept->cache, &ept->trans_buf[ept->trans_count], trans_next);
    446e:	682b      	ldr	r3, [r5, #0]
    4470:	469c      	mov	ip, r3
    4472:	4461      	add	r1, ip
    4474:	4642      	mov	r2, r8
    4476:	68e8      	ldr	r0, [r5, #12]
    4478:	4b3f      	ldr	r3, [pc, #252]	; (4578 <_usb_d_dev_in_next+0x178>)
    447a:	4798      	blx	r3
			_usbd_ep_set_buf(epn, 1, (uint32_t)ept->cache);
    447c:	68e9      	ldr	r1, [r5, #12]
	bank->ADDR.reg          = addr;
    447e:	0162      	lsls	r2, r4, #5
    4480:	4b3a      	ldr	r3, [pc, #232]	; (456c <_usb_d_dev_in_next+0x16c>)
    4482:	189b      	adds	r3, r3, r2
    4484:	6119      	str	r1, [r3, #16]
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    4486:	0163      	lsls	r3, r4, #5
    4488:	4a38      	ldr	r2, [pc, #224]	; (456c <_usb_d_dev_in_next+0x16c>)
    448a:	18d2      	adds	r2, r2, r3
    448c:	6951      	ldr	r1, [r2, #20]
    448e:	4643      	mov	r3, r8
    4490:	049b      	lsls	r3, r3, #18
    4492:	0c9b      	lsrs	r3, r3, #18
    4494:	0b89      	lsrs	r1, r1, #14
    4496:	0389      	lsls	r1, r1, #14
    4498:	430b      	orrs	r3, r1
    449a:	6153      	str	r3, [r2, #20]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    449c:	6951      	ldr	r1, [r2, #20]
    449e:	4b37      	ldr	r3, [pc, #220]	; (457c <_usb_d_dev_in_next+0x17c>)
    44a0:	400b      	ands	r3, r1
    44a2:	6153      	str	r3, [r2, #20]
	if (!isr) {
    44a4:	2e00      	cmp	r6, #0
    44a6:	d107      	bne.n	44b8 <_usb_d_dev_in_next+0xb8>
		if (is_ctrl) {
    44a8:	2f01      	cmp	r7, #1
    44aa:	d05d      	beq.n	4568 <_usb_d_dev_in_next+0x168>
			inten = USB_D_BANK1_INT_FLAGS;
    44ac:	224a      	movs	r2, #74	; 0x4a
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    44ae:	0163      	lsls	r3, r4, #5
    44b0:	4933      	ldr	r1, [pc, #204]	; (4580 <_usb_d_dev_in_next+0x180>)
    44b2:	468c      	mov	ip, r1
    44b4:	4463      	add	r3, ip
    44b6:	701a      	strb	r2, [r3, #0]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    44b8:	3408      	adds	r4, #8
    44ba:	0164      	lsls	r4, r4, #5
    44bc:	4b2d      	ldr	r3, [pc, #180]	; (4574 <_usb_d_dev_in_next+0x174>)
    44be:	469c      	mov	ip, r3
    44c0:	4464      	add	r4, ip
    44c2:	2380      	movs	r3, #128	; 0x80
    44c4:	7163      	strb	r3, [r4, #5]
}
    44c6:	bc04      	pop	{r2}
    44c8:	4690      	mov	r8, r2
    44ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    44cc:	2100      	movs	r1, #0
    44ce:	e7a7      	b.n	4420 <_usb_d_dev_in_next+0x20>
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    44d0:	b21b      	sxth	r3, r3
    44d2:	e7ab      	b.n	442c <_usb_d_dev_in_next+0x2c>
			if (trans_next > USB_D_DEV_TRANS_MAX) {
    44d4:	2380      	movs	r3, #128	; 0x80
    44d6:	019b      	lsls	r3, r3, #6
    44d8:	429a      	cmp	r2, r3
    44da:	d807      	bhi.n	44ec <_usb_d_dev_in_next+0xec>
		trans_next = ept->trans_size - ept->trans_count;
    44dc:	4690      	mov	r8, r2
			_usbd_ep_set_buf(epn, 1, (uint32_t)&ept->trans_buf[ept->trans_count]);
    44de:	682b      	ldr	r3, [r5, #0]
    44e0:	1859      	adds	r1, r3, r1
	bank->ADDR.reg          = addr;
    44e2:	0162      	lsls	r2, r4, #5
    44e4:	4b21      	ldr	r3, [pc, #132]	; (456c <_usb_d_dev_in_next+0x16c>)
    44e6:	189b      	adds	r3, r3, r2
    44e8:	6119      	str	r1, [r3, #16]
    44ea:	e7cc      	b.n	4486 <_usb_d_dev_in_next+0x86>
				trans_next = USB_D_DEV_TRANS_MAX;
    44ec:	2380      	movs	r3, #128	; 0x80
    44ee:	019b      	lsls	r3, r3, #6
    44f0:	4698      	mov	r8, r3
    44f2:	e7f4      	b.n	44de <_usb_d_dev_in_next+0xde>
	} else if (ept->flags.bits.need_zlp) {
    44f4:	7cea      	ldrb	r2, [r5, #19]
    44f6:	06d2      	lsls	r2, r2, #27
    44f8:	d50f      	bpl.n	451a <_usb_d_dev_in_next+0x11a>
		ept->flags.bits.need_zlp = 0;
    44fa:	7ceb      	ldrb	r3, [r5, #19]
    44fc:	2210      	movs	r2, #16
    44fe:	4393      	bics	r3, r2
    4500:	74eb      	strb	r3, [r5, #19]
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    4502:	0162      	lsls	r2, r4, #5
    4504:	4b19      	ldr	r3, [pc, #100]	; (456c <_usb_d_dev_in_next+0x16c>)
    4506:	189b      	adds	r3, r3, r2
    4508:	695a      	ldr	r2, [r3, #20]
    450a:	0b92      	lsrs	r2, r2, #14
    450c:	0391      	lsls	r1, r2, #14
    450e:	6159      	str	r1, [r3, #20]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    4510:	6959      	ldr	r1, [r3, #20]
    4512:	4a1a      	ldr	r2, [pc, #104]	; (457c <_usb_d_dev_in_next+0x17c>)
    4514:	400a      	ands	r2, r1
    4516:	615a      	str	r2, [r3, #20]
    4518:	e7c4      	b.n	44a4 <_usb_d_dev_in_next+0xa4>
	if (is_ctrl) {
    451a:	2f01      	cmp	r7, #1
    451c:	d00d      	beq.n	453a <_usb_d_dev_in_next+0x13a>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    451e:	0164      	lsls	r4, r4, #5
    4520:	4a18      	ldr	r2, [pc, #96]	; (4584 <_usb_d_dev_in_next+0x184>)
    4522:	4694      	mov	ip, r2
    4524:	4464      	add	r4, ip
    4526:	224a      	movs	r2, #74	; 0x4a
    4528:	7022      	strb	r2, [r4, #0]
	if (last_pkt == ept->size) {
    452a:	8a2a      	ldrh	r2, [r5, #16]
    452c:	4293      	cmp	r3, r2
    452e:	d00b      	beq.n	4548 <_usb_d_dev_in_next+0x148>
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    4530:	2100      	movs	r1, #0
    4532:	0028      	movs	r0, r5
    4534:	4b14      	ldr	r3, [pc, #80]	; (4588 <_usb_d_dev_in_next+0x188>)
    4536:	4798      	blx	r3
	return;
    4538:	e7c5      	b.n	44c6 <_usb_d_dev_in_next+0xc6>
    453a:	0164      	lsls	r4, r4, #5
    453c:	4a11      	ldr	r2, [pc, #68]	; (4584 <_usb_d_dev_in_next+0x184>)
    453e:	4694      	mov	ip, r2
    4540:	4464      	add	r4, ip
    4542:	224b      	movs	r2, #75	; 0x4b
    4544:	7022      	strb	r2, [r4, #0]
    4546:	e7f0      	b.n	452a <_usb_d_dev_in_next+0x12a>
		ept->flags.bits.is_busy = 0;
    4548:	7ceb      	ldrb	r3, [r5, #19]
    454a:	2240      	movs	r2, #64	; 0x40
    454c:	4393      	bics	r3, r2
    454e:	74eb      	strb	r3, [r5, #19]
		if (dev_inst.ep_callbacks.more(ept->ep, ept->trans_count)) {
    4550:	4b0e      	ldr	r3, [pc, #56]	; (458c <_usb_d_dev_in_next+0x18c>)
    4552:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    4554:	7ca8      	ldrb	r0, [r5, #18]
    4556:	68a9      	ldr	r1, [r5, #8]
    4558:	4798      	blx	r3
    455a:	2800      	cmp	r0, #0
    455c:	d1b3      	bne.n	44c6 <_usb_d_dev_in_next+0xc6>
		ept->flags.bits.is_busy = 1;
    455e:	7ceb      	ldrb	r3, [r5, #19]
    4560:	2240      	movs	r2, #64	; 0x40
    4562:	4313      	orrs	r3, r2
    4564:	74eb      	strb	r3, [r5, #19]
    4566:	e7e3      	b.n	4530 <_usb_d_dev_in_next+0x130>
			inten = USB_D_BANK1_INT_FLAGS | USB_DEVICE_EPINTFLAG_TRFAIL0;
    4568:	224e      	movs	r2, #78	; 0x4e
    456a:	e7a0      	b.n	44ae <_usb_d_dev_in_next+0xae>
    456c:	200003c8 	.word	0x200003c8
    4570:	000003ff 	.word	0x000003ff
    4574:	41005000 	.word	0x41005000
    4578:	00009543 	.word	0x00009543
    457c:	f0003fff 	.word	0xf0003fff
    4580:	41005109 	.word	0x41005109
    4584:	41005108 	.word	0x41005108
    4588:	000041f5 	.word	0x000041f5
    458c:	20000448 	.word	0x20000448

00004590 <_usb_d_dev_out_next>:
{
    4590:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4592:	46de      	mov	lr, fp
    4594:	4657      	mov	r7, sl
    4596:	464e      	mov	r6, r9
    4598:	4645      	mov	r5, r8
    459a:	b5e0      	push	{r5, r6, r7, lr}
    459c:	0004      	movs	r4, r0
    459e:	000f      	movs	r7, r1
	uint8_t            epn        = USB_EP_GET_N(ept->ep);
    45a0:	7c83      	ldrb	r3, [r0, #18]
    45a2:	250f      	movs	r5, #15
    45a4:	401d      	ands	r5, r3
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    45a6:	2900      	cmp	r1, #0
    45a8:	d059      	beq.n	465e <_usb_d_dev_out_next+0xce>
    45aa:	016a      	lsls	r2, r5, #5
    45ac:	4b71      	ldr	r3, [pc, #452]	; (4774 <_usb_d_dev_out_next+0x1e4>)
    45ae:	189b      	adds	r3, r3, r2
    45b0:	685b      	ldr	r3, [r3, #4]
    45b2:	011b      	lsls	r3, r3, #4
    45b4:	0c9b      	lsrs	r3, r3, #18
    45b6:	469a      	mov	sl, r3
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    45b8:	2f00      	cmp	r7, #0
    45ba:	d053      	beq.n	4664 <_usb_d_dev_out_next+0xd4>
    45bc:	016a      	lsls	r2, r5, #5
    45be:	4b6d      	ldr	r3, [pc, #436]	; (4774 <_usb_d_dev_out_next+0x1e4>)
    45c0:	189b      	adds	r3, r3, r2
    45c2:	685b      	ldr	r3, [r3, #4]
    45c4:	049b      	lsls	r3, r3, #18
    45c6:	0c9b      	lsrs	r3, r3, #18
    45c8:	4698      	mov	r8, r3
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    45ca:	8a26      	ldrh	r6, [r4, #16]
    45cc:	4b6a      	ldr	r3, [pc, #424]	; (4778 <_usb_d_dev_out_next+0x1e8>)
    45ce:	429e      	cmp	r6, r3
    45d0:	d001      	beq.n	45d6 <_usb_d_dev_out_next+0x46>
    45d2:	3e01      	subs	r6, #1
    45d4:	b2b6      	uxth	r6, r6
	uint16_t           last_pkt   = last_trans & size_mask;
    45d6:	4643      	mov	r3, r8
    45d8:	4033      	ands	r3, r6
    45da:	469b      	mov	fp, r3
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    45dc:	7ce3      	ldrb	r3, [r4, #19]
    45de:	2207      	movs	r2, #7
    45e0:	401a      	ands	r2, r3
    45e2:	4691      	mov	r9, r2
	if (isr) {
    45e4:	2f00      	cmp	r7, #0
    45e6:	d007      	beq.n	45f8 <_usb_d_dev_out_next+0x68>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    45e8:	002b      	movs	r3, r5
    45ea:	3308      	adds	r3, #8
    45ec:	015b      	lsls	r3, r3, #5
    45ee:	4a63      	ldr	r2, [pc, #396]	; (477c <_usb_d_dev_out_next+0x1ec>)
    45f0:	4694      	mov	ip, r2
    45f2:	4463      	add	r3, ip
    45f4:	2201      	movs	r2, #1
    45f6:	71da      	strb	r2, [r3, #7]
	if (ept->flags.bits.use_cache && ept->trans_size) {
    45f8:	7ce3      	ldrb	r3, [r4, #19]
    45fa:	069b      	lsls	r3, r3, #26
    45fc:	d511      	bpl.n	4622 <_usb_d_dev_out_next+0x92>
    45fe:	6862      	ldr	r2, [r4, #4]
    4600:	2a00      	cmp	r2, #0
    4602:	d00e      	beq.n	4622 <_usb_d_dev_out_next+0x92>
		uint16_t buf_remain = ept->trans_size - ept->trans_count;
    4604:	b292      	uxth	r2, r2
    4606:	8923      	ldrh	r3, [r4, #8]
    4608:	1ad2      	subs	r2, r2, r3
    460a:	b292      	uxth	r2, r2
		memcpy(&ept->trans_buf[ept->trans_count], ept->cache, (buf_remain > last_pkt) ? last_pkt : buf_remain);
    460c:	6823      	ldr	r3, [r4, #0]
    460e:	68a1      	ldr	r1, [r4, #8]
    4610:	468c      	mov	ip, r1
    4612:	4463      	add	r3, ip
    4614:	0018      	movs	r0, r3
    4616:	68e1      	ldr	r1, [r4, #12]
    4618:	4593      	cmp	fp, r2
    461a:	d200      	bcs.n	461e <_usb_d_dev_out_next+0x8e>
    461c:	465a      	mov	r2, fp
    461e:	4b58      	ldr	r3, [pc, #352]	; (4780 <_usb_d_dev_out_next+0x1f0>)
    4620:	4798      	blx	r3
	if (ept->trans_size == 0 && ept->flags.bits.need_zlp) {
    4622:	6863      	ldr	r3, [r4, #4]
    4624:	2b00      	cmp	r3, #0
    4626:	d120      	bne.n	466a <_usb_d_dev_out_next+0xda>
    4628:	7ce2      	ldrb	r2, [r4, #19]
    462a:	06d2      	lsls	r2, r2, #27
    462c:	d51d      	bpl.n	466a <_usb_d_dev_out_next+0xda>
		ept->flags.bits.need_zlp  = 0;
    462e:	7ce3      	ldrb	r3, [r4, #19]
		ept->flags.bits.use_cache = 1;
    4630:	2210      	movs	r2, #16
    4632:	4393      	bics	r3, r2
    4634:	2220      	movs	r2, #32
    4636:	4313      	orrs	r3, r2
    4638:	74e3      	strb	r3, [r4, #19]
	bank->ADDR.reg          = addr;
    463a:	494e      	ldr	r1, [pc, #312]	; (4774 <_usb_d_dev_out_next+0x1e4>)
    463c:	016a      	lsls	r2, r5, #5
    463e:	68e3      	ldr	r3, [r4, #12]
    4640:	5053      	str	r3, [r2, r1]
		_usbd_ep_set_out_trans(epn, 0, ept->size, 0);
    4642:	8a23      	ldrh	r3, [r4, #16]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    4644:	188a      	adds	r2, r1, r2
    4646:	6851      	ldr	r1, [r2, #4]
    4648:	049b      	lsls	r3, r3, #18
    464a:	091b      	lsrs	r3, r3, #4
    464c:	484d      	ldr	r0, [pc, #308]	; (4784 <_usb_d_dev_out_next+0x1f4>)
    464e:	4001      	ands	r1, r0
    4650:	430b      	orrs	r3, r1
    4652:	6053      	str	r3, [r2, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    4654:	6853      	ldr	r3, [r2, #4]
    4656:	0b9b      	lsrs	r3, r3, #14
    4658:	0399      	lsls	r1, r3, #14
    465a:	6051      	str	r1, [r2, #4]
    465c:	e047      	b.n	46ee <_usb_d_dev_out_next+0x15e>
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    465e:	2300      	movs	r3, #0
    4660:	469a      	mov	sl, r3
    4662:	e7a9      	b.n	45b8 <_usb_d_dev_out_next+0x28>
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    4664:	2300      	movs	r3, #0
    4666:	4698      	mov	r8, r3
    4668:	e7af      	b.n	45ca <_usb_d_dev_out_next+0x3a>
	} else if (isr && last_pkt < ept->size) {
    466a:	2f00      	cmp	r7, #0
    466c:	d01d      	beq.n	46aa <_usb_d_dev_out_next+0x11a>
    466e:	8a22      	ldrh	r2, [r4, #16]
    4670:	4593      	cmp	fp, r2
    4672:	d21a      	bcs.n	46aa <_usb_d_dev_out_next+0x11a>
		ept->flags.bits.need_zlp = 0;
    4674:	7ce3      	ldrb	r3, [r4, #19]
    4676:	2210      	movs	r2, #16
    4678:	4393      	bics	r3, r2
    467a:	74e3      	strb	r3, [r4, #19]
		ept->trans_count += last_trans;
    467c:	68a3      	ldr	r3, [r4, #8]
    467e:	4443      	add	r3, r8
    4680:	60a3      	str	r3, [r4, #8]
	if (is_ctrl) {
    4682:	464b      	mov	r3, r9
    4684:	2b01      	cmp	r3, #1
    4686:	d066      	beq.n	4756 <_usb_d_dev_out_next+0x1c6>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    4688:	016b      	lsls	r3, r5, #5
    468a:	4a3f      	ldr	r2, [pc, #252]	; (4788 <_usb_d_dev_out_next+0x1f8>)
    468c:	4694      	mov	ip, r2
    468e:	4463      	add	r3, ip
    4690:	2225      	movs	r2, #37	; 0x25
    4692:	701a      	strb	r2, [r3, #0]
	if (0 == epn) {
    4694:	2d00      	cmp	r5, #0
    4696:	d103      	bne.n	46a0 <_usb_d_dev_out_next+0x110>
	bank->ADDR.reg          = addr;
    4698:	016d      	lsls	r5, r5, #5
    469a:	4b36      	ldr	r3, [pc, #216]	; (4774 <_usb_d_dev_out_next+0x1e4>)
    469c:	68e2      	ldr	r2, [r4, #12]
    469e:	50ea      	str	r2, [r5, r3]
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    46a0:	2100      	movs	r1, #0
    46a2:	0020      	movs	r0, r4
    46a4:	4b39      	ldr	r3, [pc, #228]	; (478c <_usb_d_dev_out_next+0x1fc>)
    46a6:	4798      	blx	r3
	return;
    46a8:	e033      	b.n	4712 <_usb_d_dev_out_next+0x182>
		ept->trans_count += trans_size;
    46aa:	68a2      	ldr	r2, [r4, #8]
    46ac:	4452      	add	r2, sl
    46ae:	60a2      	str	r2, [r4, #8]
		if (ept->trans_count < ept->trans_size) {
    46b0:	4293      	cmp	r3, r2
    46b2:	d9e6      	bls.n	4682 <_usb_d_dev_out_next+0xf2>
			trans_next = ept->trans_size - ept->trans_count;
    46b4:	b29b      	uxth	r3, r3
    46b6:	b291      	uxth	r1, r2
    46b8:	1a5b      	subs	r3, r3, r1
    46ba:	b29b      	uxth	r3, r3
			if (ept->flags.bits.use_cache) {
    46bc:	7ce1      	ldrb	r1, [r4, #19]
    46be:	0689      	lsls	r1, r1, #26
    46c0:	d52d      	bpl.n	471e <_usb_d_dev_out_next+0x18e>
				if (trans_next > ept->size) {
    46c2:	8a21      	ldrh	r1, [r4, #16]
    46c4:	428b      	cmp	r3, r1
    46c6:	d800      	bhi.n	46ca <_usb_d_dev_out_next+0x13a>
			trans_next = ept->trans_size - ept->trans_count;
    46c8:	0019      	movs	r1, r3
				_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    46ca:	68e0      	ldr	r0, [r4, #12]
	bank->ADDR.reg          = addr;
    46cc:	016b      	lsls	r3, r5, #5
    46ce:	4a29      	ldr	r2, [pc, #164]	; (4774 <_usb_d_dev_out_next+0x1e4>)
    46d0:	5098      	str	r0, [r3, r2]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    46d2:	016b      	lsls	r3, r5, #5
    46d4:	4827      	ldr	r0, [pc, #156]	; (4774 <_usb_d_dev_out_next+0x1e4>)
    46d6:	18c0      	adds	r0, r0, r3
    46d8:	6842      	ldr	r2, [r0, #4]
    46da:	048b      	lsls	r3, r1, #18
    46dc:	091b      	lsrs	r3, r3, #4
    46de:	4929      	ldr	r1, [pc, #164]	; (4784 <_usb_d_dev_out_next+0x1f4>)
    46e0:	400a      	ands	r2, r1
    46e2:	4313      	orrs	r3, r2
    46e4:	6043      	str	r3, [r0, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    46e6:	6843      	ldr	r3, [r0, #4]
    46e8:	0b9b      	lsrs	r3, r3, #14
    46ea:	039a      	lsls	r2, r3, #14
    46ec:	6042      	str	r2, [r0, #4]
	if (!isr) {
    46ee:	2f00      	cmp	r7, #0
    46f0:	d108      	bne.n	4704 <_usb_d_dev_out_next+0x174>
		if (is_ctrl) {
    46f2:	464b      	mov	r3, r9
    46f4:	2b01      	cmp	r3, #1
    46f6:	d035      	beq.n	4764 <_usb_d_dev_out_next+0x1d4>
			inten = USB_D_BANK0_INT_FLAGS;
    46f8:	2225      	movs	r2, #37	; 0x25
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    46fa:	016b      	lsls	r3, r5, #5
    46fc:	4924      	ldr	r1, [pc, #144]	; (4790 <_usb_d_dev_out_next+0x200>)
    46fe:	468c      	mov	ip, r1
    4700:	4463      	add	r3, ip
    4702:	701a      	strb	r2, [r3, #0]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    4704:	3508      	adds	r5, #8
    4706:	016d      	lsls	r5, r5, #5
    4708:	4b1c      	ldr	r3, [pc, #112]	; (477c <_usb_d_dev_out_next+0x1ec>)
    470a:	469c      	mov	ip, r3
    470c:	4465      	add	r5, ip
    470e:	2340      	movs	r3, #64	; 0x40
    4710:	712b      	strb	r3, [r5, #4]
}
    4712:	bc3c      	pop	{r2, r3, r4, r5}
    4714:	4690      	mov	r8, r2
    4716:	4699      	mov	r9, r3
    4718:	46a2      	mov	sl, r4
    471a:	46ab      	mov	fp, r5
    471c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				if (trans_next > ept->size) {
    471e:	8a21      	ldrh	r1, [r4, #16]
    4720:	428b      	cmp	r3, r1
    4722:	d90b      	bls.n	473c <_usb_d_dev_out_next+0x1ac>
					if (trans_next > USB_D_DEV_TRANS_MAX) {
    4724:	2180      	movs	r1, #128	; 0x80
    4726:	0189      	lsls	r1, r1, #6
    4728:	428b      	cmp	r3, r1
    472a:	d80f      	bhi.n	474c <_usb_d_dev_out_next+0x1bc>
    472c:	43b3      	bics	r3, r6
    472e:	0019      	movs	r1, r3
				_usbd_ep_set_buf(epn, 0, (uint32_t)&ept->trans_buf[ept->trans_count]);
    4730:	6823      	ldr	r3, [r4, #0]
    4732:	189a      	adds	r2, r3, r2
	bank->ADDR.reg          = addr;
    4734:	016b      	lsls	r3, r5, #5
    4736:	480f      	ldr	r0, [pc, #60]	; (4774 <_usb_d_dev_out_next+0x1e4>)
    4738:	501a      	str	r2, [r3, r0]
    473a:	e7ca      	b.n	46d2 <_usb_d_dev_out_next+0x142>
				} else if (trans_next < ept->size) {
    473c:	428b      	cmp	r3, r1
    473e:	d208      	bcs.n	4752 <_usb_d_dev_out_next+0x1c2>
					ept->flags.bits.use_cache = 1;
    4740:	7ce1      	ldrb	r1, [r4, #19]
    4742:	2020      	movs	r0, #32
    4744:	4301      	orrs	r1, r0
    4746:	74e1      	strb	r1, [r4, #19]
			trans_next = ept->trans_size - ept->trans_count;
    4748:	0019      	movs	r1, r3
    474a:	e7f1      	b.n	4730 <_usb_d_dev_out_next+0x1a0>
						trans_next = USB_D_DEV_TRANS_MAX;
    474c:	2180      	movs	r1, #128	; 0x80
    474e:	0189      	lsls	r1, r1, #6
    4750:	e7ee      	b.n	4730 <_usb_d_dev_out_next+0x1a0>
			trans_next = ept->trans_size - ept->trans_count;
    4752:	0019      	movs	r1, r3
    4754:	e7ec      	b.n	4730 <_usb_d_dev_out_next+0x1a0>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    4756:	016b      	lsls	r3, r5, #5
    4758:	4a0b      	ldr	r2, [pc, #44]	; (4788 <_usb_d_dev_out_next+0x1f8>)
    475a:	4694      	mov	ip, r2
    475c:	4463      	add	r3, ip
    475e:	222d      	movs	r2, #45	; 0x2d
    4760:	701a      	strb	r2, [r3, #0]
    4762:	e797      	b.n	4694 <_usb_d_dev_out_next+0x104>
	bank->STATUS_BK.reg     = 0;
    4764:	016a      	lsls	r2, r5, #5
    4766:	4b03      	ldr	r3, [pc, #12]	; (4774 <_usb_d_dev_out_next+0x1e4>)
    4768:	189b      	adds	r3, r3, r2
    476a:	2200      	movs	r2, #0
    476c:	769a      	strb	r2, [r3, #26]
			inten = USB_D_BANK0_INT_FLAGS | USB_DEVICE_EPINTFLAG_TRFAIL1;
    476e:	322d      	adds	r2, #45	; 0x2d
    4770:	e7c3      	b.n	46fa <_usb_d_dev_out_next+0x16a>
    4772:	46c0      	nop			; (mov r8, r8)
    4774:	200003c8 	.word	0x200003c8
    4778:	000003ff 	.word	0x000003ff
    477c:	41005000 	.word	0x41005000
    4780:	00009543 	.word	0x00009543
    4784:	f0003fff 	.word	0xf0003fff
    4788:	41005108 	.word	0x41005108
    478c:	000041f5 	.word	0x000041f5
    4790:	41005109 	.word	0x41005109

00004794 <_usb_d_dev_handler>:
{
    4794:	b570      	push	{r4, r5, r6, lr}
	uint16_t epint = hw->DEVICE.EPINTSMRY.reg;
    4796:	4b89      	ldr	r3, [pc, #548]	; (49bc <_usb_d_dev_handler+0x228>)
    4798:	8c1d      	ldrh	r5, [r3, #32]
    479a:	b2ad      	uxth	r5, r5
	if (0 == epint) {
    479c:	2d00      	cmp	r5, #0
    479e:	d001      	beq.n	47a4 <_usb_d_dev_handler+0x10>
	bool     rc    = true;
    47a0:	2400      	movs	r4, #0
    47a2:	e0bf      	b.n	4924 <_usb_d_dev_handler+0x190>
	return tmp;
}

static inline hri_usbdevice_intflag_reg_t hri_usbdevice_read_INTFLAG_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTFLAG.reg;
    47a4:	8b99      	ldrh	r1, [r3, #28]
	return tmp;
}

static inline hri_usbdevice_intenset_reg_t hri_usbdevice_read_INTEN_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTENSET.reg;
    47a6:	8b1b      	ldrh	r3, [r3, #24]
	flags &= hri_usbdevice_read_INTEN_reg(USB);
    47a8:	400b      	ands	r3, r1
	if (flags & USB_DEVICE_INTFLAG_SOF) {
    47aa:	075a      	lsls	r2, r3, #29
    47ac:	d40d      	bmi.n	47ca <_usb_d_dev_handler+0x36>
	if (flags & USB_DEVICE_INTFLAG_LPMSUSP) {
    47ae:	059a      	lsls	r2, r3, #22
    47b0:	d415      	bmi.n	47de <_usb_d_dev_handler+0x4a>
	} else if (flags & USB_DEVICE_INTFLAG_RAMACER) {
    47b2:	061a      	lsls	r2, r3, #24
    47b4:	d437      	bmi.n	4826 <_usb_d_dev_handler+0x92>
	} else if (flags & USB_D_WAKEUP_INT_FLAGS) {
    47b6:	2270      	movs	r2, #112	; 0x70
    47b8:	421a      	tst	r2, r3
    47ba:	d13e      	bne.n	483a <_usb_d_dev_handler+0xa6>
	} else if (flags & USB_DEVICE_INTFLAG_EORST) {
    47bc:	071a      	lsls	r2, r3, #28
    47be:	d457      	bmi.n	4870 <_usb_d_dev_handler+0xdc>
	} else if (flags & USB_DEVICE_INTFLAG_SUSPEND) {
    47c0:	07db      	lsls	r3, r3, #31
    47c2:	d500      	bpl.n	47c6 <_usb_d_dev_handler+0x32>
    47c4:	e068      	b.n	4898 <_usb_d_dev_handler+0x104>
		rc = false;
    47c6:	2300      	movs	r3, #0
    47c8:	e006      	b.n	47d8 <_usb_d_dev_handler+0x44>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    47ca:	2204      	movs	r2, #4
    47cc:	4b7b      	ldr	r3, [pc, #492]	; (49bc <_usb_d_dev_handler+0x228>)
    47ce:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.sof();
    47d0:	4b7b      	ldr	r3, [pc, #492]	; (49c0 <_usb_d_dev_handler+0x22c>)
    47d2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    47d4:	4798      	blx	r3
		return true;
    47d6:	2301      	movs	r3, #1
		if (_usb_d_dev_handle_nep()) {
    47d8:	2b00      	cmp	r3, #0
    47da:	d0e1      	beq.n	47a0 <_usb_d_dev_handler+0xc>
}
    47dc:	bd70      	pop	{r4, r5, r6, pc}
    47de:	4b77      	ldr	r3, [pc, #476]	; (49bc <_usb_d_dev_handler+0x228>)
    47e0:	4a78      	ldr	r2, [pc, #480]	; (49c4 <_usb_d_dev_handler+0x230>)
    47e2:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = ~data;
}

static inline void hri_usbdevice_clear_INTEN_reg(const void *const hw, hri_usbdevice_intenset_reg_t mask)
{
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    47e4:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    47e6:	3a92      	subs	r2, #146	; 0x92
    47e8:	3aff      	subs	r2, #255	; 0xff
    47ea:	831a      	strh	r2, [r3, #24]
	for (i = 0; i < CONF_USB_D_MAX_EP_N; i++) {
    47ec:	2300      	movs	r3, #0
    47ee:	e001      	b.n	47f4 <_usb_d_dev_handler+0x60>
    47f0:	3301      	adds	r3, #1
    47f2:	b2db      	uxtb	r3, r3
    47f4:	2b04      	cmp	r3, #4
    47f6:	d80f      	bhi.n	4818 <_usb_d_dev_handler+0x84>
		if (bank->EXTREG.bit.SUBPID == 0x3) {
    47f8:	0158      	lsls	r0, r3, #5
    47fa:	4a73      	ldr	r2, [pc, #460]	; (49c8 <_usb_d_dev_handler+0x234>)
    47fc:	1812      	adds	r2, r2, r0
    47fe:	8912      	ldrh	r2, [r2, #8]
    4800:	0712      	lsls	r2, r2, #28
    4802:	0f12      	lsrs	r2, r2, #28
    4804:	2a03      	cmp	r2, #3
    4806:	d1f3      	bne.n	47f0 <_usb_d_dev_handler+0x5c>
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    4808:	4b6f      	ldr	r3, [pc, #444]	; (49c8 <_usb_d_dev_handler+0x234>)
    480a:	181b      	adds	r3, r3, r0
    480c:	8919      	ldrh	r1, [r3, #8]
    480e:	0449      	lsls	r1, r1, #17
    4810:	0d49      	lsrs	r1, r1, #21
			bank->EXTREG.reg = 0;
    4812:	2200      	movs	r2, #0
    4814:	811a      	strh	r2, [r3, #8]
    4816:	e000      	b.n	481a <_usb_d_dev_handler+0x86>
	uint32_t lpm_variable = 0;
    4818:	2100      	movs	r1, #0
	dev_inst.callbacks.event(USB_EV_LPM_SUSPEND, lpm_variable);
    481a:	4b69      	ldr	r3, [pc, #420]	; (49c0 <_usb_d_dev_handler+0x22c>)
    481c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    481e:	2003      	movs	r0, #3
    4820:	4798      	blx	r3
	bool     rc    = true;
    4822:	2301      	movs	r3, #1
    4824:	e7d8      	b.n	47d8 <_usb_d_dev_handler+0x44>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    4826:	2280      	movs	r2, #128	; 0x80
    4828:	4b64      	ldr	r3, [pc, #400]	; (49bc <_usb_d_dev_handler+0x228>)
    482a:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.event(USB_EV_ERROR, 0);
    482c:	4b64      	ldr	r3, [pc, #400]	; (49c0 <_usb_d_dev_handler+0x22c>)
    482e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    4830:	2100      	movs	r1, #0
    4832:	2005      	movs	r0, #5
    4834:	4798      	blx	r3
	bool     rc    = true;
    4836:	2301      	movs	r3, #1
    4838:	e7ce      	b.n	47d8 <_usb_d_dev_handler+0x44>
    483a:	4b60      	ldr	r3, [pc, #384]	; (49bc <_usb_d_dev_handler+0x228>)
    483c:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    483e:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    4840:	4a60      	ldr	r2, [pc, #384]	; (49c4 <_usb_d_dev_handler+0x230>)
    4842:	831a      	strh	r2, [r3, #24]
	if (!(SYSCTRL->DFLLCTRL.reg & SYSCTRL_DFLLCTRL_USBCRM)) {
    4844:	4b61      	ldr	r3, [pc, #388]	; (49cc <_usb_d_dev_handler+0x238>)
    4846:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    4848:	069b      	lsls	r3, r3, #26
    484a:	d40c      	bmi.n	4866 <_usb_d_dev_handler+0xd2>
	tmp = ((Sysctrl *)hw)->PCLKSR.reg;
    484c:	4b5f      	ldr	r3, [pc, #380]	; (49cc <_usb_d_dev_handler+0x238>)
    484e:	68da      	ldr	r2, [r3, #12]
	tmp &= mask;
    4850:	23d0      	movs	r3, #208	; 0xd0
    4852:	4013      	ands	r3, r2
		while (hri_sysctrl_get_PCLKSR_reg(SYSCTRL, DFLL_READY_FLAG) != DFLL_READY_FLAG)
    4854:	2bd0      	cmp	r3, #208	; 0xd0
    4856:	d1f9      	bne.n	484c <_usb_d_dev_handler+0xb8>
	dev_inst.callbacks.event(USB_EV_WAKEUP, 0);
    4858:	4b59      	ldr	r3, [pc, #356]	; (49c0 <_usb_d_dev_handler+0x22c>)
    485a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    485c:	2100      	movs	r1, #0
    485e:	2002      	movs	r0, #2
    4860:	4798      	blx	r3
	bool     rc    = true;
    4862:	2301      	movs	r3, #1
    4864:	e7b8      	b.n	47d8 <_usb_d_dev_handler+0x44>
	tmp = ((Sysctrl *)hw)->PCLKSR.reg;
    4866:	4b59      	ldr	r3, [pc, #356]	; (49cc <_usb_d_dev_handler+0x238>)
    4868:	68db      	ldr	r3, [r3, #12]
		while (hri_sysctrl_get_PCLKSR_reg(SYSCTRL, SYSCTRL_PCLKSR_DFLLRDY) != SYSCTRL_PCLKSR_DFLLRDY)
    486a:	06db      	lsls	r3, r3, #27
    486c:	d5fb      	bpl.n	4866 <_usb_d_dev_handler+0xd2>
    486e:	e7f3      	b.n	4858 <_usb_d_dev_handler+0xc4>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    4870:	4b52      	ldr	r3, [pc, #328]	; (49bc <_usb_d_dev_handler+0x228>)
    4872:	2100      	movs	r1, #0
    4874:	2280      	movs	r2, #128	; 0x80
    4876:	0052      	lsls	r2, r2, #1
    4878:	5499      	strb	r1, [r3, r2]
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    487a:	3af8      	subs	r2, #248	; 0xf8
    487c:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    487e:	3268      	adds	r2, #104	; 0x68
    4880:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    4882:	4a50      	ldr	r2, [pc, #320]	; (49c4 <_usb_d_dev_handler+0x230>)
    4884:	831a      	strh	r2, [r3, #24]
	_usb_d_dev_reset_epts();
    4886:	4b52      	ldr	r3, [pc, #328]	; (49d0 <_usb_d_dev_handler+0x23c>)
    4888:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_RESET, 0);
    488a:	4b4d      	ldr	r3, [pc, #308]	; (49c0 <_usb_d_dev_handler+0x22c>)
    488c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    488e:	2100      	movs	r1, #0
    4890:	2001      	movs	r0, #1
    4892:	4798      	blx	r3
	bool     rc    = true;
    4894:	2301      	movs	r3, #1
    4896:	e79f      	b.n	47d8 <_usb_d_dev_handler+0x44>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    4898:	4b48      	ldr	r3, [pc, #288]	; (49bc <_usb_d_dev_handler+0x228>)
    489a:	4a4a      	ldr	r2, [pc, #296]	; (49c4 <_usb_d_dev_handler+0x230>)
    489c:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    489e:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    48a0:	3a92      	subs	r2, #146	; 0x92
    48a2:	3aff      	subs	r2, #255	; 0xff
    48a4:	831a      	strh	r2, [r3, #24]
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
    48a6:	4b46      	ldr	r3, [pc, #280]	; (49c0 <_usb_d_dev_handler+0x22c>)
    48a8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    48aa:	2100      	movs	r1, #0
    48ac:	2004      	movs	r0, #4
    48ae:	4798      	blx	r3
	bool     rc    = true;
    48b0:	2301      	movs	r3, #1
    48b2:	e791      	b.n	47d8 <_usb_d_dev_handler+0x44>
	if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    48b4:	06da      	lsls	r2, r3, #27
    48b6:	d407      	bmi.n	48c8 <_usb_d_dev_handler+0x134>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    48b8:	065a      	lsls	r2, r3, #25
    48ba:	d408      	bmi.n	48ce <_usb_d_dev_handler+0x13a>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    48bc:	069b      	lsls	r3, r3, #26
    48be:	d52f      	bpl.n	4920 <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_stall(ept, 0);
    48c0:	2100      	movs	r1, #0
    48c2:	4b44      	ldr	r3, [pc, #272]	; (49d4 <_usb_d_dev_handler+0x240>)
    48c4:	4798      	blx	r3
    48c6:	e02b      	b.n	4920 <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_setup(ept);
    48c8:	4b43      	ldr	r3, [pc, #268]	; (49d8 <_usb_d_dev_handler+0x244>)
    48ca:	4798      	blx	r3
    48cc:	e028      	b.n	4920 <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_stall(ept, 1);
    48ce:	2101      	movs	r1, #1
    48d0:	4b40      	ldr	r3, [pc, #256]	; (49d4 <_usb_d_dev_handler+0x240>)
    48d2:	4798      	blx	r3
    48d4:	e024      	b.n	4920 <_usb_d_dev_handler+0x18c>
	if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    48d6:	065a      	lsls	r2, r3, #25
    48d8:	d40f      	bmi.n	48fa <_usb_d_dev_handler+0x166>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    48da:	071a      	lsls	r2, r3, #28
    48dc:	d411      	bmi.n	4902 <_usb_d_dev_handler+0x16e>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT1) {
    48de:	079a      	lsls	r2, r3, #30
    48e0:	d413      	bmi.n	490a <_usb_d_dev_handler+0x176>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    48e2:	7cc1      	ldrb	r1, [r0, #19]
    48e4:	2207      	movs	r2, #7
    48e6:	400a      	ands	r2, r1
    48e8:	2a01      	cmp	r2, #1
    48ea:	d119      	bne.n	4920 <_usb_d_dev_handler+0x18c>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    48ec:	075a      	lsls	r2, r3, #29
    48ee:	d410      	bmi.n	4912 <_usb_d_dev_handler+0x17e>
		} else if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    48f0:	06db      	lsls	r3, r3, #27
    48f2:	d515      	bpl.n	4920 <_usb_d_dev_handler+0x18c>
			_usb_d_dev_handle_setup(ept);
    48f4:	4b38      	ldr	r3, [pc, #224]	; (49d8 <_usb_d_dev_handler+0x244>)
    48f6:	4798      	blx	r3
    48f8:	e012      	b.n	4920 <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_stall(ept, 1);
    48fa:	2101      	movs	r1, #1
    48fc:	4b35      	ldr	r3, [pc, #212]	; (49d4 <_usb_d_dev_handler+0x240>)
    48fe:	4798      	blx	r3
    4900:	e00e      	b.n	4920 <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_trfail(ept, 1);
    4902:	2101      	movs	r1, #1
    4904:	4b35      	ldr	r3, [pc, #212]	; (49dc <_usb_d_dev_handler+0x248>)
    4906:	4798      	blx	r3
    4908:	e00a      	b.n	4920 <_usb_d_dev_handler+0x18c>
		_usb_d_dev_in_next(ept, true);
    490a:	2101      	movs	r1, #1
    490c:	4b34      	ldr	r3, [pc, #208]	; (49e0 <_usb_d_dev_handler+0x24c>)
    490e:	4798      	blx	r3
    4910:	e006      	b.n	4920 <_usb_d_dev_handler+0x18c>
			_usb_d_dev_handle_trfail(ept, 0);
    4912:	2100      	movs	r1, #0
    4914:	4b31      	ldr	r3, [pc, #196]	; (49dc <_usb_d_dev_handler+0x248>)
    4916:	4798      	blx	r3
    4918:	e002      	b.n	4920 <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_stall(ept, 0);
    491a:	2100      	movs	r1, #0
    491c:	4b2d      	ldr	r3, [pc, #180]	; (49d4 <_usb_d_dev_handler+0x240>)
    491e:	4798      	blx	r3
	for (i = 0; i < USB_D_N_EP; i++) {
    4920:	3401      	adds	r4, #1
    4922:	b2e4      	uxtb	r4, r4
    4924:	2c1a      	cmp	r4, #26
    4926:	d900      	bls.n	492a <_usb_d_dev_handler+0x196>
    4928:	e758      	b.n	47dc <_usb_d_dev_handler+0x48>
		struct _usb_d_dev_ep *ept = &dev_inst.ep[i];
    492a:	4b25      	ldr	r3, [pc, #148]	; (49c0 <_usb_d_dev_handler+0x22c>)
    492c:	3340      	adds	r3, #64	; 0x40
    492e:	00a2      	lsls	r2, r4, #2
    4930:	1911      	adds	r1, r2, r4
    4932:	0088      	lsls	r0, r1, #2
    4934:	0001      	movs	r1, r0
    4936:	3010      	adds	r0, #16
    4938:	1818      	adds	r0, r3, r0
    493a:	3004      	adds	r0, #4
		if (ept->ep == 0xFF) {
    493c:	185b      	adds	r3, r3, r1
    493e:	3326      	adds	r3, #38	; 0x26
    4940:	781b      	ldrb	r3, [r3, #0]
    4942:	2bff      	cmp	r3, #255	; 0xff
    4944:	d0ec      	beq.n	4920 <_usb_d_dev_handler+0x18c>
	uint8_t epn = USB_EP_GET_N(ept->ep);
    4946:	7c82      	ldrb	r2, [r0, #18]
    4948:	230f      	movs	r3, #15
    494a:	4013      	ands	r3, r2
	if (!(epint & (1u << epn))) {
    494c:	2201      	movs	r2, #1
    494e:	409a      	lsls	r2, r3
    4950:	422a      	tst	r2, r5
    4952:	d0e5      	beq.n	4920 <_usb_d_dev_handler+0x18c>
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    4954:	001a      	movs	r2, r3
    4956:	3208      	adds	r2, #8
    4958:	0152      	lsls	r2, r2, #5
    495a:	4918      	ldr	r1, [pc, #96]	; (49bc <_usb_d_dev_handler+0x228>)
    495c:	468c      	mov	ip, r1
    495e:	4462      	add	r2, ip
    4960:	79d2      	ldrb	r2, [r2, #7]
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    4962:	015b      	lsls	r3, r3, #5
    4964:	491f      	ldr	r1, [pc, #124]	; (49e4 <_usb_d_dev_handler+0x250>)
    4966:	468c      	mov	ip, r1
    4968:	4463      	add	r3, ip
    496a:	781b      	ldrb	r3, [r3, #0]
	flags &= mask;
    496c:	4013      	ands	r3, r2
	if (flags) {
    496e:	d0d7      	beq.n	4920 <_usb_d_dev_handler+0x18c>
		if ((ept->flags.bits.eptype == 0x1) && !_usb_d_dev_ep_is_busy(ept)) {
    4970:	7cc2      	ldrb	r2, [r0, #19]
    4972:	2147      	movs	r1, #71	; 0x47
    4974:	4011      	ands	r1, r2
    4976:	2901      	cmp	r1, #1
    4978:	d09c      	beq.n	48b4 <_usb_d_dev_handler+0x120>
		} else if (_usb_d_dev_ep_is_in(ept)) {
    497a:	b252      	sxtb	r2, r2
    497c:	2a00      	cmp	r2, #0
    497e:	dbaa      	blt.n	48d6 <_usb_d_dev_handler+0x142>
	if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    4980:	069a      	lsls	r2, r3, #26
    4982:	d4ca      	bmi.n	491a <_usb_d_dev_handler+0x186>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    4984:	075a      	lsls	r2, r3, #29
    4986:	d40d      	bmi.n	49a4 <_usb_d_dev_handler+0x210>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT0) {
    4988:	07da      	lsls	r2, r3, #31
    498a:	d40f      	bmi.n	49ac <_usb_d_dev_handler+0x218>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    498c:	7cc1      	ldrb	r1, [r0, #19]
    498e:	2207      	movs	r2, #7
    4990:	400a      	ands	r2, r1
    4992:	2a01      	cmp	r2, #1
    4994:	d1c4      	bne.n	4920 <_usb_d_dev_handler+0x18c>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    4996:	071a      	lsls	r2, r3, #28
    4998:	d40c      	bmi.n	49b4 <_usb_d_dev_handler+0x220>
		} else if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    499a:	06db      	lsls	r3, r3, #27
    499c:	d5c0      	bpl.n	4920 <_usb_d_dev_handler+0x18c>
			_usb_d_dev_handle_setup(ept);
    499e:	4b0e      	ldr	r3, [pc, #56]	; (49d8 <_usb_d_dev_handler+0x244>)
    49a0:	4798      	blx	r3
    49a2:	e7bd      	b.n	4920 <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_trfail(ept, 0);
    49a4:	2100      	movs	r1, #0
    49a6:	4b0d      	ldr	r3, [pc, #52]	; (49dc <_usb_d_dev_handler+0x248>)
    49a8:	4798      	blx	r3
    49aa:	e7b9      	b.n	4920 <_usb_d_dev_handler+0x18c>
		_usb_d_dev_out_next(ept, true);
    49ac:	2101      	movs	r1, #1
    49ae:	4b0e      	ldr	r3, [pc, #56]	; (49e8 <_usb_d_dev_handler+0x254>)
    49b0:	4798      	blx	r3
    49b2:	e7b5      	b.n	4920 <_usb_d_dev_handler+0x18c>
			_usb_d_dev_handle_trfail(ept, 1);
    49b4:	2101      	movs	r1, #1
    49b6:	4b09      	ldr	r3, [pc, #36]	; (49dc <_usb_d_dev_handler+0x248>)
    49b8:	4798      	blx	r3
    49ba:	e7b1      	b.n	4920 <_usb_d_dev_handler+0x18c>
    49bc:	41005000 	.word	0x41005000
    49c0:	20000448 	.word	0x20000448
    49c4:	00000201 	.word	0x00000201
    49c8:	200003c8 	.word	0x200003c8
    49cc:	40000800 	.word	0x40000800
    49d0:	000043a9 	.word	0x000043a9
    49d4:	000041c5 	.word	0x000041c5
    49d8:	00004135 	.word	0x00004135
    49dc:	00004299 	.word	0x00004299
    49e0:	00004401 	.word	0x00004401
    49e4:	41005109 	.word	0x41005109
    49e8:	00004591 	.word	0x00004591

000049ec <_usb_d_dev_init>:
{
    49ec:	b500      	push	{lr}
    49ee:	b083      	sub	sp, #12
	const uint8_t spdconf[4] = {
    49f0:	2200      	movs	r2, #0
    49f2:	ab01      	add	r3, sp, #4
    49f4:	705a      	strb	r2, [r3, #1]
	return ((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg;
    49f6:	4b21      	ldr	r3, [pc, #132]	; (4a7c <_usb_d_dev_init+0x90>)
    49f8:	789b      	ldrb	r3, [r3, #2]
	if (!hri_usbdevice_is_syncing(hw, USB_SYNCBUSY_SWRST)) {
    49fa:	07db      	lsls	r3, r3, #31
    49fc:	d41b      	bmi.n	4a36 <_usb_d_dev_init+0x4a>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    49fe:	4b1f      	ldr	r3, [pc, #124]	; (4a7c <_usb_d_dev_init+0x90>)
    4a00:	789b      	ldrb	r3, [r3, #2]
    4a02:	079b      	lsls	r3, r3, #30
    4a04:	d1fb      	bne.n	49fe <_usb_d_dev_init+0x12>

static inline hri_usb_ctrla_reg_t hri_usb_get_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t mask)
{
	uint8_t tmp;
	hri_usb_wait_for_sync(hw, USB_SYNCBUSY_MASK);
	tmp = ((Usb *)hw)->HOST.CTRLA.reg;
    4a06:	4b1d      	ldr	r3, [pc, #116]	; (4a7c <_usb_d_dev_init+0x90>)
    4a08:	781b      	ldrb	r3, [r3, #0]
		if (hri_usbdevice_get_CTRLA_reg(hw, USB_CTRLA_ENABLE)) {
    4a0a:	079b      	lsls	r3, r3, #30
    4a0c:	d50c      	bpl.n	4a28 <_usb_d_dev_init+0x3c>
	((Usb *)hw)->HOST.CTRLA.reg &= ~USB_CTRLA_ENABLE;
    4a0e:	4a1b      	ldr	r2, [pc, #108]	; (4a7c <_usb_d_dev_init+0x90>)
    4a10:	7813      	ldrb	r3, [r2, #0]
    4a12:	2102      	movs	r1, #2
    4a14:	438b      	bics	r3, r1
    4a16:	7013      	strb	r3, [r2, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    4a18:	4b18      	ldr	r3, [pc, #96]	; (4a7c <_usb_d_dev_init+0x90>)
    4a1a:	789b      	ldrb	r3, [r3, #2]
    4a1c:	079b      	lsls	r3, r3, #30
    4a1e:	d1fb      	bne.n	4a18 <_usb_d_dev_init+0x2c>
    4a20:	4b16      	ldr	r3, [pc, #88]	; (4a7c <_usb_d_dev_init+0x90>)
    4a22:	789b      	ldrb	r3, [r3, #2]
    4a24:	079b      	lsls	r3, r3, #30
    4a26:	d4fb      	bmi.n	4a20 <_usb_d_dev_init+0x34>
}

static inline void hri_usb_write_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.CTRLA.reg = data;
    4a28:	2201      	movs	r2, #1
    4a2a:	4b14      	ldr	r3, [pc, #80]	; (4a7c <_usb_d_dev_init+0x90>)
    4a2c:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    4a2e:	4b13      	ldr	r3, [pc, #76]	; (4a7c <_usb_d_dev_init+0x90>)
    4a30:	789b      	ldrb	r3, [r3, #2]
    4a32:	079b      	lsls	r3, r3, #30
    4a34:	d1fb      	bne.n	4a2e <_usb_d_dev_init+0x42>
    4a36:	4b11      	ldr	r3, [pc, #68]	; (4a7c <_usb_d_dev_init+0x90>)
    4a38:	789b      	ldrb	r3, [r3, #2]
    4a3a:	07db      	lsls	r3, r3, #31
    4a3c:	d4fb      	bmi.n	4a36 <_usb_d_dev_init+0x4a>
	dev_inst.callbacks.sof   = (_usb_d_dev_sof_cb_t)_dummy_func_no_return;
    4a3e:	4b10      	ldr	r3, [pc, #64]	; (4a80 <_usb_d_dev_init+0x94>)
    4a40:	4a10      	ldr	r2, [pc, #64]	; (4a84 <_usb_d_dev_init+0x98>)
    4a42:	641a      	str	r2, [r3, #64]	; 0x40
	dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)_dummy_func_no_return;
    4a44:	645a      	str	r2, [r3, #68]	; 0x44
	dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)_dummy_func_no_return;
    4a46:	649a      	str	r2, [r3, #72]	; 0x48
	dev_inst.ep_callbacks.more  = (_usb_d_dev_ep_cb_more_t)_dummy_func_no_return;
    4a48:	64da      	str	r2, [r3, #76]	; 0x4c
	dev_inst.ep_callbacks.done  = (_usb_d_dev_ep_cb_done_t)_dummy_func_no_return;
    4a4a:	651a      	str	r2, [r3, #80]	; 0x50
	_usb_d_dev_reset_epts();
    4a4c:	4b0e      	ldr	r3, [pc, #56]	; (4a88 <_usb_d_dev_init+0x9c>)
    4a4e:	4798      	blx	r3
	_usb_load_calib();
    4a50:	4b0e      	ldr	r3, [pc, #56]	; (4a8c <_usb_d_dev_init+0xa0>)
    4a52:	4798      	blx	r3
	((Usb *)hw)->HOST.CTRLA.reg = data;
    4a54:	2204      	movs	r2, #4
    4a56:	4b09      	ldr	r3, [pc, #36]	; (4a7c <_usb_d_dev_init+0x90>)
    4a58:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    4a5a:	4b08      	ldr	r3, [pc, #32]	; (4a7c <_usb_d_dev_init+0x90>)
    4a5c:	789b      	ldrb	r3, [r3, #2]
    4a5e:	079b      	lsls	r3, r3, #30
    4a60:	d1fb      	bne.n	4a5a <_usb_d_dev_init+0x6e>
}

static inline void hri_usb_write_DESCADD_reg(const void *const hw, hri_usb_descadd_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.DESCADD.reg = data;
    4a62:	4a06      	ldr	r2, [pc, #24]	; (4a7c <_usb_d_dev_init+0x90>)
    4a64:	4b0a      	ldr	r3, [pc, #40]	; (4a90 <_usb_d_dev_init+0xa4>)
    4a66:	6253      	str	r3, [r2, #36]	; 0x24
	hri_usbdevice_write_CTRLB_reg(hw, spdconf[speed] | USB_DEVICE_CTRLB_DETACH);
    4a68:	ab01      	add	r3, sp, #4
    4a6a:	785b      	ldrb	r3, [r3, #1]
    4a6c:	2101      	movs	r1, #1
    4a6e:	430b      	orrs	r3, r1
    4a70:	b2db      	uxtb	r3, r3
	((Usb *)hw)->DEVICE.CTRLB.reg = data;
    4a72:	8113      	strh	r3, [r2, #8]
}
    4a74:	2000      	movs	r0, #0
    4a76:	b003      	add	sp, #12
    4a78:	bd00      	pop	{pc}
    4a7a:	46c0      	nop			; (mov r8, r8)
    4a7c:	41005000 	.word	0x41005000
    4a80:	20000448 	.word	0x20000448
    4a84:	000040dd 	.word	0x000040dd
    4a88:	000043a9 	.word	0x000043a9
    4a8c:	000040e1 	.word	0x000040e1
    4a90:	200003c8 	.word	0x200003c8

00004a94 <_usb_d_dev_enable>:
	tmp = ((Usb *)hw)->HOST.SYNCBUSY.reg;
    4a94:	4b10      	ldr	r3, [pc, #64]	; (4ad8 <_usb_d_dev_enable+0x44>)
    4a96:	789b      	ldrb	r3, [r3, #2]
	if (hri_usbdevice_get_SYNCBUSY_reg(hw, (USB_SYNCBUSY_ENABLE | USB_SYNCBUSY_SWRST))) {
    4a98:	079b      	lsls	r3, r3, #30
    4a9a:	d119      	bne.n	4ad0 <_usb_d_dev_enable+0x3c>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    4a9c:	4b0e      	ldr	r3, [pc, #56]	; (4ad8 <_usb_d_dev_enable+0x44>)
    4a9e:	789b      	ldrb	r3, [r3, #2]
    4aa0:	079b      	lsls	r3, r3, #30
    4aa2:	d1fb      	bne.n	4a9c <_usb_d_dev_enable+0x8>
	return ((Usb *)hw)->HOST.CTRLA.reg;
    4aa4:	4b0c      	ldr	r3, [pc, #48]	; (4ad8 <_usb_d_dev_enable+0x44>)
    4aa6:	781b      	ldrb	r3, [r3, #0]
    4aa8:	b2db      	uxtb	r3, r3
	if ((ctrla & USB_CTRLA_ENABLE) == 0) {
    4aaa:	079a      	lsls	r2, r3, #30
    4aac:	d408      	bmi.n	4ac0 <_usb_d_dev_enable+0x2c>
		hri_usbdevice_write_CTRLA_reg(hw, ctrla | USB_CTRLA_ENABLE);
    4aae:	2202      	movs	r2, #2
    4ab0:	4313      	orrs	r3, r2
    4ab2:	b2db      	uxtb	r3, r3
	((Usb *)hw)->HOST.CTRLA.reg = data;
    4ab4:	4a08      	ldr	r2, [pc, #32]	; (4ad8 <_usb_d_dev_enable+0x44>)
    4ab6:	7013      	strb	r3, [r2, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    4ab8:	4b07      	ldr	r3, [pc, #28]	; (4ad8 <_usb_d_dev_enable+0x44>)
    4aba:	789b      	ldrb	r3, [r3, #2]
    4abc:	079b      	lsls	r3, r3, #30
    4abe:	d1fb      	bne.n	4ab8 <_usb_d_dev_enable+0x24>
    4ac0:	2280      	movs	r2, #128	; 0x80
    4ac2:	4b06      	ldr	r3, [pc, #24]	; (4adc <_usb_d_dev_enable+0x48>)
    4ac4:	601a      	str	r2, [r3, #0]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    4ac6:	4a06      	ldr	r2, [pc, #24]	; (4ae0 <_usb_d_dev_enable+0x4c>)
    4ac8:	4b03      	ldr	r3, [pc, #12]	; (4ad8 <_usb_d_dev_enable+0x44>)
    4aca:	831a      	strh	r2, [r3, #24]
	return ERR_NONE;
    4acc:	2000      	movs	r0, #0
}
    4ace:	4770      	bx	lr
		return -USB_ERR_DENIED;
    4ad0:	2011      	movs	r0, #17
    4ad2:	4240      	negs	r0, r0
    4ad4:	e7fb      	b.n	4ace <_usb_d_dev_enable+0x3a>
    4ad6:	46c0      	nop			; (mov r8, r8)
    4ad8:	41005000 	.word	0x41005000
    4adc:	e000e100 	.word	0xe000e100
    4ae0:	0000028d 	.word	0x0000028d

00004ae4 <_usb_d_dev_attach>:
	((Usb *)hw)->DEVICE.CTRLB.reg &= ~USB_DEVICE_CTRLB_DETACH;
    4ae4:	4a02      	ldr	r2, [pc, #8]	; (4af0 <_usb_d_dev_attach+0xc>)
    4ae6:	8913      	ldrh	r3, [r2, #8]
    4ae8:	2101      	movs	r1, #1
    4aea:	438b      	bics	r3, r1
    4aec:	8113      	strh	r3, [r2, #8]
}
    4aee:	4770      	bx	lr
    4af0:	41005000 	.word	0x41005000

00004af4 <_usb_d_dev_set_address>:
	hri_usbdevice_write_DADD_reg(USB, USB_DEVICE_DADD_ADDEN | USB_DEVICE_DADD_DADD(addr));
    4af4:	2380      	movs	r3, #128	; 0x80
    4af6:	425b      	negs	r3, r3
    4af8:	4318      	orrs	r0, r3
    4afa:	b2c0      	uxtb	r0, r0
	((Usb *)hw)->DEVICE.DADD.reg = data;
    4afc:	4b01      	ldr	r3, [pc, #4]	; (4b04 <_usb_d_dev_set_address+0x10>)
    4afe:	7298      	strb	r0, [r3, #10]
}
    4b00:	4770      	bx	lr
    4b02:	46c0      	nop			; (mov r8, r8)
    4b04:	41005000 	.word	0x41005000

00004b08 <_usb_d_dev_ep_init>:
{
    4b08:	b5f0      	push	{r4, r5, r6, r7, lr}
    4b0a:	46c6      	mov	lr, r8
    4b0c:	b500      	push	{lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    4b0e:	230f      	movs	r3, #15
    4b10:	4003      	ands	r3, r0
    4b12:	b244      	sxtb	r4, r0
    4b14:	46a4      	mov	ip, r4
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    4b16:	2b00      	cmp	r3, #0
    4b18:	d005      	beq.n	4b26 <_usb_d_dev_ep_init+0x1e>
    4b1a:	2c00      	cmp	r4, #0
    4b1c:	db01      	blt.n	4b22 <_usb_d_dev_ep_init+0x1a>
    4b1e:	001c      	movs	r4, r3
    4b20:	e002      	b.n	4b28 <_usb_d_dev_ep_init+0x20>
    4b22:	1d5c      	adds	r4, r3, #5
    4b24:	e000      	b.n	4b28 <_usb_d_dev_ep_init+0x20>
    4b26:	001c      	movs	r4, r3
	return &dev_inst.ep[ep_index];
    4b28:	0026      	movs	r6, r4
	uint8_t                        ep_type = attr & USB_EP_XTYPE_MASK;
    4b2a:	2503      	movs	r5, #3
    4b2c:	4029      	ands	r1, r5
	const struct _usb_ep_cfg_item *pcfg    = &_usb_ep_cfgs[epn];
    4b2e:	001f      	movs	r7, r3
	if (epn > CONF_USB_D_MAX_EP_N) {
    4b30:	2b05      	cmp	r3, #5
    4b32:	d900      	bls.n	4b36 <_usb_d_dev_ep_init+0x2e>
    4b34:	e079      	b.n	4c2a <_usb_d_dev_ep_init+0x122>
	if (ept->ep != 0xFF) {
    4b36:	00a5      	lsls	r5, r4, #2
    4b38:	192d      	adds	r5, r5, r4
    4b3a:	00ac      	lsls	r4, r5, #2
    4b3c:	46a0      	mov	r8, r4
    4b3e:	4c42      	ldr	r4, [pc, #264]	; (4c48 <_usb_d_dev_ep_init+0x140>)
    4b40:	3440      	adds	r4, #64	; 0x40
    4b42:	4444      	add	r4, r8
    4b44:	3426      	adds	r4, #38	; 0x26
    4b46:	7824      	ldrb	r4, [r4, #0]
    4b48:	2cff      	cmp	r4, #255	; 0xff
    4b4a:	d000      	beq.n	4b4e <_usb_d_dev_ep_init+0x46>
    4b4c:	e070      	b.n	4c30 <_usb_d_dev_ep_init+0x128>
	if (ep_type == USB_EP_XTYPE_CTRL) {
    4b4e:	2900      	cmp	r1, #0
    4b50:	d118      	bne.n	4b84 <_usb_d_dev_ep_init+0x7c>
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    4b52:	2b00      	cmp	r3, #0
    4b54:	d004      	beq.n	4b60 <_usb_d_dev_ep_init+0x58>
    4b56:	4664      	mov	r4, ip
    4b58:	2c00      	cmp	r4, #0
    4b5a:	db01      	blt.n	4b60 <_usb_d_dev_ep_init+0x58>
    4b5c:	3305      	adds	r3, #5
    4b5e:	b2db      	uxtb	r3, r3
		if (ept_in->ep != 0xFF) {
    4b60:	009c      	lsls	r4, r3, #2
    4b62:	18e3      	adds	r3, r4, r3
    4b64:	009d      	lsls	r5, r3, #2
    4b66:	4b38      	ldr	r3, [pc, #224]	; (4c48 <_usb_d_dev_ep_init+0x140>)
    4b68:	3340      	adds	r3, #64	; 0x40
    4b6a:	195b      	adds	r3, r3, r5
    4b6c:	3326      	adds	r3, #38	; 0x26
    4b6e:	781b      	ldrb	r3, [r3, #0]
    4b70:	2bff      	cmp	r3, #255	; 0xff
    4b72:	d160      	bne.n	4c36 <_usb_d_dev_ep_init+0x12e>
		if (pcfg->cache == NULL) {
    4b74:	007b      	lsls	r3, r7, #1
    4b76:	19db      	adds	r3, r3, r7
    4b78:	009c      	lsls	r4, r3, #2
    4b7a:	4b34      	ldr	r3, [pc, #208]	; (4c4c <_usb_d_dev_ep_init+0x144>)
    4b7c:	191b      	adds	r3, r3, r4
    4b7e:	689b      	ldr	r3, [r3, #8]
    4b80:	2b00      	cmp	r3, #0
    4b82:	d05b      	beq.n	4c3c <_usb_d_dev_ep_init+0x134>
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    4b84:	4663      	mov	r3, ip
    4b86:	2b00      	cmp	r3, #0
    4b88:	db36      	blt.n	4bf8 <_usb_d_dev_ep_init+0xf0>
    4b8a:	007b      	lsls	r3, r7, #1
    4b8c:	19db      	adds	r3, r3, r7
    4b8e:	009c      	lsls	r4, r3, #2
    4b90:	4b2e      	ldr	r3, [pc, #184]	; (4c4c <_usb_d_dev_ep_init+0x144>)
    4b92:	191b      	adds	r3, r3, r4
    4b94:	689b      	ldr	r3, [r3, #8]
    4b96:	1e5c      	subs	r4, r3, #1
    4b98:	41a3      	sbcs	r3, r4
    4b9a:	b2db      	uxtb	r3, r3
    4b9c:	2b00      	cmp	r3, #0
    4b9e:	d00a      	beq.n	4bb6 <_usb_d_dev_ep_init+0xae>
    4ba0:	4663      	mov	r3, ip
    4ba2:	2b00      	cmp	r3, #0
    4ba4:	db32      	blt.n	4c0c <_usb_d_dev_ep_init+0x104>
    4ba6:	007b      	lsls	r3, r7, #1
    4ba8:	19db      	adds	r3, r3, r7
    4baa:	009c      	lsls	r4, r3, #2
    4bac:	4b27      	ldr	r3, [pc, #156]	; (4c4c <_usb_d_dev_ep_init+0x144>)
    4bae:	191b      	adds	r3, r3, r4
    4bb0:	8a1b      	ldrh	r3, [r3, #16]
    4bb2:	4293      	cmp	r3, r2
    4bb4:	db45      	blt.n	4c42 <_usb_d_dev_ep_init+0x13a>
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    4bb6:	4663      	mov	r3, ip
    4bb8:	2b00      	cmp	r3, #0
    4bba:	db2e      	blt.n	4c1a <_usb_d_dev_ep_init+0x112>
    4bbc:	007b      	lsls	r3, r7, #1
    4bbe:	19df      	adds	r7, r3, r7
    4bc0:	00bc      	lsls	r4, r7, #2
    4bc2:	4b22      	ldr	r3, [pc, #136]	; (4c4c <_usb_d_dev_ep_init+0x144>)
    4bc4:	191b      	adds	r3, r3, r4
    4bc6:	689b      	ldr	r3, [r3, #8]
    4bc8:	469c      	mov	ip, r3
    4bca:	4b1f      	ldr	r3, [pc, #124]	; (4c48 <_usb_d_dev_ep_init+0x140>)
    4bcc:	00b5      	lsls	r5, r6, #2
    4bce:	19af      	adds	r7, r5, r6
    4bd0:	00bc      	lsls	r4, r7, #2
    4bd2:	191c      	adds	r4, r3, r4
    4bd4:	4667      	mov	r7, ip
    4bd6:	6627      	str	r7, [r4, #96]	; 0x60
	ept->size     = max_pkt_siz;
    4bd8:	3340      	adds	r3, #64	; 0x40
    4bda:	19af      	adds	r7, r5, r6
    4bdc:	00bc      	lsls	r4, r7, #2
    4bde:	0027      	movs	r7, r4
    4be0:	191c      	adds	r4, r3, r4
    4be2:	84a2      	strh	r2, [r4, #36]	; 0x24
	ept->flags.u8 = (ep_type + 1);
    4be4:	3101      	adds	r1, #1
    4be6:	3427      	adds	r4, #39	; 0x27
    4be8:	7021      	strb	r1, [r4, #0]
	ept->ep       = ep;
    4bea:	19db      	adds	r3, r3, r7
    4bec:	3326      	adds	r3, #38	; 0x26
    4bee:	7018      	strb	r0, [r3, #0]
	return USB_OK;
    4bf0:	2000      	movs	r0, #0
}
    4bf2:	bc04      	pop	{r2}
    4bf4:	4690      	mov	r8, r2
    4bf6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    4bf8:	007b      	lsls	r3, r7, #1
    4bfa:	19db      	adds	r3, r3, r7
    4bfc:	009c      	lsls	r4, r3, #2
    4bfe:	4b13      	ldr	r3, [pc, #76]	; (4c4c <_usb_d_dev_ep_init+0x144>)
    4c00:	191b      	adds	r3, r3, r4
    4c02:	68db      	ldr	r3, [r3, #12]
    4c04:	1e5c      	subs	r4, r3, #1
    4c06:	41a3      	sbcs	r3, r4
    4c08:	b2db      	uxtb	r3, r3
    4c0a:	e7c7      	b.n	4b9c <_usb_d_dev_ep_init+0x94>
    4c0c:	007b      	lsls	r3, r7, #1
    4c0e:	19db      	adds	r3, r3, r7
    4c10:	009c      	lsls	r4, r3, #2
    4c12:	4b0e      	ldr	r3, [pc, #56]	; (4c4c <_usb_d_dev_ep_init+0x144>)
    4c14:	191b      	adds	r3, r3, r4
    4c16:	8a5b      	ldrh	r3, [r3, #18]
    4c18:	e7cb      	b.n	4bb2 <_usb_d_dev_ep_init+0xaa>
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    4c1a:	007b      	lsls	r3, r7, #1
    4c1c:	19df      	adds	r7, r3, r7
    4c1e:	00bc      	lsls	r4, r7, #2
    4c20:	4b0a      	ldr	r3, [pc, #40]	; (4c4c <_usb_d_dev_ep_init+0x144>)
    4c22:	191b      	adds	r3, r3, r4
    4c24:	68db      	ldr	r3, [r3, #12]
    4c26:	469c      	mov	ip, r3
    4c28:	e7cf      	b.n	4bca <_usb_d_dev_ep_init+0xc2>
		return -USB_ERR_PARAM;
    4c2a:	2012      	movs	r0, #18
    4c2c:	4240      	negs	r0, r0
    4c2e:	e7e0      	b.n	4bf2 <_usb_d_dev_ep_init+0xea>
		return -USB_ERR_REDO;
    4c30:	2014      	movs	r0, #20
    4c32:	4240      	negs	r0, r0
    4c34:	e7dd      	b.n	4bf2 <_usb_d_dev_ep_init+0xea>
			return -USB_ERR_REDO;
    4c36:	2014      	movs	r0, #20
    4c38:	4240      	negs	r0, r0
    4c3a:	e7da      	b.n	4bf2 <_usb_d_dev_ep_init+0xea>
			return -USB_ERR_FUNC;
    4c3c:	2013      	movs	r0, #19
    4c3e:	4240      	negs	r0, r0
    4c40:	e7d7      	b.n	4bf2 <_usb_d_dev_ep_init+0xea>
		return -USB_ERR_FUNC;
    4c42:	2013      	movs	r0, #19
    4c44:	4240      	negs	r0, r0
    4c46:	e7d4      	b.n	4bf2 <_usb_d_dev_ep_init+0xea>
    4c48:	20000448 	.word	0x20000448
    4c4c:	0000acd0 	.word	0x0000acd0

00004c50 <_usb_d_dev_ep_deinit>:
{
    4c50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4c52:	0004      	movs	r4, r0
	uint8_t               epn = USB_EP_GET_N(ep);
    4c54:	250f      	movs	r5, #15
    4c56:	4005      	ands	r5, r0
    4c58:	b247      	sxtb	r7, r0
	bool                  dir = USB_EP_GET_DIR(ep);
    4c5a:	0ffb      	lsrs	r3, r7, #31
    4c5c:	469c      	mov	ip, r3
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    4c5e:	2d00      	cmp	r5, #0
    4c60:	d005      	beq.n	4c6e <_usb_d_dev_ep_deinit+0x1e>
    4c62:	2f00      	cmp	r7, #0
    4c64:	db01      	blt.n	4c6a <_usb_d_dev_ep_deinit+0x1a>
    4c66:	002a      	movs	r2, r5
    4c68:	e002      	b.n	4c70 <_usb_d_dev_ep_deinit+0x20>
    4c6a:	1d6a      	adds	r2, r5, #5
    4c6c:	e000      	b.n	4c70 <_usb_d_dev_ep_deinit+0x20>
    4c6e:	002a      	movs	r2, r5
	return &dev_inst.ep[ep_index];
    4c70:	0016      	movs	r6, r2
    4c72:	0093      	lsls	r3, r2, #2
    4c74:	189b      	adds	r3, r3, r2
    4c76:	0099      	lsls	r1, r3, #2
    4c78:	3110      	adds	r1, #16
    4c7a:	4823      	ldr	r0, [pc, #140]	; (4d08 <_usb_d_dev_ep_deinit+0xb8>)
    4c7c:	3040      	adds	r0, #64	; 0x40
    4c7e:	1840      	adds	r0, r0, r1
    4c80:	3004      	adds	r0, #4
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    4c82:	2d05      	cmp	r5, #5
    4c84:	d830      	bhi.n	4ce8 <_usb_d_dev_ep_deinit+0x98>
    4c86:	0093      	lsls	r3, r2, #2
    4c88:	189a      	adds	r2, r3, r2
    4c8a:	0091      	lsls	r1, r2, #2
    4c8c:	4b1e      	ldr	r3, [pc, #120]	; (4d08 <_usb_d_dev_ep_deinit+0xb8>)
    4c8e:	3340      	adds	r3, #64	; 0x40
    4c90:	185b      	adds	r3, r3, r1
    4c92:	3326      	adds	r3, #38	; 0x26
    4c94:	781b      	ldrb	r3, [r3, #0]
    4c96:	2bff      	cmp	r3, #255	; 0xff
    4c98:	d026      	beq.n	4ce8 <_usb_d_dev_ep_deinit+0x98>
	_usb_d_dev_trans_stop(ept, dir, USB_TRANS_RESET);
    4c9a:	2203      	movs	r2, #3
    4c9c:	4661      	mov	r1, ip
    4c9e:	4b1b      	ldr	r3, [pc, #108]	; (4d0c <_usb_d_dev_ep_deinit+0xbc>)
    4ca0:	4798      	blx	r3
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    4ca2:	00b2      	lsls	r2, r6, #2
    4ca4:	1992      	adds	r2, r2, r6
    4ca6:	0091      	lsls	r1, r2, #2
    4ca8:	4b17      	ldr	r3, [pc, #92]	; (4d08 <_usb_d_dev_ep_deinit+0xb8>)
    4caa:	185b      	adds	r3, r3, r1
    4cac:	3360      	adds	r3, #96	; 0x60
    4cae:	79da      	ldrb	r2, [r3, #7]
    4cb0:	2307      	movs	r3, #7
    4cb2:	4013      	ands	r3, r2
    4cb4:	2b01      	cmp	r3, #1
    4cb6:	d018      	beq.n	4cea <_usb_d_dev_ep_deinit+0x9a>
	} else if (USB_EP_GET_DIR(ep)) {
    4cb8:	2f00      	cmp	r7, #0
    4cba:	db1c      	blt.n	4cf6 <_usb_d_dev_ep_deinit+0xa6>
		hw->DEVICE.DeviceEndpoint[ep].EPCFG.reg &= ~USB_DEVICE_EPCFG_EPTYPE0_Msk;
    4cbc:	4a14      	ldr	r2, [pc, #80]	; (4d10 <_usb_d_dev_ep_deinit+0xc0>)
    4cbe:	3408      	adds	r4, #8
    4cc0:	0164      	lsls	r4, r4, #5
    4cc2:	5ca3      	ldrb	r3, [r4, r2]
    4cc4:	2107      	movs	r1, #7
    4cc6:	438b      	bics	r3, r1
    4cc8:	54a3      	strb	r3, [r4, r2]
	ept->flags.u8 = 0;
    4cca:	4b0f      	ldr	r3, [pc, #60]	; (4d08 <_usb_d_dev_ep_deinit+0xb8>)
    4ccc:	3340      	adds	r3, #64	; 0x40
    4cce:	00b1      	lsls	r1, r6, #2
    4cd0:	1988      	adds	r0, r1, r6
    4cd2:	0082      	lsls	r2, r0, #2
    4cd4:	189a      	adds	r2, r3, r2
    4cd6:	3227      	adds	r2, #39	; 0x27
    4cd8:	2000      	movs	r0, #0
    4cda:	7010      	strb	r0, [r2, #0]
	ept->ep       = 0xFF;
    4cdc:	198e      	adds	r6, r1, r6
    4cde:	00b2      	lsls	r2, r6, #2
    4ce0:	189b      	adds	r3, r3, r2
    4ce2:	3326      	adds	r3, #38	; 0x26
    4ce4:	22ff      	movs	r2, #255	; 0xff
    4ce6:	701a      	strb	r2, [r3, #0]
}
    4ce8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		hw->DEVICE.DeviceEndpoint[ep].EPCFG.reg = 0;
    4cea:	3408      	adds	r4, #8
    4cec:	0164      	lsls	r4, r4, #5
    4cee:	2200      	movs	r2, #0
    4cf0:	4b07      	ldr	r3, [pc, #28]	; (4d10 <_usb_d_dev_ep_deinit+0xc0>)
    4cf2:	54e2      	strb	r2, [r4, r3]
    4cf4:	e7e9      	b.n	4cca <_usb_d_dev_ep_deinit+0x7a>
		hw->DEVICE.DeviceEndpoint[USB_EP_GET_N(ep)].EPCFG.reg &= ~USB_DEVICE_EPCFG_EPTYPE1_Msk;
    4cf6:	4a06      	ldr	r2, [pc, #24]	; (4d10 <_usb_d_dev_ep_deinit+0xc0>)
    4cf8:	3508      	adds	r5, #8
    4cfa:	016d      	lsls	r5, r5, #5
    4cfc:	5cab      	ldrb	r3, [r5, r2]
    4cfe:	2170      	movs	r1, #112	; 0x70
    4d00:	438b      	bics	r3, r1
    4d02:	54ab      	strb	r3, [r5, r2]
    4d04:	e7e1      	b.n	4cca <_usb_d_dev_ep_deinit+0x7a>
    4d06:	46c0      	nop			; (mov r8, r8)
    4d08:	20000448 	.word	0x20000448
    4d0c:	0000421d 	.word	0x0000421d
    4d10:	41005000 	.word	0x41005000

00004d14 <_usb_d_dev_ep_enable>:
{
    4d14:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t               epn   = USB_EP_GET_N(ep);
    4d16:	230f      	movs	r3, #15
    4d18:	4003      	ands	r3, r0
    4d1a:	b240      	sxtb	r0, r0
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    4d1c:	2b00      	cmp	r3, #0
    4d1e:	d005      	beq.n	4d2c <_usb_d_dev_ep_enable+0x18>
    4d20:	2800      	cmp	r0, #0
    4d22:	db01      	blt.n	4d28 <_usb_d_dev_ep_enable+0x14>
    4d24:	001e      	movs	r6, r3
    4d26:	e002      	b.n	4d2e <_usb_d_dev_ep_enable+0x1a>
    4d28:	1d5e      	adds	r6, r3, #5
    4d2a:	e000      	b.n	4d2e <_usb_d_dev_ep_enable+0x1a>
    4d2c:	001e      	movs	r6, r3
	return &dev_inst.ep[ep_index];
    4d2e:	0034      	movs	r4, r6
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    4d30:	001a      	movs	r2, r3
    4d32:	3208      	adds	r2, #8
    4d34:	0152      	lsls	r2, r2, #5
    4d36:	49b4      	ldr	r1, [pc, #720]	; (5008 <_usb_d_dev_ep_enable+0x2f4>)
    4d38:	5c55      	ldrb	r5, [r2, r1]
    4d3a:	b2ed      	uxtb	r5, r5
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    4d3c:	2b05      	cmp	r3, #5
    4d3e:	d900      	bls.n	4d42 <_usb_d_dev_ep_enable+0x2e>
    4d40:	e152      	b.n	4fe8 <_usb_d_dev_ep_enable+0x2d4>
    4d42:	00b1      	lsls	r1, r6, #2
    4d44:	1989      	adds	r1, r1, r6
    4d46:	008e      	lsls	r6, r1, #2
    4d48:	4ab0      	ldr	r2, [pc, #704]	; (500c <_usb_d_dev_ep_enable+0x2f8>)
    4d4a:	3240      	adds	r2, #64	; 0x40
    4d4c:	1992      	adds	r2, r2, r6
    4d4e:	3226      	adds	r2, #38	; 0x26
    4d50:	7812      	ldrb	r2, [r2, #0]
    4d52:	2aff      	cmp	r2, #255	; 0xff
    4d54:	d100      	bne.n	4d58 <_usb_d_dev_ep_enable+0x44>
    4d56:	e14a      	b.n	4fee <_usb_d_dev_ep_enable+0x2da>
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    4d58:	015a      	lsls	r2, r3, #5
    4d5a:	4ead      	ldr	r6, [pc, #692]	; (5010 <_usb_d_dev_ep_enable+0x2fc>)
    4d5c:	18b6      	adds	r6, r6, r2
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    4d5e:	00a1      	lsls	r1, r4, #2
    4d60:	1909      	adds	r1, r1, r4
    4d62:	008f      	lsls	r7, r1, #2
    4d64:	4aa9      	ldr	r2, [pc, #676]	; (500c <_usb_d_dev_ep_enable+0x2f8>)
    4d66:	19d2      	adds	r2, r2, r7
    4d68:	3260      	adds	r2, #96	; 0x60
    4d6a:	79d1      	ldrb	r1, [r2, #7]
    4d6c:	2207      	movs	r2, #7
    4d6e:	400a      	ands	r2, r1
    4d70:	2a01      	cmp	r2, #1
    4d72:	d037      	beq.n	4de4 <_usb_d_dev_ep_enable+0xd0>
	} else if (dir) {
    4d74:	2800      	cmp	r0, #0
    4d76:	da00      	bge.n	4d7a <_usb_d_dev_ep_enable+0x66>
    4d78:	e0cd      	b.n	4f16 <_usb_d_dev_ep_enable+0x202>
		if (epcfg & USB_DEVICE_EPCFG_EPTYPE0_Msk) {
    4d7a:	076a      	lsls	r2, r5, #29
    4d7c:	d000      	beq.n	4d80 <_usb_d_dev_ep_enable+0x6c>
    4d7e:	e13f      	b.n	5000 <_usb_d_dev_ep_enable+0x2ec>
		epcfg |= USB_DEVICE_EPCFG_EPTYPE0(ept->flags.bits.eptype);
    4d80:	4aa2      	ldr	r2, [pc, #648]	; (500c <_usb_d_dev_ep_enable+0x2f8>)
    4d82:	00a0      	lsls	r0, r4, #2
    4d84:	1907      	adds	r7, r0, r4
    4d86:	00b9      	lsls	r1, r7, #2
    4d88:	1851      	adds	r1, r2, r1
    4d8a:	3160      	adds	r1, #96	; 0x60
    4d8c:	79c9      	ldrb	r1, [r1, #7]
    4d8e:	0749      	lsls	r1, r1, #29
    4d90:	0f49      	lsrs	r1, r1, #29
    4d92:	430d      	orrs	r5, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    4d94:	0019      	movs	r1, r3
    4d96:	3108      	adds	r1, #8
    4d98:	0149      	lsls	r1, r1, #5
    4d9a:	4f9b      	ldr	r7, [pc, #620]	; (5008 <_usb_d_dev_ep_enable+0x2f4>)
    4d9c:	55cd      	strb	r5, [r1, r7]
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    4d9e:	3240      	adds	r2, #64	; 0x40
    4da0:	1904      	adds	r4, r0, r4
    4da2:	00a1      	lsls	r1, r4, #2
    4da4:	1852      	adds	r2, r2, r1
    4da6:	8c90      	ldrh	r0, [r2, #36]	; 0x24
    4da8:	0382      	lsls	r2, r0, #14
    4daa:	499a      	ldr	r1, [pc, #616]	; (5014 <_usb_d_dev_ep_enable+0x300>)
    4dac:	400a      	ands	r2, r1
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    4dae:	2180      	movs	r1, #128	; 0x80
    4db0:	0089      	lsls	r1, r1, #2
    4db2:	4288      	cmp	r0, r1
    4db4:	d900      	bls.n	4db8 <_usb_d_dev_ep_enable+0xa4>
    4db6:	e0fa      	b.n	4fae <_usb_d_dev_ep_enable+0x29a>
    4db8:	3901      	subs	r1, #1
    4dba:	39ff      	subs	r1, #255	; 0xff
    4dbc:	4288      	cmp	r0, r1
    4dbe:	d900      	bls.n	4dc2 <_usb_d_dev_ep_enable+0xae>
    4dc0:	e108      	b.n	4fd4 <_usb_d_dev_ep_enable+0x2c0>
    4dc2:	2880      	cmp	r0, #128	; 0x80
    4dc4:	d900      	bls.n	4dc8 <_usb_d_dev_ep_enable+0xb4>
    4dc6:	e107      	b.n	4fd8 <_usb_d_dev_ep_enable+0x2c4>
    4dc8:	2840      	cmp	r0, #64	; 0x40
    4dca:	d900      	bls.n	4dce <_usb_d_dev_ep_enable+0xba>
    4dcc:	e106      	b.n	4fdc <_usb_d_dev_ep_enable+0x2c8>
    4dce:	2820      	cmp	r0, #32
    4dd0:	d900      	bls.n	4dd4 <_usb_d_dev_ep_enable+0xc0>
    4dd2:	e105      	b.n	4fe0 <_usb_d_dev_ep_enable+0x2cc>
    4dd4:	2810      	cmp	r0, #16
    4dd6:	d900      	bls.n	4dda <_usb_d_dev_ep_enable+0xc6>
    4dd8:	e104      	b.n	4fe4 <_usb_d_dev_ep_enable+0x2d0>
    4dda:	39f8      	subs	r1, #248	; 0xf8
    4ddc:	4281      	cmp	r1, r0
    4dde:	4189      	sbcs	r1, r1
    4de0:	4249      	negs	r1, r1
    4de2:	e0e5      	b.n	4fb0 <_usb_d_dev_ep_enable+0x29c>
		if (epcfg & (USB_DEVICE_EPCFG_EPTYPE1_Msk | USB_DEVICE_EPCFG_EPTYPE0_Msk)) {
    4de4:	3276      	adds	r2, #118	; 0x76
    4de6:	422a      	tst	r2, r5
    4de8:	d000      	beq.n	4dec <_usb_d_dev_ep_enable+0xd8>
    4dea:	e103      	b.n	4ff4 <_usb_d_dev_ep_enable+0x2e0>
    4dec:	001a      	movs	r2, r3
    4dee:	3208      	adds	r2, #8
    4df0:	0152      	lsls	r2, r2, #5
    4df2:	2011      	movs	r0, #17
    4df4:	4984      	ldr	r1, [pc, #528]	; (5008 <_usb_d_dev_ep_enable+0x2f4>)
    4df6:	5450      	strb	r0, [r2, r1]
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    4df8:	4a84      	ldr	r2, [pc, #528]	; (500c <_usb_d_dev_ep_enable+0x2f8>)
    4dfa:	3240      	adds	r2, #64	; 0x40
    4dfc:	19d2      	adds	r2, r2, r7
    4dfe:	8c92      	ldrh	r2, [r2, #36]	; 0x24
    4e00:	0391      	lsls	r1, r2, #14
    4e02:	4884      	ldr	r0, [pc, #528]	; (5014 <_usb_d_dev_ep_enable+0x300>)
    4e04:	4001      	ands	r1, r0
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    4e06:	2080      	movs	r0, #128	; 0x80
    4e08:	0080      	lsls	r0, r0, #2
    4e0a:	4282      	cmp	r2, r0
    4e0c:	d810      	bhi.n	4e30 <_usb_d_dev_ep_enable+0x11c>
    4e0e:	3801      	subs	r0, #1
    4e10:	38ff      	subs	r0, #255	; 0xff
    4e12:	4282      	cmp	r2, r0
    4e14:	d827      	bhi.n	4e66 <_usb_d_dev_ep_enable+0x152>
    4e16:	2a80      	cmp	r2, #128	; 0x80
    4e18:	d827      	bhi.n	4e6a <_usb_d_dev_ep_enable+0x156>
    4e1a:	2a40      	cmp	r2, #64	; 0x40
    4e1c:	d827      	bhi.n	4e6e <_usb_d_dev_ep_enable+0x15a>
    4e1e:	2a20      	cmp	r2, #32
    4e20:	d827      	bhi.n	4e72 <_usb_d_dev_ep_enable+0x15e>
    4e22:	2a10      	cmp	r2, #16
    4e24:	d827      	bhi.n	4e76 <_usb_d_dev_ep_enable+0x162>
    4e26:	38f8      	subs	r0, #248	; 0xf8
    4e28:	4290      	cmp	r0, r2
    4e2a:	4180      	sbcs	r0, r0
    4e2c:	4240      	negs	r0, r0
    4e2e:	e000      	b.n	4e32 <_usb_d_dev_ep_enable+0x11e>
    4e30:	2007      	movs	r0, #7
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    4e32:	0700      	lsls	r0, r0, #28
    4e34:	4301      	orrs	r1, r0
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    4e36:	6071      	str	r1, [r6, #4]
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    4e38:	0491      	lsls	r1, r2, #18
    4e3a:	0c89      	lsrs	r1, r1, #18
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    4e3c:	2080      	movs	r0, #128	; 0x80
    4e3e:	0080      	lsls	r0, r0, #2
    4e40:	4282      	cmp	r2, r0
    4e42:	d81a      	bhi.n	4e7a <_usb_d_dev_ep_enable+0x166>
    4e44:	3801      	subs	r0, #1
    4e46:	38ff      	subs	r0, #255	; 0xff
    4e48:	4282      	cmp	r2, r0
    4e4a:	d85a      	bhi.n	4f02 <_usb_d_dev_ep_enable+0x1ee>
    4e4c:	2a80      	cmp	r2, #128	; 0x80
    4e4e:	d85a      	bhi.n	4f06 <_usb_d_dev_ep_enable+0x1f2>
    4e50:	2a40      	cmp	r2, #64	; 0x40
    4e52:	d85a      	bhi.n	4f0a <_usb_d_dev_ep_enable+0x1f6>
    4e54:	2a20      	cmp	r2, #32
    4e56:	d85a      	bhi.n	4f0e <_usb_d_dev_ep_enable+0x1fa>
    4e58:	2a10      	cmp	r2, #16
    4e5a:	d85a      	bhi.n	4f12 <_usb_d_dev_ep_enable+0x1fe>
    4e5c:	38f8      	subs	r0, #248	; 0xf8
    4e5e:	4290      	cmp	r0, r2
    4e60:	4192      	sbcs	r2, r2
    4e62:	4252      	negs	r2, r2
    4e64:	e00a      	b.n	4e7c <_usb_d_dev_ep_enable+0x168>
    4e66:	2006      	movs	r0, #6
    4e68:	e7e3      	b.n	4e32 <_usb_d_dev_ep_enable+0x11e>
    4e6a:	2005      	movs	r0, #5
    4e6c:	e7e1      	b.n	4e32 <_usb_d_dev_ep_enable+0x11e>
    4e6e:	2004      	movs	r0, #4
    4e70:	e7df      	b.n	4e32 <_usb_d_dev_ep_enable+0x11e>
    4e72:	2003      	movs	r0, #3
    4e74:	e7dd      	b.n	4e32 <_usb_d_dev_ep_enable+0x11e>
    4e76:	2002      	movs	r0, #2
    4e78:	e7db      	b.n	4e32 <_usb_d_dev_ep_enable+0x11e>
    4e7a:	2207      	movs	r2, #7
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    4e7c:	0712      	lsls	r2, r2, #28
    4e7e:	430a      	orrs	r2, r1
    4e80:	6172      	str	r2, [r6, #20]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    4e82:	001a      	movs	r2, r3
    4e84:	3208      	adds	r2, #8
    4e86:	0152      	lsls	r2, r2, #5
    4e88:	495f      	ldr	r1, [pc, #380]	; (5008 <_usb_d_dev_ep_enable+0x2f4>)
    4e8a:	468c      	mov	ip, r1
    4e8c:	4462      	add	r2, ip
    4e8e:	2140      	movs	r1, #64	; 0x40
    4e90:	7151      	strb	r1, [r2, #5]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    4e92:	2080      	movs	r0, #128	; 0x80
    4e94:	7110      	strb	r0, [r2, #4]
	bank->STATUS_BK.reg     = 0;
    4e96:	4d5e      	ldr	r5, [pc, #376]	; (5010 <_usb_d_dev_ep_enable+0x2fc>)
    4e98:	015b      	lsls	r3, r3, #5
    4e9a:	18eb      	adds	r3, r5, r3
    4e9c:	2200      	movs	r2, #0
    4e9e:	729a      	strb	r2, [r3, #10]
    4ea0:	769a      	strb	r2, [r3, #26]
	uint8_t epn = USB_EP_GET_N(ept->ep);
    4ea2:	485a      	ldr	r0, [pc, #360]	; (500c <_usb_d_dev_ep_enable+0x2f8>)
    4ea4:	0006      	movs	r6, r0
    4ea6:	3640      	adds	r6, #64	; 0x40
    4ea8:	00a2      	lsls	r2, r4, #2
    4eaa:	1917      	adds	r7, r2, r4
    4eac:	00bb      	lsls	r3, r7, #2
    4eae:	18f3      	adds	r3, r6, r3
    4eb0:	3326      	adds	r3, #38	; 0x26
    4eb2:	781b      	ldrb	r3, [r3, #0]
    4eb4:	270f      	movs	r7, #15
    4eb6:	403b      	ands	r3, r7
	_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    4eb8:	1917      	adds	r7, r2, r4
    4eba:	00bf      	lsls	r7, r7, #2
    4ebc:	46bc      	mov	ip, r7
    4ebe:	19c0      	adds	r0, r0, r7
    4ec0:	6e07      	ldr	r7, [r0, #96]	; 0x60
	bank->ADDR.reg          = addr;
    4ec2:	0158      	lsls	r0, r3, #5
    4ec4:	5147      	str	r7, [r0, r5]
	_usbd_ep_set_out_trans(epn, 0, ept->size, 0);
    4ec6:	4662      	mov	r2, ip
    4ec8:	18b6      	adds	r6, r6, r2
    4eca:	8cb2      	ldrh	r2, [r6, #36]	; 0x24
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    4ecc:	182c      	adds	r4, r5, r0
    4ece:	6865      	ldr	r5, [r4, #4]
    4ed0:	0492      	lsls	r2, r2, #18
    4ed2:	0912      	lsrs	r2, r2, #4
    4ed4:	4e50      	ldr	r6, [pc, #320]	; (5018 <_usb_d_dev_ep_enable+0x304>)
    4ed6:	4035      	ands	r5, r6
    4ed8:	432a      	orrs	r2, r5
    4eda:	6062      	str	r2, [r4, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    4edc:	6862      	ldr	r2, [r4, #4]
    4ede:	0b92      	lsrs	r2, r2, #14
    4ee0:	0395      	lsls	r5, r2, #14
    4ee2:	6065      	str	r5, [r4, #4]
    4ee4:	3308      	adds	r3, #8
    4ee6:	015b      	lsls	r3, r3, #5
    4ee8:	4a47      	ldr	r2, [pc, #284]	; (5008 <_usb_d_dev_ep_enable+0x2f4>)
    4eea:	4694      	mov	ip, r2
    4eec:	4463      	add	r3, ip
    4eee:	22b0      	movs	r2, #176	; 0xb0
    4ef0:	711a      	strb	r2, [r3, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    4ef2:	7159      	strb	r1, [r3, #5]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    4ef4:	4b49      	ldr	r3, [pc, #292]	; (501c <_usb_d_dev_ep_enable+0x308>)
    4ef6:	469c      	mov	ip, r3
    4ef8:	4460      	add	r0, ip
    4efa:	2310      	movs	r3, #16
    4efc:	7003      	strb	r3, [r0, #0]
	return USB_OK;
    4efe:	2000      	movs	r0, #0
    4f00:	e067      	b.n	4fd2 <_usb_d_dev_ep_enable+0x2be>
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    4f02:	2206      	movs	r2, #6
    4f04:	e7ba      	b.n	4e7c <_usb_d_dev_ep_enable+0x168>
    4f06:	2205      	movs	r2, #5
    4f08:	e7b8      	b.n	4e7c <_usb_d_dev_ep_enable+0x168>
    4f0a:	2204      	movs	r2, #4
    4f0c:	e7b6      	b.n	4e7c <_usb_d_dev_ep_enable+0x168>
    4f0e:	2203      	movs	r2, #3
    4f10:	e7b4      	b.n	4e7c <_usb_d_dev_ep_enable+0x168>
    4f12:	2202      	movs	r2, #2
    4f14:	e7b2      	b.n	4e7c <_usb_d_dev_ep_enable+0x168>
		if (epcfg & USB_DEVICE_EPCFG_EPTYPE1_Msk) {
    4f16:	2270      	movs	r2, #112	; 0x70
    4f18:	422a      	tst	r2, r5
    4f1a:	d000      	beq.n	4f1e <_usb_d_dev_ep_enable+0x20a>
    4f1c:	e06d      	b.n	4ffa <_usb_d_dev_ep_enable+0x2e6>
		epcfg |= USB_DEVICE_EPCFG_EPTYPE1(ept->flags.bits.eptype);
    4f1e:	493b      	ldr	r1, [pc, #236]	; (500c <_usb_d_dev_ep_enable+0x2f8>)
    4f20:	00a0      	lsls	r0, r4, #2
    4f22:	1907      	adds	r7, r0, r4
    4f24:	00ba      	lsls	r2, r7, #2
    4f26:	188a      	adds	r2, r1, r2
    4f28:	3260      	adds	r2, #96	; 0x60
    4f2a:	79d2      	ldrb	r2, [r2, #7]
    4f2c:	0752      	lsls	r2, r2, #29
    4f2e:	0e52      	lsrs	r2, r2, #25
    4f30:	4315      	orrs	r5, r2
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    4f32:	001a      	movs	r2, r3
    4f34:	3208      	adds	r2, #8
    4f36:	0152      	lsls	r2, r2, #5
    4f38:	4f33      	ldr	r7, [pc, #204]	; (5008 <_usb_d_dev_ep_enable+0x2f4>)
    4f3a:	55d5      	strb	r5, [r2, r7]
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    4f3c:	3140      	adds	r1, #64	; 0x40
    4f3e:	1904      	adds	r4, r0, r4
    4f40:	00a2      	lsls	r2, r4, #2
    4f42:	1889      	adds	r1, r1, r2
    4f44:	8c89      	ldrh	r1, [r1, #36]	; 0x24
    4f46:	048a      	lsls	r2, r1, #18
    4f48:	0c92      	lsrs	r2, r2, #18
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    4f4a:	2080      	movs	r0, #128	; 0x80
    4f4c:	0080      	lsls	r0, r0, #2
    4f4e:	4281      	cmp	r1, r0
    4f50:	d810      	bhi.n	4f74 <_usb_d_dev_ep_enable+0x260>
    4f52:	3801      	subs	r0, #1
    4f54:	38ff      	subs	r0, #255	; 0xff
    4f56:	4281      	cmp	r1, r0
    4f58:	d81f      	bhi.n	4f9a <_usb_d_dev_ep_enable+0x286>
    4f5a:	2980      	cmp	r1, #128	; 0x80
    4f5c:	d81f      	bhi.n	4f9e <_usb_d_dev_ep_enable+0x28a>
    4f5e:	2940      	cmp	r1, #64	; 0x40
    4f60:	d81f      	bhi.n	4fa2 <_usb_d_dev_ep_enable+0x28e>
    4f62:	2920      	cmp	r1, #32
    4f64:	d81f      	bhi.n	4fa6 <_usb_d_dev_ep_enable+0x292>
    4f66:	2910      	cmp	r1, #16
    4f68:	d81f      	bhi.n	4faa <_usb_d_dev_ep_enable+0x296>
    4f6a:	38f8      	subs	r0, #248	; 0xf8
    4f6c:	4288      	cmp	r0, r1
    4f6e:	4189      	sbcs	r1, r1
    4f70:	4249      	negs	r1, r1
    4f72:	e000      	b.n	4f76 <_usb_d_dev_ep_enable+0x262>
    4f74:	2107      	movs	r1, #7
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    4f76:	0709      	lsls	r1, r1, #28
    4f78:	430a      	orrs	r2, r1
    4f7a:	6172      	str	r2, [r6, #20]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    4f7c:	001a      	movs	r2, r3
    4f7e:	3208      	adds	r2, #8
    4f80:	0152      	lsls	r2, r2, #5
    4f82:	4921      	ldr	r1, [pc, #132]	; (5008 <_usb_d_dev_ep_enable+0x2f4>)
    4f84:	468c      	mov	ip, r1
    4f86:	4462      	add	r2, ip
    4f88:	2180      	movs	r1, #128	; 0x80
    4f8a:	7111      	strb	r1, [r2, #4]
	bank->STATUS_BK.reg     = 0;
    4f8c:	015a      	lsls	r2, r3, #5
    4f8e:	4b20      	ldr	r3, [pc, #128]	; (5010 <_usb_d_dev_ep_enable+0x2fc>)
    4f90:	189b      	adds	r3, r3, r2
    4f92:	2200      	movs	r2, #0
    4f94:	769a      	strb	r2, [r3, #26]
	return USB_OK;
    4f96:	2000      	movs	r0, #0
    4f98:	e01b      	b.n	4fd2 <_usb_d_dev_ep_enable+0x2be>
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    4f9a:	2106      	movs	r1, #6
    4f9c:	e7eb      	b.n	4f76 <_usb_d_dev_ep_enable+0x262>
    4f9e:	2105      	movs	r1, #5
    4fa0:	e7e9      	b.n	4f76 <_usb_d_dev_ep_enable+0x262>
    4fa2:	2104      	movs	r1, #4
    4fa4:	e7e7      	b.n	4f76 <_usb_d_dev_ep_enable+0x262>
    4fa6:	2103      	movs	r1, #3
    4fa8:	e7e5      	b.n	4f76 <_usb_d_dev_ep_enable+0x262>
    4faa:	2102      	movs	r1, #2
    4fac:	e7e3      	b.n	4f76 <_usb_d_dev_ep_enable+0x262>
    4fae:	2107      	movs	r1, #7
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    4fb0:	0709      	lsls	r1, r1, #28
    4fb2:	430a      	orrs	r2, r1
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    4fb4:	6072      	str	r2, [r6, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    4fb6:	001a      	movs	r2, r3
    4fb8:	3208      	adds	r2, #8
    4fba:	0152      	lsls	r2, r2, #5
    4fbc:	4912      	ldr	r1, [pc, #72]	; (5008 <_usb_d_dev_ep_enable+0x2f4>)
    4fbe:	468c      	mov	ip, r1
    4fc0:	4462      	add	r2, ip
    4fc2:	2140      	movs	r1, #64	; 0x40
    4fc4:	7151      	strb	r1, [r2, #5]
	bank->STATUS_BK.reg     = 0;
    4fc6:	015b      	lsls	r3, r3, #5
    4fc8:	4a11      	ldr	r2, [pc, #68]	; (5010 <_usb_d_dev_ep_enable+0x2fc>)
    4fca:	18d3      	adds	r3, r2, r3
    4fcc:	2200      	movs	r2, #0
    4fce:	729a      	strb	r2, [r3, #10]
	return USB_OK;
    4fd0:	2000      	movs	r0, #0
}
    4fd2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    4fd4:	2106      	movs	r1, #6
    4fd6:	e7eb      	b.n	4fb0 <_usb_d_dev_ep_enable+0x29c>
    4fd8:	2105      	movs	r1, #5
    4fda:	e7e9      	b.n	4fb0 <_usb_d_dev_ep_enable+0x29c>
    4fdc:	2104      	movs	r1, #4
    4fde:	e7e7      	b.n	4fb0 <_usb_d_dev_ep_enable+0x29c>
    4fe0:	2103      	movs	r1, #3
    4fe2:	e7e5      	b.n	4fb0 <_usb_d_dev_ep_enable+0x29c>
    4fe4:	2102      	movs	r1, #2
    4fe6:	e7e3      	b.n	4fb0 <_usb_d_dev_ep_enable+0x29c>
		return -USB_ERR_PARAM;
    4fe8:	2012      	movs	r0, #18
    4fea:	4240      	negs	r0, r0
    4fec:	e7f1      	b.n	4fd2 <_usb_d_dev_ep_enable+0x2be>
    4fee:	2012      	movs	r0, #18
    4ff0:	4240      	negs	r0, r0
    4ff2:	e7ee      	b.n	4fd2 <_usb_d_dev_ep_enable+0x2be>
			return -USB_ERR_REDO;
    4ff4:	2014      	movs	r0, #20
    4ff6:	4240      	negs	r0, r0
    4ff8:	e7eb      	b.n	4fd2 <_usb_d_dev_ep_enable+0x2be>
			return -USB_ERR_REDO;
    4ffa:	2014      	movs	r0, #20
    4ffc:	4240      	negs	r0, r0
    4ffe:	e7e8      	b.n	4fd2 <_usb_d_dev_ep_enable+0x2be>
			return -USB_ERR_REDO;
    5000:	2014      	movs	r0, #20
    5002:	4240      	negs	r0, r0
    5004:	e7e5      	b.n	4fd2 <_usb_d_dev_ep_enable+0x2be>
    5006:	46c0      	nop			; (mov r8, r8)
    5008:	41005000 	.word	0x41005000
    500c:	20000448 	.word	0x20000448
    5010:	200003c8 	.word	0x200003c8
    5014:	0fffc000 	.word	0x0fffc000
    5018:	f0003fff 	.word	0xf0003fff
    501c:	41005109 	.word	0x41005109

00005020 <_usb_d_dev_ep_stall>:
{
    5020:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    5022:	220f      	movs	r2, #15
    5024:	4002      	ands	r2, r0
    5026:	b240      	sxtb	r0, r0
	bool                  dir = USB_EP_GET_DIR(ep);
    5028:	0fc4      	lsrs	r4, r0, #31
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    502a:	2a00      	cmp	r2, #0
    502c:	d005      	beq.n	503a <_usb_d_dev_ep_stall+0x1a>
    502e:	2800      	cmp	r0, #0
    5030:	db01      	blt.n	5036 <_usb_d_dev_ep_stall+0x16>
    5032:	0013      	movs	r3, r2
    5034:	e002      	b.n	503c <_usb_d_dev_ep_stall+0x1c>
    5036:	1d53      	adds	r3, r2, #5
    5038:	e000      	b.n	503c <_usb_d_dev_ep_stall+0x1c>
    503a:	0013      	movs	r3, r2
	return &dev_inst.ep[ep_index];
    503c:	001d      	movs	r5, r3
    503e:	0098      	lsls	r0, r3, #2
    5040:	18c0      	adds	r0, r0, r3
    5042:	0083      	lsls	r3, r0, #2
    5044:	3310      	adds	r3, #16
    5046:	0018      	movs	r0, r3
    5048:	4b47      	ldr	r3, [pc, #284]	; (5168 <_usb_d_dev_ep_stall+0x148>)
    504a:	3340      	adds	r3, #64	; 0x40
    504c:	181b      	adds	r3, r3, r0
    504e:	3304      	adds	r3, #4
	if (epn > CONF_USB_D_MAX_EP_N) {
    5050:	2a05      	cmp	r2, #5
    5052:	d900      	bls.n	5056 <_usb_d_dev_ep_stall+0x36>
    5054:	e084      	b.n	5160 <_usb_d_dev_ep_stall+0x140>
	if (USB_EP_STALL_SET == ctrl) {
    5056:	2901      	cmp	r1, #1
    5058:	d018      	beq.n	508c <_usb_d_dev_ep_stall+0x6c>
	} else if (USB_EP_STALL_CLR == ctrl) {
    505a:	2900      	cmp	r1, #0
    505c:	d03d      	beq.n	50da <_usb_d_dev_ep_stall+0xba>
	uint8_t epn = USB_EP_GET_N(ept->ep);
    505e:	00aa      	lsls	r2, r5, #2
    5060:	1952      	adds	r2, r2, r5
    5062:	0091      	lsls	r1, r2, #2
    5064:	4b40      	ldr	r3, [pc, #256]	; (5168 <_usb_d_dev_ep_stall+0x148>)
    5066:	3340      	adds	r3, #64	; 0x40
    5068:	185b      	adds	r3, r3, r1
    506a:	3326      	adds	r3, #38	; 0x26
    506c:	781a      	ldrb	r2, [r3, #0]
    506e:	230f      	movs	r3, #15
    5070:	4013      	ands	r3, r2
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    5072:	3308      	adds	r3, #8
    5074:	015b      	lsls	r3, r3, #5
    5076:	4a3d      	ldr	r2, [pc, #244]	; (516c <_usb_d_dev_ep_stall+0x14c>)
    5078:	4694      	mov	ip, r2
    507a:	4463      	add	r3, ip
    507c:	7998      	ldrb	r0, [r3, #6]
	return (hri_usbendpoint_read_EPSTATUS_reg(hw, epn) & (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    507e:	2310      	movs	r3, #16
    5080:	40a3      	lsls	r3, r4
    5082:	4018      	ands	r0, r3
    5084:	1e43      	subs	r3, r0, #1
    5086:	4198      	sbcs	r0, r3
    5088:	b2c0      	uxtb	r0, r0
}
    508a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint8_t epn = USB_EP_GET_N(ept->ep);
    508c:	4836      	ldr	r0, [pc, #216]	; (5168 <_usb_d_dev_ep_stall+0x148>)
    508e:	0003      	movs	r3, r0
    5090:	3340      	adds	r3, #64	; 0x40
    5092:	00aa      	lsls	r2, r5, #2
    5094:	1956      	adds	r6, r2, r5
    5096:	00b1      	lsls	r1, r6, #2
    5098:	185b      	adds	r3, r3, r1
    509a:	3326      	adds	r3, #38	; 0x26
    509c:	781b      	ldrb	r3, [r3, #0]
    509e:	210f      	movs	r1, #15
    50a0:	400b      	ands	r3, r1
		hri_usbendpoint_set_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    50a2:	2610      	movs	r6, #16
    50a4:	40a6      	lsls	r6, r4
    50a6:	b2f6      	uxtb	r6, r6
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    50a8:	0019      	movs	r1, r3
    50aa:	3108      	adds	r1, #8
    50ac:	0149      	lsls	r1, r1, #5
    50ae:	4f2f      	ldr	r7, [pc, #188]	; (516c <_usb_d_dev_ep_stall+0x14c>)
    50b0:	46bc      	mov	ip, r7
    50b2:	4461      	add	r1, ip
    50b4:	714e      	strb	r6, [r1, #5]
	_usbd_ep_int_en(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    50b6:	2120      	movs	r1, #32
    50b8:	40a1      	lsls	r1, r4
	hri_usbendpoint_set_EPINTEN_reg(USB, epn, flags);
    50ba:	b2cc      	uxtb	r4, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    50bc:	0159      	lsls	r1, r3, #5
    50be:	4b2c      	ldr	r3, [pc, #176]	; (5170 <_usb_d_dev_ep_stall+0x150>)
    50c0:	469c      	mov	ip, r3
    50c2:	4461      	add	r1, ip
    50c4:	700c      	strb	r4, [r1, #0]
	ept->flags.bits.is_stalled = 1;
    50c6:	1952      	adds	r2, r2, r5
    50c8:	0093      	lsls	r3, r2, #2
    50ca:	18c3      	adds	r3, r0, r3
    50cc:	3360      	adds	r3, #96	; 0x60
    50ce:	79da      	ldrb	r2, [r3, #7]
    50d0:	2108      	movs	r1, #8
    50d2:	430a      	orrs	r2, r1
    50d4:	71da      	strb	r2, [r3, #7]
		rc = _usb_d_dev_ep_stall_set(ept, dir);
    50d6:	2000      	movs	r0, #0
    50d8:	e7d7      	b.n	508a <_usb_d_dev_ep_stall+0x6a>
	uint8_t epn        = USB_EP_GET_N(ept->ep);
    50da:	7c9a      	ldrb	r2, [r3, #18]
    50dc:	310f      	adds	r1, #15
    50de:	400a      	ands	r2, r1
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    50e0:	0011      	movs	r1, r2
    50e2:	3108      	adds	r1, #8
    50e4:	0149      	lsls	r1, r1, #5
    50e6:	4821      	ldr	r0, [pc, #132]	; (516c <_usb_d_dev_ep_stall+0x14c>)
    50e8:	4684      	mov	ip, r0
    50ea:	4461      	add	r1, ip
    50ec:	7988      	ldrb	r0, [r1, #6]
	return (hri_usbendpoint_read_EPSTATUS_reg(hw, epn) & (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    50ee:	2110      	movs	r1, #16
    50f0:	40a1      	lsls	r1, r4
	if (!is_stalled) {
    50f2:	4208      	tst	r0, r1
    50f4:	d024      	beq.n	5140 <_usb_d_dev_ep_stall+0x120>
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    50f6:	b2c9      	uxtb	r1, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    50f8:	0010      	movs	r0, r2
    50fa:	3008      	adds	r0, #8
    50fc:	0140      	lsls	r0, r0, #5
    50fe:	4460      	add	r0, ip
    5100:	7101      	strb	r1, [r0, #4]
	_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    5102:	2120      	movs	r1, #32
    5104:	40a1      	lsls	r1, r4
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    5106:	b2ce      	uxtb	r6, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    5108:	0155      	lsls	r5, r2, #5
    510a:	4f1a      	ldr	r7, [pc, #104]	; (5174 <_usb_d_dev_ep_stall+0x154>)
    510c:	46bc      	mov	ip, r7
    510e:	4465      	add	r5, ip
    5110:	702e      	strb	r6, [r5, #0]
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    5112:	79c0      	ldrb	r0, [r0, #7]
	if (_usbd_ep_is_stall_sent(epn, dir)) {
    5114:	4208      	tst	r0, r1
    5116:	d00a      	beq.n	512e <_usb_d_dev_ep_stall+0x10e>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    5118:	0011      	movs	r1, r2
    511a:	3108      	adds	r1, #8
    511c:	0149      	lsls	r1, r1, #5
    511e:	4813      	ldr	r0, [pc, #76]	; (516c <_usb_d_dev_ep_stall+0x14c>)
    5120:	4684      	mov	ip, r0
    5122:	4461      	add	r1, ip
    5124:	71ce      	strb	r6, [r1, #7]
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_DTGLOUT << bank_n));
    5126:	2001      	movs	r0, #1
    5128:	40a0      	lsls	r0, r4
    512a:	b2c0      	uxtb	r0, r0
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    512c:	7108      	strb	r0, [r1, #4]
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    512e:	7cd8      	ldrb	r0, [r3, #19]
    5130:	2107      	movs	r1, #7
    5132:	4001      	ands	r1, r0
    5134:	2901      	cmp	r1, #1
    5136:	d005      	beq.n	5144 <_usb_d_dev_ep_stall+0x124>
		ept->flags.bits.is_stalled = 0;
    5138:	7cda      	ldrb	r2, [r3, #19]
    513a:	2108      	movs	r1, #8
    513c:	438a      	bics	r2, r1
    513e:	74da      	strb	r2, [r3, #19]
		rc = _usb_d_dev_ep_stall_clr(ept, dir);
    5140:	2000      	movs	r0, #0
    5142:	e7a2      	b.n	508a <_usb_d_dev_ep_stall+0x6a>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    5144:	3208      	adds	r2, #8
    5146:	0152      	lsls	r2, r2, #5
    5148:	4908      	ldr	r1, [pc, #32]	; (516c <_usb_d_dev_ep_stall+0x14c>)
    514a:	468c      	mov	ip, r1
    514c:	4462      	add	r2, ip
    514e:	7991      	ldrb	r1, [r2, #6]
		if ((hri_usbendpoint_read_EPSTATUS_reg(USB, epn) & USB_DEVICE_EPSTATUS_STALLRQ_Msk) == 0) {
    5150:	2230      	movs	r2, #48	; 0x30
    5152:	4211      	tst	r1, r2
    5154:	d1f4      	bne.n	5140 <_usb_d_dev_ep_stall+0x120>
			ept->flags.bits.is_stalled = 0;
    5156:	0002      	movs	r2, r0
    5158:	2108      	movs	r1, #8
    515a:	438a      	bics	r2, r1
    515c:	74da      	strb	r2, [r3, #19]
    515e:	e7ef      	b.n	5140 <_usb_d_dev_ep_stall+0x120>
		return -USB_ERR_PARAM;
    5160:	2012      	movs	r0, #18
    5162:	4240      	negs	r0, r0
    5164:	e791      	b.n	508a <_usb_d_dev_ep_stall+0x6a>
    5166:	46c0      	nop			; (mov r8, r8)
    5168:	20000448 	.word	0x20000448
    516c:	41005000 	.word	0x41005000
    5170:	41005109 	.word	0x41005109
    5174:	41005108 	.word	0x41005108

00005178 <_usb_d_dev_ep_read_req>:

int32_t _usb_d_dev_ep_read_req(const uint8_t ep, uint8_t *req_buf)
{
    5178:	b570      	push	{r4, r5, r6, lr}
    517a:	000e      	movs	r6, r1
	uint8_t            epn   = USB_EP_GET_N(ep);
    517c:	240f      	movs	r4, #15
    517e:	4004      	ands	r4, r0
	UsbDeviceDescBank *bank  = prvt_inst.desc_table[epn].DeviceDescBank;
    5180:	0162      	lsls	r2, r4, #5
    5182:	4b18      	ldr	r3, [pc, #96]	; (51e4 <_usb_d_dev_ep_read_req+0x6c>)
    5184:	189b      	adds	r3, r3, r2
	uint32_t           addr  = bank[0].ADDR.reg;
    5186:	6819      	ldr	r1, [r3, #0]
	uint16_t           bytes = bank[0].PCKSIZE.bit.BYTE_COUNT;
    5188:	685d      	ldr	r5, [r3, #4]
    518a:	04ad      	lsls	r5, r5, #18
    518c:	0cad      	lsrs	r5, r5, #18

	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
    518e:	2c05      	cmp	r4, #5
    5190:	d81f      	bhi.n	51d2 <_usb_d_dev_ep_read_req+0x5a>
    5192:	2e00      	cmp	r6, #0
    5194:	d020      	beq.n	51d8 <_usb_d_dev_ep_read_req+0x60>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    5196:	0023      	movs	r3, r4
    5198:	3308      	adds	r3, #8
    519a:	015b      	lsls	r3, r3, #5
    519c:	4a12      	ldr	r2, [pc, #72]	; (51e8 <_usb_d_dev_ep_read_req+0x70>)
    519e:	5c9b      	ldrb	r3, [r3, r2]
		return -USB_ERR_PARAM;
	}
	if (!_usbd_ep_is_ctrl(epn)) {
    51a0:	2b11      	cmp	r3, #17
    51a2:	d11c      	bne.n	51de <_usb_d_dev_ep_read_req+0x66>
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    51a4:	0023      	movs	r3, r4
    51a6:	3308      	adds	r3, #8
    51a8:	015b      	lsls	r3, r3, #5
    51aa:	4694      	mov	ip, r2
    51ac:	4463      	add	r3, ip
    51ae:	79db      	ldrb	r3, [r3, #7]
		return -USB_ERR_FUNC;
	}
	if (!_usbd_ep_is_setup(epn)) {
    51b0:	06db      	lsls	r3, r3, #27
    51b2:	d401      	bmi.n	51b8 <_usb_d_dev_ep_read_req+0x40>
		return ERR_NONE;
    51b4:	2000      	movs	r0, #0
	}
	memcpy(req_buf, (void *)addr, 8);
	_usbd_ep_ack_setup(epn);

	return bytes;
}
    51b6:	bd70      	pop	{r4, r5, r6, pc}
	memcpy(req_buf, (void *)addr, 8);
    51b8:	2208      	movs	r2, #8
    51ba:	0030      	movs	r0, r6
    51bc:	4b0b      	ldr	r3, [pc, #44]	; (51ec <_usb_d_dev_ep_read_req+0x74>)
    51be:	4798      	blx	r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    51c0:	3408      	adds	r4, #8
    51c2:	0164      	lsls	r4, r4, #5
    51c4:	4b08      	ldr	r3, [pc, #32]	; (51e8 <_usb_d_dev_ep_read_req+0x70>)
    51c6:	469c      	mov	ip, r3
    51c8:	4464      	add	r4, ip
    51ca:	2310      	movs	r3, #16
    51cc:	71e3      	strb	r3, [r4, #7]
	return bytes;
    51ce:	0028      	movs	r0, r5
    51d0:	e7f1      	b.n	51b6 <_usb_d_dev_ep_read_req+0x3e>
		return -USB_ERR_PARAM;
    51d2:	2012      	movs	r0, #18
    51d4:	4240      	negs	r0, r0
    51d6:	e7ee      	b.n	51b6 <_usb_d_dev_ep_read_req+0x3e>
    51d8:	2012      	movs	r0, #18
    51da:	4240      	negs	r0, r0
    51dc:	e7eb      	b.n	51b6 <_usb_d_dev_ep_read_req+0x3e>
		return -USB_ERR_FUNC;
    51de:	2013      	movs	r0, #19
    51e0:	4240      	negs	r0, r0
    51e2:	e7e8      	b.n	51b6 <_usb_d_dev_ep_read_req+0x3e>
    51e4:	200003c8 	.word	0x200003c8
    51e8:	41005000 	.word	0x41005000
    51ec:	00009543 	.word	0x00009543

000051f0 <_usb_d_dev_ep_trans>:

int32_t _usb_d_dev_ep_trans(const struct usb_d_transfer *trans)
{
    51f0:	b5f0      	push	{r4, r5, r6, r7, lr}
    51f2:	46de      	mov	lr, fp
    51f4:	4657      	mov	r7, sl
    51f6:	464e      	mov	r6, r9
    51f8:	4645      	mov	r5, r8
    51fa:	b5e0      	push	{r5, r6, r7, lr}
    51fc:	b085      	sub	sp, #20
    51fe:	4680      	mov	r8, r0
	uint8_t               epn = USB_EP_GET_N(trans->ep);
    5200:	7a05      	ldrb	r5, [r0, #8]
    5202:	220f      	movs	r2, #15
    5204:	402a      	ands	r2, r5
    5206:	b26d      	sxtb	r5, r5
	bool                  dir = USB_EP_GET_DIR(trans->ep);
    5208:	0feb      	lsrs	r3, r5, #31
    520a:	4699      	mov	r9, r3
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    520c:	2a00      	cmp	r2, #0
    520e:	d005      	beq.n	521c <_usb_d_dev_ep_trans+0x2c>
    5210:	2d00      	cmp	r5, #0
    5212:	db01      	blt.n	5218 <_usb_d_dev_ep_trans+0x28>
    5214:	0010      	movs	r0, r2
    5216:	e002      	b.n	521e <_usb_d_dev_ep_trans+0x2e>
    5218:	1d50      	adds	r0, r2, #5
    521a:	e000      	b.n	521e <_usb_d_dev_ep_trans+0x2e>
    521c:	0010      	movs	r0, r2
	return &dev_inst.ep[ep_index];
    521e:	0006      	movs	r6, r0
    5220:	4b60      	ldr	r3, [pc, #384]	; (53a4 <_usb_d_dev_ep_trans+0x1b4>)
    5222:	3340      	adds	r3, #64	; 0x40
    5224:	0081      	lsls	r1, r0, #2
    5226:	180f      	adds	r7, r1, r0
    5228:	00bc      	lsls	r4, r7, #2
    522a:	3410      	adds	r4, #16
    522c:	191c      	adds	r4, r3, r4
    522e:	3404      	adds	r4, #4
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);

	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    5230:	00b8      	lsls	r0, r7, #2
    5232:	181b      	adds	r3, r3, r0
    5234:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    5236:	495c      	ldr	r1, [pc, #368]	; (53a8 <_usb_d_dev_ep_trans+0x1b8>)
    5238:	428b      	cmp	r3, r1
    523a:	d042      	beq.n	52c2 <_usb_d_dev_ep_trans+0xd2>
    523c:	1e5f      	subs	r7, r3, #1
    523e:	b2bf      	uxth	r7, r7
	bool     size_n_aligned = (trans->size & size_mask);
    5240:	4641      	mov	r1, r8
    5242:	6849      	ldr	r1, [r1, #4]
    5244:	400f      	ands	r7, r1

	bool use_cache = false;

	volatile hal_atomic_t flags;

	if (epn > CONF_USB_D_MAX_EP_N) {
    5246:	2a05      	cmp	r2, #5
    5248:	d900      	bls.n	524c <_usb_d_dev_ep_trans+0x5c>
    524a:	e0a1      	b.n	5390 <_usb_d_dev_ep_trans+0x1a0>
	 * 1. Buffer not in RAM (cache all).
	 * 2. IN/OUT with unaligned buffer (cache all).
	 * 3. OUT with unaligned packet size (cache last packet).
	 * 4. OUT size < 8 (sub-case for 3).
	 */
	if (!_usb_is_addr4dma(trans->buf, trans->size) || (!_usb_is_aligned(trans->buf))
    524c:	4642      	mov	r2, r8
    524e:	6812      	ldr	r2, [r2, #0]
    5250:	4856      	ldr	r0, [pc, #344]	; (53ac <_usb_d_dev_ep_trans+0x1bc>)
    5252:	4282      	cmp	r2, r0
    5254:	d90c      	bls.n	5270 <_usb_d_dev_ep_trans+0x80>
    5256:	1888      	adds	r0, r1, r2
    5258:	9001      	str	r0, [sp, #4]
    525a:	4855      	ldr	r0, [pc, #340]	; (53b0 <_usb_d_dev_ep_trans+0x1c0>)
    525c:	4684      	mov	ip, r0
    525e:	9801      	ldr	r0, [sp, #4]
    5260:	4560      	cmp	r0, ip
    5262:	d805      	bhi.n	5270 <_usb_d_dev_ep_trans+0x80>
    5264:	0792      	lsls	r2, r2, #30
    5266:	d103      	bne.n	5270 <_usb_d_dev_ep_trans+0x80>
	    || (!dir && (trans->size < ept->size))) {
    5268:	2d00      	cmp	r5, #0
    526a:	db2c      	blt.n	52c6 <_usb_d_dev_ep_trans+0xd6>
    526c:	4299      	cmp	r1, r3
    526e:	d22d      	bcs.n	52cc <_usb_d_dev_ep_trans+0xdc>
		if (!ept->cache) {
    5270:	00b3      	lsls	r3, r6, #2
    5272:	199b      	adds	r3, r3, r6
    5274:	009a      	lsls	r2, r3, #2
    5276:	4b4b      	ldr	r3, [pc, #300]	; (53a4 <_usb_d_dev_ep_trans+0x1b4>)
    5278:	189b      	adds	r3, r3, r2
    527a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    527c:	2b00      	cmp	r3, #0
    527e:	d100      	bne.n	5282 <_usb_d_dev_ep_trans+0x92>
    5280:	e089      	b.n	5396 <_usb_d_dev_ep_trans+0x1a6>
			return -USB_ERR_FUNC;
		}
		/* Use cache all the time. */
		use_cache = true;
    5282:	2301      	movs	r3, #1
    5284:	9301      	str	r3, [sp, #4]
	}
	if (!dir && size_n_aligned) {
    5286:	2d00      	cmp	r5, #0
    5288:	db0a      	blt.n	52a0 <_usb_d_dev_ep_trans+0xb0>
    528a:	2f00      	cmp	r7, #0
    528c:	d008      	beq.n	52a0 <_usb_d_dev_ep_trans+0xb0>
		if (!ept->cache) {
    528e:	00b3      	lsls	r3, r6, #2
    5290:	199b      	adds	r3, r3, r6
    5292:	009a      	lsls	r2, r3, #2
    5294:	4b43      	ldr	r3, [pc, #268]	; (53a4 <_usb_d_dev_ep_trans+0x1b4>)
    5296:	189b      	adds	r3, r3, r2
    5298:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    529a:	2b00      	cmp	r3, #0
    529c:	d100      	bne.n	52a0 <_usb_d_dev_ep_trans+0xb0>
    529e:	e07d      	b.n	539c <_usb_d_dev_ep_trans+0x1ac>
		}
		/* Set 'use_cache' on last packet. */
	}

	/* Check halt */
	if (ept->flags.bits.is_stalled) {
    52a0:	00b2      	lsls	r2, r6, #2
    52a2:	1992      	adds	r2, r2, r6
    52a4:	0091      	lsls	r1, r2, #2
    52a6:	4b3f      	ldr	r3, [pc, #252]	; (53a4 <_usb_d_dev_ep_trans+0x1b4>)
    52a8:	185b      	adds	r3, r3, r1
    52aa:	3360      	adds	r3, #96	; 0x60
    52ac:	79db      	ldrb	r3, [r3, #7]
    52ae:	071b      	lsls	r3, r3, #28
    52b0:	d50f      	bpl.n	52d2 <_usb_d_dev_ep_trans+0xe2>
		return USB_HALTED;
    52b2:	2002      	movs	r0, #2
	} else {
		_usb_d_dev_out_next(ept, false);
	}

	return ERR_NONE;
}
    52b4:	b005      	add	sp, #20
    52b6:	bc3c      	pop	{r2, r3, r4, r5}
    52b8:	4690      	mov	r8, r2
    52ba:	4699      	mov	r9, r3
    52bc:	46a2      	mov	sl, r4
    52be:	46ab      	mov	fp, r5
    52c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    52c2:	001f      	movs	r7, r3
    52c4:	e7bc      	b.n	5240 <_usb_d_dev_ep_trans+0x50>
	bool use_cache = false;
    52c6:	2300      	movs	r3, #0
    52c8:	9301      	str	r3, [sp, #4]
    52ca:	e7dc      	b.n	5286 <_usb_d_dev_ep_trans+0x96>
    52cc:	2300      	movs	r3, #0
    52ce:	9301      	str	r3, [sp, #4]
    52d0:	e7d9      	b.n	5286 <_usb_d_dev_ep_trans+0x96>
	atomic_enter_critical(&flags);
    52d2:	a803      	add	r0, sp, #12
    52d4:	4b37      	ldr	r3, [pc, #220]	; (53b4 <_usb_d_dev_ep_trans+0x1c4>)
    52d6:	4798      	blx	r3
	if (_usb_d_dev_ep_is_busy(ept)) {
    52d8:	00b2      	lsls	r2, r6, #2
    52da:	1992      	adds	r2, r2, r6
    52dc:	0091      	lsls	r1, r2, #2
    52de:	4b31      	ldr	r3, [pc, #196]	; (53a4 <_usb_d_dev_ep_trans+0x1b4>)
    52e0:	185b      	adds	r3, r3, r1
    52e2:	3360      	adds	r3, #96	; 0x60
    52e4:	79db      	ldrb	r3, [r3, #7]
    52e6:	065b      	lsls	r3, r3, #25
    52e8:	d430      	bmi.n	534c <_usb_d_dev_ep_trans+0x15c>
	ept->flags.bits.is_busy = 1;
    52ea:	00b3      	lsls	r3, r6, #2
    52ec:	199b      	adds	r3, r3, r6
    52ee:	009a      	lsls	r2, r3, #2
    52f0:	4b2c      	ldr	r3, [pc, #176]	; (53a4 <_usb_d_dev_ep_trans+0x1b4>)
    52f2:	469b      	mov	fp, r3
    52f4:	4493      	add	fp, r2
    52f6:	2360      	movs	r3, #96	; 0x60
    52f8:	445b      	add	r3, fp
    52fa:	469a      	mov	sl, r3
    52fc:	79db      	ldrb	r3, [r3, #7]
    52fe:	2240      	movs	r2, #64	; 0x40
    5300:	4313      	orrs	r3, r2
    5302:	4652      	mov	r2, sl
    5304:	71d3      	strb	r3, [r2, #7]
	atomic_leave_critical(&flags);
    5306:	a803      	add	r0, sp, #12
    5308:	4b2b      	ldr	r3, [pc, #172]	; (53b8 <_usb_d_dev_ep_trans+0x1c8>)
    530a:	4798      	blx	r3
	ept->trans_buf   = trans->buf;
    530c:	465b      	mov	r3, fp
    530e:	4642      	mov	r2, r8
    5310:	6812      	ldr	r2, [r2, #0]
    5312:	655a      	str	r2, [r3, #84]	; 0x54
	ept->trans_size  = trans->size;
    5314:	4642      	mov	r2, r8
    5316:	6852      	ldr	r2, [r2, #4]
    5318:	659a      	str	r2, [r3, #88]	; 0x58
	ept->trans_count = 0;
    531a:	2300      	movs	r3, #0
    531c:	465a      	mov	r2, fp
    531e:	65d3      	str	r3, [r2, #92]	; 0x5c
	ept->flags.bits.dir       = dir;
    5320:	464b      	mov	r3, r9
    5322:	01db      	lsls	r3, r3, #7
    5324:	4652      	mov	r2, sl
    5326:	79d2      	ldrb	r2, [r2, #7]
    5328:	217f      	movs	r1, #127	; 0x7f
    532a:	4011      	ands	r1, r2
	ept->flags.bits.use_cache = use_cache;
    532c:	9a01      	ldr	r2, [sp, #4]
    532e:	0152      	lsls	r2, r2, #5
    5330:	430b      	orrs	r3, r1
    5332:	2120      	movs	r1, #32
    5334:	438b      	bics	r3, r1
    5336:	431a      	orrs	r2, r3
    5338:	4653      	mov	r3, sl
    533a:	71da      	strb	r2, [r3, #7]
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    533c:	4643      	mov	r3, r8
    533e:	7a5b      	ldrb	r3, [r3, #9]
    5340:	2b00      	cmp	r3, #0
    5342:	d008      	beq.n	5356 <_usb_d_dev_ep_trans+0x166>
    5344:	2f00      	cmp	r7, #0
    5346:	d01b      	beq.n	5380 <_usb_d_dev_ep_trans+0x190>
    5348:	2200      	movs	r2, #0
    534a:	e005      	b.n	5358 <_usb_d_dev_ep_trans+0x168>
		atomic_leave_critical(&flags);
    534c:	a803      	add	r0, sp, #12
    534e:	4b1a      	ldr	r3, [pc, #104]	; (53b8 <_usb_d_dev_ep_trans+0x1c8>)
    5350:	4798      	blx	r3
		return USB_BUSY;
    5352:	2001      	movs	r0, #1
    5354:	e7ae      	b.n	52b4 <_usb_d_dev_ep_trans+0xc4>
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    5356:	2200      	movs	r2, #0
    5358:	00b3      	lsls	r3, r6, #2
    535a:	199e      	adds	r6, r3, r6
    535c:	00b1      	lsls	r1, r6, #2
    535e:	4b11      	ldr	r3, [pc, #68]	; (53a4 <_usb_d_dev_ep_trans+0x1b4>)
    5360:	185b      	adds	r3, r3, r1
    5362:	3360      	adds	r3, #96	; 0x60
    5364:	0111      	lsls	r1, r2, #4
    5366:	79da      	ldrb	r2, [r3, #7]
    5368:	2010      	movs	r0, #16
    536a:	4382      	bics	r2, r0
    536c:	430a      	orrs	r2, r1
    536e:	71da      	strb	r2, [r3, #7]
	if (dir) {
    5370:	2d00      	cmp	r5, #0
    5372:	db07      	blt.n	5384 <_usb_d_dev_ep_trans+0x194>
		_usb_d_dev_out_next(ept, false);
    5374:	2100      	movs	r1, #0
    5376:	0020      	movs	r0, r4
    5378:	4b10      	ldr	r3, [pc, #64]	; (53bc <_usb_d_dev_ep_trans+0x1cc>)
    537a:	4798      	blx	r3
	return ERR_NONE;
    537c:	2000      	movs	r0, #0
    537e:	e799      	b.n	52b4 <_usb_d_dev_ep_trans+0xc4>
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    5380:	2201      	movs	r2, #1
    5382:	e7e9      	b.n	5358 <_usb_d_dev_ep_trans+0x168>
		_usb_d_dev_in_next(ept, false);
    5384:	2100      	movs	r1, #0
    5386:	0020      	movs	r0, r4
    5388:	4b0d      	ldr	r3, [pc, #52]	; (53c0 <_usb_d_dev_ep_trans+0x1d0>)
    538a:	4798      	blx	r3
	return ERR_NONE;
    538c:	2000      	movs	r0, #0
    538e:	e791      	b.n	52b4 <_usb_d_dev_ep_trans+0xc4>
		return -USB_ERR_PARAM;
    5390:	2012      	movs	r0, #18
    5392:	4240      	negs	r0, r0
    5394:	e78e      	b.n	52b4 <_usb_d_dev_ep_trans+0xc4>
			return -USB_ERR_FUNC;
    5396:	2013      	movs	r0, #19
    5398:	4240      	negs	r0, r0
    539a:	e78b      	b.n	52b4 <_usb_d_dev_ep_trans+0xc4>
			return -USB_ERR_PARAM;
    539c:	2012      	movs	r0, #18
    539e:	4240      	negs	r0, r0
    53a0:	e788      	b.n	52b4 <_usb_d_dev_ep_trans+0xc4>
    53a2:	46c0      	nop			; (mov r8, r8)
    53a4:	20000448 	.word	0x20000448
    53a8:	000003ff 	.word	0x000003ff
    53ac:	1fffffff 	.word	0x1fffffff
    53b0:	20007fff 	.word	0x20007fff
    53b4:	00001271 	.word	0x00001271
    53b8:	0000127f 	.word	0x0000127f
    53bc:	00004591 	.word	0x00004591
    53c0:	00004401 	.word	0x00004401

000053c4 <_usb_d_dev_register_callback>:
	return USB_OK;
}

void _usb_d_dev_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    53c4:	2900      	cmp	r1, #0
    53c6:	d006      	beq.n	53d6 <_usb_d_dev_register_callback+0x12>
	if (type == USB_D_CB_EVENT) {
    53c8:	2801      	cmp	r0, #1
    53ca:	d006      	beq.n	53da <_usb_d_dev_register_callback+0x16>
		dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)f;
	} else if (type == USB_D_CB_SOF) {
    53cc:	2800      	cmp	r0, #0
    53ce:	d101      	bne.n	53d4 <_usb_d_dev_register_callback+0x10>
		dev_inst.callbacks.sof = (_usb_d_dev_sof_cb_t)f;
    53d0:	4b03      	ldr	r3, [pc, #12]	; (53e0 <_usb_d_dev_register_callback+0x1c>)
    53d2:	6419      	str	r1, [r3, #64]	; 0x40
	}
}
    53d4:	4770      	bx	lr
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    53d6:	4903      	ldr	r1, [pc, #12]	; (53e4 <_usb_d_dev_register_callback+0x20>)
    53d8:	e7f6      	b.n	53c8 <_usb_d_dev_register_callback+0x4>
		dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)f;
    53da:	4b01      	ldr	r3, [pc, #4]	; (53e0 <_usb_d_dev_register_callback+0x1c>)
    53dc:	6459      	str	r1, [r3, #68]	; 0x44
    53de:	e7f9      	b.n	53d4 <_usb_d_dev_register_callback+0x10>
    53e0:	20000448 	.word	0x20000448
    53e4:	000040dd 	.word	0x000040dd

000053e8 <_usb_d_dev_register_ep_callback>:

void _usb_d_dev_register_ep_callback(const enum usb_d_dev_ep_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    53e8:	2900      	cmp	r1, #0
    53ea:	d008      	beq.n	53fe <_usb_d_dev_register_ep_callback+0x16>
	if (type == USB_D_DEV_EP_CB_SETUP) {
    53ec:	2800      	cmp	r0, #0
    53ee:	d008      	beq.n	5402 <_usb_d_dev_register_ep_callback+0x1a>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
	} else if (type == USB_D_DEV_EP_CB_MORE) {
    53f0:	2801      	cmp	r0, #1
    53f2:	d009      	beq.n	5408 <_usb_d_dev_register_ep_callback+0x20>
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
	} else if (type == USB_D_DEV_EP_CB_DONE) {
    53f4:	2802      	cmp	r0, #2
    53f6:	d106      	bne.n	5406 <_usb_d_dev_register_ep_callback+0x1e>
		dev_inst.ep_callbacks.done = (_usb_d_dev_ep_cb_done_t)f;
    53f8:	4b05      	ldr	r3, [pc, #20]	; (5410 <_usb_d_dev_register_ep_callback+0x28>)
    53fa:	6519      	str	r1, [r3, #80]	; 0x50
	}
}
    53fc:	e003      	b.n	5406 <_usb_d_dev_register_ep_callback+0x1e>
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    53fe:	4905      	ldr	r1, [pc, #20]	; (5414 <_usb_d_dev_register_ep_callback+0x2c>)
    5400:	e7f4      	b.n	53ec <_usb_d_dev_register_ep_callback+0x4>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
    5402:	4b03      	ldr	r3, [pc, #12]	; (5410 <_usb_d_dev_register_ep_callback+0x28>)
    5404:	6499      	str	r1, [r3, #72]	; 0x48
}
    5406:	4770      	bx	lr
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
    5408:	4b01      	ldr	r3, [pc, #4]	; (5410 <_usb_d_dev_register_ep_callback+0x28>)
    540a:	64d9      	str	r1, [r3, #76]	; 0x4c
    540c:	e7fb      	b.n	5406 <_usb_d_dev_register_ep_callback+0x1e>
    540e:	46c0      	nop			; (mov r8, r8)
    5410:	20000448 	.word	0x20000448
    5414:	000040dd 	.word	0x000040dd

00005418 <USB_Handler>:

/**
 * \brief USB interrupt handler
 */
void USB_Handler(void)
{
    5418:	b510      	push	{r4, lr}

	_usb_d_dev_handler();
    541a:	4b01      	ldr	r3, [pc, #4]	; (5420 <USB_Handler+0x8>)
    541c:	4798      	blx	r3
}
    541e:	bd10      	pop	{r4, pc}
    5420:	00004795 	.word	0x00004795

00005424 <set_prev_curr_form>:
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, convert_cb_ADC_0);
	adc_async_enable_channel(&ADC_0, 0);
}

static void set_prev_curr_form(const uint8_t form){
	session_data.previous_form = session_data.current_form;
    5424:	4b02      	ldr	r3, [pc, #8]	; (5430 <set_prev_curr_form+0xc>)
    5426:	7b1a      	ldrb	r2, [r3, #12]
    5428:	735a      	strb	r2, [r3, #13]
	session_data.current_form = form;
    542a:	7318      	strb	r0, [r3, #12]
}
    542c:	4770      	bx	lr
    542e:	46c0      	nop			; (mov r8, r8)
    5430:	20000a3c 	.word	0x20000a3c

00005434 <sync_trigger>:
	pb_received = true;
	}
}

static void sync_trigger(void)	// called by ext irq
{	
    5434:	b510      	push	{r4, lr}
	if ((session_data.session_running) && (!trigger_debounce)){
    5436:	4b24      	ldr	r3, [pc, #144]	; (54c8 <sync_trigger+0x94>)
    5438:	789b      	ldrb	r3, [r3, #2]
    543a:	2b00      	cmp	r3, #0
    543c:	d040      	beq.n	54c0 <sync_trigger+0x8c>
    543e:	4b23      	ldr	r3, [pc, #140]	; (54cc <sync_trigger+0x98>)
    5440:	881b      	ldrh	r3, [r3, #0]
    5442:	2b00      	cmp	r3, #0
    5444:	d13c      	bne.n	54c0 <sync_trigger+0x8c>
		trigger_debounce = TRIGGER_DEBOUNCE_TIME;
    5446:	2232      	movs	r2, #50	; 0x32
    5448:	4b20      	ldr	r3, [pc, #128]	; (54cc <sync_trigger+0x98>)
    544a:	801a      	strh	r2, [r3, #0]
		session_data.current_slice += 1;
    544c:	4a1e      	ldr	r2, [pc, #120]	; (54c8 <sync_trigger+0x94>)
    544e:	8b53      	ldrh	r3, [r2, #26]
    5450:	3301      	adds	r3, #1
    5452:	b29b      	uxth	r3, r3
    5454:	8353      	strh	r3, [r2, #26]
		
		if (((session_data.current_slice >= session_data.no_of_slices) && (session_data.current_volume == session_data.no_of_volumes)) ||
    5456:	8a52      	ldrh	r2, [r2, #18]
    5458:	4293      	cmp	r3, r2
    545a:	d304      	bcc.n	5466 <sync_trigger+0x32>
    545c:	491a      	ldr	r1, [pc, #104]	; (54c8 <sync_trigger+0x94>)
    545e:	8b08      	ldrh	r0, [r1, #24]
    5460:	8a09      	ldrh	r1, [r1, #16]
    5462:	4288      	cmp	r0, r1
    5464:	d004      	beq.n	5470 <sync_trigger+0x3c>
			(session_data.current_volume > session_data.no_of_volumes)){
    5466:	4918      	ldr	r1, [pc, #96]	; (54c8 <sync_trigger+0x94>)
    5468:	8b08      	ldrh	r0, [r1, #24]
    546a:	8a09      	ldrh	r1, [r1, #16]
		if (((session_data.current_slice >= session_data.no_of_slices) && (session_data.current_volume == session_data.no_of_volumes)) ||
    546c:	4288      	cmp	r0, r1
    546e:	d902      	bls.n	5476 <sync_trigger+0x42>
			session_data.session_finished = true;
    5470:	2001      	movs	r0, #1
    5472:	4915      	ldr	r1, [pc, #84]	; (54c8 <sync_trigger+0x94>)
    5474:	7048      	strb	r0, [r1, #1]
		}
		
		if ((session_data.current_slice > session_data.no_of_slices) && (!session_data.session_finished)){
    5476:	4293      	cmp	r3, r2
    5478:	d909      	bls.n	548e <sync_trigger+0x5a>
    547a:	4b13      	ldr	r3, [pc, #76]	; (54c8 <sync_trigger+0x94>)
    547c:	785b      	ldrb	r3, [r3, #1]
    547e:	2b00      	cmp	r3, #0
    5480:	d105      	bne.n	548e <sync_trigger+0x5a>
			session_data.current_volume += 1;	
    5482:	4b11      	ldr	r3, [pc, #68]	; (54c8 <sync_trigger+0x94>)
    5484:	8b1a      	ldrh	r2, [r3, #24]
    5486:	3201      	adds	r2, #1
    5488:	831a      	strh	r2, [r3, #24]
			session_data.current_slice = 1;					
    548a:	2201      	movs	r2, #1
    548c:	835a      	strh	r2, [r3, #26]
			}
		
		uint16_t divider = session_data.trig_on_volume;
    548e:	4b0e      	ldr	r3, [pc, #56]	; (54c8 <sync_trigger+0x94>)
    5490:	8a9b      	ldrh	r3, [r3, #20]
		if (divider == 0) {
    5492:	2b00      	cmp	r3, #0
    5494:	d015      	beq.n	54c2 <sync_trigger+0x8e>
		uint16_t divider = session_data.trig_on_volume;
    5496:	0019      	movs	r1, r3
			divider = 1;
		}
		if ((session_data.trig_on_volume == 0) || (((session_data.current_volume - 1) % divider) == 0)){
    5498:	2b00      	cmp	r3, #0
    549a:	d006      	beq.n	54aa <sync_trigger+0x76>
    549c:	4b0a      	ldr	r3, [pc, #40]	; (54c8 <sync_trigger+0x94>)
    549e:	8b18      	ldrh	r0, [r3, #24]
    54a0:	3801      	subs	r0, #1
    54a2:	4b0b      	ldr	r3, [pc, #44]	; (54d0 <sync_trigger+0x9c>)
    54a4:	4798      	blx	r3
    54a6:	2900      	cmp	r1, #0
    54a8:	d10a      	bne.n	54c0 <sync_trigger+0x8c>
			if ((session_data.trig_on_slice == 0) || (session_data.trig_on_slice == session_data.current_slice)){
    54aa:	4b07      	ldr	r3, [pc, #28]	; (54c8 <sync_trigger+0x94>)
    54ac:	8adb      	ldrh	r3, [r3, #22]
    54ae:	2b00      	cmp	r3, #0
    54b0:	d003      	beq.n	54ba <sync_trigger+0x86>
    54b2:	4a05      	ldr	r2, [pc, #20]	; (54c8 <sync_trigger+0x94>)
    54b4:	8b52      	ldrh	r2, [r2, #26]
    54b6:	4293      	cmp	r3, r2
    54b8:	d102      	bne.n	54c0 <sync_trigger+0x8c>
				session_data.trigger = true;
    54ba:	2201      	movs	r2, #1
    54bc:	4b02      	ldr	r3, [pc, #8]	; (54c8 <sync_trigger+0x94>)
    54be:	715a      	strb	r2, [r3, #5]
			}
		}
	}	
}
    54c0:	bd10      	pop	{r4, pc}
			divider = 1;
    54c2:	2101      	movs	r1, #1
    54c4:	e7e8      	b.n	5498 <sync_trigger+0x64>
    54c6:	46c0      	nop			; (mov r8, r8)
    54c8:	20000a3c 	.word	0x20000a3c
    54cc:	20000000 	.word	0x20000000
    54d0:	0000947d 	.word	0x0000947d

000054d4 <button>:
{
    54d4:	b510      	push	{r4, lr}
	if (!pb_debounce){
    54d6:	4b07      	ldr	r3, [pc, #28]	; (54f4 <button+0x20>)
    54d8:	885b      	ldrh	r3, [r3, #2]
    54da:	2b00      	cmp	r3, #0
    54dc:	d000      	beq.n	54e0 <button+0xc>
}
    54de:	bd10      	pop	{r4, pc}
	printf("button pressed\r\n");
    54e0:	4805      	ldr	r0, [pc, #20]	; (54f8 <button+0x24>)
    54e2:	4b06      	ldr	r3, [pc, #24]	; (54fc <button+0x28>)
    54e4:	4798      	blx	r3
	pb_debounce = PB_DEBOUNCE_TIME;
    54e6:	22c8      	movs	r2, #200	; 0xc8
    54e8:	4b02      	ldr	r3, [pc, #8]	; (54f4 <button+0x20>)
    54ea:	805a      	strh	r2, [r3, #2]
	pb_received = true;
    54ec:	3ac7      	subs	r2, #199	; 0xc7
    54ee:	4b04      	ldr	r3, [pc, #16]	; (5500 <button+0x2c>)
    54f0:	701a      	strb	r2, [r3, #0]
}
    54f2:	e7f4      	b.n	54de <button+0xa>
    54f4:	20000000 	.word	0x20000000
    54f8:	0000dba4 	.word	0x0000dba4
    54fc:	00009659 	.word	0x00009659
    5500:	20000740 	.word	0x20000740

00005504 <convert_cb_ADC_0>:
{
    5504:	b570      	push	{r4, r5, r6, lr}
	adc_async_read_channel(&ADC_0, channel, &adc_value, 2);
    5506:	4c04      	ldr	r4, [pc, #16]	; (5518 <convert_cb_ADC_0+0x14>)
    5508:	1ca2      	adds	r2, r4, #2
    550a:	2302      	movs	r3, #2
    550c:	4803      	ldr	r0, [pc, #12]	; (551c <convert_cb_ADC_0+0x18>)
    550e:	4d04      	ldr	r5, [pc, #16]	; (5520 <convert_cb_ADC_0+0x1c>)
    5510:	47a8      	blx	r5
	adc_read=true;
    5512:	2301      	movs	r3, #1
    5514:	7123      	strb	r3, [r4, #4]
}
    5516:	bd70      	pop	{r4, r5, r6, pc}
    5518:	20000740 	.word	0x20000740
    551c:	2000091c 	.word	0x2000091c
    5520:	00001171 	.word	0x00001171

00005524 <TIMER_task2_cb>:
		//gpio_toggle_pin_level(T1);
	}
}

static void TIMER_task2_cb(const struct timer_task *const timer_task)  // 1.6Hz
{
    5524:	b510      	push	{r4, lr}
	//gpio_toggle_pin_level(T2);
	if (adc_read){
    5526:	4b06      	ldr	r3, [pc, #24]	; (5540 <TIMER_task2_cb+0x1c>)
    5528:	791b      	ldrb	r3, [r3, #4]
    552a:	2b00      	cmp	r3, #0
    552c:	d100      	bne.n	5530 <TIMER_task2_cb+0xc>
		adc_read=false;
		//printf("ADC value: %d\r\n", adc_value);
		adc_async_start_conversion(&ADC_0);
	}
}
    552e:	bd10      	pop	{r4, pc}
		adc_read=false;
    5530:	2200      	movs	r2, #0
    5532:	4b03      	ldr	r3, [pc, #12]	; (5540 <TIMER_task2_cb+0x1c>)
    5534:	711a      	strb	r2, [r3, #4]
		adc_async_start_conversion(&ADC_0);
    5536:	4803      	ldr	r0, [pc, #12]	; (5544 <TIMER_task2_cb+0x20>)
    5538:	4b03      	ldr	r3, [pc, #12]	; (5548 <TIMER_task2_cb+0x24>)
    553a:	4798      	blx	r3
}
    553c:	e7f7      	b.n	552e <TIMER_task2_cb+0xa>
    553e:	46c0      	nop			; (mov r8, r8)
    5540:	20000740 	.word	0x20000740
    5544:	2000091c 	.word	0x2000091c
    5548:	00001249 	.word	0x00001249

0000554c <TIMER_task1_cb>:
   {	
    554c:	b570      	push	{r4, r5, r6, lr}
	if (error_beep_length){
    554e:	4b87      	ldr	r3, [pc, #540]	; (576c <TIMER_task1_cb+0x220>)
    5550:	88db      	ldrh	r3, [r3, #6]
    5552:	2b00      	cmp	r3, #0
    5554:	d112      	bne.n	557c <TIMER_task1_cb+0x30>
	else if (click_length){
    5556:	4b85      	ldr	r3, [pc, #532]	; (576c <TIMER_task1_cb+0x220>)
    5558:	891b      	ldrh	r3, [r3, #8]
    555a:	2b00      	cmp	r3, #0
    555c:	d000      	beq.n	5560 <TIMER_task1_cb+0x14>
    555e:	e0a8      	b.n	56b2 <TIMER_task1_cb+0x166>
	else if (beep_sound_length){
    5560:	4b83      	ldr	r3, [pc, #524]	; (5770 <TIMER_task1_cb+0x224>)
    5562:	881b      	ldrh	r3, [r3, #0]
    5564:	2b00      	cmp	r3, #0
    5566:	d100      	bne.n	556a <TIMER_task1_cb+0x1e>
    5568:	e0cb      	b.n	5702 <TIMER_task1_cb+0x1b6>
		if (session_data.response_sound){
    556a:	4a82      	ldr	r2, [pc, #520]	; (5774 <TIMER_task1_cb+0x228>)
    556c:	7ad2      	ldrb	r2, [r2, #11]
    556e:	2a00      	cmp	r2, #0
    5570:	d000      	beq.n	5574 <TIMER_task1_cb+0x28>
    5572:	e0b2      	b.n	56da <TIMER_task1_cb+0x18e>
			beep_sound_length = 0;
    5574:	2200      	movs	r2, #0
    5576:	4b7e      	ldr	r3, [pc, #504]	; (5770 <TIMER_task1_cb+0x224>)
    5578:	801a      	strh	r2, [r3, #0]
    557a:	e010      	b.n	559e <TIMER_task1_cb+0x52>
		dc_out = error_beep_sound_data[ERROR_BEEP_LENGTH - error_beep_length];
    557c:	4a7e      	ldr	r2, [pc, #504]	; (5778 <TIMER_task1_cb+0x22c>)
    557e:	1ad3      	subs	r3, r2, r3
    5580:	005b      	lsls	r3, r3, #1
    5582:	4a7e      	ldr	r2, [pc, #504]	; (577c <TIMER_task1_cb+0x230>)
    5584:	5a9b      	ldrh	r3, [r3, r2]
    5586:	4a7e      	ldr	r2, [pc, #504]	; (5780 <TIMER_task1_cb+0x234>)
    5588:	8093      	strh	r3, [r2, #4]
 		dac_async_write(&DAC_0, 0, &dc_out, 1);
    558a:	3204      	adds	r2, #4
    558c:	2301      	movs	r3, #1
    558e:	2100      	movs	r1, #0
    5590:	487c      	ldr	r0, [pc, #496]	; (5784 <TIMER_task1_cb+0x238>)
    5592:	4c7d      	ldr	r4, [pc, #500]	; (5788 <TIMER_task1_cb+0x23c>)
    5594:	47a0      	blx	r4
 		error_beep_length --;
    5596:	4a75      	ldr	r2, [pc, #468]	; (576c <TIMER_task1_cb+0x220>)
    5598:	88d3      	ldrh	r3, [r2, #6]
    559a:	3b01      	subs	r3, #1
    559c:	80d3      	strh	r3, [r2, #6]
	if (prescaler){
    559e:	4b78      	ldr	r3, [pc, #480]	; (5780 <TIMER_task1_cb+0x234>)
    55a0:	799b      	ldrb	r3, [r3, #6]
    55a2:	2b00      	cmp	r3, #0
    55a4:	d000      	beq.n	55a8 <TIMER_task1_cb+0x5c>
    55a6:	e0cd      	b.n	5744 <TIMER_task1_cb+0x1f8>
		prescaler = PRESCALER_VALUE;
    55a8:	2207      	movs	r2, #7
    55aa:	4b75      	ldr	r3, [pc, #468]	; (5780 <TIMER_task1_cb+0x234>)
    55ac:	719a      	strb	r2, [r3, #6]
		if (usb_disconnected_prescaler){
    55ae:	4b6f      	ldr	r3, [pc, #444]	; (576c <TIMER_task1_cb+0x220>)
    55b0:	7a9b      	ldrb	r3, [r3, #10]
    55b2:	2b00      	cmp	r3, #0
    55b4:	d100      	bne.n	55b8 <TIMER_task1_cb+0x6c>
    55b6:	e0c9      	b.n	574c <TIMER_task1_cb+0x200>
			usb_disconnected_prescaler --;
    55b8:	3b01      	subs	r3, #1
    55ba:	4a6c      	ldr	r2, [pc, #432]	; (576c <TIMER_task1_cb+0x220>)
    55bc:	7293      	strb	r3, [r2, #10]
		if (timeout_counter){
    55be:	4b6b      	ldr	r3, [pc, #428]	; (576c <TIMER_task1_cb+0x220>)
    55c0:	68db      	ldr	r3, [r3, #12]
    55c2:	2b00      	cmp	r3, #0
    55c4:	d002      	beq.n	55cc <TIMER_task1_cb+0x80>
			timeout_counter --;
    55c6:	3b01      	subs	r3, #1
    55c8:	4a68      	ldr	r2, [pc, #416]	; (576c <TIMER_task1_cb+0x220>)
    55ca:	60d3      	str	r3, [r2, #12]
		if (trigger_debounce){
    55cc:	4b6c      	ldr	r3, [pc, #432]	; (5780 <TIMER_task1_cb+0x234>)
    55ce:	881b      	ldrh	r3, [r3, #0]
    55d0:	2b00      	cmp	r3, #0
    55d2:	d002      	beq.n	55da <TIMER_task1_cb+0x8e>
			trigger_debounce --;
    55d4:	3b01      	subs	r3, #1
    55d6:	4a6a      	ldr	r2, [pc, #424]	; (5780 <TIMER_task1_cb+0x234>)
    55d8:	8013      	strh	r3, [r2, #0]
		if (trig_LED_delay){
    55da:	4b69      	ldr	r3, [pc, #420]	; (5780 <TIMER_task1_cb+0x234>)
    55dc:	891b      	ldrh	r3, [r3, #8]
    55de:	2b00      	cmp	r3, #0
    55e0:	d002      	beq.n	55e8 <TIMER_task1_cb+0x9c>
			trig_LED_delay --;
    55e2:	3b01      	subs	r3, #1
    55e4:	4a66      	ldr	r2, [pc, #408]	; (5780 <TIMER_task1_cb+0x234>)
    55e6:	8113      	strh	r3, [r2, #8]
		if (pb_debounce){
    55e8:	4b65      	ldr	r3, [pc, #404]	; (5780 <TIMER_task1_cb+0x234>)
    55ea:	885b      	ldrh	r3, [r3, #2]
    55ec:	2b00      	cmp	r3, #0
    55ee:	d002      	beq.n	55f6 <TIMER_task1_cb+0xaa>
			pb_debounce --;
    55f0:	3b01      	subs	r3, #1
    55f2:	4a63      	ldr	r2, [pc, #396]	; (5780 <TIMER_task1_cb+0x234>)
    55f4:	8053      	strh	r3, [r2, #2]
		if (session_data.simulation_mode){		
    55f6:	4b5f      	ldr	r3, [pc, #380]	; (5774 <TIMER_task1_cb+0x228>)
    55f8:	78db      	ldrb	r3, [r3, #3]
    55fa:	2b00      	cmp	r3, #0
    55fc:	d100      	bne.n	5600 <TIMER_task1_cb+0xb4>
    55fe:	e0a4      	b.n	574a <TIMER_task1_cb+0x1fe>
			pulse_counter += 1;
    5600:	4a5a      	ldr	r2, [pc, #360]	; (576c <TIMER_task1_cb+0x220>)
    5602:	8a13      	ldrh	r3, [r2, #16]
    5604:	3301      	adds	r3, #1
    5606:	b29b      	uxth	r3, r3
    5608:	8213      	strh	r3, [r2, #16]
			TR_counter += 1;
    560a:	8a54      	ldrh	r4, [r2, #18]
    560c:	3401      	adds	r4, #1
    560e:	b2a4      	uxth	r4, r4
    5610:	8254      	strh	r4, [r2, #18]
			if (pulse_counter >= session_data.pulse_length){ // slice acquisition starts
    5612:	4a58      	ldr	r2, [pc, #352]	; (5774 <TIMER_task1_cb+0x228>)
    5614:	8c12      	ldrh	r2, [r2, #32]
    5616:	4293      	cmp	r3, r2
    5618:	d334      	bcc.n	5684 <TIMER_task1_cb+0x138>
				pulse_counter = 0;
    561a:	2200      	movs	r2, #0
    561c:	4b53      	ldr	r3, [pc, #332]	; (576c <TIMER_task1_cb+0x220>)
    561e:	821a      	strh	r2, [r3, #16]
				if (session_data.current_slice < session_data.no_of_slices){
    5620:	4a54      	ldr	r2, [pc, #336]	; (5774 <TIMER_task1_cb+0x228>)
    5622:	8b53      	ldrh	r3, [r2, #26]
    5624:	8a52      	ldrh	r2, [r2, #18]
    5626:	4293      	cmp	r3, r2
    5628:	d22c      	bcs.n	5684 <TIMER_task1_cb+0x138>
					session_data.current_slice += 1;
    562a:	3301      	adds	r3, #1
    562c:	b29d      	uxth	r5, r3
    562e:	4b51      	ldr	r3, [pc, #324]	; (5774 <TIMER_task1_cb+0x228>)
    5630:	835d      	strh	r5, [r3, #26]
					if (((session_data.current_slice >= session_data.no_of_slices) && (session_data.current_volume == session_data.no_of_volumes)) || 
    5632:	42aa      	cmp	r2, r5
    5634:	d803      	bhi.n	563e <TIMER_task1_cb+0xf2>
    5636:	8b1a      	ldrh	r2, [r3, #24]
    5638:	8a1b      	ldrh	r3, [r3, #16]
    563a:	429a      	cmp	r2, r3
    563c:	d004      	beq.n	5648 <TIMER_task1_cb+0xfc>
						(session_data.current_volume > session_data.no_of_volumes)){
    563e:	4b4d      	ldr	r3, [pc, #308]	; (5774 <TIMER_task1_cb+0x228>)
    5640:	8b1a      	ldrh	r2, [r3, #24]
    5642:	8a1b      	ldrh	r3, [r3, #16]
					if (((session_data.current_slice >= session_data.no_of_slices) && (session_data.current_volume == session_data.no_of_volumes)) || 
    5644:	429a      	cmp	r2, r3
    5646:	d902      	bls.n	564e <TIMER_task1_cb+0x102>
						session_data.session_finished = true;
    5648:	2201      	movs	r2, #1
    564a:	4b4a      	ldr	r3, [pc, #296]	; (5774 <TIMER_task1_cb+0x228>)
    564c:	705a      	strb	r2, [r3, #1]
					uint16_t divider = session_data.trig_on_volume;
    564e:	4b49      	ldr	r3, [pc, #292]	; (5774 <TIMER_task1_cb+0x228>)
    5650:	8a9b      	ldrh	r3, [r3, #20]
					if (divider == 0) {
    5652:	2b00      	cmp	r3, #0
    5654:	d100      	bne.n	5658 <TIMER_task1_cb+0x10c>
    5656:	e087      	b.n	5768 <TIMER_task1_cb+0x21c>
					uint16_t divider = session_data.trig_on_volume;
    5658:	0019      	movs	r1, r3
					if ((session_data.trig_on_volume == 0) || (((session_data.current_volume - 1) % divider) == 0)){
    565a:	2b00      	cmp	r3, #0
    565c:	d006      	beq.n	566c <TIMER_task1_cb+0x120>
    565e:	4b45      	ldr	r3, [pc, #276]	; (5774 <TIMER_task1_cb+0x228>)
    5660:	8b18      	ldrh	r0, [r3, #24]
    5662:	3801      	subs	r0, #1
    5664:	4b49      	ldr	r3, [pc, #292]	; (578c <TIMER_task1_cb+0x240>)
    5666:	4798      	blx	r3
    5668:	2900      	cmp	r1, #0
    566a:	d10b      	bne.n	5684 <TIMER_task1_cb+0x138>
						if ((session_data.trig_on_slice == 0) || (session_data.trig_on_slice == session_data.current_slice)){
    566c:	4b41      	ldr	r3, [pc, #260]	; (5774 <TIMER_task1_cb+0x228>)
    566e:	8adb      	ldrh	r3, [r3, #22]
    5670:	2b00      	cmp	r3, #0
    5672:	d001      	beq.n	5678 <TIMER_task1_cb+0x12c>
    5674:	429d      	cmp	r5, r3
    5676:	d105      	bne.n	5684 <TIMER_task1_cb+0x138>
							session_data.trigger = true;
    5678:	2201      	movs	r2, #1
    567a:	4b3e      	ldr	r3, [pc, #248]	; (5774 <TIMER_task1_cb+0x228>)
    567c:	715a      	strb	r2, [r3, #5]
							sync_beep_length = SYNC_BEEP_LENGTH;
    567e:	4a44      	ldr	r2, [pc, #272]	; (5790 <TIMER_task1_cb+0x244>)
    5680:	4b44      	ldr	r3, [pc, #272]	; (5794 <TIMER_task1_cb+0x248>)
    5682:	801a      	strh	r2, [r3, #0]
			if (TR_counter >= session_data.TR_time){ // new volume acquisition starts
    5684:	4b3b      	ldr	r3, [pc, #236]	; (5774 <TIMER_task1_cb+0x228>)
    5686:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5688:	429c      	cmp	r4, r3
    568a:	d35e      	bcc.n	574a <TIMER_task1_cb+0x1fe>
				TR_counter = 0;
    568c:	4b37      	ldr	r3, [pc, #220]	; (576c <TIMER_task1_cb+0x220>)
    568e:	2200      	movs	r2, #0
    5690:	825a      	strh	r2, [r3, #18]
				pulse_counter = 0;
    5692:	821a      	strh	r2, [r3, #16]
				session_data.current_volume += 1;
    5694:	4a37      	ldr	r2, [pc, #220]	; (5774 <TIMER_task1_cb+0x228>)
    5696:	8b13      	ldrh	r3, [r2, #24]
    5698:	3301      	adds	r3, #1
    569a:	b29b      	uxth	r3, r3
    569c:	8313      	strh	r3, [r2, #24]
				if (session_data.current_volume > session_data.no_of_volumes){
    569e:	8a12      	ldrh	r2, [r2, #16]
    56a0:	4293      	cmp	r3, r2
    56a2:	d902      	bls.n	56aa <TIMER_task1_cb+0x15e>
					session_data.session_finished = true;
    56a4:	2201      	movs	r2, #1
    56a6:	4b33      	ldr	r3, [pc, #204]	; (5774 <TIMER_task1_cb+0x228>)
    56a8:	705a      	strb	r2, [r3, #1]
				session_data.current_slice = 0;
    56aa:	2200      	movs	r2, #0
    56ac:	4b31      	ldr	r3, [pc, #196]	; (5774 <TIMER_task1_cb+0x228>)
    56ae:	835a      	strh	r2, [r3, #26]
}
    56b0:	e04b      	b.n	574a <TIMER_task1_cb+0x1fe>
		dc_out = click_sound_data[CLICK_SOUND_LENGTH - click_length];
    56b2:	22bc      	movs	r2, #188	; 0xbc
    56b4:	0052      	lsls	r2, r2, #1
    56b6:	1ad3      	subs	r3, r2, r3
    56b8:	005b      	lsls	r3, r3, #1
    56ba:	4a37      	ldr	r2, [pc, #220]	; (5798 <TIMER_task1_cb+0x24c>)
    56bc:	18d3      	adds	r3, r2, r3
    56be:	889b      	ldrh	r3, [r3, #4]
    56c0:	4a2f      	ldr	r2, [pc, #188]	; (5780 <TIMER_task1_cb+0x234>)
    56c2:	8093      	strh	r3, [r2, #4]
		dac_async_write(&DAC_0, 0, &dc_out, 1);
    56c4:	3204      	adds	r2, #4
    56c6:	2301      	movs	r3, #1
    56c8:	2100      	movs	r1, #0
    56ca:	482e      	ldr	r0, [pc, #184]	; (5784 <TIMER_task1_cb+0x238>)
    56cc:	4c2e      	ldr	r4, [pc, #184]	; (5788 <TIMER_task1_cb+0x23c>)
    56ce:	47a0      	blx	r4
		click_length --;
    56d0:	4a26      	ldr	r2, [pc, #152]	; (576c <TIMER_task1_cb+0x220>)
    56d2:	8913      	ldrh	r3, [r2, #8]
    56d4:	3b01      	subs	r3, #1
    56d6:	8113      	strh	r3, [r2, #8]
    56d8:	e761      	b.n	559e <TIMER_task1_cb+0x52>
			dc_out = beep_sound_data[BEEP_SOUND_LENGTH - beep_sound_length];
    56da:	4a30      	ldr	r2, [pc, #192]	; (579c <TIMER_task1_cb+0x250>)
    56dc:	1ad3      	subs	r3, r2, r3
    56de:	005b      	lsls	r3, r3, #1
    56e0:	4a2f      	ldr	r2, [pc, #188]	; (57a0 <TIMER_task1_cb+0x254>)
    56e2:	18d3      	adds	r3, r2, r3
    56e4:	2274      	movs	r2, #116	; 0x74
    56e6:	5a9b      	ldrh	r3, [r3, r2]
    56e8:	4a25      	ldr	r2, [pc, #148]	; (5780 <TIMER_task1_cb+0x234>)
    56ea:	8093      	strh	r3, [r2, #4]
			dac_async_write(&DAC_0, 0, &dc_out, 1);
    56ec:	3204      	adds	r2, #4
    56ee:	2301      	movs	r3, #1
    56f0:	2100      	movs	r1, #0
    56f2:	4824      	ldr	r0, [pc, #144]	; (5784 <TIMER_task1_cb+0x238>)
    56f4:	4c24      	ldr	r4, [pc, #144]	; (5788 <TIMER_task1_cb+0x23c>)
    56f6:	47a0      	blx	r4
			beep_sound_length --;
    56f8:	4a1d      	ldr	r2, [pc, #116]	; (5770 <TIMER_task1_cb+0x224>)
    56fa:	8813      	ldrh	r3, [r2, #0]
    56fc:	3b01      	subs	r3, #1
    56fe:	8013      	strh	r3, [r2, #0]
    5700:	e74d      	b.n	559e <TIMER_task1_cb+0x52>
	else if (sync_beep_length){
    5702:	4b24      	ldr	r3, [pc, #144]	; (5794 <TIMER_task1_cb+0x248>)
    5704:	881b      	ldrh	r3, [r3, #0]
    5706:	2b00      	cmp	r3, #0
    5708:	d100      	bne.n	570c <TIMER_task1_cb+0x1c0>
    570a:	e748      	b.n	559e <TIMER_task1_cb+0x52>
		if (session_data.trigger_sound){
    570c:	4a19      	ldr	r2, [pc, #100]	; (5774 <TIMER_task1_cb+0x228>)
    570e:	7a92      	ldrb	r2, [r2, #10]
    5710:	2a00      	cmp	r2, #0
    5712:	d103      	bne.n	571c <TIMER_task1_cb+0x1d0>
			sync_beep_length = 0;
    5714:	2200      	movs	r2, #0
    5716:	4b1f      	ldr	r3, [pc, #124]	; (5794 <TIMER_task1_cb+0x248>)
    5718:	801a      	strh	r2, [r3, #0]
    571a:	e740      	b.n	559e <TIMER_task1_cb+0x52>
			dc_out = sync_beep_sound_data[SYNC_BEEP_LENGTH - sync_beep_length];
    571c:	4a1c      	ldr	r2, [pc, #112]	; (5790 <TIMER_task1_cb+0x244>)
    571e:	1ad3      	subs	r3, r2, r3
    5720:	005b      	lsls	r3, r3, #1
    5722:	4a20      	ldr	r2, [pc, #128]	; (57a4 <TIMER_task1_cb+0x258>)
    5724:	18d3      	adds	r3, r2, r3
    5726:	226c      	movs	r2, #108	; 0x6c
    5728:	5a9b      	ldrh	r3, [r3, r2]
    572a:	4a15      	ldr	r2, [pc, #84]	; (5780 <TIMER_task1_cb+0x234>)
    572c:	8093      	strh	r3, [r2, #4]
			dac_async_write(&DAC_0, 0, &dc_out, 1);
    572e:	3204      	adds	r2, #4
    5730:	2301      	movs	r3, #1
    5732:	2100      	movs	r1, #0
    5734:	4813      	ldr	r0, [pc, #76]	; (5784 <TIMER_task1_cb+0x238>)
    5736:	4c14      	ldr	r4, [pc, #80]	; (5788 <TIMER_task1_cb+0x23c>)
    5738:	47a0      	blx	r4
			sync_beep_length --;
    573a:	4a16      	ldr	r2, [pc, #88]	; (5794 <TIMER_task1_cb+0x248>)
    573c:	8813      	ldrh	r3, [r2, #0]
    573e:	3b01      	subs	r3, #1
    5740:	8013      	strh	r3, [r2, #0]
    5742:	e72c      	b.n	559e <TIMER_task1_cb+0x52>
		prescaler --;
    5744:	3b01      	subs	r3, #1
    5746:	4a0e      	ldr	r2, [pc, #56]	; (5780 <TIMER_task1_cb+0x234>)
    5748:	7193      	strb	r3, [r2, #6]
}
    574a:	bd70      	pop	{r4, r5, r6, pc}
			usb_disconnected_prescaler = 5;
    574c:	2205      	movs	r2, #5
    574e:	4b07      	ldr	r3, [pc, #28]	; (576c <TIMER_task1_cb+0x220>)
    5750:	729a      	strb	r2, [r3, #10]
			if (usb_disconnected < 500){
    5752:	4b15      	ldr	r3, [pc, #84]	; (57a8 <TIMER_task1_cb+0x25c>)
    5754:	881b      	ldrh	r3, [r3, #0]
    5756:	22f4      	movs	r2, #244	; 0xf4
    5758:	32ff      	adds	r2, #255	; 0xff
    575a:	4293      	cmp	r3, r2
    575c:	d900      	bls.n	5760 <TIMER_task1_cb+0x214>
    575e:	e72e      	b.n	55be <TIMER_task1_cb+0x72>
				usb_disconnected ++;
    5760:	3301      	adds	r3, #1
    5762:	4a11      	ldr	r2, [pc, #68]	; (57a8 <TIMER_task1_cb+0x25c>)
    5764:	8013      	strh	r3, [r2, #0]
    5766:	e72a      	b.n	55be <TIMER_task1_cb+0x72>
						divider = 1;
    5768:	2101      	movs	r1, #1
    576a:	e776      	b.n	565a <TIMER_task1_cb+0x10e>
    576c:	20000740 	.word	0x20000740
    5770:	20000184 	.word	0x20000184
    5774:	20000a3c 	.word	0x20000a3c
    5778:	00000c82 	.word	0x00000c82
    577c:	0000ae74 	.word	0x0000ae74
    5780:	20000000 	.word	0x20000000
    5784:	20000948 	.word	0x20000948
    5788:	00001381 	.word	0x00001381
    578c:	0000947d 	.word	0x0000947d
    5790:	000003d6 	.word	0x000003d6
    5794:	20000182 	.word	0x20000182
    5798:	0000c774 	.word	0x0000c774
    579c:	0000047c 	.word	0x0000047c
    57a0:	0000c9f4 	.word	0x0000c9f4
    57a4:	0000d2f4 	.word	0x0000d2f4
    57a8:	20000180 	.word	0x20000180

000057ac <write_flash>:
void write_flash(){
    57ac:	b5f0      	push	{r4, r5, r6, r7, lr}
    57ae:	46d6      	mov	lr, sl
    57b0:	b500      	push	{lr}
    57b2:	b084      	sub	sp, #16
	i = session_data.no_of_slices;
    57b4:	4f45      	ldr	r7, [pc, #276]	; (58cc <write_flash+0x120>)
    57b6:	8a79      	ldrh	r1, [r7, #18]
    57b8:	9103      	str	r1, [sp, #12]
	printf("flash write no of slices, %u\r\n", i);
    57ba:	4845      	ldr	r0, [pc, #276]	; (58d0 <write_flash+0x124>)
    57bc:	4d45      	ldr	r5, [pc, #276]	; (58d4 <write_flash+0x128>)
    57be:	47a8      	blx	r5
	flash_write(&FLASH_0, ad, ic, 2);
    57c0:	ac03      	add	r4, sp, #12
    57c2:	2302      	movs	r3, #2
    57c4:	0022      	movs	r2, r4
    57c6:	21f8      	movs	r1, #248	; 0xf8
    57c8:	0289      	lsls	r1, r1, #10
    57ca:	4843      	ldr	r0, [pc, #268]	; (58d8 <write_flash+0x12c>)
    57cc:	4e43      	ldr	r6, [pc, #268]	; (58dc <write_flash+0x130>)
    57ce:	46b2      	mov	sl, r6
    57d0:	47b0      	blx	r6
	printf("flash written no of slices, %u, %u\r\n", ic[0], ic[1]);
    57d2:	7821      	ldrb	r1, [r4, #0]
    57d4:	7862      	ldrb	r2, [r4, #1]
    57d6:	4842      	ldr	r0, [pc, #264]	; (58e0 <write_flash+0x134>)
    57d8:	47a8      	blx	r5
	delay_ms(delay);
    57da:	200a      	movs	r0, #10
    57dc:	4e41      	ldr	r6, [pc, #260]	; (58e4 <write_flash+0x138>)
    57de:	47b0      	blx	r6
	i = session_data.no_of_volumes;
    57e0:	8a39      	ldrh	r1, [r7, #16]
    57e2:	9103      	str	r1, [sp, #12]
	printf("flash write no of volumes, %u\r\n", i);
    57e4:	4840      	ldr	r0, [pc, #256]	; (58e8 <write_flash+0x13c>)
    57e6:	47a8      	blx	r5
	flash_write(&FLASH_0, ad + 2, ic, 2);
    57e8:	2302      	movs	r3, #2
    57ea:	0022      	movs	r2, r4
    57ec:	493f      	ldr	r1, [pc, #252]	; (58ec <write_flash+0x140>)
    57ee:	483a      	ldr	r0, [pc, #232]	; (58d8 <write_flash+0x12c>)
    57f0:	47d0      	blx	sl
	printf("flash written no of volumes, %u, %u\r\n", ic[0], ic[1]);
    57f2:	7821      	ldrb	r1, [r4, #0]
    57f4:	7862      	ldrb	r2, [r4, #1]
    57f6:	483e      	ldr	r0, [pc, #248]	; (58f0 <write_flash+0x144>)
    57f8:	47a8      	blx	r5
	delay_ms(delay);
    57fa:	200a      	movs	r0, #10
    57fc:	47b0      	blx	r6
	i = session_data.trig_on_slice;
    57fe:	8af9      	ldrh	r1, [r7, #22]
    5800:	9103      	str	r1, [sp, #12]
	printf("flash write trigg on slice, %u\r\n", i);
    5802:	483c      	ldr	r0, [pc, #240]	; (58f4 <write_flash+0x148>)
    5804:	47a8      	blx	r5
	flash_write(&FLASH_0, ad + 4, ic, 2);
    5806:	2302      	movs	r3, #2
    5808:	0022      	movs	r2, r4
    580a:	493b      	ldr	r1, [pc, #236]	; (58f8 <write_flash+0x14c>)
    580c:	4832      	ldr	r0, [pc, #200]	; (58d8 <write_flash+0x12c>)
    580e:	47d0      	blx	sl
	printf("flash written trigg on slice, %u, %u\r\n", ic[0], ic[1]);
    5810:	7821      	ldrb	r1, [r4, #0]
    5812:	7862      	ldrb	r2, [r4, #1]
    5814:	4839      	ldr	r0, [pc, #228]	; (58fc <write_flash+0x150>)
    5816:	47a8      	blx	r5
	delay_ms(delay);
    5818:	200a      	movs	r0, #10
    581a:	47b0      	blx	r6
	i = session_data.trig_on_volume;
    581c:	8ab9      	ldrh	r1, [r7, #20]
    581e:	9103      	str	r1, [sp, #12]
	printf("flash write trigg on volume, %u\r\n", i);
    5820:	4837      	ldr	r0, [pc, #220]	; (5900 <write_flash+0x154>)
    5822:	47a8      	blx	r5
	flash_write(&FLASH_0, ad + 6, ic, 2);
    5824:	2302      	movs	r3, #2
    5826:	0022      	movs	r2, r4
    5828:	4936      	ldr	r1, [pc, #216]	; (5904 <write_flash+0x158>)
    582a:	482b      	ldr	r0, [pc, #172]	; (58d8 <write_flash+0x12c>)
    582c:	47d0      	blx	sl
	printf("flash written trigg on volume, %u, %u\r\n", ic[0], ic[1]);
    582e:	7821      	ldrb	r1, [r4, #0]
    5830:	7862      	ldrb	r2, [r4, #1]
    5832:	4835      	ldr	r0, [pc, #212]	; (5908 <write_flash+0x15c>)
    5834:	47a8      	blx	r5
	delay_ms(delay);
    5836:	200a      	movs	r0, #10
    5838:	47b0      	blx	r6
	i = session_data.pulse_length;
    583a:	8c39      	ldrh	r1, [r7, #32]
    583c:	9103      	str	r1, [sp, #12]
	printf("flash write pulse length, %u\r\n", i);
    583e:	4833      	ldr	r0, [pc, #204]	; (590c <write_flash+0x160>)
    5840:	47a8      	blx	r5
	flash_write(&FLASH_0, ad + 8, ic, 2);
    5842:	2302      	movs	r3, #2
    5844:	0022      	movs	r2, r4
    5846:	4932      	ldr	r1, [pc, #200]	; (5910 <write_flash+0x164>)
    5848:	4823      	ldr	r0, [pc, #140]	; (58d8 <write_flash+0x12c>)
    584a:	47d0      	blx	sl
	printf("flash written pulse lenght, %u, %u\r\n", ic[0], ic[1]);
    584c:	7821      	ldrb	r1, [r4, #0]
    584e:	7862      	ldrb	r2, [r4, #1]
    5850:	4830      	ldr	r0, [pc, #192]	; (5914 <write_flash+0x168>)
    5852:	47a8      	blx	r5
	delay_ms(delay);
    5854:	200a      	movs	r0, #10
    5856:	47b0      	blx	r6
	li = session_data.TR_time;
    5858:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    585a:	9302      	str	r3, [sp, #8]
	printf("flash write TR time, %lu\r\n", li);
    585c:	0019      	movs	r1, r3
    585e:	482e      	ldr	r0, [pc, #184]	; (5918 <write_flash+0x16c>)
    5860:	47a8      	blx	r5
	flash_write(&FLASH_0, ad + 0x0a, lic, 4);
    5862:	2304      	movs	r3, #4
    5864:	aa02      	add	r2, sp, #8
    5866:	492d      	ldr	r1, [pc, #180]	; (591c <write_flash+0x170>)
    5868:	481b      	ldr	r0, [pc, #108]	; (58d8 <write_flash+0x12c>)
    586a:	47d0      	blx	sl
	printf("flash written TR time, %u, %u, %u, %u\r\n", lic[0], lic[1], lic[2], lic[3]);
    586c:	466b      	mov	r3, sp
    586e:	7a19      	ldrb	r1, [r3, #8]
    5870:	7a5a      	ldrb	r2, [r3, #9]
    5872:	7a9b      	ldrb	r3, [r3, #10]
    5874:	4668      	mov	r0, sp
    5876:	7ac0      	ldrb	r0, [r0, #11]
    5878:	9000      	str	r0, [sp, #0]
    587a:	4829      	ldr	r0, [pc, #164]	; (5920 <write_flash+0x174>)
    587c:	47a8      	blx	r5
	delay_ms(delay);	
    587e:	200a      	movs	r0, #10
    5880:	47b0      	blx	r6
	i = session_data.trigger_sound * 256 + session_data.response_sound;
    5882:	7ab9      	ldrb	r1, [r7, #10]
    5884:	0209      	lsls	r1, r1, #8
    5886:	7afb      	ldrb	r3, [r7, #11]
    5888:	18c9      	adds	r1, r1, r3
    588a:	9103      	str	r1, [sp, #12]
	printf("flash write trigger / response sound, %u\r\n", i);
    588c:	4825      	ldr	r0, [pc, #148]	; (5924 <write_flash+0x178>)
    588e:	47a8      	blx	r5
	flash_write(&FLASH_0, ad + 0x0e, ic, 2);
    5890:	2302      	movs	r3, #2
    5892:	0022      	movs	r2, r4
    5894:	4924      	ldr	r1, [pc, #144]	; (5928 <write_flash+0x17c>)
    5896:	4810      	ldr	r0, [pc, #64]	; (58d8 <write_flash+0x12c>)
    5898:	47d0      	blx	sl
	printf("flash written trigger / response sound, %u, %u\r\n", ic[1], ic[0]);
    589a:	7861      	ldrb	r1, [r4, #1]
    589c:	7822      	ldrb	r2, [r4, #0]
    589e:	4823      	ldr	r0, [pc, #140]	; (592c <write_flash+0x180>)
    58a0:	47a8      	blx	r5
	delay_ms(delay);
    58a2:	200a      	movs	r0, #10
    58a4:	47b0      	blx	r6
	i = session_data.sound_volume;
    58a6:	89f9      	ldrh	r1, [r7, #14]
    58a8:	9103      	str	r1, [sp, #12]
	printf("flash write sound volume, %u\r\n", i);
    58aa:	4821      	ldr	r0, [pc, #132]	; (5930 <write_flash+0x184>)
    58ac:	47a8      	blx	r5
	flash_write(&FLASH_0, ad + 0x10, ic, 2);
    58ae:	2302      	movs	r3, #2
    58b0:	0022      	movs	r2, r4
    58b2:	4920      	ldr	r1, [pc, #128]	; (5934 <write_flash+0x188>)
    58b4:	4808      	ldr	r0, [pc, #32]	; (58d8 <write_flash+0x12c>)
    58b6:	47d0      	blx	sl
	printf("flash written sound volume, %u, %u\r\n", ic[0], ic[1]);
    58b8:	7821      	ldrb	r1, [r4, #0]
    58ba:	7862      	ldrb	r2, [r4, #1]
    58bc:	481e      	ldr	r0, [pc, #120]	; (5938 <write_flash+0x18c>)
    58be:	47a8      	blx	r5
	delay_ms(delay);
    58c0:	200a      	movs	r0, #10
    58c2:	47b0      	blx	r6
}
    58c4:	b004      	add	sp, #16
    58c6:	bc04      	pop	{r2}
    58c8:	4692      	mov	sl, r2
    58ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    58cc:	20000a3c 	.word	0x20000a3c
    58d0:	0000dbb4 	.word	0x0000dbb4
    58d4:	00009565 	.word	0x00009565
    58d8:	20000900 	.word	0x20000900
    58dc:	000016bd 	.word	0x000016bd
    58e0:	0000dbd4 	.word	0x0000dbd4
    58e4:	0000141d 	.word	0x0000141d
    58e8:	0000dbfc 	.word	0x0000dbfc
    58ec:	0003e002 	.word	0x0003e002
    58f0:	0000dc1c 	.word	0x0000dc1c
    58f4:	0000dc44 	.word	0x0000dc44
    58f8:	0003e004 	.word	0x0003e004
    58fc:	0000dc68 	.word	0x0000dc68
    5900:	0000dc90 	.word	0x0000dc90
    5904:	0003e006 	.word	0x0003e006
    5908:	0000dcb4 	.word	0x0000dcb4
    590c:	0000dcdc 	.word	0x0000dcdc
    5910:	0003e008 	.word	0x0003e008
    5914:	0000dcfc 	.word	0x0000dcfc
    5918:	0000dd24 	.word	0x0000dd24
    591c:	0003e00a 	.word	0x0003e00a
    5920:	0000dd40 	.word	0x0000dd40
    5924:	0000dd68 	.word	0x0000dd68
    5928:	0003e00e 	.word	0x0003e00e
    592c:	0000dd94 	.word	0x0000dd94
    5930:	0000ddc8 	.word	0x0000ddc8
    5934:	0003e010 	.word	0x0003e010
    5938:	0000dde8 	.word	0x0000dde8

0000593c <read_flash>:
void read_flash(){
    593c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	printf("read session data from flash\r\n");
    593e:	4874      	ldr	r0, [pc, #464]	; (5b10 <read_flash+0x1d4>)
    5940:	4b74      	ldr	r3, [pc, #464]	; (5b14 <read_flash+0x1d8>)
    5942:	4798      	blx	r3
	flash_read(&FLASH_0, ad, a, 2);	
    5944:	4c74      	ldr	r4, [pc, #464]	; (5b18 <read_flash+0x1dc>)
    5946:	0022      	movs	r2, r4
    5948:	3214      	adds	r2, #20
    594a:	2302      	movs	r3, #2
    594c:	21f8      	movs	r1, #248	; 0xf8
    594e:	0289      	lsls	r1, r1, #10
    5950:	4872      	ldr	r0, [pc, #456]	; (5b1c <read_flash+0x1e0>)
    5952:	4d73      	ldr	r5, [pc, #460]	; (5b20 <read_flash+0x1e4>)
    5954:	47a8      	blx	r5
	session_data.no_of_slices = a[0] + a[1] * 256;	
    5956:	7d21      	ldrb	r1, [r4, #20]
    5958:	7d63      	ldrb	r3, [r4, #21]
    595a:	021b      	lsls	r3, r3, #8
    595c:	18c9      	adds	r1, r1, r3
    595e:	b289      	uxth	r1, r1
    5960:	4c70      	ldr	r4, [pc, #448]	; (5b24 <read_flash+0x1e8>)
    5962:	8261      	strh	r1, [r4, #18]
	printf("no_of_slices read from flash: %u\r\n", session_data.no_of_slices);	
    5964:	4870      	ldr	r0, [pc, #448]	; (5b28 <read_flash+0x1ec>)
    5966:	4b71      	ldr	r3, [pc, #452]	; (5b2c <read_flash+0x1f0>)
    5968:	4798      	blx	r3
	if ((session_data.no_of_slices < 1) || (session_data.no_of_slices > 999)) {
    596a:	8a63      	ldrh	r3, [r4, #18]
    596c:	3b01      	subs	r3, #1
    596e:	b29b      	uxth	r3, r3
    5970:	4a6f      	ldr	r2, [pc, #444]	; (5b30 <read_flash+0x1f4>)
    5972:	4293      	cmp	r3, r2
    5974:	d902      	bls.n	597c <read_flash+0x40>
		session_data.no_of_slices = 25;
    5976:	2219      	movs	r2, #25
    5978:	4b6a      	ldr	r3, [pc, #424]	; (5b24 <read_flash+0x1e8>)
    597a:	825a      	strh	r2, [r3, #18]
	flash_read(&FLASH_0, ad + 2, a, 2);
    597c:	4c66      	ldr	r4, [pc, #408]	; (5b18 <read_flash+0x1dc>)
    597e:	0022      	movs	r2, r4
    5980:	3214      	adds	r2, #20
    5982:	2302      	movs	r3, #2
    5984:	496b      	ldr	r1, [pc, #428]	; (5b34 <read_flash+0x1f8>)
    5986:	4865      	ldr	r0, [pc, #404]	; (5b1c <read_flash+0x1e0>)
    5988:	4d65      	ldr	r5, [pc, #404]	; (5b20 <read_flash+0x1e4>)
    598a:	47a8      	blx	r5
	session_data.no_of_volumes = a[0] + a[1] * 256;
    598c:	7d21      	ldrb	r1, [r4, #20]
    598e:	7d63      	ldrb	r3, [r4, #21]
    5990:	021b      	lsls	r3, r3, #8
    5992:	18c9      	adds	r1, r1, r3
    5994:	b289      	uxth	r1, r1
    5996:	4c63      	ldr	r4, [pc, #396]	; (5b24 <read_flash+0x1e8>)
    5998:	8221      	strh	r1, [r4, #16]
	printf("no_of_volumes read from flash: %u\r\n", session_data.no_of_volumes);	
    599a:	4867      	ldr	r0, [pc, #412]	; (5b38 <read_flash+0x1fc>)
    599c:	4b63      	ldr	r3, [pc, #396]	; (5b2c <read_flash+0x1f0>)
    599e:	4798      	blx	r3
	if ((session_data.no_of_volumes < 1) || (session_data.no_of_volumes > 9999)) {
    59a0:	8a23      	ldrh	r3, [r4, #16]
    59a2:	3b01      	subs	r3, #1
    59a4:	b29b      	uxth	r3, r3
    59a6:	4a65      	ldr	r2, [pc, #404]	; (5b3c <read_flash+0x200>)
    59a8:	4293      	cmp	r3, r2
    59aa:	d902      	bls.n	59b2 <read_flash+0x76>
		session_data.no_of_volumes = 100;
    59ac:	2264      	movs	r2, #100	; 0x64
    59ae:	4b5d      	ldr	r3, [pc, #372]	; (5b24 <read_flash+0x1e8>)
    59b0:	821a      	strh	r2, [r3, #16]
	flash_read(&FLASH_0, ad + 4, a, 2);
    59b2:	4c59      	ldr	r4, [pc, #356]	; (5b18 <read_flash+0x1dc>)
    59b4:	0022      	movs	r2, r4
    59b6:	3214      	adds	r2, #20
    59b8:	2302      	movs	r3, #2
    59ba:	4961      	ldr	r1, [pc, #388]	; (5b40 <read_flash+0x204>)
    59bc:	4857      	ldr	r0, [pc, #348]	; (5b1c <read_flash+0x1e0>)
    59be:	4d58      	ldr	r5, [pc, #352]	; (5b20 <read_flash+0x1e4>)
    59c0:	47a8      	blx	r5
	session_data.trig_on_slice = a[0] + a[1] * 256;
    59c2:	7d21      	ldrb	r1, [r4, #20]
    59c4:	7d63      	ldrb	r3, [r4, #21]
    59c6:	021b      	lsls	r3, r3, #8
    59c8:	18c9      	adds	r1, r1, r3
    59ca:	b289      	uxth	r1, r1
    59cc:	4c55      	ldr	r4, [pc, #340]	; (5b24 <read_flash+0x1e8>)
    59ce:	82e1      	strh	r1, [r4, #22]
	printf("trig_on_slice read from flash: %u\r\n", session_data.trig_on_slice);	
    59d0:	485c      	ldr	r0, [pc, #368]	; (5b44 <read_flash+0x208>)
    59d2:	4b56      	ldr	r3, [pc, #344]	; (5b2c <read_flash+0x1f0>)
    59d4:	4798      	blx	r3
	if ((session_data.trig_on_slice < 0) || (session_data.trig_on_slice > 999)) {
    59d6:	8ae2      	ldrh	r2, [r4, #22]
    59d8:	4b5b      	ldr	r3, [pc, #364]	; (5b48 <read_flash+0x20c>)
    59da:	429a      	cmp	r2, r3
    59dc:	d902      	bls.n	59e4 <read_flash+0xa8>
		session_data.trig_on_slice = 0;
    59de:	2200      	movs	r2, #0
    59e0:	4b50      	ldr	r3, [pc, #320]	; (5b24 <read_flash+0x1e8>)
    59e2:	82da      	strh	r2, [r3, #22]
	flash_read(&FLASH_0, ad + 6, a, 2);
    59e4:	4c4c      	ldr	r4, [pc, #304]	; (5b18 <read_flash+0x1dc>)
    59e6:	0022      	movs	r2, r4
    59e8:	3214      	adds	r2, #20
    59ea:	2302      	movs	r3, #2
    59ec:	4957      	ldr	r1, [pc, #348]	; (5b4c <read_flash+0x210>)
    59ee:	484b      	ldr	r0, [pc, #300]	; (5b1c <read_flash+0x1e0>)
    59f0:	4d4b      	ldr	r5, [pc, #300]	; (5b20 <read_flash+0x1e4>)
    59f2:	47a8      	blx	r5
	session_data.trig_on_volume = a[0] + a[1] * 256;
    59f4:	7d21      	ldrb	r1, [r4, #20]
    59f6:	7d63      	ldrb	r3, [r4, #21]
    59f8:	021b      	lsls	r3, r3, #8
    59fa:	18c9      	adds	r1, r1, r3
    59fc:	b289      	uxth	r1, r1
    59fe:	4c49      	ldr	r4, [pc, #292]	; (5b24 <read_flash+0x1e8>)
    5a00:	82a1      	strh	r1, [r4, #20]
	printf("trig_on_volume read from flash: %u\r\n", session_data.trig_on_volume);	
    5a02:	4853      	ldr	r0, [pc, #332]	; (5b50 <read_flash+0x214>)
    5a04:	4b49      	ldr	r3, [pc, #292]	; (5b2c <read_flash+0x1f0>)
    5a06:	4798      	blx	r3
	if ((session_data.trig_on_volume < 0) || (session_data.trig_on_volume > 9999)) {
    5a08:	8aa2      	ldrh	r2, [r4, #20]
    5a0a:	4b52      	ldr	r3, [pc, #328]	; (5b54 <read_flash+0x218>)
    5a0c:	429a      	cmp	r2, r3
    5a0e:	d902      	bls.n	5a16 <read_flash+0xda>
		session_data.trig_on_volume = 0;
    5a10:	2200      	movs	r2, #0
    5a12:	4b44      	ldr	r3, [pc, #272]	; (5b24 <read_flash+0x1e8>)
    5a14:	829a      	strh	r2, [r3, #20]
	flash_read(&FLASH_0, ad + 8, a, 2);
    5a16:	4c40      	ldr	r4, [pc, #256]	; (5b18 <read_flash+0x1dc>)
    5a18:	0022      	movs	r2, r4
    5a1a:	3214      	adds	r2, #20
    5a1c:	2302      	movs	r3, #2
    5a1e:	494e      	ldr	r1, [pc, #312]	; (5b58 <read_flash+0x21c>)
    5a20:	483e      	ldr	r0, [pc, #248]	; (5b1c <read_flash+0x1e0>)
    5a22:	4d3f      	ldr	r5, [pc, #252]	; (5b20 <read_flash+0x1e4>)
    5a24:	47a8      	blx	r5
	session_data.pulse_length = a[0] + a[1] * 256;
    5a26:	7d21      	ldrb	r1, [r4, #20]
    5a28:	7d63      	ldrb	r3, [r4, #21]
    5a2a:	021b      	lsls	r3, r3, #8
    5a2c:	18c9      	adds	r1, r1, r3
    5a2e:	b289      	uxth	r1, r1
    5a30:	4c3c      	ldr	r4, [pc, #240]	; (5b24 <read_flash+0x1e8>)
    5a32:	8421      	strh	r1, [r4, #32]
	printf("pulse_length read from flash: %u\r\n", session_data.pulse_length);	
    5a34:	4849      	ldr	r0, [pc, #292]	; (5b5c <read_flash+0x220>)
    5a36:	4b3d      	ldr	r3, [pc, #244]	; (5b2c <read_flash+0x1f0>)
    5a38:	4798      	blx	r3
	if ((session_data.pulse_length < 100) || (session_data.pulse_length > 999)) {
    5a3a:	8c23      	ldrh	r3, [r4, #32]
    5a3c:	3b64      	subs	r3, #100	; 0x64
    5a3e:	b29b      	uxth	r3, r3
    5a40:	4a47      	ldr	r2, [pc, #284]	; (5b60 <read_flash+0x224>)
    5a42:	4293      	cmp	r3, r2
    5a44:	d902      	bls.n	5a4c <read_flash+0x110>
		session_data.pulse_length = 100;
    5a46:	2264      	movs	r2, #100	; 0x64
    5a48:	4b36      	ldr	r3, [pc, #216]	; (5b24 <read_flash+0x1e8>)
    5a4a:	841a      	strh	r2, [r3, #32]
	flash_read(&FLASH_0, ad + 0x0a, a, 4);
    5a4c:	4c32      	ldr	r4, [pc, #200]	; (5b18 <read_flash+0x1dc>)
    5a4e:	0022      	movs	r2, r4
    5a50:	3214      	adds	r2, #20
    5a52:	2304      	movs	r3, #4
    5a54:	4943      	ldr	r1, [pc, #268]	; (5b64 <read_flash+0x228>)
    5a56:	4831      	ldr	r0, [pc, #196]	; (5b1c <read_flash+0x1e0>)
    5a58:	4d31      	ldr	r5, [pc, #196]	; (5b20 <read_flash+0x1e4>)
    5a5a:	47a8      	blx	r5
	session_data.TR_time = a[0] + a[1] * 256 + a[2] * 65536 + a[3] * 16777216;
    5a5c:	7d21      	ldrb	r1, [r4, #20]
    5a5e:	7d63      	ldrb	r3, [r4, #21]
    5a60:	021b      	lsls	r3, r3, #8
    5a62:	18c9      	adds	r1, r1, r3
    5a64:	7da3      	ldrb	r3, [r4, #22]
    5a66:	041b      	lsls	r3, r3, #16
    5a68:	18c9      	adds	r1, r1, r3
    5a6a:	7de3      	ldrb	r3, [r4, #23]
    5a6c:	061b      	lsls	r3, r3, #24
    5a6e:	18c9      	adds	r1, r1, r3
    5a70:	4c2c      	ldr	r4, [pc, #176]	; (5b24 <read_flash+0x1e8>)
    5a72:	6261      	str	r1, [r4, #36]	; 0x24
	printf("TR_time read from flash: %lu\r\n", session_data.TR_time);	
    5a74:	483c      	ldr	r0, [pc, #240]	; (5b68 <read_flash+0x22c>)
    5a76:	4b2d      	ldr	r3, [pc, #180]	; (5b2c <read_flash+0x1f0>)
    5a78:	4798      	blx	r3
	uint32_t minvalue_long = session_data.pulse_length * session_data.no_of_slices;
    5a7a:	8c22      	ldrh	r2, [r4, #32]
    5a7c:	8a63      	ldrh	r3, [r4, #18]
    5a7e:	4353      	muls	r3, r2
	if (minvalue_long > 999999){   // hibaellenrzs!!!!!!!!!!!!
    5a80:	4a3a      	ldr	r2, [pc, #232]	; (5b6c <read_flash+0x230>)
    5a82:	4293      	cmp	r3, r2
    5a84:	d900      	bls.n	5a88 <read_flash+0x14c>
		minvalue_long = 999999;
    5a86:	0013      	movs	r3, r2
	if (session_data.TR_time < minvalue_long) {  
    5a88:	4a26      	ldr	r2, [pc, #152]	; (5b24 <read_flash+0x1e8>)
    5a8a:	6a52      	ldr	r2, [r2, #36]	; 0x24
    5a8c:	4293      	cmp	r3, r2
    5a8e:	d901      	bls.n	5a94 <read_flash+0x158>
		session_data.TR_time = minvalue_long;
    5a90:	4a24      	ldr	r2, [pc, #144]	; (5b24 <read_flash+0x1e8>)
    5a92:	6253      	str	r3, [r2, #36]	; 0x24
	if (session_data.TR_time > 999999) {
    5a94:	4b23      	ldr	r3, [pc, #140]	; (5b24 <read_flash+0x1e8>)
    5a96:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    5a98:	4b34      	ldr	r3, [pc, #208]	; (5b6c <read_flash+0x230>)
    5a9a:	429a      	cmp	r2, r3
    5a9c:	d902      	bls.n	5aa4 <read_flash+0x168>
		session_data.TR_time = 999999;
    5a9e:	001a      	movs	r2, r3
    5aa0:	4b20      	ldr	r3, [pc, #128]	; (5b24 <read_flash+0x1e8>)
    5aa2:	625a      	str	r2, [r3, #36]	; 0x24
	flash_read(&FLASH_0, ad + 0x0e, a, 2);
    5aa4:	4c1c      	ldr	r4, [pc, #112]	; (5b18 <read_flash+0x1dc>)
    5aa6:	0022      	movs	r2, r4
    5aa8:	3214      	adds	r2, #20
    5aaa:	2302      	movs	r3, #2
    5aac:	4930      	ldr	r1, [pc, #192]	; (5b70 <read_flash+0x234>)
    5aae:	481b      	ldr	r0, [pc, #108]	; (5b1c <read_flash+0x1e0>)
    5ab0:	4d1b      	ldr	r5, [pc, #108]	; (5b20 <read_flash+0x1e4>)
    5ab2:	47a8      	blx	r5
	if (a[1] > 0){
    5ab4:	7d63      	ldrb	r3, [r4, #21]
    5ab6:	2b00      	cmp	r3, #0
    5ab8:	d022      	beq.n	5b00 <read_flash+0x1c4>
		session_data.trigger_sound = true;
    5aba:	2201      	movs	r2, #1
    5abc:	4b19      	ldr	r3, [pc, #100]	; (5b24 <read_flash+0x1e8>)
    5abe:	729a      	strb	r2, [r3, #10]
	if (a[0] > 0){
    5ac0:	4b15      	ldr	r3, [pc, #84]	; (5b18 <read_flash+0x1dc>)
    5ac2:	7d1b      	ldrb	r3, [r3, #20]
    5ac4:	2b00      	cmp	r3, #0
    5ac6:	d01f      	beq.n	5b08 <read_flash+0x1cc>
		session_data.response_sound = true;
    5ac8:	2201      	movs	r2, #1
    5aca:	4b16      	ldr	r3, [pc, #88]	; (5b24 <read_flash+0x1e8>)
    5acc:	72da      	strb	r2, [r3, #11]
	printf("trigger / response sound: %u, %u\r\n", session_data.trigger_sound, session_data.response_sound);		
    5ace:	4c15      	ldr	r4, [pc, #84]	; (5b24 <read_flash+0x1e8>)
    5ad0:	7aa1      	ldrb	r1, [r4, #10]
    5ad2:	7ae2      	ldrb	r2, [r4, #11]
    5ad4:	4827      	ldr	r0, [pc, #156]	; (5b74 <read_flash+0x238>)
    5ad6:	4d15      	ldr	r5, [pc, #84]	; (5b2c <read_flash+0x1f0>)
    5ad8:	47a8      	blx	r5
	flash_read(&FLASH_0, ad + 0x10, a, 2);
    5ada:	4e0f      	ldr	r6, [pc, #60]	; (5b18 <read_flash+0x1dc>)
    5adc:	0032      	movs	r2, r6
    5ade:	3214      	adds	r2, #20
    5ae0:	2302      	movs	r3, #2
    5ae2:	4925      	ldr	r1, [pc, #148]	; (5b78 <read_flash+0x23c>)
    5ae4:	480d      	ldr	r0, [pc, #52]	; (5b1c <read_flash+0x1e0>)
    5ae6:	4f0e      	ldr	r7, [pc, #56]	; (5b20 <read_flash+0x1e4>)
    5ae8:	47b8      	blx	r7
	session_data.sound_volume = a[0];
    5aea:	7d31      	ldrb	r1, [r6, #20]
    5aec:	81e1      	strh	r1, [r4, #14]
	printf("sound volume read from flash: %u\r\n", session_data.sound_volume);	
    5aee:	4823      	ldr	r0, [pc, #140]	; (5b7c <read_flash+0x240>)
    5af0:	47a8      	blx	r5
	if ((session_data.sound_volume < 0) || (session_data.sound_volume > 127)) {
    5af2:	89e3      	ldrh	r3, [r4, #14]
    5af4:	2b7f      	cmp	r3, #127	; 0x7f
    5af6:	d902      	bls.n	5afe <read_flash+0x1c2>
		session_data.sound_volume = 64;
    5af8:	2240      	movs	r2, #64	; 0x40
    5afa:	4b0a      	ldr	r3, [pc, #40]	; (5b24 <read_flash+0x1e8>)
    5afc:	81da      	strh	r2, [r3, #14]
}
    5afe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		session_data.trigger_sound = false;
    5b00:	2200      	movs	r2, #0
    5b02:	4b08      	ldr	r3, [pc, #32]	; (5b24 <read_flash+0x1e8>)
    5b04:	729a      	strb	r2, [r3, #10]
    5b06:	e7db      	b.n	5ac0 <read_flash+0x184>
		session_data.response_sound = false;
    5b08:	2200      	movs	r2, #0
    5b0a:	4b06      	ldr	r3, [pc, #24]	; (5b24 <read_flash+0x1e8>)
    5b0c:	72da      	strb	r2, [r3, #11]
    5b0e:	e7de      	b.n	5ace <read_flash+0x192>
    5b10:	0000de10 	.word	0x0000de10
    5b14:	00009659 	.word	0x00009659
    5b18:	20000740 	.word	0x20000740
    5b1c:	20000900 	.word	0x20000900
    5b20:	0000163d 	.word	0x0000163d
    5b24:	20000a3c 	.word	0x20000a3c
    5b28:	0000de30 	.word	0x0000de30
    5b2c:	00009565 	.word	0x00009565
    5b30:	000003e6 	.word	0x000003e6
    5b34:	0003e002 	.word	0x0003e002
    5b38:	0000de54 	.word	0x0000de54
    5b3c:	0000270e 	.word	0x0000270e
    5b40:	0003e004 	.word	0x0003e004
    5b44:	0000de78 	.word	0x0000de78
    5b48:	000003e7 	.word	0x000003e7
    5b4c:	0003e006 	.word	0x0003e006
    5b50:	0000de9c 	.word	0x0000de9c
    5b54:	0000270f 	.word	0x0000270f
    5b58:	0003e008 	.word	0x0003e008
    5b5c:	0000dec4 	.word	0x0000dec4
    5b60:	00000383 	.word	0x00000383
    5b64:	0003e00a 	.word	0x0003e00a
    5b68:	0000dee8 	.word	0x0000dee8
    5b6c:	000f423f 	.word	0x000f423f
    5b70:	0003e00e 	.word	0x0003e00e
    5b74:	0000df08 	.word	0x0000df08
    5b78:	0003e010 	.word	0x0003e010
    5b7c:	0000df2c 	.word	0x0000df2c

00005b80 <resync>:
void resync(){
    5b80:	b510      	push	{r4, lr}
	printf("no ACK received, resync");
    5b82:	4802      	ldr	r0, [pc, #8]	; (5b8c <resync+0xc>)
    5b84:	4b02      	ldr	r3, [pc, #8]	; (5b90 <resync+0x10>)
    5b86:	4798      	blx	r3
}
    5b88:	bd10      	pop	{r4, pc}
    5b8a:	46c0      	nop			; (mov r8, r8)
    5b8c:	0000df50 	.word	0x0000df50
    5b90:	00009565 	.word	0x00009565

00005b94 <io_write_clear_ack>:
{
    5b94:	b570      	push	{r4, r5, r6, lr}
    5b96:	0006      	movs	r6, r0
    5b98:	000d      	movs	r5, r1
	if (ACK_received){
    5b9a:	4b21      	ldr	r3, [pc, #132]	; (5c20 <io_write_clear_ack+0x8c>)
    5b9c:	781b      	ldrb	r3, [r3, #0]
    5b9e:	2b00      	cmp	r3, #0
    5ba0:	d013      	beq.n	5bca <io_write_clear_ack+0x36>
		ACK_received = false;
    5ba2:	2200      	movs	r2, #0
    5ba4:	4b1e      	ldr	r3, [pc, #120]	; (5c20 <io_write_clear_ack+0x8c>)
    5ba6:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < length; i++)
    5ba8:	2400      	movs	r4, #0
    5baa:	e00b      	b.n	5bc4 <io_write_clear_ack+0x30>
			io_write(&USART_1.io, &buf[i], 1);
    5bac:	1931      	adds	r1, r6, r4
    5bae:	2201      	movs	r2, #1
    5bb0:	481c      	ldr	r0, [pc, #112]	; (5c24 <io_write_clear_ack+0x90>)
    5bb2:	4b1d      	ldr	r3, [pc, #116]	; (5c28 <io_write_clear_ack+0x94>)
    5bb4:	4798      	blx	r3
			while(usart_async_is_tx_empty(&USART_1)!=1);  // waiting the tx is over		
    5bb6:	481b      	ldr	r0, [pc, #108]	; (5c24 <io_write_clear_ack+0x90>)
    5bb8:	4b1c      	ldr	r3, [pc, #112]	; (5c2c <io_write_clear_ack+0x98>)
    5bba:	4798      	blx	r3
    5bbc:	2801      	cmp	r0, #1
    5bbe:	d1fa      	bne.n	5bb6 <io_write_clear_ack+0x22>
		for (i = 0; i < length; i++)
    5bc0:	3401      	adds	r4, #1
    5bc2:	b2e4      	uxtb	r4, r4
    5bc4:	42ac      	cmp	r4, r5
    5bc6:	d3f1      	bcc.n	5bac <io_write_clear_ack+0x18>
}
    5bc8:	bd70      	pop	{r4, r5, r6, pc}
		printf("start timeout\r\n");
    5bca:	4819      	ldr	r0, [pc, #100]	; (5c30 <io_write_clear_ack+0x9c>)
    5bcc:	4b19      	ldr	r3, [pc, #100]	; (5c34 <io_write_clear_ack+0xa0>)
    5bce:	4798      	blx	r3
		timeout_counter = ACK_TIMEOUT;
    5bd0:	22c8      	movs	r2, #200	; 0xc8
    5bd2:	0052      	lsls	r2, r2, #1
    5bd4:	4b18      	ldr	r3, [pc, #96]	; (5c38 <io_write_clear_ack+0xa4>)
    5bd6:	60da      	str	r2, [r3, #12]
		while (timeout_counter){
    5bd8:	4b17      	ldr	r3, [pc, #92]	; (5c38 <io_write_clear_ack+0xa4>)
    5bda:	68db      	ldr	r3, [r3, #12]
    5bdc:	2b00      	cmp	r3, #0
    5bde:	d006      	beq.n	5bee <io_write_clear_ack+0x5a>
			delay_us(100);    		// delay nlkl release-ban nem mkdik, csak debug-ban!!!!!
    5be0:	2064      	movs	r0, #100	; 0x64
    5be2:	4b16      	ldr	r3, [pc, #88]	; (5c3c <io_write_clear_ack+0xa8>)
    5be4:	4798      	blx	r3
				if (ACK_received){
    5be6:	4b0e      	ldr	r3, [pc, #56]	; (5c20 <io_write_clear_ack+0x8c>)
    5be8:	781b      	ldrb	r3, [r3, #0]
    5bea:	2b00      	cmp	r3, #0
    5bec:	d0f4      	beq.n	5bd8 <io_write_clear_ack+0x44>
		if (ACK_received){
    5bee:	4b0c      	ldr	r3, [pc, #48]	; (5c20 <io_write_clear_ack+0x8c>)
    5bf0:	781b      	ldrb	r3, [r3, #0]
    5bf2:	2b00      	cmp	r3, #0
    5bf4:	d102      	bne.n	5bfc <io_write_clear_ack+0x68>
			resync();
    5bf6:	4b12      	ldr	r3, [pc, #72]	; (5c40 <io_write_clear_ack+0xac>)
    5bf8:	4798      	blx	r3
}
    5bfa:	e7e5      	b.n	5bc8 <io_write_clear_ack+0x34>
			printf("received an ACK finally...\r\n");
    5bfc:	4811      	ldr	r0, [pc, #68]	; (5c44 <io_write_clear_ack+0xb0>)
    5bfe:	4c0d      	ldr	r4, [pc, #52]	; (5c34 <io_write_clear_ack+0xa0>)
    5c00:	47a0      	blx	r4
			printf("timeout counter: %lu\r\n", (ACK_TIMEOUT - timeout_counter));
    5c02:	4b0d      	ldr	r3, [pc, #52]	; (5c38 <io_write_clear_ack+0xa4>)
    5c04:	68db      	ldr	r3, [r3, #12]
    5c06:	21c8      	movs	r1, #200	; 0xc8
    5c08:	0049      	lsls	r1, r1, #1
    5c0a:	1ac9      	subs	r1, r1, r3
    5c0c:	480e      	ldr	r0, [pc, #56]	; (5c48 <io_write_clear_ack+0xb4>)
    5c0e:	4b0f      	ldr	r3, [pc, #60]	; (5c4c <io_write_clear_ack+0xb8>)
    5c10:	4798      	blx	r3
			printf("send command\r\n");
    5c12:	480f      	ldr	r0, [pc, #60]	; (5c50 <io_write_clear_ack+0xbc>)
    5c14:	47a0      	blx	r4
			io_write_clear_ack(buf, length);
    5c16:	0029      	movs	r1, r5
    5c18:	0030      	movs	r0, r6
    5c1a:	f7ff ffbb 	bl	5b94 <io_write_clear_ack>
    5c1e:	e7d3      	b.n	5bc8 <io_write_clear_ack+0x34>
    5c20:	20000a64 	.word	0x20000a64
    5c24:	200009a8 	.word	0x200009a8
    5c28:	00001949 	.word	0x00001949
    5c2c:	00001f99 	.word	0x00001f99
    5c30:	0000df68 	.word	0x0000df68
    5c34:	00009659 	.word	0x00009659
    5c38:	20000740 	.word	0x20000740
    5c3c:	000013fd 	.word	0x000013fd
    5c40:	00005b81 	.word	0x00005b81
    5c44:	0000df78 	.word	0x0000df78
    5c48:	0000df94 	.word	0x0000df94
    5c4c:	00009565 	.word	0x00009565
    5c50:	0000dfac 	.word	0x0000dfac

00005c54 <getCRC>:
{
    5c54:	b510      	push	{r4, lr}
	unsigned char i, crc = 0;
    5c56:	2200      	movs	r2, #0
	for (i = 0; i < length; i++)
    5c58:	2300      	movs	r3, #0
    5c5a:	e003      	b.n	5c64 <getCRC+0x10>
		crc ^= message[i];
    5c5c:	5cc4      	ldrb	r4, [r0, r3]
    5c5e:	4062      	eors	r2, r4
	for (i = 0; i < length; i++)
    5c60:	3301      	adds	r3, #1
    5c62:	b2db      	uxtb	r3, r3
    5c64:	428b      	cmp	r3, r1
    5c66:	d3f9      	bcc.n	5c5c <getCRC+0x8>
}
    5c68:	0010      	movs	r0, r2
    5c6a:	bd10      	pop	{r4, pc}

00005c6c <print_no>:
static void print_no(uint32_t number, uint8_t str_no){
    5c6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5c6e:	0006      	movs	r6, r0
    5c70:	000f      	movs	r7, r1
	unsigned char length = snprintf(buffer, 25, "___%lu", number);
    5c72:	4c10      	ldr	r4, [pc, #64]	; (5cb4 <print_no+0x48>)
    5c74:	0003      	movs	r3, r0
    5c76:	4a10      	ldr	r2, [pc, #64]	; (5cb8 <print_no+0x4c>)
    5c78:	2119      	movs	r1, #25
    5c7a:	0020      	movs	r0, r4
    5c7c:	4d0f      	ldr	r5, [pc, #60]	; (5cbc <print_no+0x50>)
    5c7e:	47a8      	blx	r5
    5c80:	b2c5      	uxtb	r5, r0
	buffer[0] = WRITE_STR;
    5c82:	2302      	movs	r3, #2
    5c84:	7023      	strb	r3, [r4, #0]
	buffer[1] = str_no;
    5c86:	7067      	strb	r7, [r4, #1]
	buffer[2] = length-3;
    5c88:	1eeb      	subs	r3, r5, #3
    5c8a:	70a3      	strb	r3, [r4, #2]
    5c8c:	27ff      	movs	r7, #255	; 0xff
    5c8e:	4007      	ands	r7, r0
	buffer[length] = getCRC(buffer, length);
    5c90:	0029      	movs	r1, r5
    5c92:	0020      	movs	r0, r4
    5c94:	4b0a      	ldr	r3, [pc, #40]	; (5cc0 <print_no+0x54>)
    5c96:	4798      	blx	r3
    5c98:	55e0      	strb	r0, [r4, r7]
	buffer[length+1] = 0; // ????????????
    5c9a:	3701      	adds	r7, #1
    5c9c:	2300      	movs	r3, #0
    5c9e:	55e3      	strb	r3, [r4, r7]
    io_write_clear_ack(buffer, length+1);
    5ca0:	3501      	adds	r5, #1
    5ca2:	b2e9      	uxtb	r1, r5
    5ca4:	0020      	movs	r0, r4
    5ca6:	4b07      	ldr	r3, [pc, #28]	; (5cc4 <print_no+0x58>)
    5ca8:	4798      	blx	r3
	printf("number: %lu\r\n", number);
    5caa:	0031      	movs	r1, r6
    5cac:	4806      	ldr	r0, [pc, #24]	; (5cc8 <print_no+0x5c>)
    5cae:	4b07      	ldr	r3, [pc, #28]	; (5ccc <print_no+0x60>)
    5cb0:	4798      	blx	r3
}
    5cb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5cb4:	20000a84 	.word	0x20000a84
    5cb8:	0000dfbc 	.word	0x0000dfbc
    5cbc:	000097d9 	.word	0x000097d9
    5cc0:	00005c55 	.word	0x00005c55
    5cc4:	00005b95 	.word	0x00005b95
    5cc8:	0000dfc4 	.word	0x0000dfc4
    5ccc:	00009565 	.word	0x00009565

00005cd0 <print_version>:
static void print_version(){
    5cd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	unsigned char length = snprintf(buffer, 25, "___version: %s", VERSION);
    5cd2:	4e11      	ldr	r6, [pc, #68]	; (5d18 <print_version+0x48>)
    5cd4:	4c11      	ldr	r4, [pc, #68]	; (5d1c <print_version+0x4c>)
    5cd6:	0033      	movs	r3, r6
    5cd8:	4a11      	ldr	r2, [pc, #68]	; (5d20 <print_version+0x50>)
    5cda:	2119      	movs	r1, #25
    5cdc:	0020      	movs	r0, r4
    5cde:	4d11      	ldr	r5, [pc, #68]	; (5d24 <print_version+0x54>)
    5ce0:	47a8      	blx	r5
    5ce2:	b2c5      	uxtb	r5, r0
	buffer[0] = WRITE_STR;
    5ce4:	2302      	movs	r3, #2
    5ce6:	7023      	strb	r3, [r4, #0]
	buffer[1] = VERSION_STR;
    5ce8:	330b      	adds	r3, #11
    5cea:	7063      	strb	r3, [r4, #1]
	buffer[2] = length-3;
    5cec:	1eeb      	subs	r3, r5, #3
    5cee:	70a3      	strb	r3, [r4, #2]
    5cf0:	27ff      	movs	r7, #255	; 0xff
    5cf2:	4007      	ands	r7, r0
	buffer[length] = getCRC(buffer, length);
    5cf4:	0029      	movs	r1, r5
    5cf6:	0020      	movs	r0, r4
    5cf8:	4b0b      	ldr	r3, [pc, #44]	; (5d28 <print_version+0x58>)
    5cfa:	4798      	blx	r3
    5cfc:	55e0      	strb	r0, [r4, r7]
	buffer[length+1] = 0; // ????????????
    5cfe:	3701      	adds	r7, #1
    5d00:	2300      	movs	r3, #0
    5d02:	55e3      	strb	r3, [r4, r7]
	io_write_clear_ack(buffer, length+1);
    5d04:	3501      	adds	r5, #1
    5d06:	b2e9      	uxtb	r1, r5
    5d08:	0020      	movs	r0, r4
    5d0a:	4b08      	ldr	r3, [pc, #32]	; (5d2c <print_version+0x5c>)
    5d0c:	4798      	blx	r3
	printf("version: %s\r\n", VERSION);
    5d0e:	0031      	movs	r1, r6
    5d10:	4807      	ldr	r0, [pc, #28]	; (5d30 <print_version+0x60>)
    5d12:	4b08      	ldr	r3, [pc, #32]	; (5d34 <print_version+0x64>)
    5d14:	4798      	blx	r3
}
    5d16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5d18:	0000dfd4 	.word	0x0000dfd4
    5d1c:	20000a84 	.word	0x20000a84
    5d20:	0000dfdc 	.word	0x0000dfdc
    5d24:	000097d9 	.word	0x000097d9
    5d28:	00005c55 	.word	0x00005c55
    5d2c:	00005b95 	.word	0x00005b95
    5d30:	0000dfec 	.word	0x0000dfec
    5d34:	00009565 	.word	0x00009565

00005d38 <switch_to_form>:
{		
    5d38:	b570      	push	{r4, r5, r6, lr}
    5d3a:	0004      	movs	r4, r0
	switch (form){
    5d3c:	280b      	cmp	r0, #11
    5d3e:	d80e      	bhi.n	5d5e <switch_to_form+0x26>
    5d40:	0083      	lsls	r3, r0, #2
    5d42:	4a86      	ldr	r2, [pc, #536]	; (5f5c <switch_to_form+0x224>)
    5d44:	58d3      	ldr	r3, [r2, r3]
    5d46:	469f      	mov	pc, r3
			printf("sw to default form\r\n");
    5d48:	4885      	ldr	r0, [pc, #532]	; (5f60 <switch_to_form+0x228>)
    5d4a:	4b86      	ldr	r3, [pc, #536]	; (5f64 <switch_to_form+0x22c>)
    5d4c:	4798      	blx	r3
			io_write_clear_ack(switch_to_default_form,6);
    5d4e:	2106      	movs	r1, #6
    5d50:	4885      	ldr	r0, [pc, #532]	; (5f68 <switch_to_form+0x230>)
    5d52:	3018      	adds	r0, #24
    5d54:	4b85      	ldr	r3, [pc, #532]	; (5f6c <switch_to_form+0x234>)
    5d56:	4798      	blx	r3
			set_prev_curr_form(form);			
    5d58:	0020      	movs	r0, r4
    5d5a:	4b85      	ldr	r3, [pc, #532]	; (5f70 <switch_to_form+0x238>)
    5d5c:	4798      	blx	r3
}
    5d5e:	bd70      	pop	{r4, r5, r6, pc}
			printf("sw to ses running form\r\n");
    5d60:	4884      	ldr	r0, [pc, #528]	; (5f74 <switch_to_form+0x23c>)
    5d62:	4b80      	ldr	r3, [pc, #512]	; (5f64 <switch_to_form+0x22c>)
    5d64:	4798      	blx	r3
			io_write_clear_ack(switch_to_session_running_form,6);
    5d66:	2106      	movs	r1, #6
    5d68:	487f      	ldr	r0, [pc, #508]	; (5f68 <switch_to_form+0x230>)
    5d6a:	3020      	adds	r0, #32
    5d6c:	4b7f      	ldr	r3, [pc, #508]	; (5f6c <switch_to_form+0x234>)
    5d6e:	4798      	blx	r3
			set_prev_curr_form(form);
    5d70:	0020      	movs	r0, r4
    5d72:	4b7f      	ldr	r3, [pc, #508]	; (5f70 <switch_to_form+0x238>)
    5d74:	4798      	blx	r3
		break;	
    5d76:	e7f2      	b.n	5d5e <switch_to_form+0x26>
			printf("sw to man trig form\r\n");
    5d78:	487f      	ldr	r0, [pc, #508]	; (5f78 <switch_to_form+0x240>)
    5d7a:	4b7a      	ldr	r3, [pc, #488]	; (5f64 <switch_to_form+0x22c>)
    5d7c:	4798      	blx	r3
			io_write_clear_ack(switch_to_manual_trigger_form,6);
    5d7e:	2106      	movs	r1, #6
    5d80:	4879      	ldr	r0, [pc, #484]	; (5f68 <switch_to_form+0x230>)
    5d82:	3028      	adds	r0, #40	; 0x28
    5d84:	4b79      	ldr	r3, [pc, #484]	; (5f6c <switch_to_form+0x234>)
    5d86:	4798      	blx	r3
			set_prev_curr_form(form);
    5d88:	0020      	movs	r0, r4
    5d8a:	4b79      	ldr	r3, [pc, #484]	; (5f70 <switch_to_form+0x238>)
    5d8c:	4798      	blx	r3
			break;
    5d8e:	e7e6      	b.n	5d5e <switch_to_form+0x26>
			printf("sw to sim running form\r\n");
    5d90:	487a      	ldr	r0, [pc, #488]	; (5f7c <switch_to_form+0x244>)
    5d92:	4b74      	ldr	r3, [pc, #464]	; (5f64 <switch_to_form+0x22c>)
    5d94:	4798      	blx	r3
			io_write_clear_ack(switch_to_simulation_running_form,6);
    5d96:	2106      	movs	r1, #6
    5d98:	4873      	ldr	r0, [pc, #460]	; (5f68 <switch_to_form+0x230>)
    5d9a:	3030      	adds	r0, #48	; 0x30
    5d9c:	4b73      	ldr	r3, [pc, #460]	; (5f6c <switch_to_form+0x234>)
    5d9e:	4798      	blx	r3
			set_prev_curr_form(form);
    5da0:	0020      	movs	r0, r4
    5da2:	4b73      	ldr	r3, [pc, #460]	; (5f70 <switch_to_form+0x238>)
    5da4:	4798      	blx	r3
		break;
    5da6:	e7da      	b.n	5d5e <switch_to_form+0x26>
			printf("switch to settings 1 form\r\n");
    5da8:	4875      	ldr	r0, [pc, #468]	; (5f80 <switch_to_form+0x248>)
    5daa:	4b6e      	ldr	r3, [pc, #440]	; (5f64 <switch_to_form+0x22c>)
    5dac:	4798      	blx	r3
			io_write_clear_ack(switch_to_settings_1_form,6);
    5dae:	2106      	movs	r1, #6
    5db0:	486d      	ldr	r0, [pc, #436]	; (5f68 <switch_to_form+0x230>)
    5db2:	3038      	adds	r0, #56	; 0x38
    5db4:	4b6d      	ldr	r3, [pc, #436]	; (5f6c <switch_to_form+0x234>)
    5db6:	4798      	blx	r3
			set_prev_curr_form(form);
    5db8:	0020      	movs	r0, r4
    5dba:	4b6d      	ldr	r3, [pc, #436]	; (5f70 <switch_to_form+0x238>)
    5dbc:	4798      	blx	r3
			if (session_data.response_sound){
    5dbe:	4b71      	ldr	r3, [pc, #452]	; (5f84 <switch_to_form+0x24c>)
    5dc0:	7adb      	ldrb	r3, [r3, #11]
    5dc2:	2b00      	cmp	r3, #0
    5dc4:	d02b      	beq.n	5e1e <switch_to_form+0xe6>
				printf("setting response sound switch and text on\r\n");
    5dc6:	4870      	ldr	r0, [pc, #448]	; (5f88 <switch_to_form+0x250>)
    5dc8:	4b66      	ldr	r3, [pc, #408]	; (5f64 <switch_to_form+0x22c>)
    5dca:	4798      	blx	r3
				io_write_clear_ack(set_response_sound_on,6);
    5dcc:	4c66      	ldr	r4, [pc, #408]	; (5f68 <switch_to_form+0x230>)
    5dce:	0020      	movs	r0, r4
    5dd0:	3040      	adds	r0, #64	; 0x40
    5dd2:	2106      	movs	r1, #6
    5dd4:	4d65      	ldr	r5, [pc, #404]	; (5f6c <switch_to_form+0x234>)
    5dd6:	47a8      	blx	r5
				io_write_clear_ack(set_response_sound_switch_on,6);
    5dd8:	0020      	movs	r0, r4
    5dda:	3048      	adds	r0, #72	; 0x48
    5ddc:	2106      	movs	r1, #6
    5dde:	47a8      	blx	r5
			if (session_data.trigger_sound){
    5de0:	4b68      	ldr	r3, [pc, #416]	; (5f84 <switch_to_form+0x24c>)
    5de2:	7a9b      	ldrb	r3, [r3, #10]
    5de4:	2b00      	cmp	r3, #0
    5de6:	d028      	beq.n	5e3a <switch_to_form+0x102>
				printf("setting trigger sound switch and text on\r\n");
    5de8:	4868      	ldr	r0, [pc, #416]	; (5f8c <switch_to_form+0x254>)
    5dea:	4b5e      	ldr	r3, [pc, #376]	; (5f64 <switch_to_form+0x22c>)
    5dec:	4798      	blx	r3
				io_write_clear_ack(set_trigger_sound_on,6);
    5dee:	4c5e      	ldr	r4, [pc, #376]	; (5f68 <switch_to_form+0x230>)
    5df0:	0020      	movs	r0, r4
    5df2:	3060      	adds	r0, #96	; 0x60
    5df4:	2106      	movs	r1, #6
    5df6:	4d5d      	ldr	r5, [pc, #372]	; (5f6c <switch_to_form+0x234>)
    5df8:	47a8      	blx	r5
				io_write_clear_ack(set_trigger_sound_switch_on,6);
    5dfa:	0020      	movs	r0, r4
    5dfc:	3068      	adds	r0, #104	; 0x68
    5dfe:	2106      	movs	r1, #6
    5e00:	47a8      	blx	r5
				printf("setting trig on slice string\r\n");
    5e02:	4863      	ldr	r0, [pc, #396]	; (5f90 <switch_to_form+0x258>)
    5e04:	4e57      	ldr	r6, [pc, #348]	; (5f64 <switch_to_form+0x22c>)
    5e06:	47b0      	blx	r6
				print_no(session_temp.trig_on_slice, SLICE_TRIGGERNO_STR);
    5e08:	4d62      	ldr	r5, [pc, #392]	; (5f94 <switch_to_form+0x25c>)
    5e0a:	88e8      	ldrh	r0, [r5, #6]
    5e0c:	2104      	movs	r1, #4
    5e0e:	4c62      	ldr	r4, [pc, #392]	; (5f98 <switch_to_form+0x260>)
    5e10:	47a0      	blx	r4
				printf("setting trig on volume string\r\n");
    5e12:	4862      	ldr	r0, [pc, #392]	; (5f9c <switch_to_form+0x264>)
    5e14:	47b0      	blx	r6
				print_no(session_temp.trig_on_volume, VOLUME_TRIGGERNO_STR);
    5e16:	88a8      	ldrh	r0, [r5, #4]
    5e18:	2105      	movs	r1, #5
    5e1a:	47a0      	blx	r4
		break;
    5e1c:	e79f      	b.n	5d5e <switch_to_form+0x26>
				printf("setting response sound switch and text off\r\n");
    5e1e:	4860      	ldr	r0, [pc, #384]	; (5fa0 <switch_to_form+0x268>)
    5e20:	4b50      	ldr	r3, [pc, #320]	; (5f64 <switch_to_form+0x22c>)
    5e22:	4798      	blx	r3
				io_write_clear_ack(set_response_sound_off,6);
    5e24:	4c50      	ldr	r4, [pc, #320]	; (5f68 <switch_to_form+0x230>)
    5e26:	0020      	movs	r0, r4
    5e28:	3050      	adds	r0, #80	; 0x50
    5e2a:	2106      	movs	r1, #6
    5e2c:	4d4f      	ldr	r5, [pc, #316]	; (5f6c <switch_to_form+0x234>)
    5e2e:	47a8      	blx	r5
				io_write_clear_ack(set_response_sound_switch_off,6);
    5e30:	0020      	movs	r0, r4
    5e32:	3058      	adds	r0, #88	; 0x58
    5e34:	2106      	movs	r1, #6
    5e36:	47a8      	blx	r5
    5e38:	e7d2      	b.n	5de0 <switch_to_form+0xa8>
				printf("setting trigger sound switch and text off\r\n");
    5e3a:	485a      	ldr	r0, [pc, #360]	; (5fa4 <switch_to_form+0x26c>)
    5e3c:	4b49      	ldr	r3, [pc, #292]	; (5f64 <switch_to_form+0x22c>)
    5e3e:	4798      	blx	r3
				io_write_clear_ack(set_trigger_sound_off,6);
    5e40:	4c49      	ldr	r4, [pc, #292]	; (5f68 <switch_to_form+0x230>)
    5e42:	0020      	movs	r0, r4
    5e44:	3070      	adds	r0, #112	; 0x70
    5e46:	2106      	movs	r1, #6
    5e48:	4d48      	ldr	r5, [pc, #288]	; (5f6c <switch_to_form+0x234>)
    5e4a:	47a8      	blx	r5
				io_write_clear_ack(set_trigger_sound_switch_off,6);
    5e4c:	0020      	movs	r0, r4
    5e4e:	3078      	adds	r0, #120	; 0x78
    5e50:	2106      	movs	r1, #6
    5e52:	47a8      	blx	r5
    5e54:	e7d5      	b.n	5e02 <switch_to_form+0xca>
			printf("sw to settings 2 form\r\n");
    5e56:	4854      	ldr	r0, [pc, #336]	; (5fa8 <switch_to_form+0x270>)
    5e58:	4d42      	ldr	r5, [pc, #264]	; (5f64 <switch_to_form+0x22c>)
    5e5a:	47a8      	blx	r5
			io_write_clear_ack(switch_to_settings_2_form,6);
    5e5c:	2106      	movs	r1, #6
    5e5e:	4853      	ldr	r0, [pc, #332]	; (5fac <switch_to_form+0x274>)
    5e60:	4b42      	ldr	r3, [pc, #264]	; (5f6c <switch_to_form+0x234>)
    5e62:	4798      	blx	r3
			set_prev_curr_form(form);					
    5e64:	0020      	movs	r0, r4
    5e66:	4b42      	ldr	r3, [pc, #264]	; (5f70 <switch_to_form+0x238>)
    5e68:	4798      	blx	r3
			printf("setting no of volumes string\r\n");
    5e6a:	4851      	ldr	r0, [pc, #324]	; (5fb0 <switch_to_form+0x278>)
    5e6c:	47a8      	blx	r5
			print_no(session_temp.no_of_volumes, SET_VOLUMES_STR);
    5e6e:	4e49      	ldr	r6, [pc, #292]	; (5f94 <switch_to_form+0x25c>)
    5e70:	8830      	ldrh	r0, [r6, #0]
    5e72:	2107      	movs	r1, #7
    5e74:	4c48      	ldr	r4, [pc, #288]	; (5f98 <switch_to_form+0x260>)
    5e76:	47a0      	blx	r4
			printf("setting no of slices string\r\n");
    5e78:	484e      	ldr	r0, [pc, #312]	; (5fb4 <switch_to_form+0x27c>)
    5e7a:	47a8      	blx	r5
			print_no(session_temp.no_of_slices, SET_SLICES_STR);
    5e7c:	8870      	ldrh	r0, [r6, #2]
    5e7e:	2106      	movs	r1, #6
    5e80:	47a0      	blx	r4
			printf("setting pulse length string\r\n"); 
    5e82:	484d      	ldr	r0, [pc, #308]	; (5fb8 <switch_to_form+0x280>)
    5e84:	47a8      	blx	r5
 			print_no(session_temp.pulse_length, PULSE_LENGTH_STR);
    5e86:	8930      	ldrh	r0, [r6, #8]
    5e88:	2108      	movs	r1, #8
    5e8a:	47a0      	blx	r4
			printf("setting TR time string\r\n");
    5e8c:	484b      	ldr	r0, [pc, #300]	; (5fbc <switch_to_form+0x284>)
    5e8e:	47a8      	blx	r5
 			print_no(session_temp.TR_time, TR_TIME_STR);
    5e90:	68f0      	ldr	r0, [r6, #12]
    5e92:	2109      	movs	r1, #9
    5e94:	47a0      	blx	r4
		break;
    5e96:	e762      	b.n	5d5e <switch_to_form+0x26>
			printf("sw to settings 3 form\r\n");
    5e98:	4849      	ldr	r0, [pc, #292]	; (5fc0 <switch_to_form+0x288>)
    5e9a:	4b32      	ldr	r3, [pc, #200]	; (5f64 <switch_to_form+0x22c>)
    5e9c:	4798      	blx	r3
			io_write_clear_ack(switch_to_settings_3_form,6);
    5e9e:	2106      	movs	r1, #6
    5ea0:	4842      	ldr	r0, [pc, #264]	; (5fac <switch_to_form+0x274>)
    5ea2:	3008      	adds	r0, #8
    5ea4:	4b31      	ldr	r3, [pc, #196]	; (5f6c <switch_to_form+0x234>)
    5ea6:	4798      	blx	r3
			set_prev_curr_form(form);
    5ea8:	0020      	movs	r0, r4
    5eaa:	4b31      	ldr	r3, [pc, #196]	; (5f70 <switch_to_form+0x238>)
    5eac:	4798      	blx	r3
		break;
    5eae:	e756      	b.n	5d5e <switch_to_form+0x26>
			printf("sw to keyboard form\r\n");
    5eb0:	4844      	ldr	r0, [pc, #272]	; (5fc4 <switch_to_form+0x28c>)
    5eb2:	4b2c      	ldr	r3, [pc, #176]	; (5f64 <switch_to_form+0x22c>)
    5eb4:	4798      	blx	r3
			io_write_clear_ack(switch_to_keyboard_form,6);
    5eb6:	2106      	movs	r1, #6
    5eb8:	483c      	ldr	r0, [pc, #240]	; (5fac <switch_to_form+0x274>)
    5eba:	3010      	adds	r0, #16
    5ebc:	4b2b      	ldr	r3, [pc, #172]	; (5f6c <switch_to_form+0x234>)
    5ebe:	4798      	blx	r3
			set_prev_curr_form(form);
    5ec0:	0020      	movs	r0, r4
    5ec2:	4b2b      	ldr	r3, [pc, #172]	; (5f70 <switch_to_form+0x238>)
    5ec4:	4798      	blx	r3
		break;
    5ec6:	e74a      	b.n	5d5e <switch_to_form+0x26>
			printf("sw to menu form\r\n");
    5ec8:	483f      	ldr	r0, [pc, #252]	; (5fc8 <switch_to_form+0x290>)
    5eca:	4b26      	ldr	r3, [pc, #152]	; (5f64 <switch_to_form+0x22c>)
    5ecc:	4798      	blx	r3
			io_write_clear_ack(switch_to_menu_form,6);
    5ece:	2106      	movs	r1, #6
    5ed0:	4836      	ldr	r0, [pc, #216]	; (5fac <switch_to_form+0x274>)
    5ed2:	3018      	adds	r0, #24
    5ed4:	4b25      	ldr	r3, [pc, #148]	; (5f6c <switch_to_form+0x234>)
    5ed6:	4798      	blx	r3
			set_prev_curr_form(form);
    5ed8:	0020      	movs	r0, r4
    5eda:	4b25      	ldr	r3, [pc, #148]	; (5f70 <switch_to_form+0x238>)
    5edc:	4798      	blx	r3
		break;		
    5ede:	e73e      	b.n	5d5e <switch_to_form+0x26>
			printf("sw to about form\r\n");
    5ee0:	483a      	ldr	r0, [pc, #232]	; (5fcc <switch_to_form+0x294>)
    5ee2:	4b20      	ldr	r3, [pc, #128]	; (5f64 <switch_to_form+0x22c>)
    5ee4:	4798      	blx	r3
			io_write_clear_ack(switch_to_about_form,6);
    5ee6:	2106      	movs	r1, #6
    5ee8:	4830      	ldr	r0, [pc, #192]	; (5fac <switch_to_form+0x274>)
    5eea:	3020      	adds	r0, #32
    5eec:	4b1f      	ldr	r3, [pc, #124]	; (5f6c <switch_to_form+0x234>)
    5eee:	4798      	blx	r3
			print_version();
    5ef0:	4b37      	ldr	r3, [pc, #220]	; (5fd0 <switch_to_form+0x298>)
    5ef2:	4798      	blx	r3
			set_prev_curr_form(form);
    5ef4:	0020      	movs	r0, r4
    5ef6:	4b1e      	ldr	r3, [pc, #120]	; (5f70 <switch_to_form+0x238>)
    5ef8:	4798      	blx	r3
		break;
    5efa:	e730      	b.n	5d5e <switch_to_form+0x26>
			printf("sw to error form\r\n");
    5efc:	4835      	ldr	r0, [pc, #212]	; (5fd4 <switch_to_form+0x29c>)
    5efe:	4b19      	ldr	r3, [pc, #100]	; (5f64 <switch_to_form+0x22c>)
    5f00:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    5f02:	23c0      	movs	r3, #192	; 0xc0
    5f04:	05db      	lsls	r3, r3, #23
    5f06:	2280      	movs	r2, #128	; 0x80
    5f08:	0212      	lsls	r2, r2, #8
    5f0a:	615a      	str	r2, [r3, #20]
    5f0c:	2280      	movs	r2, #128	; 0x80
    5f0e:	01d2      	lsls	r2, r2, #7
    5f10:	615a      	str	r2, [r3, #20]
    5f12:	2294      	movs	r2, #148	; 0x94
    5f14:	2180      	movs	r1, #128	; 0x80
    5f16:	0249      	lsls	r1, r1, #9
    5f18:	5099      	str	r1, [r3, r2]
    5f1a:	2180      	movs	r1, #128	; 0x80
    5f1c:	0289      	lsls	r1, r1, #10
    5f1e:	5099      	str	r1, [r3, r2]
    5f20:	2280      	movs	r2, #128	; 0x80
    5f22:	0352      	lsls	r2, r2, #13
    5f24:	615a      	str	r2, [r3, #20]
    5f26:	2280      	movs	r2, #128	; 0x80
    5f28:	0392      	lsls	r2, r2, #14
    5f2a:	615a      	str	r2, [r3, #20]
    5f2c:	2280      	movs	r2, #128	; 0x80
    5f2e:	0192      	lsls	r2, r2, #6
    5f30:	615a      	str	r2, [r3, #20]
				session_data.session_running = false;
    5f32:	4b14      	ldr	r3, [pc, #80]	; (5f84 <switch_to_form+0x24c>)
    5f34:	2200      	movs	r2, #0
    5f36:	709a      	strb	r2, [r3, #2]
				session_data.simulation_mode = false;
    5f38:	70da      	strb	r2, [r3, #3]
				session_data.manual_trigger=false;
    5f3a:	711a      	strb	r2, [r3, #4]
				session_data.trigger = false;
    5f3c:	715a      	strb	r2, [r3, #5]
				session_data.current_volume = 1;
    5f3e:	2101      	movs	r1, #1
    5f40:	8319      	strh	r1, [r3, #24]
				session_data.current_slice = 0;
    5f42:	835a      	strh	r2, [r3, #26]
			io_write_clear_ack(switch_to_error_form,6);
    5f44:	3105      	adds	r1, #5
    5f46:	4819      	ldr	r0, [pc, #100]	; (5fac <switch_to_form+0x274>)
    5f48:	3028      	adds	r0, #40	; 0x28
    5f4a:	4b08      	ldr	r3, [pc, #32]	; (5f6c <switch_to_form+0x234>)
    5f4c:	4798      	blx	r3
			set_prev_curr_form(form);
    5f4e:	0020      	movs	r0, r4
    5f50:	4b07      	ldr	r3, [pc, #28]	; (5f70 <switch_to_form+0x238>)
    5f52:	4798      	blx	r3
			error_beep_length = ERROR_BEEP_LENGTH;
    5f54:	4a20      	ldr	r2, [pc, #128]	; (5fd8 <switch_to_form+0x2a0>)
    5f56:	4b21      	ldr	r3, [pc, #132]	; (5fdc <switch_to_form+0x2a4>)
    5f58:	80da      	strh	r2, [r3, #6]
}
    5f5a:	e700      	b.n	5d5e <switch_to_form+0x26>
    5f5c:	0000ad20 	.word	0x0000ad20
    5f60:	0000dffc 	.word	0x0000dffc
    5f64:	00009659 	.word	0x00009659
    5f68:	0000daf4 	.word	0x0000daf4
    5f6c:	00005b95 	.word	0x00005b95
    5f70:	00005425 	.word	0x00005425
    5f74:	0000e010 	.word	0x0000e010
    5f78:	0000e028 	.word	0x0000e028
    5f7c:	0000e040 	.word	0x0000e040
    5f80:	0000e058 	.word	0x0000e058
    5f84:	20000a3c 	.word	0x20000a3c
    5f88:	0000e074 	.word	0x0000e074
    5f8c:	0000e0cc 	.word	0x0000e0cc
    5f90:	0000e124 	.word	0x0000e124
    5f94:	20000a68 	.word	0x20000a68
    5f98:	00005c6d 	.word	0x00005c6d
    5f9c:	0000e144 	.word	0x0000e144
    5fa0:	0000e0a0 	.word	0x0000e0a0
    5fa4:	0000e0f8 	.word	0x0000e0f8
    5fa8:	0000e164 	.word	0x0000e164
    5fac:	0000db74 	.word	0x0000db74
    5fb0:	0000e17c 	.word	0x0000e17c
    5fb4:	0000e19c 	.word	0x0000e19c
    5fb8:	0000e1bc 	.word	0x0000e1bc
    5fbc:	0000e1dc 	.word	0x0000e1dc
    5fc0:	0000e1f4 	.word	0x0000e1f4
    5fc4:	0000e20c 	.word	0x0000e20c
    5fc8:	0000e224 	.word	0x0000e224
    5fcc:	0000e238 	.word	0x0000e238
    5fd0:	00005cd1 	.word	0x00005cd1
    5fd4:	0000e24c 	.word	0x0000e24c
    5fd8:	00000c82 	.word	0x00000c82
    5fdc:	20000740 	.word	0x20000740

00005fe0 <print_slices>:
static void print_slices(uint8_t str_no){
    5fe0:	b5f0      	push	{r4, r5, r6, r7, lr}
    5fe2:	b083      	sub	sp, #12
    5fe4:	0006      	movs	r6, r0
	uint8_t length = snprintf(buffer, 64, "___%u / %u    ", session_data.current_slice, session_data.no_of_slices);
    5fe6:	4f12      	ldr	r7, [pc, #72]	; (6030 <print_slices+0x50>)
    5fe8:	8b7b      	ldrh	r3, [r7, #26]
    5fea:	8a7a      	ldrh	r2, [r7, #18]
    5fec:	4c11      	ldr	r4, [pc, #68]	; (6034 <print_slices+0x54>)
    5fee:	9200      	str	r2, [sp, #0]
    5ff0:	4a11      	ldr	r2, [pc, #68]	; (6038 <print_slices+0x58>)
    5ff2:	2140      	movs	r1, #64	; 0x40
    5ff4:	0020      	movs	r0, r4
    5ff6:	4d11      	ldr	r5, [pc, #68]	; (603c <print_slices+0x5c>)
    5ff8:	47a8      	blx	r5
    5ffa:	b2c5      	uxtb	r5, r0
	buffer[0] = WRITE_STR;
    5ffc:	2302      	movs	r3, #2
    5ffe:	7023      	strb	r3, [r4, #0]
	buffer[1] = str_no;
    6000:	7066      	strb	r6, [r4, #1]
	buffer[2] = length-3;
    6002:	1eeb      	subs	r3, r5, #3
    6004:	70a3      	strb	r3, [r4, #2]
    6006:	26ff      	movs	r6, #255	; 0xff
    6008:	4006      	ands	r6, r0
	buffer[length] = getCRC(buffer, length);
    600a:	0029      	movs	r1, r5
    600c:	0020      	movs	r0, r4
    600e:	4b0c      	ldr	r3, [pc, #48]	; (6040 <print_slices+0x60>)
    6010:	4798      	blx	r3
    6012:	55a0      	strb	r0, [r4, r6]
	buffer[length+1] = 0; // ????????????
    6014:	3601      	adds	r6, #1
    6016:	2300      	movs	r3, #0
    6018:	55a3      	strb	r3, [r4, r6]
	io_write_clear_ack(buffer,length+1);
    601a:	3501      	adds	r5, #1
    601c:	b2e9      	uxtb	r1, r5
    601e:	0020      	movs	r0, r4
    6020:	4b08      	ldr	r3, [pc, #32]	; (6044 <print_slices+0x64>)
    6022:	4798      	blx	r3
	printf("current slice: %u\r\n", session_data.current_slice);
    6024:	8b79      	ldrh	r1, [r7, #26]
    6026:	4808      	ldr	r0, [pc, #32]	; (6048 <print_slices+0x68>)
    6028:	4b08      	ldr	r3, [pc, #32]	; (604c <print_slices+0x6c>)
    602a:	4798      	blx	r3
}
    602c:	b003      	add	sp, #12
    602e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6030:	20000a3c 	.word	0x20000a3c
    6034:	20000a84 	.word	0x20000a84
    6038:	0000e260 	.word	0x0000e260
    603c:	000097d9 	.word	0x000097d9
    6040:	00005c55 	.word	0x00005c55
    6044:	00005b95 	.word	0x00005b95
    6048:	0000e270 	.word	0x0000e270
    604c:	00009565 	.word	0x00009565

00006050 <print_volumes>:
static void print_volumes(uint8_t str_no){
    6050:	b5f0      	push	{r4, r5, r6, r7, lr}
    6052:	b083      	sub	sp, #12
    6054:	0006      	movs	r6, r0
	uint8_t length = snprintf(buffer, 64, "___%u / %u    ", session_data.current_volume, session_data.no_of_volumes);
    6056:	4f12      	ldr	r7, [pc, #72]	; (60a0 <print_volumes+0x50>)
    6058:	8b3b      	ldrh	r3, [r7, #24]
    605a:	8a3a      	ldrh	r2, [r7, #16]
    605c:	4c11      	ldr	r4, [pc, #68]	; (60a4 <print_volumes+0x54>)
    605e:	9200      	str	r2, [sp, #0]
    6060:	4a11      	ldr	r2, [pc, #68]	; (60a8 <print_volumes+0x58>)
    6062:	2140      	movs	r1, #64	; 0x40
    6064:	0020      	movs	r0, r4
    6066:	4d11      	ldr	r5, [pc, #68]	; (60ac <print_volumes+0x5c>)
    6068:	47a8      	blx	r5
    606a:	b2c5      	uxtb	r5, r0
	buffer[0] = WRITE_STR;
    606c:	2302      	movs	r3, #2
    606e:	7023      	strb	r3, [r4, #0]
	buffer[1] = str_no;
    6070:	7066      	strb	r6, [r4, #1]
	buffer[2] = length-3;
    6072:	1eeb      	subs	r3, r5, #3
    6074:	70a3      	strb	r3, [r4, #2]
    6076:	26ff      	movs	r6, #255	; 0xff
    6078:	4006      	ands	r6, r0
	buffer[length] = getCRC(buffer, length);
    607a:	0029      	movs	r1, r5
    607c:	0020      	movs	r0, r4
    607e:	4b0c      	ldr	r3, [pc, #48]	; (60b0 <print_volumes+0x60>)
    6080:	4798      	blx	r3
    6082:	55a0      	strb	r0, [r4, r6]
	buffer[length+1] = 0; // ????????????
    6084:	3601      	adds	r6, #1
    6086:	2300      	movs	r3, #0
    6088:	55a3      	strb	r3, [r4, r6]
	io_write_clear_ack(buffer,length+1);
    608a:	3501      	adds	r5, #1
    608c:	b2e9      	uxtb	r1, r5
    608e:	0020      	movs	r0, r4
    6090:	4b08      	ldr	r3, [pc, #32]	; (60b4 <print_volumes+0x64>)
    6092:	4798      	blx	r3
	printf("**********current volume: %u\r\n", session_data.current_volume);
    6094:	8b39      	ldrh	r1, [r7, #24]
    6096:	4808      	ldr	r0, [pc, #32]	; (60b8 <print_volumes+0x68>)
    6098:	4b08      	ldr	r3, [pc, #32]	; (60bc <print_volumes+0x6c>)
    609a:	4798      	blx	r3
}
    609c:	b003      	add	sp, #12
    609e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    60a0:	20000a3c 	.word	0x20000a3c
    60a4:	20000a84 	.word	0x20000a84
    60a8:	0000e260 	.word	0x0000e260
    60ac:	000097d9 	.word	0x000097d9
    60b0:	00005c55 	.word	0x00005c55
    60b4:	00005b95 	.word	0x00005b95
    60b8:	0000e284 	.word	0x0000e284
    60bc:	00009565 	.word	0x00009565

000060c0 <ADC_init>:
{
    60c0:	b570      	push	{r4, r5, r6, lr}
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, convert_cb_ADC_0);
    60c2:	4c06      	ldr	r4, [pc, #24]	; (60dc <ADC_init+0x1c>)
    60c4:	4b06      	ldr	r3, [pc, #24]	; (60e0 <ADC_init+0x20>)
    60c6:	2200      	movs	r2, #0
    60c8:	2100      	movs	r1, #0
    60ca:	0020      	movs	r0, r4
    60cc:	4d05      	ldr	r5, [pc, #20]	; (60e4 <ADC_init+0x24>)
    60ce:	47a8      	blx	r5
	adc_async_enable_channel(&ADC_0, 0);
    60d0:	2100      	movs	r1, #0
    60d2:	0020      	movs	r0, r4
    60d4:	4b04      	ldr	r3, [pc, #16]	; (60e8 <ADC_init+0x28>)
    60d6:	4798      	blx	r3
}
    60d8:	bd70      	pop	{r4, r5, r6, pc}
    60da:	46c0      	nop			; (mov r8, r8)
    60dc:	2000091c 	.word	0x2000091c
    60e0:	00005505 	.word	0x00005505
    60e4:	000010f5 	.word	0x000010f5
    60e8:	000010b5 	.word	0x000010b5

000060ec <ps_error>:
void ps_error(){
    60ec:	b510      	push	{r4, lr}
	switch_to_form(ERROR_FORM);
    60ee:	200b      	movs	r0, #11
    60f0:	4b13      	ldr	r3, [pc, #76]	; (6140 <ps_error+0x54>)
    60f2:	4798      	blx	r3
	if (adc_value < 1550){
    60f4:	4b13      	ldr	r3, [pc, #76]	; (6144 <ps_error+0x58>)
    60f6:	885a      	ldrh	r2, [r3, #2]
    60f8:	4b13      	ldr	r3, [pc, #76]	; (6148 <ps_error+0x5c>)
    60fa:	429a      	cmp	r2, r3
    60fc:	d90b      	bls.n	6116 <ps_error+0x2a>
	if (adc_value > 2000){
    60fe:	4b11      	ldr	r3, [pc, #68]	; (6144 <ps_error+0x58>)
    6100:	885a      	ldrh	r2, [r3, #2]
    6102:	23fa      	movs	r3, #250	; 0xfa
    6104:	00db      	lsls	r3, r3, #3
    6106:	429a      	cmp	r2, r3
    6108:	d80f      	bhi.n	612a <ps_error+0x3e>
	printf("psup voltage is %d\r\n", adc_value);
    610a:	4b0e      	ldr	r3, [pc, #56]	; (6144 <ps_error+0x58>)
    610c:	8859      	ldrh	r1, [r3, #2]
    610e:	480f      	ldr	r0, [pc, #60]	; (614c <ps_error+0x60>)
    6110:	4b0f      	ldr	r3, [pc, #60]	; (6150 <ps_error+0x64>)
    6112:	4798      	blx	r3
}
    6114:	bd10      	pop	{r4, pc}
		io_write_clear_ack(set_error_text_PS_low,6);
    6116:	2106      	movs	r1, #6
    6118:	480e      	ldr	r0, [pc, #56]	; (6154 <ps_error+0x68>)
    611a:	4b0f      	ldr	r3, [pc, #60]	; (6158 <ps_error+0x6c>)
    611c:	4798      	blx	r3
		printf("!!!!!!!!!!!!!!!!!!!");
    611e:	480f      	ldr	r0, [pc, #60]	; (615c <ps_error+0x70>)
    6120:	4c0b      	ldr	r4, [pc, #44]	; (6150 <ps_error+0x64>)
    6122:	47a0      	blx	r4
		printf("ps voltage too low");
    6124:	480e      	ldr	r0, [pc, #56]	; (6160 <ps_error+0x74>)
    6126:	47a0      	blx	r4
    6128:	e7e9      	b.n	60fe <ps_error+0x12>
		io_write_clear_ack(set_error_text_PS_high,6);
    612a:	2106      	movs	r1, #6
    612c:	4809      	ldr	r0, [pc, #36]	; (6154 <ps_error+0x68>)
    612e:	3008      	adds	r0, #8
    6130:	4b09      	ldr	r3, [pc, #36]	; (6158 <ps_error+0x6c>)
    6132:	4798      	blx	r3
		printf("!!!!!!!!!!!!!!!!!!!");
    6134:	4809      	ldr	r0, [pc, #36]	; (615c <ps_error+0x70>)
    6136:	4c06      	ldr	r4, [pc, #24]	; (6150 <ps_error+0x64>)
    6138:	47a0      	blx	r4
		printf("ps voltage too high");
    613a:	480a      	ldr	r0, [pc, #40]	; (6164 <ps_error+0x78>)
    613c:	47a0      	blx	r4
    613e:	e7e4      	b.n	610a <ps_error+0x1e>
    6140:	00005d39 	.word	0x00005d39
    6144:	20000740 	.word	0x20000740
    6148:	0000060d 	.word	0x0000060d
    614c:	0000e2e0 	.word	0x0000e2e0
    6150:	00009565 	.word	0x00009565
    6154:	0000ae08 	.word	0x0000ae08
    6158:	00005b95 	.word	0x00005b95
    615c:	0000e2a4 	.word	0x0000e2a4
    6160:	0000e2b8 	.word	0x0000e2b8
    6164:	0000e2cc 	.word	0x0000e2cc

00006168 <usb_error>:
void usb_error(){
    6168:	b510      	push	{r4, lr}
	switch_to_form(ERROR_FORM);	
    616a:	200b      	movs	r0, #11
    616c:	4b0d      	ldr	r3, [pc, #52]	; (61a4 <usb_error+0x3c>)
    616e:	4798      	blx	r3
	io_write_clear_ack(set_error_text_USB_error,6);
    6170:	2106      	movs	r1, #6
    6172:	480d      	ldr	r0, [pc, #52]	; (61a8 <usb_error+0x40>)
    6174:	3010      	adds	r0, #16
    6176:	4b0d      	ldr	r3, [pc, #52]	; (61ac <usb_error+0x44>)
    6178:	4798      	blx	r3
	printf("!!!!!!!!!!!!!!!!!!!\r\n");
    617a:	480d      	ldr	r0, [pc, #52]	; (61b0 <usb_error+0x48>)
    617c:	4c0d      	ldr	r4, [pc, #52]	; (61b4 <usb_error+0x4c>)
    617e:	47a0      	blx	r4
	printf("USB error\r\n");
    6180:	480d      	ldr	r0, [pc, #52]	; (61b8 <usb_error+0x50>)
    6182:	47a0      	blx	r4
	while (usb_disconnected){
    6184:	e002      	b.n	618c <usb_error+0x24>
		delay_ms(1);		// delay nlkl release-ban nem mkdik, csak debug-ban!!!!!
    6186:	2001      	movs	r0, #1
    6188:	4b0c      	ldr	r3, [pc, #48]	; (61bc <usb_error+0x54>)
    618a:	4798      	blx	r3
	while (usb_disconnected){
    618c:	4b0c      	ldr	r3, [pc, #48]	; (61c0 <usb_error+0x58>)
    618e:	881b      	ldrh	r3, [r3, #0]
    6190:	2b00      	cmp	r3, #0
    6192:	d1f8      	bne.n	6186 <usb_error+0x1e>
	printf("USB connection ok\r\n");
    6194:	480b      	ldr	r0, [pc, #44]	; (61c4 <usb_error+0x5c>)
    6196:	4b07      	ldr	r3, [pc, #28]	; (61b4 <usb_error+0x4c>)
    6198:	4798      	blx	r3
	switch_to_form(DEFAULT_FORM);
    619a:	2000      	movs	r0, #0
    619c:	4b01      	ldr	r3, [pc, #4]	; (61a4 <usb_error+0x3c>)
    619e:	4798      	blx	r3
}
    61a0:	bd10      	pop	{r4, pc}
    61a2:	46c0      	nop			; (mov r8, r8)
    61a4:	00005d39 	.word	0x00005d39
    61a8:	0000ae08 	.word	0x0000ae08
    61ac:	00005b95 	.word	0x00005b95
    61b0:	0000e2f8 	.word	0x0000e2f8
    61b4:	00009659 	.word	0x00009659
    61b8:	0000e310 	.word	0x0000e310
    61bc:	0000141d 	.word	0x0000141d
    61c0:	20000180 	.word	0x20000180
    61c4:	0000e31c 	.word	0x0000e31c

000061c8 <start_simulation>:
{
    61c8:	b570      	push	{r4, r5, r6, lr}
	printf("starting simulation\r\n");
    61ca:	4817      	ldr	r0, [pc, #92]	; (6228 <start_simulation+0x60>)
    61cc:	4d17      	ldr	r5, [pc, #92]	; (622c <start_simulation+0x64>)
    61ce:	47a8      	blx	r5
	pulse_counter = 0;
    61d0:	4917      	ldr	r1, [pc, #92]	; (6230 <start_simulation+0x68>)
    61d2:	2200      	movs	r2, #0
    61d4:	2300      	movs	r3, #0
    61d6:	820a      	strh	r2, [r1, #16]
	TR_counter = 0;
    61d8:	824a      	strh	r2, [r1, #18]
	session_data.trig_LED_on = false;
    61da:	4c16      	ldr	r4, [pc, #88]	; (6234 <start_simulation+0x6c>)
    61dc:	7023      	strb	r3, [r4, #0]
	session_data.trigger = false;
    61de:	7163      	strb	r3, [r4, #5]
	session_data.current_volume = 1;
    61e0:	2101      	movs	r1, #1
    61e2:	8321      	strh	r1, [r4, #24]
	session_data.current_slice = 0;
    61e4:	8362      	strh	r2, [r4, #26]
	session_data.previous_volume = session_data.no_of_volumes;
    61e6:	8a21      	ldrh	r1, [r4, #16]
    61e8:	83a1      	strh	r1, [r4, #28]
	session_data.previous_slice = 0;
    61ea:	83e2      	strh	r2, [r4, #30]
	session_data.simulated_A=false;
    61ec:	71a3      	strb	r3, [r4, #6]
	session_data.simulated_B=false;
    61ee:	71e3      	strb	r3, [r4, #7]
	session_data.simulated_C=false;
    61f0:	7223      	strb	r3, [r4, #8]
	session_data.simulated_D=false;
    61f2:	7263      	strb	r3, [r4, #9]
	session_data.manual_trigger=false;
    61f4:	7123      	strb	r3, [r4, #4]
	session_data.session_running = false;
    61f6:	70a3      	strb	r3, [r4, #2]
	session_data.session_finished = false;
    61f8:	7063      	strb	r3, [r4, #1]
	switch_to_form(SIMULATION_RUNNING_FORM);
    61fa:	2003      	movs	r0, #3
    61fc:	4b0e      	ldr	r3, [pc, #56]	; (6238 <start_simulation+0x70>)
    61fe:	4798      	blx	r3
	printf("setting current slice string\r\n");
    6200:	480e      	ldr	r0, [pc, #56]	; (623c <start_simulation+0x74>)
    6202:	47a8      	blx	r5
	print_slices(SIMULATION_CURRENT_SLICE_STR);
    6204:	200e      	movs	r0, #14
    6206:	4b0e      	ldr	r3, [pc, #56]	; (6240 <start_simulation+0x78>)
    6208:	4798      	blx	r3
	printf("setting current volume string\r\n");	
    620a:	480e      	ldr	r0, [pc, #56]	; (6244 <start_simulation+0x7c>)
    620c:	47a8      	blx	r5
	print_volumes(SIMULATION_CURRENT_VOLUME_STR);
    620e:	200f      	movs	r0, #15
    6210:	4b0d      	ldr	r3, [pc, #52]	; (6248 <start_simulation+0x80>)
    6212:	4798      	blx	r3
	printf("playing start sound\r\n");
    6214:	480d      	ldr	r0, [pc, #52]	; (624c <start_simulation+0x84>)
    6216:	47a8      	blx	r5
	delay_ms(1000);
    6218:	20fa      	movs	r0, #250	; 0xfa
    621a:	0080      	lsls	r0, r0, #2
    621c:	4b0c      	ldr	r3, [pc, #48]	; (6250 <start_simulation+0x88>)
    621e:	4798      	blx	r3
	session_data.simulation_mode=true;	
    6220:	2301      	movs	r3, #1
    6222:	70e3      	strb	r3, [r4, #3]
}
    6224:	bd70      	pop	{r4, r5, r6, pc}
    6226:	46c0      	nop			; (mov r8, r8)
    6228:	0000e330 	.word	0x0000e330
    622c:	00009659 	.word	0x00009659
    6230:	20000740 	.word	0x20000740
    6234:	20000a3c 	.word	0x20000a3c
    6238:	00005d39 	.word	0x00005d39
    623c:	0000e348 	.word	0x0000e348
    6240:	00005fe1 	.word	0x00005fe1
    6244:	0000e368 	.word	0x0000e368
    6248:	00006051 	.word	0x00006051
    624c:	0000e388 	.word	0x0000e388
    6250:	0000141d 	.word	0x0000141d

00006254 <stop_simulation>:
{
    6254:	b510      	push	{r4, lr}
	printf("stopping simulation\r\n");
    6256:	480b      	ldr	r0, [pc, #44]	; (6284 <stop_simulation+0x30>)
    6258:	4b0b      	ldr	r3, [pc, #44]	; (6288 <stop_simulation+0x34>)
    625a:	4798      	blx	r3
	pb_received = false;
    625c:	2400      	movs	r4, #0
    625e:	4b0b      	ldr	r3, [pc, #44]	; (628c <stop_simulation+0x38>)
    6260:	701c      	strb	r4, [r3, #0]
	io_write_clear_ack(simulation_trigger_LED_off,6);
    6262:	2106      	movs	r1, #6
    6264:	480a      	ldr	r0, [pc, #40]	; (6290 <stop_simulation+0x3c>)
    6266:	3018      	adds	r0, #24
    6268:	4b0a      	ldr	r3, [pc, #40]	; (6294 <stop_simulation+0x40>)
    626a:	4798      	blx	r3
	switch_to_form(MENU_FORM);
    626c:	2007      	movs	r0, #7
    626e:	4b0a      	ldr	r3, [pc, #40]	; (6298 <stop_simulation+0x44>)
    6270:	4798      	blx	r3
	session_data.session_running = false;
    6272:	4b0a      	ldr	r3, [pc, #40]	; (629c <stop_simulation+0x48>)
    6274:	709c      	strb	r4, [r3, #2]
	session_data.simulation_mode = false;
    6276:	70dc      	strb	r4, [r3, #3]
	session_data.manual_trigger=false;
    6278:	711c      	strb	r4, [r3, #4]
	session_data.trigger = false;
    627a:	715c      	strb	r4, [r3, #5]
	session_data.current_volume = 1;
    627c:	2201      	movs	r2, #1
    627e:	831a      	strh	r2, [r3, #24]
	session_data.current_slice = 0;
    6280:	835c      	strh	r4, [r3, #26]
}
    6282:	bd10      	pop	{r4, pc}
    6284:	0000e3a0 	.word	0x0000e3a0
    6288:	00009659 	.word	0x00009659
    628c:	20000740 	.word	0x20000740
    6290:	0000ae08 	.word	0x0000ae08
    6294:	00005b95 	.word	0x00005b95
    6298:	00005d39 	.word	0x00005d39
    629c:	20000a3c 	.word	0x20000a3c

000062a0 <start_man_trig>:
{
    62a0:	b570      	push	{r4, r5, r6, lr}
	printf("starting manual trigger\r\n");
    62a2:	4813      	ldr	r0, [pc, #76]	; (62f0 <start_man_trig+0x50>)
    62a4:	4d13      	ldr	r5, [pc, #76]	; (62f4 <start_man_trig+0x54>)
    62a6:	47a8      	blx	r5
	session_data.trig_LED_on = false;
    62a8:	4c13      	ldr	r4, [pc, #76]	; (62f8 <start_man_trig+0x58>)
    62aa:	2200      	movs	r2, #0
    62ac:	7022      	strb	r2, [r4, #0]
	session_data.trigger = false;
    62ae:	7162      	strb	r2, [r4, #5]
	session_data.current_volume = 1;
    62b0:	2301      	movs	r3, #1
    62b2:	8323      	strh	r3, [r4, #24]
	session_data.current_slice = 0;
    62b4:	2300      	movs	r3, #0
    62b6:	8362      	strh	r2, [r4, #26]
	session_data.previous_volume = session_data.no_of_volumes;
    62b8:	8a21      	ldrh	r1, [r4, #16]
    62ba:	83a1      	strh	r1, [r4, #28]
	session_data.previous_slice = 0;
    62bc:	83e2      	strh	r2, [r4, #30]
	session_data.simulated_A=false;
    62be:	71a3      	strb	r3, [r4, #6]
	session_data.simulated_B=false;
    62c0:	71e3      	strb	r3, [r4, #7]
	session_data.simulated_C=false;
    62c2:	7223      	strb	r3, [r4, #8]
	session_data.simulated_D=false;
    62c4:	7263      	strb	r3, [r4, #9]
	session_data.simulation_mode=false;
    62c6:	70e3      	strb	r3, [r4, #3]
	session_data.session_running= false;
    62c8:	70a3      	strb	r3, [r4, #2]
	session_data.session_finished = false;	
    62ca:	7063      	strb	r3, [r4, #1]
	switch_to_form(MANUAL_TRIGGER_FORM);
    62cc:	2002      	movs	r0, #2
    62ce:	4b0b      	ldr	r3, [pc, #44]	; (62fc <start_man_trig+0x5c>)
    62d0:	4798      	blx	r3
	printf("setting current slice string\r\n");
    62d2:	480b      	ldr	r0, [pc, #44]	; (6300 <start_man_trig+0x60>)
    62d4:	47a8      	blx	r5
	print_slices(MAN_TRIG_CURRENT_SLICE_STR);
    62d6:	2010      	movs	r0, #16
    62d8:	4b0a      	ldr	r3, [pc, #40]	; (6304 <start_man_trig+0x64>)
    62da:	4798      	blx	r3
	printf("setting current volume string\r\n");
    62dc:	480a      	ldr	r0, [pc, #40]	; (6308 <start_man_trig+0x68>)
    62de:	47a8      	blx	r5
	print_volumes(MAN_TRIG_CURRENT_VOLUME_STR);
    62e0:	2011      	movs	r0, #17
    62e2:	4b0a      	ldr	r3, [pc, #40]	; (630c <start_man_trig+0x6c>)
    62e4:	4798      	blx	r3
	printf("playing start sound\r\n");
    62e6:	480a      	ldr	r0, [pc, #40]	; (6310 <start_man_trig+0x70>)
    62e8:	47a8      	blx	r5
	session_data.manual_trigger=true;	
    62ea:	2301      	movs	r3, #1
    62ec:	7123      	strb	r3, [r4, #4]
}
    62ee:	bd70      	pop	{r4, r5, r6, pc}
    62f0:	0000e3b8 	.word	0x0000e3b8
    62f4:	00009659 	.word	0x00009659
    62f8:	20000a3c 	.word	0x20000a3c
    62fc:	00005d39 	.word	0x00005d39
    6300:	0000e348 	.word	0x0000e348
    6304:	00005fe1 	.word	0x00005fe1
    6308:	0000e368 	.word	0x0000e368
    630c:	00006051 	.word	0x00006051
    6310:	0000e388 	.word	0x0000e388

00006314 <stop_man_trig>:
{
    6314:	b510      	push	{r4, lr}
	printf("stopping manual trigger\r\n");
    6316:	480b      	ldr	r0, [pc, #44]	; (6344 <stop_man_trig+0x30>)
    6318:	4b0b      	ldr	r3, [pc, #44]	; (6348 <stop_man_trig+0x34>)
    631a:	4798      	blx	r3
	pb_received = false;
    631c:	2400      	movs	r4, #0
    631e:	4b0b      	ldr	r3, [pc, #44]	; (634c <stop_man_trig+0x38>)
    6320:	701c      	strb	r4, [r3, #0]
	io_write_clear_ack(man_trig_trigger_LED_off,6);
    6322:	2106      	movs	r1, #6
    6324:	480a      	ldr	r0, [pc, #40]	; (6350 <stop_man_trig+0x3c>)
    6326:	3020      	adds	r0, #32
    6328:	4b0a      	ldr	r3, [pc, #40]	; (6354 <stop_man_trig+0x40>)
    632a:	4798      	blx	r3
	switch_to_form(MENU_FORM);
    632c:	2007      	movs	r0, #7
    632e:	4b0a      	ldr	r3, [pc, #40]	; (6358 <stop_man_trig+0x44>)
    6330:	4798      	blx	r3
	session_data.session_running = false;
    6332:	4b0a      	ldr	r3, [pc, #40]	; (635c <stop_man_trig+0x48>)
    6334:	709c      	strb	r4, [r3, #2]
	session_data.simulation_mode = false;
    6336:	70dc      	strb	r4, [r3, #3]
	session_data.manual_trigger=false;
    6338:	711c      	strb	r4, [r3, #4]
	session_data.trigger = false;
    633a:	715c      	strb	r4, [r3, #5]
	session_data.current_volume = 1;
    633c:	2201      	movs	r2, #1
    633e:	831a      	strh	r2, [r3, #24]
	session_data.current_slice = 0;
    6340:	835c      	strh	r4, [r3, #26]
}
    6342:	bd10      	pop	{r4, pc}
    6344:	0000e3d4 	.word	0x0000e3d4
    6348:	00009659 	.word	0x00009659
    634c:	20000740 	.word	0x20000740
    6350:	0000ae08 	.word	0x0000ae08
    6354:	00005b95 	.word	0x00005b95
    6358:	00005d39 	.word	0x00005d39
    635c:	20000a3c 	.word	0x20000a3c

00006360 <start_session>:
{
    6360:	b570      	push	{r4, r5, r6, lr}
	if ((adc_value > 1550) && (adc_value < 2000)) {
    6362:	4b22      	ldr	r3, [pc, #136]	; (63ec <start_session+0x8c>)
    6364:	885b      	ldrh	r3, [r3, #2]
    6366:	4a22      	ldr	r2, [pc, #136]	; (63f0 <start_session+0x90>)
    6368:	4694      	mov	ip, r2
    636a:	4463      	add	r3, ip
    636c:	b29b      	uxth	r3, r3
    636e:	22e0      	movs	r2, #224	; 0xe0
    6370:	0052      	lsls	r2, r2, #1
    6372:	4293      	cmp	r3, r2
    6374:	d902      	bls.n	637c <start_session+0x1c>
		ps_error();
    6376:	4b1f      	ldr	r3, [pc, #124]	; (63f4 <start_session+0x94>)
    6378:	4798      	blx	r3
}
    637a:	bd70      	pop	{r4, r5, r6, pc}
		printf("starting session\r\n");
    637c:	481e      	ldr	r0, [pc, #120]	; (63f8 <start_session+0x98>)
    637e:	4d1f      	ldr	r5, [pc, #124]	; (63fc <start_session+0x9c>)
    6380:	47a8      	blx	r5
		session_data.trig_LED_on = false;
    6382:	4c1f      	ldr	r4, [pc, #124]	; (6400 <start_session+0xa0>)
    6384:	2200      	movs	r2, #0
    6386:	7022      	strb	r2, [r4, #0]
		session_data.trigger = false;
    6388:	7162      	strb	r2, [r4, #5]
		session_data.current_volume = 1;
    638a:	2301      	movs	r3, #1
    638c:	8323      	strh	r3, [r4, #24]
		session_data.current_slice = 0;
    638e:	2300      	movs	r3, #0
    6390:	8362      	strh	r2, [r4, #26]
		session_data.previous_volume = session_data.no_of_volumes;
    6392:	8a21      	ldrh	r1, [r4, #16]
    6394:	83a1      	strh	r1, [r4, #28]
		session_data.previous_slice = 0;
    6396:	83e2      	strh	r2, [r4, #30]
		session_data.simulated_A=false;
    6398:	71a3      	strb	r3, [r4, #6]
		session_data.simulated_B=false;
    639a:	71e3      	strb	r3, [r4, #7]
		session_data.simulated_C=false;
    639c:	7223      	strb	r3, [r4, #8]
		session_data.simulated_D=false;
    639e:	7263      	strb	r3, [r4, #9]
		session_data.simulation_mode=false;
    63a0:	70e3      	strb	r3, [r4, #3]
		session_data.session_finished = false;
    63a2:	7063      	strb	r3, [r4, #1]
		switch_to_form(SESSION_RUNNING_FORM);
    63a4:	2001      	movs	r0, #1
    63a6:	4b17      	ldr	r3, [pc, #92]	; (6404 <start_session+0xa4>)
    63a8:	4798      	blx	r3
		printf("enable RX pwr\r\n");
    63aa:	4817      	ldr	r0, [pc, #92]	; (6408 <start_session+0xa8>)
    63ac:	47a8      	blx	r5
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    63ae:	26c0      	movs	r6, #192	; 0xc0
    63b0:	05f6      	lsls	r6, r6, #23
    63b2:	2380      	movs	r3, #128	; 0x80
    63b4:	019b      	lsls	r3, r3, #6
    63b6:	61b3      	str	r3, [r6, #24]
		printf("powering up TX ch. 1\r\n");
    63b8:	4814      	ldr	r0, [pc, #80]	; (640c <start_session+0xac>)
    63ba:	47a8      	blx	r5
    63bc:	2380      	movs	r3, #128	; 0x80
    63be:	021b      	lsls	r3, r3, #8
    63c0:	61b3      	str	r3, [r6, #24]
		printf("powering up TX ch. 2\r\n");
    63c2:	4813      	ldr	r0, [pc, #76]	; (6410 <start_session+0xb0>)
    63c4:	47a8      	blx	r5
    63c6:	2380      	movs	r3, #128	; 0x80
    63c8:	01db      	lsls	r3, r3, #7
    63ca:	61b3      	str	r3, [r6, #24]
		printf("setting current slice string\r\n");
    63cc:	4811      	ldr	r0, [pc, #68]	; (6414 <start_session+0xb4>)
    63ce:	47a8      	blx	r5
		print_slices(CURRENT_SLICE_STR);
    63d0:	2000      	movs	r0, #0
    63d2:	4b11      	ldr	r3, [pc, #68]	; (6418 <start_session+0xb8>)
    63d4:	4798      	blx	r3
		printf("setting current volume string\r\n");
    63d6:	4811      	ldr	r0, [pc, #68]	; (641c <start_session+0xbc>)
    63d8:	47a8      	blx	r5
		print_volumes(CURRENT_VOLUME_STR);
    63da:	2001      	movs	r0, #1
    63dc:	4b10      	ldr	r3, [pc, #64]	; (6420 <start_session+0xc0>)
    63de:	4798      	blx	r3
		printf("playing start sound\r\n");
    63e0:	4810      	ldr	r0, [pc, #64]	; (6424 <start_session+0xc4>)
    63e2:	47a8      	blx	r5
		session_data.session_running = true;
    63e4:	2301      	movs	r3, #1
    63e6:	70a3      	strb	r3, [r4, #2]
    63e8:	e7c7      	b.n	637a <start_session+0x1a>
    63ea:	46c0      	nop			; (mov r8, r8)
    63ec:	20000740 	.word	0x20000740
    63f0:	fffff9f1 	.word	0xfffff9f1
    63f4:	000060ed 	.word	0x000060ed
    63f8:	0000e3f0 	.word	0x0000e3f0
    63fc:	00009659 	.word	0x00009659
    6400:	20000a3c 	.word	0x20000a3c
    6404:	00005d39 	.word	0x00005d39
    6408:	0000e404 	.word	0x0000e404
    640c:	0000e414 	.word	0x0000e414
    6410:	0000e42c 	.word	0x0000e42c
    6414:	0000e348 	.word	0x0000e348
    6418:	00005fe1 	.word	0x00005fe1
    641c:	0000e368 	.word	0x0000e368
    6420:	00006051 	.word	0x00006051
    6424:	0000e388 	.word	0x0000e388

00006428 <stop_session>:
{
    6428:	b570      	push	{r4, r5, r6, lr}
	printf("stopping session\r\n");
    642a:	4810      	ldr	r0, [pc, #64]	; (646c <stop_session+0x44>)
    642c:	4c10      	ldr	r4, [pc, #64]	; (6470 <stop_session+0x48>)
    642e:	47a0      	blx	r4
	switch_to_form(DEFAULT_FORM);
    6430:	2000      	movs	r0, #0
    6432:	4b10      	ldr	r3, [pc, #64]	; (6474 <stop_session+0x4c>)
    6434:	4798      	blx	r3
	session_data.session_running = false;
    6436:	4b10      	ldr	r3, [pc, #64]	; (6478 <stop_session+0x50>)
    6438:	2200      	movs	r2, #0
    643a:	709a      	strb	r2, [r3, #2]
	session_data.simulation_mode = false;
    643c:	70da      	strb	r2, [r3, #3]
	session_data.trigger = false;
    643e:	715a      	strb	r2, [r3, #5]
	session_data.current_volume = 1;
    6440:	2101      	movs	r1, #1
    6442:	8319      	strh	r1, [r3, #24]
	session_data.current_slice = 0;
    6444:	835a      	strh	r2, [r3, #26]
	printf("powering down TX ch. 1\r\n");
    6446:	480d      	ldr	r0, [pc, #52]	; (647c <stop_session+0x54>)
    6448:	47a0      	blx	r4
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    644a:	25c0      	movs	r5, #192	; 0xc0
    644c:	05ed      	lsls	r5, r5, #23
    644e:	2380      	movs	r3, #128	; 0x80
    6450:	021b      	lsls	r3, r3, #8
    6452:	616b      	str	r3, [r5, #20]
	printf("powering down TX ch. 2\r\n");
    6454:	480a      	ldr	r0, [pc, #40]	; (6480 <stop_session+0x58>)
    6456:	47a0      	blx	r4
    6458:	2380      	movs	r3, #128	; 0x80
    645a:	01db      	lsls	r3, r3, #7
    645c:	616b      	str	r3, [r5, #20]
	printf("disable RX pwr\r\n");
    645e:	4809      	ldr	r0, [pc, #36]	; (6484 <stop_session+0x5c>)
    6460:	47a0      	blx	r4
    6462:	2380      	movs	r3, #128	; 0x80
    6464:	019b      	lsls	r3, r3, #6
    6466:	616b      	str	r3, [r5, #20]
}
    6468:	bd70      	pop	{r4, r5, r6, pc}
    646a:	46c0      	nop			; (mov r8, r8)
    646c:	0000e444 	.word	0x0000e444
    6470:	00009659 	.word	0x00009659
    6474:	00005d39 	.word	0x00005d39
    6478:	20000a3c 	.word	0x20000a3c
    647c:	0000e458 	.word	0x0000e458
    6480:	0000e470 	.word	0x0000e470
    6484:	0000e488 	.word	0x0000e488

00006488 <TIMER_init>:

void TIMER_init(void)
{
    6488:	b570      	push	{r4, r5, r6, lr}
	TIMER_0_task1.interval = 1; // 8kHz
    648a:	490d      	ldr	r1, [pc, #52]	; (64c0 <TIMER_init+0x38>)
    648c:	2301      	movs	r3, #1
    648e:	620b      	str	r3, [r1, #32]
	TIMER_0_task1.cb       = TIMER_task1_cb;
    6490:	4a0c      	ldr	r2, [pc, #48]	; (64c4 <TIMER_init+0x3c>)
    6492:	624a      	str	r2, [r1, #36]	; 0x24
	TIMER_0_task1.mode     = TIMER_TASK_REPEAT;
    6494:	2228      	movs	r2, #40	; 0x28
    6496:	548b      	strb	r3, [r1, r2]
	TIMER_0_task2.interval = 5000;   //1.6 Hz
    6498:	4a0b      	ldr	r2, [pc, #44]	; (64c8 <TIMER_init+0x40>)
    649a:	634a      	str	r2, [r1, #52]	; 0x34
	TIMER_0_task2.cb       = TIMER_task2_cb;
    649c:	4a0b      	ldr	r2, [pc, #44]	; (64cc <TIMER_init+0x44>)
    649e:	638a      	str	r2, [r1, #56]	; 0x38
	TIMER_0_task2.mode     = TIMER_TASK_REPEAT;
    64a0:	000e      	movs	r6, r1
    64a2:	362c      	adds	r6, #44	; 0x2c
    64a4:	7433      	strb	r3, [r6, #16]

	timer_add_task(&TIMER_0, &TIMER_0_task1);
    64a6:	3118      	adds	r1, #24
    64a8:	4c09      	ldr	r4, [pc, #36]	; (64d0 <TIMER_init+0x48>)
    64aa:	0020      	movs	r0, r4
    64ac:	4d09      	ldr	r5, [pc, #36]	; (64d4 <TIMER_init+0x4c>)
    64ae:	47a8      	blx	r5
	timer_add_task(&TIMER_0, &TIMER_0_task2);
    64b0:	0031      	movs	r1, r6
    64b2:	0020      	movs	r0, r4
    64b4:	47a8      	blx	r5
	timer_start(&TIMER_0);
    64b6:	0020      	movs	r0, r4
    64b8:	4b07      	ldr	r3, [pc, #28]	; (64d8 <TIMER_init+0x50>)
    64ba:	4798      	blx	r3
}
    64bc:	bd70      	pop	{r4, r5, r6, pc}
    64be:	46c0      	nop			; (mov r8, r8)
    64c0:	20000740 	.word	0x20000740
    64c4:	0000554d 	.word	0x0000554d
    64c8:	00001388 	.word	0x00001388
    64cc:	00005525 	.word	0x00005525
    64d0:	20000a18 	.word	0x20000a18
    64d4:	00001c0d 	.word	0x00001c0d
    64d8:	00001bd1 	.word	0x00001bd1

000064dc <main>:

int main(void)
{
    64dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    64de:	46c6      	mov	lr, r8
    64e0:	b500      	push	{lr}
	pb_received = false;
    64e2:	4ec4      	ldr	r6, [pc, #784]	; (67f4 <main+0x318>)
    64e4:	2400      	movs	r4, #0
    64e6:	7034      	strb	r4, [r6, #0]
	uint16_t page_size;
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
    64e8:	4bc3      	ldr	r3, [pc, #780]	; (67f8 <main+0x31c>)
    64ea:	4798      	blx	r3
    64ec:	25c0      	movs	r5, #192	; 0xc0
    64ee:	05ed      	lsls	r5, r5, #23
    64f0:	2380      	movs	r3, #128	; 0x80
    64f2:	021b      	lsls	r3, r3, #8
    64f4:	616b      	str	r3, [r5, #20]
    64f6:	2380      	movs	r3, #128	; 0x80
    64f8:	01db      	lsls	r3, r3, #7
    64fa:	616b      	str	r3, [r5, #20]
    64fc:	2394      	movs	r3, #148	; 0x94
    64fe:	2280      	movs	r2, #128	; 0x80
    6500:	0252      	lsls	r2, r2, #9
    6502:	50ea      	str	r2, [r5, r3]
    6504:	2280      	movs	r2, #128	; 0x80
    6506:	0292      	lsls	r2, r2, #10
    6508:	50ea      	str	r2, [r5, r3]
    650a:	2380      	movs	r3, #128	; 0x80
    650c:	035b      	lsls	r3, r3, #13
    650e:	616b      	str	r3, [r5, #20]
    6510:	2380      	movs	r3, #128	; 0x80
    6512:	039b      	lsls	r3, r3, #14
    6514:	616b      	str	r3, [r5, #20]
    6516:	2380      	movs	r3, #128	; 0x80
    6518:	019b      	lsls	r3, r3, #6
    651a:	616b      	str	r3, [r5, #20]
	gpio_set_pin_level(T5, false);
	gpio_set_pin_level(T6, false);
	gpio_set_pin_level(RX_PWR, false);
	
	
	ADC_init();
    651c:	4bb7      	ldr	r3, [pc, #732]	; (67fc <main+0x320>)
    651e:	4798      	blx	r3
	adc_read=true;
    6520:	2701      	movs	r7, #1
    6522:	7137      	strb	r7, [r6, #4]
	TIMER_init();
    6524:	4bb6      	ldr	r3, [pc, #728]	; (6800 <main+0x324>)
    6526:	4798      	blx	r3
	uart_init();  // LCD communication
    6528:	4bb6      	ldr	r3, [pc, #728]	; (6804 <main+0x328>)
    652a:	4798      	blx	r3
		
	page_size = flash_get_page_size(&FLASH_0);	
    652c:	48b6      	ldr	r0, [pc, #728]	; (6808 <main+0x32c>)
    652e:	4bb7      	ldr	r3, [pc, #732]	; (680c <main+0x330>)
    6530:	4798      	blx	r3
	printf("\r\nFLASH page size: %d\r\n", page_size);
    6532:	0401      	lsls	r1, r0, #16
    6534:	0c09      	lsrs	r1, r1, #16
    6536:	48b6      	ldr	r0, [pc, #728]	; (6810 <main+0x334>)
    6538:	4eb6      	ldr	r6, [pc, #728]	; (6814 <main+0x338>)
    653a:	47b0      	blx	r6
	
	page_size=sizeof(session_data);
	printf("\r\nsession data size: %d\r\n", page_size);
    653c:	2128      	movs	r1, #40	; 0x28
    653e:	48b6      	ldr	r0, [pc, #728]	; (6818 <main+0x33c>)
    6540:	47b0      	blx	r6
	
	page_size=sizeof(session_data.sound_volume);
	printf("\r\nsound volume size: %d\r\n", page_size);
    6542:	2102      	movs	r1, #2
    6544:	48b5      	ldr	r0, [pc, #724]	; (681c <main+0x340>)
    6546:	47b0      	blx	r6
	
	page_size=sizeof(session_data.response_sound);
	printf("\r\nresponse sound size: %d\r\n", page_size);
    6548:	2101      	movs	r1, #1
    654a:	48b5      	ldr	r0, [pc, #724]	; (6820 <main+0x344>)
    654c:	47b0      	blx	r6
	
	page_size=sizeof(session_data.current_form);
	printf("\r\ncurrent form size: %d\r\n", page_size);	
    654e:	2101      	movs	r1, #1
    6550:	48b4      	ldr	r0, [pc, #720]	; (6824 <main+0x348>)
    6552:	47b0      	blx	r6
	
	printf("reading settings from FLASH memory");
    6554:	48b4      	ldr	r0, [pc, #720]	; (6828 <main+0x34c>)
    6556:	47b0      	blx	r6
	read_flash();
    6558:	4bb4      	ldr	r3, [pc, #720]	; (682c <main+0x350>)
    655a:	4798      	blx	r3
	
	session_data.trigger = false;
    655c:	4bb4      	ldr	r3, [pc, #720]	; (6830 <main+0x354>)
    655e:	715c      	strb	r4, [r3, #5]
	session_data.session_running = false;
    6560:	709c      	strb	r4, [r3, #2]
	session_data.session_finished = false;
    6562:	705c      	strb	r4, [r3, #1]
	session_data.simulation_mode = false;
    6564:	70dc      	strb	r4, [r3, #3]
	session_data.manual_trigger = false;
    6566:	711c      	strb	r4, [r3, #4]
	session_data.current_form = DEFAULT_FORM;
    6568:	731c      	strb	r4, [r3, #12]
	session_data.previous_form = DEFAULT_FORM;
    656a:	735c      	strb	r4, [r3, #13]
	session_data.simulated_A = false;
    656c:	719c      	strb	r4, [r3, #6]
	session_data.simulated_B = false;
    656e:	71dc      	strb	r4, [r3, #7]
	session_data.simulated_C = false;
    6570:	721c      	strb	r4, [r3, #8]
	session_data.simulated_D = false;
    6572:	725c      	strb	r4, [r3, #9]

	printf("enabling DAC\r\n");
    6574:	48af      	ldr	r0, [pc, #700]	; (6834 <main+0x358>)
    6576:	4eb0      	ldr	r6, [pc, #704]	; (6838 <main+0x35c>)
    6578:	47b0      	blx	r6
	dac_async_enable_channel(&DAC_0, 0);
    657a:	2100      	movs	r1, #0
    657c:	48af      	ldr	r0, [pc, #700]	; (683c <main+0x360>)
    657e:	4bb0      	ldr	r3, [pc, #704]	; (6840 <main+0x364>)
    6580:	4798      	blx	r3
	
	printf("register ext irq sync trigger\r\n");
    6582:	48b0      	ldr	r0, [pc, #704]	; (6844 <main+0x368>)
    6584:	47b0      	blx	r6
    ext_irq_register(I0, sync_trigger);
    6586:	49b0      	ldr	r1, [pc, #704]	; (6848 <main+0x36c>)
    6588:	2022      	movs	r0, #34	; 0x22
    658a:	4bb0      	ldr	r3, [pc, #704]	; (684c <main+0x370>)
    658c:	4698      	mov	r8, r3
    658e:	4798      	blx	r3
	
	printf("register ext irq button\r\n");
    6590:	48af      	ldr	r0, [pc, #700]	; (6850 <main+0x374>)
    6592:	47b0      	blx	r6
    ext_irq_register(PB2, button);
    6594:	49af      	ldr	r1, [pc, #700]	; (6854 <main+0x378>)
    6596:	2023      	movs	r0, #35	; 0x23
    6598:	47c0      	blx	r8
		
	printf("reset LCD\r\n");
    659a:	48af      	ldr	r0, [pc, #700]	; (6858 <main+0x37c>)
    659c:	47b0      	blx	r6
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    659e:	2380      	movs	r3, #128	; 0x80
    65a0:	055b      	lsls	r3, r3, #21
    65a2:	61ab      	str	r3, [r5, #24]
	gpio_set_pin_level(DISP_RESET, true);
	delay_ms(2000);
    65a4:	20fa      	movs	r0, #250	; 0xfa
    65a6:	00c0      	lsls	r0, r0, #3
    65a8:	4bac      	ldr	r3, [pc, #688]	; (685c <main+0x380>)
    65aa:	4798      	blx	r3
	printf("set ACK after display reset\r\n");
    65ac:	48ac      	ldr	r0, [pc, #688]	; (6860 <main+0x384>)
    65ae:	47b0      	blx	r6
	ACK_received = true;
    65b0:	4bac      	ldr	r3, [pc, #688]	; (6864 <main+0x388>)
    65b2:	701f      	strb	r7, [r3, #0]
	
	printf("enabling audio amp\r\n");
    65b4:	48ac      	ldr	r0, [pc, #688]	; (6868 <main+0x38c>)
    65b6:	47b0      	blx	r6
    65b8:	2220      	movs	r2, #32
    65ba:	2398      	movs	r3, #152	; 0x98
    65bc:	50ea      	str	r2, [r5, r3]
	gpio_set_pin_level(AUDENB, true);

	printf("***************************************\r\n");
    65be:	48ab      	ldr	r0, [pc, #684]	; (686c <main+0x390>)
    65c0:	47b0      	blx	r6
	printf("initialization done, starting main loop\r\n");
    65c2:	48ab      	ldr	r0, [pc, #684]	; (6870 <main+0x394>)
    65c4:	47b0      	blx	r6
	usb_disconnected = 0;
    65c6:	4bab      	ldr	r3, [pc, #684]	; (6874 <main+0x398>)
    65c8:	801c      	strh	r4, [r3, #0]
    65ca:	e186      	b.n	68da <main+0x3fe>
	while (1) {		
		
		if ((adc_value < 1500) || (adc_value > 2000)) {
			ps_error_counter ++;
    65cc:	4889      	ldr	r0, [pc, #548]	; (67f4 <main+0x318>)
    65ce:	2340      	movs	r3, #64	; 0x40
    65d0:	5ac2      	ldrh	r2, [r0, r3]
    65d2:	3201      	adds	r2, #1
    65d4:	b292      	uxth	r2, r2
    65d6:	52c2      	strh	r2, [r0, r3]
			printf("ps dip, voltage: %d, counter: %u\r\n", adc_value, ps_error_counter);
    65d8:	48a7      	ldr	r0, [pc, #668]	; (6878 <main+0x39c>)
    65da:	4b8e      	ldr	r3, [pc, #568]	; (6814 <main+0x338>)
    65dc:	4798      	blx	r3
    65de:	e18a      	b.n	68f6 <main+0x41a>
		}
		else{
			ps_error_counter = 0;
		}
		if (ps_error_counter > 3){
			ps_error();
    65e0:	4ba6      	ldr	r3, [pc, #664]	; (687c <main+0x3a0>)
    65e2:	4798      	blx	r3
    65e4:	e18d      	b.n	6902 <main+0x426>
		}
		
		
		if (usb_disconnected > 100){
			printf("USB disconnected!\r\n");
    65e6:	48a6      	ldr	r0, [pc, #664]	; (6880 <main+0x3a4>)
    65e8:	4b93      	ldr	r3, [pc, #588]	; (6838 <main+0x35c>)
    65ea:	4798      	blx	r3
			usb_error();
    65ec:	4ba5      	ldr	r3, [pc, #660]	; (6884 <main+0x3a8>)
    65ee:	4798      	blx	r3
    65f0:	e18c      	b.n	690c <main+0x430>
				session_data.previous_volume = session_data.current_volume;				
				print_volumes(CURRENT_VOLUME_STR);			
			}
			
			if (session_data.session_finished) {
				session_data.session_running = false;
    65f2:	2200      	movs	r2, #0
    65f4:	4b8e      	ldr	r3, [pc, #568]	; (6830 <main+0x354>)
    65f6:	709a      	strb	r2, [r3, #2]
				delay_ms(2000);
    65f8:	20fa      	movs	r0, #250	; 0xfa
    65fa:	00c0      	lsls	r0, r0, #3
    65fc:	4b97      	ldr	r3, [pc, #604]	; (685c <main+0x380>)
    65fe:	4798      	blx	r3
				stop_session();
    6600:	4ba1      	ldr	r3, [pc, #644]	; (6888 <main+0x3ac>)
    6602:	4798      	blx	r3
    6604:	e1a0      	b.n	6948 <main+0x46c>
			}
		}
		
		else if (session_data.manual_trigger) {
    6606:	4b8a      	ldr	r3, [pc, #552]	; (6830 <main+0x354>)
    6608:	791b      	ldrb	r3, [r3, #4]
    660a:	2b00      	cmp	r3, #0
    660c:	d100      	bne.n	6610 <main+0x134>
    660e:	e09e      	b.n	674e <main+0x272>
			
			if (pb_received){
    6610:	4b78      	ldr	r3, [pc, #480]	; (67f4 <main+0x318>)
    6612:	781b      	ldrb	r3, [r3, #0]
    6614:	2b00      	cmp	r3, #0
    6616:	d00a      	beq.n	662e <main+0x152>
				pb_received = false;
    6618:	2200      	movs	r2, #0
    661a:	4b76      	ldr	r3, [pc, #472]	; (67f4 <main+0x318>)
    661c:	701a      	strb	r2, [r3, #0]
				if ((!session_data.simulation_mode) && (!session_data.session_running) && (session_data.manual_trigger) && (!trigger_debounce)){
    661e:	4b84      	ldr	r3, [pc, #528]	; (6830 <main+0x354>)
    6620:	78db      	ldrb	r3, [r3, #3]
    6622:	2b00      	cmp	r3, #0
    6624:	d103      	bne.n	662e <main+0x152>
    6626:	4b99      	ldr	r3, [pc, #612]	; (688c <main+0x3b0>)
    6628:	881b      	ldrh	r3, [r3, #0]
    662a:	2b00      	cmp	r3, #0
    662c:	d02b      	beq.n	6686 <main+0x1aa>
						}
					}
				}
			}
			
			if ((!trig_LED_delay) && (session_data.trig_LED_on)){
    662e:	4b97      	ldr	r3, [pc, #604]	; (688c <main+0x3b0>)
    6630:	891b      	ldrh	r3, [r3, #8]
    6632:	2b00      	cmp	r3, #0
    6634:	d104      	bne.n	6640 <main+0x164>
    6636:	4b7e      	ldr	r3, [pc, #504]	; (6830 <main+0x354>)
    6638:	781b      	ldrb	r3, [r3, #0]
    663a:	2b00      	cmp	r3, #0
    663c:	d000      	beq.n	6640 <main+0x164>
    663e:	e07a      	b.n	6736 <main+0x25a>
				printf("man trig switch trigger LED off\r\n");
				io_write_clear_ack(man_trig_trigger_LED_off,6);
				
			}
			
			if (session_data.previous_slice != session_data.current_slice){
    6640:	4b7b      	ldr	r3, [pc, #492]	; (6830 <main+0x354>)
    6642:	8bda      	ldrh	r2, [r3, #30]
    6644:	8b5b      	ldrh	r3, [r3, #26]
    6646:	429a      	cmp	r2, r3
    6648:	d004      	beq.n	6654 <main+0x178>
				session_data.previous_slice = session_data.current_slice;
    664a:	4a79      	ldr	r2, [pc, #484]	; (6830 <main+0x354>)
    664c:	83d3      	strh	r3, [r2, #30]
				
				print_slices(MAN_TRIG_CURRENT_SLICE_STR);
    664e:	2010      	movs	r0, #16
    6650:	4b8f      	ldr	r3, [pc, #572]	; (6890 <main+0x3b4>)
    6652:	4798      	blx	r3
			}
			
			if (session_data.previous_volume != session_data.current_volume){
    6654:	4b76      	ldr	r3, [pc, #472]	; (6830 <main+0x354>)
    6656:	8b9a      	ldrh	r2, [r3, #28]
    6658:	8b1b      	ldrh	r3, [r3, #24]
    665a:	429a      	cmp	r2, r3
    665c:	d004      	beq.n	6668 <main+0x18c>
				session_data.previous_volume = session_data.current_volume;
    665e:	4a74      	ldr	r2, [pc, #464]	; (6830 <main+0x354>)
    6660:	8393      	strh	r3, [r2, #28]
				
				print_volumes(MAN_TRIG_CURRENT_VOLUME_STR);
    6662:	2011      	movs	r0, #17
    6664:	4b8b      	ldr	r3, [pc, #556]	; (6894 <main+0x3b8>)
    6666:	4798      	blx	r3
			}
			
			if (session_data.session_finished) {
    6668:	4b71      	ldr	r3, [pc, #452]	; (6830 <main+0x354>)
    666a:	785b      	ldrb	r3, [r3, #1]
    666c:	2b00      	cmp	r3, #0
    666e:	d100      	bne.n	6672 <main+0x196>
    6670:	e16a      	b.n	6948 <main+0x46c>
				session_data.manual_trigger = false;
    6672:	2200      	movs	r2, #0
    6674:	4b6e      	ldr	r3, [pc, #440]	; (6830 <main+0x354>)
    6676:	711a      	strb	r2, [r3, #4]
				delay_ms(2000);
    6678:	20fa      	movs	r0, #250	; 0xfa
    667a:	00c0      	lsls	r0, r0, #3
    667c:	4b77      	ldr	r3, [pc, #476]	; (685c <main+0x380>)
    667e:	4798      	blx	r3
				stop_man_trig();
    6680:	4b85      	ldr	r3, [pc, #532]	; (6898 <main+0x3bc>)
    6682:	4798      	blx	r3
    6684:	e160      	b.n	6948 <main+0x46c>
					trigger_debounce = TRIGGER_DEBOUNCE_TIME;
    6686:	3232      	adds	r2, #50	; 0x32
    6688:	4b80      	ldr	r3, [pc, #512]	; (688c <main+0x3b0>)
    668a:	801a      	strh	r2, [r3, #0]
					printf("simulated S\r\n");
    668c:	4883      	ldr	r0, [pc, #524]	; (689c <main+0x3c0>)
    668e:	4b6a      	ldr	r3, [pc, #424]	; (6838 <main+0x35c>)
    6690:	4798      	blx	r3
					session_data.current_slice += 1;
    6692:	4a67      	ldr	r2, [pc, #412]	; (6830 <main+0x354>)
    6694:	8b53      	ldrh	r3, [r2, #26]
    6696:	3301      	adds	r3, #1
    6698:	b29b      	uxth	r3, r3
    669a:	8353      	strh	r3, [r2, #26]
					if (((session_data.current_slice >= session_data.no_of_slices) && (session_data.current_volume == session_data.no_of_volumes)) ||
    669c:	8a52      	ldrh	r2, [r2, #18]
    669e:	4293      	cmp	r3, r2
    66a0:	d304      	bcc.n	66ac <main+0x1d0>
    66a2:	4963      	ldr	r1, [pc, #396]	; (6830 <main+0x354>)
    66a4:	8b08      	ldrh	r0, [r1, #24]
    66a6:	8a09      	ldrh	r1, [r1, #16]
    66a8:	4288      	cmp	r0, r1
    66aa:	d004      	beq.n	66b6 <main+0x1da>
					(session_data.current_volume > session_data.no_of_volumes)){
    66ac:	4960      	ldr	r1, [pc, #384]	; (6830 <main+0x354>)
    66ae:	8b08      	ldrh	r0, [r1, #24]
    66b0:	8a09      	ldrh	r1, [r1, #16]
					if (((session_data.current_slice >= session_data.no_of_slices) && (session_data.current_volume == session_data.no_of_volumes)) ||
    66b2:	4288      	cmp	r0, r1
    66b4:	d902      	bls.n	66bc <main+0x1e0>
						session_data.session_finished = true;
    66b6:	2001      	movs	r0, #1
    66b8:	495d      	ldr	r1, [pc, #372]	; (6830 <main+0x354>)
    66ba:	7048      	strb	r0, [r1, #1]
					if ((session_data.current_slice > session_data.no_of_slices) && (!session_data.session_finished)){
    66bc:	4293      	cmp	r3, r2
    66be:	d909      	bls.n	66d4 <main+0x1f8>
    66c0:	4b5b      	ldr	r3, [pc, #364]	; (6830 <main+0x354>)
    66c2:	785b      	ldrb	r3, [r3, #1]
    66c4:	2b00      	cmp	r3, #0
    66c6:	d105      	bne.n	66d4 <main+0x1f8>
						session_data.current_volume += 1;
    66c8:	4b59      	ldr	r3, [pc, #356]	; (6830 <main+0x354>)
    66ca:	8b1a      	ldrh	r2, [r3, #24]
    66cc:	3201      	adds	r2, #1
    66ce:	831a      	strh	r2, [r3, #24]
						session_data.current_slice = 1;
    66d0:	2201      	movs	r2, #1
    66d2:	835a      	strh	r2, [r3, #26]
					uint16_t divider = session_data.trig_on_volume;
    66d4:	4b56      	ldr	r3, [pc, #344]	; (6830 <main+0x354>)
    66d6:	8a9b      	ldrh	r3, [r3, #20]
					if (divider == 0) {
    66d8:	2b00      	cmp	r3, #0
    66da:	d02a      	beq.n	6732 <main+0x256>
					uint16_t divider = session_data.trig_on_volume;
    66dc:	0019      	movs	r1, r3
					if ((session_data.trig_on_volume == 0) || (((session_data.current_volume - 1) % divider) == 0)){
    66de:	2b00      	cmp	r3, #0
    66e0:	d006      	beq.n	66f0 <main+0x214>
    66e2:	4b53      	ldr	r3, [pc, #332]	; (6830 <main+0x354>)
    66e4:	8b18      	ldrh	r0, [r3, #24]
    66e6:	3801      	subs	r0, #1
    66e8:	4b6d      	ldr	r3, [pc, #436]	; (68a0 <main+0x3c4>)
    66ea:	4798      	blx	r3
    66ec:	2900      	cmp	r1, #0
    66ee:	d19e      	bne.n	662e <main+0x152>
						if ((session_data.trig_on_slice == 0) || (session_data.trig_on_slice == session_data.current_slice)){
    66f0:	4b4f      	ldr	r3, [pc, #316]	; (6830 <main+0x354>)
    66f2:	8adb      	ldrh	r3, [r3, #22]
    66f4:	2b00      	cmp	r3, #0
    66f6:	d003      	beq.n	6700 <main+0x224>
    66f8:	4a4d      	ldr	r2, [pc, #308]	; (6830 <main+0x354>)
    66fa:	8b52      	ldrh	r2, [r2, #26]
    66fc:	4293      	cmp	r3, r2
    66fe:	d196      	bne.n	662e <main+0x152>
							session_data.trigger = true;
    6700:	4b4b      	ldr	r3, [pc, #300]	; (6830 <main+0x354>)
    6702:	2201      	movs	r2, #1
    6704:	715a      	strb	r2, [r3, #5]
							sync_beep_length = SYNC_BEEP_LENGTH;
    6706:	4967      	ldr	r1, [pc, #412]	; (68a4 <main+0x3c8>)
    6708:	4a67      	ldr	r2, [pc, #412]	; (68a8 <main+0x3cc>)
    670a:	8011      	strh	r1, [r2, #0]
							if (!session_data.trig_LED_on){
    670c:	781b      	ldrb	r3, [r3, #0]
    670e:	2b00      	cmp	r3, #0
    6710:	d000      	beq.n	6714 <main+0x238>
    6712:	e78c      	b.n	662e <main+0x152>
								session_data.trig_LED_on = true;
    6714:	2201      	movs	r2, #1
    6716:	4b46      	ldr	r3, [pc, #280]	; (6830 <main+0x354>)
    6718:	701a      	strb	r2, [r3, #0]
								printf("switch trigger LED on\r\n");
    671a:	4864      	ldr	r0, [pc, #400]	; (68ac <main+0x3d0>)
    671c:	4b46      	ldr	r3, [pc, #280]	; (6838 <main+0x35c>)
    671e:	4798      	blx	r3
								io_write_clear_ack(man_trig_trigger_LED_on,6);
    6720:	2106      	movs	r1, #6
    6722:	4863      	ldr	r0, [pc, #396]	; (68b0 <main+0x3d4>)
    6724:	3028      	adds	r0, #40	; 0x28
    6726:	4b63      	ldr	r3, [pc, #396]	; (68b4 <main+0x3d8>)
    6728:	4798      	blx	r3
								trig_LED_delay = TRIGGER_LED_DELAY;
    672a:	2250      	movs	r2, #80	; 0x50
    672c:	4b57      	ldr	r3, [pc, #348]	; (688c <main+0x3b0>)
    672e:	811a      	strh	r2, [r3, #8]
    6730:	e77d      	b.n	662e <main+0x152>
						divider = 1;
    6732:	2101      	movs	r1, #1
    6734:	e7d3      	b.n	66de <main+0x202>
				session_data.trig_LED_on = false;
    6736:	2200      	movs	r2, #0
    6738:	4b3d      	ldr	r3, [pc, #244]	; (6830 <main+0x354>)
    673a:	701a      	strb	r2, [r3, #0]
				printf("man trig switch trigger LED off\r\n");
    673c:	485e      	ldr	r0, [pc, #376]	; (68b8 <main+0x3dc>)
    673e:	4b3e      	ldr	r3, [pc, #248]	; (6838 <main+0x35c>)
    6740:	4798      	blx	r3
				io_write_clear_ack(man_trig_trigger_LED_off,6);
    6742:	2106      	movs	r1, #6
    6744:	485a      	ldr	r0, [pc, #360]	; (68b0 <main+0x3d4>)
    6746:	3020      	adds	r0, #32
    6748:	4b5a      	ldr	r3, [pc, #360]	; (68b4 <main+0x3d8>)
    674a:	4798      	blx	r3
    674c:	e778      	b.n	6640 <main+0x164>
			}
		}
		
		else if (session_data.simulation_mode) {
    674e:	4b38      	ldr	r3, [pc, #224]	; (6830 <main+0x354>)
    6750:	78db      	ldrb	r3, [r3, #3]
    6752:	2b00      	cmp	r3, #0
    6754:	d100      	bne.n	6758 <main+0x27c>
    6756:	e0f7      	b.n	6948 <main+0x46c>
			
			if ((session_data.trigger) && (!session_data.trig_LED_on)){
    6758:	4b35      	ldr	r3, [pc, #212]	; (6830 <main+0x354>)
    675a:	795b      	ldrb	r3, [r3, #5]
    675c:	2b00      	cmp	r3, #0
    675e:	d003      	beq.n	6768 <main+0x28c>
    6760:	4b33      	ldr	r3, [pc, #204]	; (6830 <main+0x354>)
    6762:	781b      	ldrb	r3, [r3, #0]
    6764:	2b00      	cmp	r3, #0
    6766:	d02a      	beq.n	67be <main+0x2e2>
				printf("simulation switch trigger LED on\r\n");
				io_write_clear_ack(simulation_trigger_LED_on,6);
				trig_LED_delay = TRIGGER_LED_DELAY;
			}			
			
			if ((!trig_LED_delay) && (session_data.trig_LED_on)){
    6768:	4b48      	ldr	r3, [pc, #288]	; (688c <main+0x3b0>)
    676a:	891b      	ldrh	r3, [r3, #8]
    676c:	2b00      	cmp	r3, #0
    676e:	d103      	bne.n	6778 <main+0x29c>
    6770:	4b2f      	ldr	r3, [pc, #188]	; (6830 <main+0x354>)
    6772:	781b      	ldrb	r3, [r3, #0]
    6774:	2b00      	cmp	r3, #0
    6776:	d131      	bne.n	67dc <main+0x300>
				session_data.trig_LED_on = false;
				printf("simulation switch trigger LED off\r\n");
				io_write_clear_ack(simulation_trigger_LED_off,6);				
			}
			
			if (session_data.previous_slice != session_data.current_slice){
    6778:	4b2d      	ldr	r3, [pc, #180]	; (6830 <main+0x354>)
    677a:	8bda      	ldrh	r2, [r3, #30]
    677c:	8b5b      	ldrh	r3, [r3, #26]
    677e:	429a      	cmp	r2, r3
    6780:	d004      	beq.n	678c <main+0x2b0>
				session_data.previous_slice = session_data.current_slice;
    6782:	4a2b      	ldr	r2, [pc, #172]	; (6830 <main+0x354>)
    6784:	83d3      	strh	r3, [r2, #30]
				print_slices(SIMULATION_CURRENT_SLICE_STR);
    6786:	200e      	movs	r0, #14
    6788:	4b41      	ldr	r3, [pc, #260]	; (6890 <main+0x3b4>)
    678a:	4798      	blx	r3
			}
			
			if (session_data.previous_volume != session_data.current_volume){
    678c:	4b28      	ldr	r3, [pc, #160]	; (6830 <main+0x354>)
    678e:	8b9a      	ldrh	r2, [r3, #28]
    6790:	8b1b      	ldrh	r3, [r3, #24]
    6792:	429a      	cmp	r2, r3
    6794:	d004      	beq.n	67a0 <main+0x2c4>
				session_data.previous_volume = session_data.current_volume;
    6796:	4a26      	ldr	r2, [pc, #152]	; (6830 <main+0x354>)
    6798:	8393      	strh	r3, [r2, #28]
				print_volumes(SIMULATION_CURRENT_VOLUME_STR);			
    679a:	200f      	movs	r0, #15
    679c:	4b3d      	ldr	r3, [pc, #244]	; (6894 <main+0x3b8>)
    679e:	4798      	blx	r3
			}			
	
			if (session_data.session_finished) {
    67a0:	4b23      	ldr	r3, [pc, #140]	; (6830 <main+0x354>)
    67a2:	785b      	ldrb	r3, [r3, #1]
    67a4:	2b00      	cmp	r3, #0
    67a6:	d100      	bne.n	67aa <main+0x2ce>
    67a8:	e0ce      	b.n	6948 <main+0x46c>
				session_data.simulation_mode = false;
    67aa:	2200      	movs	r2, #0
    67ac:	4b20      	ldr	r3, [pc, #128]	; (6830 <main+0x354>)
    67ae:	70da      	strb	r2, [r3, #3]
				delay_ms(2000);
    67b0:	20fa      	movs	r0, #250	; 0xfa
    67b2:	00c0      	lsls	r0, r0, #3
    67b4:	4b29      	ldr	r3, [pc, #164]	; (685c <main+0x380>)
    67b6:	4798      	blx	r3
				stop_simulation();
    67b8:	4b40      	ldr	r3, [pc, #256]	; (68bc <main+0x3e0>)
    67ba:	4798      	blx	r3
    67bc:	e0c4      	b.n	6948 <main+0x46c>
				session_data.trig_LED_on = true;
    67be:	2201      	movs	r2, #1
    67c0:	4b1b      	ldr	r3, [pc, #108]	; (6830 <main+0x354>)
    67c2:	701a      	strb	r2, [r3, #0]
				printf("simulation switch trigger LED on\r\n");
    67c4:	483e      	ldr	r0, [pc, #248]	; (68c0 <main+0x3e4>)
    67c6:	4b1c      	ldr	r3, [pc, #112]	; (6838 <main+0x35c>)
    67c8:	4798      	blx	r3
				io_write_clear_ack(simulation_trigger_LED_on,6);
    67ca:	2106      	movs	r1, #6
    67cc:	4838      	ldr	r0, [pc, #224]	; (68b0 <main+0x3d4>)
    67ce:	3030      	adds	r0, #48	; 0x30
    67d0:	4b38      	ldr	r3, [pc, #224]	; (68b4 <main+0x3d8>)
    67d2:	4798      	blx	r3
				trig_LED_delay = TRIGGER_LED_DELAY;
    67d4:	2250      	movs	r2, #80	; 0x50
    67d6:	4b2d      	ldr	r3, [pc, #180]	; (688c <main+0x3b0>)
    67d8:	811a      	strh	r2, [r3, #8]
    67da:	e7c5      	b.n	6768 <main+0x28c>
				session_data.trig_LED_on = false;
    67dc:	2200      	movs	r2, #0
    67de:	4b14      	ldr	r3, [pc, #80]	; (6830 <main+0x354>)
    67e0:	701a      	strb	r2, [r3, #0]
				printf("simulation switch trigger LED off\r\n");
    67e2:	4838      	ldr	r0, [pc, #224]	; (68c4 <main+0x3e8>)
    67e4:	4b14      	ldr	r3, [pc, #80]	; (6838 <main+0x35c>)
    67e6:	4798      	blx	r3
				io_write_clear_ack(simulation_trigger_LED_off,6);				
    67e8:	2106      	movs	r1, #6
    67ea:	4831      	ldr	r0, [pc, #196]	; (68b0 <main+0x3d4>)
    67ec:	3018      	adds	r0, #24
    67ee:	4b31      	ldr	r3, [pc, #196]	; (68b4 <main+0x3d8>)
    67f0:	4798      	blx	r3
    67f2:	e7c1      	b.n	6778 <main+0x29c>
    67f4:	20000740 	.word	0x20000740
    67f8:	00000115 	.word	0x00000115
    67fc:	000060c1 	.word	0x000060c1
    6800:	00006489 	.word	0x00006489
    6804:	00007b21 	.word	0x00007b21
    6808:	20000900 	.word	0x20000900
    680c:	00001879 	.word	0x00001879
    6810:	0000e498 	.word	0x0000e498
    6814:	00009565 	.word	0x00009565
    6818:	0000e4b0 	.word	0x0000e4b0
    681c:	0000e4cc 	.word	0x0000e4cc
    6820:	0000e4e8 	.word	0x0000e4e8
    6824:	0000e504 	.word	0x0000e504
    6828:	0000e520 	.word	0x0000e520
    682c:	0000593d 	.word	0x0000593d
    6830:	20000a3c 	.word	0x20000a3c
    6834:	0000e544 	.word	0x0000e544
    6838:	00009659 	.word	0x00009659
    683c:	20000948 	.word	0x20000948
    6840:	00001345 	.word	0x00001345
    6844:	0000e554 	.word	0x0000e554
    6848:	00005435 	.word	0x00005435
    684c:	000014b5 	.word	0x000014b5
    6850:	0000e574 	.word	0x0000e574
    6854:	000054d5 	.word	0x000054d5
    6858:	0000e590 	.word	0x0000e590
    685c:	0000141d 	.word	0x0000141d
    6860:	0000e59c 	.word	0x0000e59c
    6864:	20000a64 	.word	0x20000a64
    6868:	0000e5bc 	.word	0x0000e5bc
    686c:	0000e5d0 	.word	0x0000e5d0
    6870:	0000e5fc 	.word	0x0000e5fc
    6874:	20000180 	.word	0x20000180
    6878:	0000e628 	.word	0x0000e628
    687c:	000060ed 	.word	0x000060ed
    6880:	0000e64c 	.word	0x0000e64c
    6884:	00006169 	.word	0x00006169
    6888:	00006429 	.word	0x00006429
    688c:	20000000 	.word	0x20000000
    6890:	00005fe1 	.word	0x00005fe1
    6894:	00006051 	.word	0x00006051
    6898:	00006315 	.word	0x00006315
    689c:	0000e660 	.word	0x0000e660
    68a0:	0000947d 	.word	0x0000947d
    68a4:	000003d6 	.word	0x000003d6
    68a8:	20000182 	.word	0x20000182
    68ac:	0000e670 	.word	0x0000e670
    68b0:	0000ae08 	.word	0x0000ae08
    68b4:	00005b95 	.word	0x00005b95
    68b8:	0000e688 	.word	0x0000e688
    68bc:	00006255 	.word	0x00006255
    68c0:	0000e6ac 	.word	0x0000e6ac
    68c4:	0000e6d0 	.word	0x0000e6d0
			if (session_data.session_running){
				printf("stop session by pushbutton\r\n");
				stop_session();
			}
			else{
				printf("start session by pushbutton\r\n");
    68c8:	48c5      	ldr	r0, [pc, #788]	; (6be0 <main+0x704>)
    68ca:	4bc6      	ldr	r3, [pc, #792]	; (6be4 <main+0x708>)
    68cc:	4798      	blx	r3
				start_session();
    68ce:	4bc6      	ldr	r3, [pc, #792]	; (6be8 <main+0x70c>)
    68d0:	4798      	blx	r3
			}
		}
				
		if (event_report.report_valid){			
    68d2:	4bc6      	ldr	r3, [pc, #792]	; (6bec <main+0x710>)
    68d4:	795b      	ldrb	r3, [r3, #5]
    68d6:	2b00      	cmp	r3, #0
    68d8:	d14f      	bne.n	697a <main+0x49e>
		if ((adc_value < 1500) || (adc_value > 2000)) {
    68da:	4bc5      	ldr	r3, [pc, #788]	; (6bf0 <main+0x714>)
    68dc:	8859      	ldrh	r1, [r3, #2]
    68de:	4bc5      	ldr	r3, [pc, #788]	; (6bf4 <main+0x718>)
    68e0:	18cb      	adds	r3, r1, r3
    68e2:	b29b      	uxth	r3, r3
    68e4:	22fa      	movs	r2, #250	; 0xfa
    68e6:	0052      	lsls	r2, r2, #1
    68e8:	4293      	cmp	r3, r2
    68ea:	d900      	bls.n	68ee <main+0x412>
    68ec:	e66e      	b.n	65cc <main+0xf0>
			ps_error_counter = 0;
    68ee:	2100      	movs	r1, #0
    68f0:	2340      	movs	r3, #64	; 0x40
    68f2:	4abf      	ldr	r2, [pc, #764]	; (6bf0 <main+0x714>)
    68f4:	52d1      	strh	r1, [r2, r3]
		if (ps_error_counter > 3){
    68f6:	2340      	movs	r3, #64	; 0x40
    68f8:	4abd      	ldr	r2, [pc, #756]	; (6bf0 <main+0x714>)
    68fa:	5ad3      	ldrh	r3, [r2, r3]
    68fc:	2b03      	cmp	r3, #3
    68fe:	d900      	bls.n	6902 <main+0x426>
    6900:	e66e      	b.n	65e0 <main+0x104>
		if (usb_disconnected > 100){
    6902:	4bbd      	ldr	r3, [pc, #756]	; (6bf8 <main+0x71c>)
    6904:	881b      	ldrh	r3, [r3, #0]
    6906:	2b64      	cmp	r3, #100	; 0x64
    6908:	d900      	bls.n	690c <main+0x430>
    690a:	e66c      	b.n	65e6 <main+0x10a>
		if (session_data.session_running) {		
    690c:	4bbb      	ldr	r3, [pc, #748]	; (6bfc <main+0x720>)
    690e:	789b      	ldrb	r3, [r3, #2]
    6910:	2b00      	cmp	r3, #0
    6912:	d100      	bne.n	6916 <main+0x43a>
    6914:	e677      	b.n	6606 <main+0x12a>
			if (session_data.previous_slice != session_data.current_slice){
    6916:	4bb9      	ldr	r3, [pc, #740]	; (6bfc <main+0x720>)
    6918:	8bda      	ldrh	r2, [r3, #30]
    691a:	8b5b      	ldrh	r3, [r3, #26]
    691c:	429a      	cmp	r2, r3
    691e:	d004      	beq.n	692a <main+0x44e>
				session_data.previous_slice = session_data.current_slice;					
    6920:	4ab6      	ldr	r2, [pc, #728]	; (6bfc <main+0x720>)
    6922:	83d3      	strh	r3, [r2, #30]
				print_slices(CURRENT_SLICE_STR);
    6924:	2000      	movs	r0, #0
    6926:	4bb6      	ldr	r3, [pc, #728]	; (6c00 <main+0x724>)
    6928:	4798      	blx	r3
			if (session_data.previous_volume != session_data.current_volume){
    692a:	4bb4      	ldr	r3, [pc, #720]	; (6bfc <main+0x720>)
    692c:	8b9a      	ldrh	r2, [r3, #28]
    692e:	8b1b      	ldrh	r3, [r3, #24]
    6930:	429a      	cmp	r2, r3
    6932:	d004      	beq.n	693e <main+0x462>
				session_data.previous_volume = session_data.current_volume;				
    6934:	4ab1      	ldr	r2, [pc, #708]	; (6bfc <main+0x720>)
    6936:	8393      	strh	r3, [r2, #28]
				print_volumes(CURRENT_VOLUME_STR);			
    6938:	2001      	movs	r0, #1
    693a:	4bb2      	ldr	r3, [pc, #712]	; (6c04 <main+0x728>)
    693c:	4798      	blx	r3
			if (session_data.session_finished) {
    693e:	4baf      	ldr	r3, [pc, #700]	; (6bfc <main+0x720>)
    6940:	785b      	ldrb	r3, [r3, #1]
    6942:	2b00      	cmp	r3, #0
    6944:	d000      	beq.n	6948 <main+0x46c>
    6946:	e654      	b.n	65f2 <main+0x116>
		if ((pb_received) && (!session_data.simulation_mode) && (!session_data.manual_trigger)){
    6948:	4ba9      	ldr	r3, [pc, #676]	; (6bf0 <main+0x714>)
    694a:	781b      	ldrb	r3, [r3, #0]
    694c:	2b00      	cmp	r3, #0
    694e:	d0c0      	beq.n	68d2 <main+0x3f6>
    6950:	4baa      	ldr	r3, [pc, #680]	; (6bfc <main+0x720>)
    6952:	78db      	ldrb	r3, [r3, #3]
    6954:	2b00      	cmp	r3, #0
    6956:	d1bc      	bne.n	68d2 <main+0x3f6>
    6958:	4ba8      	ldr	r3, [pc, #672]	; (6bfc <main+0x720>)
    695a:	791b      	ldrb	r3, [r3, #4]
    695c:	2b00      	cmp	r3, #0
    695e:	d1b8      	bne.n	68d2 <main+0x3f6>
			pb_received = false;
    6960:	2200      	movs	r2, #0
    6962:	4ba3      	ldr	r3, [pc, #652]	; (6bf0 <main+0x714>)
    6964:	701a      	strb	r2, [r3, #0]
			if (session_data.session_running){
    6966:	4ba5      	ldr	r3, [pc, #660]	; (6bfc <main+0x720>)
    6968:	789b      	ldrb	r3, [r3, #2]
    696a:	2b00      	cmp	r3, #0
    696c:	d0ac      	beq.n	68c8 <main+0x3ec>
				printf("stop session by pushbutton\r\n");
    696e:	48a6      	ldr	r0, [pc, #664]	; (6c08 <main+0x72c>)
    6970:	4b9c      	ldr	r3, [pc, #624]	; (6be4 <main+0x708>)
    6972:	4798      	blx	r3
				stop_session();
    6974:	4ba5      	ldr	r3, [pc, #660]	; (6c0c <main+0x730>)
    6976:	4798      	blx	r3
    6978:	e7ab      	b.n	68d2 <main+0x3f6>
			event_report.report_valid=false;
    697a:	4b9c      	ldr	r3, [pc, #624]	; (6bec <main+0x710>)
    697c:	2200      	movs	r2, #0
    697e:	715a      	strb	r2, [r3, #5]
	
			switch (event_report.object_id) {
    6980:	781b      	ldrb	r3, [r3, #0]
    6982:	2b0d      	cmp	r3, #13
    6984:	d100      	bne.n	6988 <main+0x4ac>
    6986:	e36b      	b.n	7060 <main+0xb84>
    6988:	2b1e      	cmp	r3, #30
    698a:	d100      	bne.n	698e <main+0x4b2>
    698c:	e2c3      	b.n	6f16 <main+0xa3a>
    698e:	2b06      	cmp	r3, #6
    6990:	d006      	beq.n	69a0 <main+0x4c4>
				break;
				default:
				;					
			}
			
			printf("Event received from %u, index: %u\r\n", event_report.object_id, event_report.object_index);
    6992:	4b96      	ldr	r3, [pc, #600]	; (6bec <main+0x710>)
    6994:	7819      	ldrb	r1, [r3, #0]
    6996:	785a      	ldrb	r2, [r3, #1]
    6998:	489d      	ldr	r0, [pc, #628]	; (6c10 <main+0x734>)
    699a:	4b9e      	ldr	r3, [pc, #632]	; (6c14 <main+0x738>)
    699c:	4798      	blx	r3
    699e:	e79c      	b.n	68da <main+0x3fe>
					printf("\r\nwinbutton pressed, index: %u\r\n", event_report.object_index);
    69a0:	4c92      	ldr	r4, [pc, #584]	; (6bec <main+0x710>)
    69a2:	7861      	ldrb	r1, [r4, #1]
    69a4:	489c      	ldr	r0, [pc, #624]	; (6c18 <main+0x73c>)
    69a6:	4b9b      	ldr	r3, [pc, #620]	; (6c14 <main+0x738>)
    69a8:	4798      	blx	r3
					if ((event_report.object_index < STOP_SIMULATION) && (event_report.object_index > MAN_TRIG_BACK)){ //avoid doubleclick with 'Both' action buttons
    69aa:	7863      	ldrb	r3, [r4, #1]
    69ac:	1f1a      	subs	r2, r3, #4
    69ae:	b2d2      	uxtb	r2, r2
    69b0:	2a08      	cmp	r2, #8
    69b2:	d808      	bhi.n	69c6 <main+0x4ea>
						if (event_report.value_lsb == 1){
    69b4:	4a8d      	ldr	r2, [pc, #564]	; (6bec <main+0x710>)
    69b6:	78d2      	ldrb	r2, [r2, #3]
    69b8:	2a01      	cmp	r2, #1
    69ba:	d108      	bne.n	69ce <main+0x4f2>
							click_length = CLICK_SOUND_LENGTH;
    69bc:	21bc      	movs	r1, #188	; 0xbc
    69be:	0049      	lsls	r1, r1, #1
    69c0:	4a8b      	ldr	r2, [pc, #556]	; (6bf0 <main+0x714>)
    69c2:	8111      	strh	r1, [r2, #8]
    69c4:	e003      	b.n	69ce <main+0x4f2>
						click_length = CLICK_SOUND_LENGTH;
    69c6:	21bc      	movs	r1, #188	; 0xbc
    69c8:	0049      	lsls	r1, r1, #1
    69ca:	4a89      	ldr	r2, [pc, #548]	; (6bf0 <main+0x714>)
    69cc:	8111      	strh	r1, [r2, #8]
					switch (event_report.object_index) {
    69ce:	2b21      	cmp	r3, #33	; 0x21
    69d0:	d8df      	bhi.n	6992 <main+0x4b6>
    69d2:	009b      	lsls	r3, r3, #2
    69d4:	4a91      	ldr	r2, [pc, #580]	; (6c1c <main+0x740>)
    69d6:	58d3      	ldr	r3, [r2, r3]
    69d8:	469f      	mov	pc, r3
							start_session();
    69da:	4b83      	ldr	r3, [pc, #524]	; (6be8 <main+0x70c>)
    69dc:	4798      	blx	r3
						break;
    69de:	e7d8      	b.n	6992 <main+0x4b6>
							switch_to_form(MENU_FORM);
    69e0:	2007      	movs	r0, #7
    69e2:	4b8f      	ldr	r3, [pc, #572]	; (6c20 <main+0x744>)
    69e4:	4798      	blx	r3
							printf("switching to form 7\r\n");
    69e6:	488f      	ldr	r0, [pc, #572]	; (6c24 <main+0x748>)
    69e8:	4b7e      	ldr	r3, [pc, #504]	; (6be4 <main+0x708>)
    69ea:	4798      	blx	r3
						break;
    69ec:	e7d1      	b.n	6992 <main+0x4b6>
							stop_session();
    69ee:	4b87      	ldr	r3, [pc, #540]	; (6c0c <main+0x730>)
    69f0:	4798      	blx	r3
						break;
    69f2:	e7ce      	b.n	6992 <main+0x4b6>
							if (event_report.value_lsb == ON){
    69f4:	4b7d      	ldr	r3, [pc, #500]	; (6bec <main+0x710>)
    69f6:	78db      	ldrb	r3, [r3, #3]
    69f8:	2b01      	cmp	r3, #1
    69fa:	d006      	beq.n	6a0a <main+0x52e>
								session_data.simulated_A = false;
    69fc:	2200      	movs	r2, #0
    69fe:	4b7f      	ldr	r3, [pc, #508]	; (6bfc <main+0x720>)
    6a00:	719a      	strb	r2, [r3, #6]
							printf("simulated A\r\n");
    6a02:	4889      	ldr	r0, [pc, #548]	; (6c28 <main+0x74c>)
    6a04:	4b77      	ldr	r3, [pc, #476]	; (6be4 <main+0x708>)
    6a06:	4798      	blx	r3
						break;
    6a08:	e7c3      	b.n	6992 <main+0x4b6>
								session_data.simulated_A = true;
    6a0a:	2201      	movs	r2, #1
    6a0c:	4b7b      	ldr	r3, [pc, #492]	; (6bfc <main+0x720>)
    6a0e:	719a      	strb	r2, [r3, #6]
								delay_ms(10);
    6a10:	200a      	movs	r0, #10
    6a12:	4b86      	ldr	r3, [pc, #536]	; (6c2c <main+0x750>)
    6a14:	4798      	blx	r3
    6a16:	e7f4      	b.n	6a02 <main+0x526>
							if (event_report.value_lsb == ON){
    6a18:	4b74      	ldr	r3, [pc, #464]	; (6bec <main+0x710>)
    6a1a:	78db      	ldrb	r3, [r3, #3]
    6a1c:	2b01      	cmp	r3, #1
    6a1e:	d006      	beq.n	6a2e <main+0x552>
								session_data.simulated_B = false;
    6a20:	2200      	movs	r2, #0
    6a22:	4b76      	ldr	r3, [pc, #472]	; (6bfc <main+0x720>)
    6a24:	71da      	strb	r2, [r3, #7]
							printf("simulated B\r\n");
    6a26:	4882      	ldr	r0, [pc, #520]	; (6c30 <main+0x754>)
    6a28:	4b6e      	ldr	r3, [pc, #440]	; (6be4 <main+0x708>)
    6a2a:	4798      	blx	r3
						break;
    6a2c:	e7b1      	b.n	6992 <main+0x4b6>
								session_data.simulated_B = true;
    6a2e:	2201      	movs	r2, #1
    6a30:	4b72      	ldr	r3, [pc, #456]	; (6bfc <main+0x720>)
    6a32:	71da      	strb	r2, [r3, #7]
								delay_ms(10);
    6a34:	200a      	movs	r0, #10
    6a36:	4b7d      	ldr	r3, [pc, #500]	; (6c2c <main+0x750>)
    6a38:	4798      	blx	r3
    6a3a:	e7f4      	b.n	6a26 <main+0x54a>
							if (event_report.value_lsb == ON){
    6a3c:	4b6b      	ldr	r3, [pc, #428]	; (6bec <main+0x710>)
    6a3e:	78db      	ldrb	r3, [r3, #3]
    6a40:	2b01      	cmp	r3, #1
    6a42:	d006      	beq.n	6a52 <main+0x576>
								session_data.simulated_C = false;
    6a44:	2200      	movs	r2, #0
    6a46:	4b6d      	ldr	r3, [pc, #436]	; (6bfc <main+0x720>)
    6a48:	721a      	strb	r2, [r3, #8]
							printf("simulated C\r\n");
    6a4a:	487a      	ldr	r0, [pc, #488]	; (6c34 <main+0x758>)
    6a4c:	4b65      	ldr	r3, [pc, #404]	; (6be4 <main+0x708>)
    6a4e:	4798      	blx	r3
						break;
    6a50:	e79f      	b.n	6992 <main+0x4b6>
								session_data.simulated_C = true;
    6a52:	2201      	movs	r2, #1
    6a54:	4b69      	ldr	r3, [pc, #420]	; (6bfc <main+0x720>)
    6a56:	721a      	strb	r2, [r3, #8]
								delay_ms(10);
    6a58:	200a      	movs	r0, #10
    6a5a:	4b74      	ldr	r3, [pc, #464]	; (6c2c <main+0x750>)
    6a5c:	4798      	blx	r3
    6a5e:	e7f4      	b.n	6a4a <main+0x56e>
							if (event_report.value_lsb == ON){
    6a60:	4b62      	ldr	r3, [pc, #392]	; (6bec <main+0x710>)
    6a62:	78db      	ldrb	r3, [r3, #3]
    6a64:	2b01      	cmp	r3, #1
    6a66:	d006      	beq.n	6a76 <main+0x59a>
								session_data.simulated_D = false;
    6a68:	2200      	movs	r2, #0
    6a6a:	4b64      	ldr	r3, [pc, #400]	; (6bfc <main+0x720>)
    6a6c:	725a      	strb	r2, [r3, #9]
							printf("simulated D\r\n");
    6a6e:	4872      	ldr	r0, [pc, #456]	; (6c38 <main+0x75c>)
    6a70:	4b5c      	ldr	r3, [pc, #368]	; (6be4 <main+0x708>)
    6a72:	4798      	blx	r3
						break;
    6a74:	e78d      	b.n	6992 <main+0x4b6>
								session_data.simulated_D = true;
    6a76:	2201      	movs	r2, #1
    6a78:	4b60      	ldr	r3, [pc, #384]	; (6bfc <main+0x720>)
    6a7a:	725a      	strb	r2, [r3, #9]
								delay_ms(10);
    6a7c:	200a      	movs	r0, #10
    6a7e:	4b6b      	ldr	r3, [pc, #428]	; (6c2c <main+0x750>)
    6a80:	4798      	blx	r3
    6a82:	e7f4      	b.n	6a6e <main+0x592>
							if ((event_report.value_lsb == ON) && (!session_data.simulation_mode) && (!session_data.session_running) && (session_data.manual_trigger) && (!trigger_debounce)){
    6a84:	4b59      	ldr	r3, [pc, #356]	; (6bec <main+0x710>)
    6a86:	78db      	ldrb	r3, [r3, #3]
    6a88:	2b01      	cmp	r3, #1
    6a8a:	d182      	bne.n	6992 <main+0x4b6>
    6a8c:	4b5b      	ldr	r3, [pc, #364]	; (6bfc <main+0x720>)
    6a8e:	78db      	ldrb	r3, [r3, #3]
    6a90:	2b00      	cmp	r3, #0
    6a92:	d000      	beq.n	6a96 <main+0x5ba>
    6a94:	e77d      	b.n	6992 <main+0x4b6>
    6a96:	4b59      	ldr	r3, [pc, #356]	; (6bfc <main+0x720>)
    6a98:	789b      	ldrb	r3, [r3, #2]
    6a9a:	2b00      	cmp	r3, #0
    6a9c:	d000      	beq.n	6aa0 <main+0x5c4>
    6a9e:	e778      	b.n	6992 <main+0x4b6>
    6aa0:	4b56      	ldr	r3, [pc, #344]	; (6bfc <main+0x720>)
    6aa2:	791b      	ldrb	r3, [r3, #4]
    6aa4:	2b00      	cmp	r3, #0
    6aa6:	d100      	bne.n	6aaa <main+0x5ce>
    6aa8:	e773      	b.n	6992 <main+0x4b6>
    6aaa:	4b64      	ldr	r3, [pc, #400]	; (6c3c <main+0x760>)
    6aac:	881b      	ldrh	r3, [r3, #0]
    6aae:	2b00      	cmp	r3, #0
    6ab0:	d000      	beq.n	6ab4 <main+0x5d8>
    6ab2:	e76e      	b.n	6992 <main+0x4b6>
								trigger_debounce = TRIGGER_DEBOUNCE_TIME;
    6ab4:	2232      	movs	r2, #50	; 0x32
    6ab6:	4b61      	ldr	r3, [pc, #388]	; (6c3c <main+0x760>)
    6ab8:	801a      	strh	r2, [r3, #0]
								printf("simulated S\r\n");
    6aba:	4861      	ldr	r0, [pc, #388]	; (6c40 <main+0x764>)
    6abc:	4b49      	ldr	r3, [pc, #292]	; (6be4 <main+0x708>)
    6abe:	4798      	blx	r3
								session_data.current_slice += 1;
    6ac0:	4a4e      	ldr	r2, [pc, #312]	; (6bfc <main+0x720>)
    6ac2:	8b53      	ldrh	r3, [r2, #26]
    6ac4:	3301      	adds	r3, #1
    6ac6:	b29b      	uxth	r3, r3
    6ac8:	8353      	strh	r3, [r2, #26]
								if (((session_data.current_slice >= session_data.no_of_slices) && (session_data.current_volume == session_data.no_of_volumes)) ||
    6aca:	8a52      	ldrh	r2, [r2, #18]
    6acc:	4293      	cmp	r3, r2
    6ace:	d304      	bcc.n	6ada <main+0x5fe>
    6ad0:	494a      	ldr	r1, [pc, #296]	; (6bfc <main+0x720>)
    6ad2:	8b08      	ldrh	r0, [r1, #24]
    6ad4:	8a09      	ldrh	r1, [r1, #16]
    6ad6:	4288      	cmp	r0, r1
    6ad8:	d004      	beq.n	6ae4 <main+0x608>
								(session_data.current_volume > session_data.no_of_volumes)){
    6ada:	4948      	ldr	r1, [pc, #288]	; (6bfc <main+0x720>)
    6adc:	8b08      	ldrh	r0, [r1, #24]
    6ade:	8a09      	ldrh	r1, [r1, #16]
								if (((session_data.current_slice >= session_data.no_of_slices) && (session_data.current_volume == session_data.no_of_volumes)) ||
    6ae0:	4288      	cmp	r0, r1
    6ae2:	d902      	bls.n	6aea <main+0x60e>
									session_data.session_finished = true;
    6ae4:	2001      	movs	r0, #1
    6ae6:	4945      	ldr	r1, [pc, #276]	; (6bfc <main+0x720>)
    6ae8:	7048      	strb	r0, [r1, #1]
								if ((session_data.current_slice > session_data.no_of_slices) && (!session_data.session_finished)){
    6aea:	4293      	cmp	r3, r2
    6aec:	d909      	bls.n	6b02 <main+0x626>
    6aee:	4b43      	ldr	r3, [pc, #268]	; (6bfc <main+0x720>)
    6af0:	785b      	ldrb	r3, [r3, #1]
    6af2:	2b00      	cmp	r3, #0
    6af4:	d105      	bne.n	6b02 <main+0x626>
									session_data.current_volume += 1;
    6af6:	4b41      	ldr	r3, [pc, #260]	; (6bfc <main+0x720>)
    6af8:	8b1a      	ldrh	r2, [r3, #24]
    6afa:	3201      	adds	r2, #1
    6afc:	831a      	strh	r2, [r3, #24]
									session_data.current_slice = 1;
    6afe:	2201      	movs	r2, #1
    6b00:	835a      	strh	r2, [r3, #26]
								uint16_t divider = session_data.trig_on_volume;
    6b02:	4b3e      	ldr	r3, [pc, #248]	; (6bfc <main+0x720>)
    6b04:	8a9b      	ldrh	r3, [r3, #20]
								if (divider == 0) {
    6b06:	2b00      	cmp	r3, #0
    6b08:	d02f      	beq.n	6b6a <main+0x68e>
								uint16_t divider = session_data.trig_on_volume;
    6b0a:	0019      	movs	r1, r3
								if ((session_data.trig_on_volume == 0) || (((session_data.current_volume - 1) % divider) == 0)){
    6b0c:	2b00      	cmp	r3, #0
    6b0e:	d007      	beq.n	6b20 <main+0x644>
    6b10:	4b3a      	ldr	r3, [pc, #232]	; (6bfc <main+0x720>)
    6b12:	8b18      	ldrh	r0, [r3, #24]
    6b14:	3801      	subs	r0, #1
    6b16:	4b4b      	ldr	r3, [pc, #300]	; (6c44 <main+0x768>)
    6b18:	4798      	blx	r3
    6b1a:	2900      	cmp	r1, #0
    6b1c:	d000      	beq.n	6b20 <main+0x644>
    6b1e:	e738      	b.n	6992 <main+0x4b6>
									if ((session_data.trig_on_slice == 0) || (session_data.trig_on_slice == session_data.current_slice)){
    6b20:	4b36      	ldr	r3, [pc, #216]	; (6bfc <main+0x720>)
    6b22:	8adb      	ldrh	r3, [r3, #22]
    6b24:	2b00      	cmp	r3, #0
    6b26:	d004      	beq.n	6b32 <main+0x656>
    6b28:	4a34      	ldr	r2, [pc, #208]	; (6bfc <main+0x720>)
    6b2a:	8b52      	ldrh	r2, [r2, #26]
    6b2c:	4293      	cmp	r3, r2
    6b2e:	d000      	beq.n	6b32 <main+0x656>
    6b30:	e72f      	b.n	6992 <main+0x4b6>
										session_data.trigger = true;										
    6b32:	4c32      	ldr	r4, [pc, #200]	; (6bfc <main+0x720>)
    6b34:	2301      	movs	r3, #1
    6b36:	7163      	strb	r3, [r4, #5]
										printf("start sync sound\r\n");
    6b38:	4843      	ldr	r0, [pc, #268]	; (6c48 <main+0x76c>)
    6b3a:	4b2a      	ldr	r3, [pc, #168]	; (6be4 <main+0x708>)
    6b3c:	4798      	blx	r3
										sync_beep_length = SYNC_BEEP_LENGTH;
    6b3e:	4a43      	ldr	r2, [pc, #268]	; (6c4c <main+0x770>)
    6b40:	4b43      	ldr	r3, [pc, #268]	; (6c50 <main+0x774>)
    6b42:	801a      	strh	r2, [r3, #0]
										if (!session_data.trig_LED_on){
    6b44:	7823      	ldrb	r3, [r4, #0]
    6b46:	2b00      	cmp	r3, #0
    6b48:	d000      	beq.n	6b4c <main+0x670>
    6b4a:	e722      	b.n	6992 <main+0x4b6>
											session_data.trig_LED_on = true;
    6b4c:	2201      	movs	r2, #1
    6b4e:	4b2b      	ldr	r3, [pc, #172]	; (6bfc <main+0x720>)
    6b50:	701a      	strb	r2, [r3, #0]
											printf("switch trigger LED on\r\n");
    6b52:	4840      	ldr	r0, [pc, #256]	; (6c54 <main+0x778>)
    6b54:	4b23      	ldr	r3, [pc, #140]	; (6be4 <main+0x708>)
    6b56:	4798      	blx	r3
											io_write_clear_ack(man_trig_trigger_LED_on,6);
    6b58:	2106      	movs	r1, #6
    6b5a:	483f      	ldr	r0, [pc, #252]	; (6c58 <main+0x77c>)
    6b5c:	3028      	adds	r0, #40	; 0x28
    6b5e:	4b3f      	ldr	r3, [pc, #252]	; (6c5c <main+0x780>)
    6b60:	4798      	blx	r3
											trig_LED_delay = TRIGGER_LED_DELAY;
    6b62:	2250      	movs	r2, #80	; 0x50
    6b64:	4b35      	ldr	r3, [pc, #212]	; (6c3c <main+0x760>)
    6b66:	811a      	strh	r2, [r3, #8]
    6b68:	e713      	b.n	6992 <main+0x4b6>
									divider = 1;
    6b6a:	2101      	movs	r1, #1
    6b6c:	e7ce      	b.n	6b0c <main+0x630>
							stop_man_trig();						
    6b6e:	4b3c      	ldr	r3, [pc, #240]	; (6c60 <main+0x784>)
    6b70:	4798      	blx	r3
						break;
    6b72:	e70e      	b.n	6992 <main+0x4b6>
							if (event_report.value_lsb == ON){
    6b74:	4b1d      	ldr	r3, [pc, #116]	; (6bec <main+0x710>)
    6b76:	78db      	ldrb	r3, [r3, #3]
    6b78:	2b01      	cmp	r3, #1
    6b7a:	d006      	beq.n	6b8a <main+0x6ae>
								session_data.simulated_A = false;
    6b7c:	2200      	movs	r2, #0
    6b7e:	4b1f      	ldr	r3, [pc, #124]	; (6bfc <main+0x720>)
    6b80:	719a      	strb	r2, [r3, #6]
							printf("simulated A\r\n");
    6b82:	4829      	ldr	r0, [pc, #164]	; (6c28 <main+0x74c>)
    6b84:	4b17      	ldr	r3, [pc, #92]	; (6be4 <main+0x708>)
    6b86:	4798      	blx	r3
						break;
    6b88:	e703      	b.n	6992 <main+0x4b6>
								session_data.simulated_A = true;
    6b8a:	2201      	movs	r2, #1
    6b8c:	4b1b      	ldr	r3, [pc, #108]	; (6bfc <main+0x720>)
    6b8e:	719a      	strb	r2, [r3, #6]
								delay_ms(10);
    6b90:	200a      	movs	r0, #10
    6b92:	4b26      	ldr	r3, [pc, #152]	; (6c2c <main+0x750>)
    6b94:	4798      	blx	r3
    6b96:	e7f4      	b.n	6b82 <main+0x6a6>
							if (event_report.value_lsb == ON){
    6b98:	4b14      	ldr	r3, [pc, #80]	; (6bec <main+0x710>)
    6b9a:	78db      	ldrb	r3, [r3, #3]
    6b9c:	2b01      	cmp	r3, #1
    6b9e:	d006      	beq.n	6bae <main+0x6d2>
								session_data.simulated_B = false;
    6ba0:	2200      	movs	r2, #0
    6ba2:	4b16      	ldr	r3, [pc, #88]	; (6bfc <main+0x720>)
    6ba4:	71da      	strb	r2, [r3, #7]
							printf("simulated B\r\n");
    6ba6:	4822      	ldr	r0, [pc, #136]	; (6c30 <main+0x754>)
    6ba8:	4b0e      	ldr	r3, [pc, #56]	; (6be4 <main+0x708>)
    6baa:	4798      	blx	r3
						break;
    6bac:	e6f1      	b.n	6992 <main+0x4b6>
								session_data.simulated_B = true;
    6bae:	2201      	movs	r2, #1
    6bb0:	4b12      	ldr	r3, [pc, #72]	; (6bfc <main+0x720>)
    6bb2:	71da      	strb	r2, [r3, #7]
								delay_ms(10);
    6bb4:	200a      	movs	r0, #10
    6bb6:	4b1d      	ldr	r3, [pc, #116]	; (6c2c <main+0x750>)
    6bb8:	4798      	blx	r3
    6bba:	e7f4      	b.n	6ba6 <main+0x6ca>
							if (event_report.value_lsb == ON){
    6bbc:	4b0b      	ldr	r3, [pc, #44]	; (6bec <main+0x710>)
    6bbe:	78db      	ldrb	r3, [r3, #3]
    6bc0:	2b01      	cmp	r3, #1
    6bc2:	d006      	beq.n	6bd2 <main+0x6f6>
								session_data.simulated_C = false;
    6bc4:	2200      	movs	r2, #0
    6bc6:	4b0d      	ldr	r3, [pc, #52]	; (6bfc <main+0x720>)
    6bc8:	721a      	strb	r2, [r3, #8]
							printf("simulated C\r\n");
    6bca:	481a      	ldr	r0, [pc, #104]	; (6c34 <main+0x758>)
    6bcc:	4b05      	ldr	r3, [pc, #20]	; (6be4 <main+0x708>)
    6bce:	4798      	blx	r3
						break;
    6bd0:	e6df      	b.n	6992 <main+0x4b6>
								session_data.simulated_C = true;
    6bd2:	2201      	movs	r2, #1
    6bd4:	4b09      	ldr	r3, [pc, #36]	; (6bfc <main+0x720>)
    6bd6:	721a      	strb	r2, [r3, #8]
								delay_ms(10);
    6bd8:	200a      	movs	r0, #10
    6bda:	4b14      	ldr	r3, [pc, #80]	; (6c2c <main+0x750>)
    6bdc:	4798      	blx	r3
    6bde:	e7f4      	b.n	6bca <main+0x6ee>
    6be0:	0000e710 	.word	0x0000e710
    6be4:	00009659 	.word	0x00009659
    6be8:	00006361 	.word	0x00006361
    6bec:	20000a34 	.word	0x20000a34
    6bf0:	20000740 	.word	0x20000740
    6bf4:	fffffa24 	.word	0xfffffa24
    6bf8:	20000180 	.word	0x20000180
    6bfc:	20000a3c 	.word	0x20000a3c
    6c00:	00005fe1 	.word	0x00005fe1
    6c04:	00006051 	.word	0x00006051
    6c08:	0000e6f4 	.word	0x0000e6f4
    6c0c:	00006429 	.word	0x00006429
    6c10:	0000eb54 	.word	0x0000eb54
    6c14:	00009565 	.word	0x00009565
    6c18:	0000e730 	.word	0x0000e730
    6c1c:	0000ad50 	.word	0x0000ad50
    6c20:	00005d39 	.word	0x00005d39
    6c24:	0000e754 	.word	0x0000e754
    6c28:	0000e76c 	.word	0x0000e76c
    6c2c:	0000141d 	.word	0x0000141d
    6c30:	0000e77c 	.word	0x0000e77c
    6c34:	0000e78c 	.word	0x0000e78c
    6c38:	0000e79c 	.word	0x0000e79c
    6c3c:	20000000 	.word	0x20000000
    6c40:	0000e660 	.word	0x0000e660
    6c44:	0000947d 	.word	0x0000947d
    6c48:	0000e7ac 	.word	0x0000e7ac
    6c4c:	000003d6 	.word	0x000003d6
    6c50:	20000182 	.word	0x20000182
    6c54:	0000e670 	.word	0x0000e670
    6c58:	0000ae08 	.word	0x0000ae08
    6c5c:	00005b95 	.word	0x00005b95
    6c60:	00006315 	.word	0x00006315
							if (event_report.value_lsb == ON){
    6c64:	4bd3      	ldr	r3, [pc, #844]	; (6fb4 <main+0xad8>)
    6c66:	78db      	ldrb	r3, [r3, #3]
    6c68:	2b01      	cmp	r3, #1
    6c6a:	d006      	beq.n	6c7a <main+0x79e>
								session_data.simulated_D = false;
    6c6c:	2200      	movs	r2, #0
    6c6e:	4bd2      	ldr	r3, [pc, #840]	; (6fb8 <main+0xadc>)
    6c70:	725a      	strb	r2, [r3, #9]
							printf("simulated D\r\n");
    6c72:	48d2      	ldr	r0, [pc, #840]	; (6fbc <main+0xae0>)
    6c74:	4bd2      	ldr	r3, [pc, #840]	; (6fc0 <main+0xae4>)
    6c76:	4798      	blx	r3
						break;
    6c78:	e68b      	b.n	6992 <main+0x4b6>
								session_data.simulated_D = true;
    6c7a:	2201      	movs	r2, #1
    6c7c:	4bce      	ldr	r3, [pc, #824]	; (6fb8 <main+0xadc>)
    6c7e:	725a      	strb	r2, [r3, #9]
								delay_ms(10);
    6c80:	200a      	movs	r0, #10
    6c82:	4bd0      	ldr	r3, [pc, #832]	; (6fc4 <main+0xae8>)
    6c84:	4798      	blx	r3
    6c86:	e7f4      	b.n	6c72 <main+0x796>
							stop_simulation();												
    6c88:	4bcf      	ldr	r3, [pc, #828]	; (6fc8 <main+0xaec>)
    6c8a:	4798      	blx	r3
						break;
    6c8c:	e681      	b.n	6992 <main+0x4b6>
							session_temp.parameter = SLICE_TRIGGERNO_BTN;
    6c8e:	4ccf      	ldr	r4, [pc, #828]	; (6fcc <main+0xaf0>)
    6c90:	230e      	movs	r3, #14
    6c92:	7423      	strb	r3, [r4, #16]
							switch_to_form(KEYBOARD_FORM);
    6c94:	2006      	movs	r0, #6
    6c96:	4bce      	ldr	r3, [pc, #824]	; (6fd0 <main+0xaf4>)
    6c98:	4798      	blx	r3
							kb_value = session_temp.trig_on_slice;
    6c9a:	88e3      	ldrh	r3, [r4, #6]
    6c9c:	4ccd      	ldr	r4, [pc, #820]	; (6fd4 <main+0xaf8>)
    6c9e:	6463      	str	r3, [r4, #68]	; 0x44
							minvalue = 0;
    6ca0:	2300      	movs	r3, #0
    6ca2:	64a3      	str	r3, [r4, #72]	; 0x48
							maxvalue = 999;
    6ca4:	4bcc      	ldr	r3, [pc, #816]	; (6fd8 <main+0xafc>)
    6ca6:	64e3      	str	r3, [r4, #76]	; 0x4c
							io_write_clear_ack(set_trigg_slice_txt,6);
    6ca8:	2106      	movs	r1, #6
    6caa:	48cc      	ldr	r0, [pc, #816]	; (6fdc <main+0xb00>)
    6cac:	3038      	adds	r0, #56	; 0x38
    6cae:	4bcc      	ldr	r3, [pc, #816]	; (6fe0 <main+0xb04>)
    6cb0:	4798      	blx	r3
							print_no(kb_value, 11);
    6cb2:	6c60      	ldr	r0, [r4, #68]	; 0x44
    6cb4:	210b      	movs	r1, #11
    6cb6:	4bcb      	ldr	r3, [pc, #812]	; (6fe4 <main+0xb08>)
    6cb8:	4798      	blx	r3
							printf("set slice trigg no, switch to form 6\r\n");
    6cba:	48cb      	ldr	r0, [pc, #812]	; (6fe8 <main+0xb0c>)
    6cbc:	4bc0      	ldr	r3, [pc, #768]	; (6fc0 <main+0xae4>)
    6cbe:	4798      	blx	r3
						break;
    6cc0:	e667      	b.n	6992 <main+0x4b6>
							session_temp.parameter = VOLUME_TRIGGERNO_BTN;
    6cc2:	4cc2      	ldr	r4, [pc, #776]	; (6fcc <main+0xaf0>)
    6cc4:	2312      	movs	r3, #18
    6cc6:	7423      	strb	r3, [r4, #16]
							switch_to_form(KEYBOARD_FORM);
    6cc8:	2006      	movs	r0, #6
    6cca:	4bc1      	ldr	r3, [pc, #772]	; (6fd0 <main+0xaf4>)
    6ccc:	4798      	blx	r3
							kb_value = session_temp.trig_on_volume;
    6cce:	88a3      	ldrh	r3, [r4, #4]
    6cd0:	4cc0      	ldr	r4, [pc, #768]	; (6fd4 <main+0xaf8>)
    6cd2:	6463      	str	r3, [r4, #68]	; 0x44
							minvalue = 0;
    6cd4:	2300      	movs	r3, #0
    6cd6:	64a3      	str	r3, [r4, #72]	; 0x48
							maxvalue = 9999;
    6cd8:	4bc4      	ldr	r3, [pc, #784]	; (6fec <main+0xb10>)
    6cda:	64e3      	str	r3, [r4, #76]	; 0x4c
							io_write_clear_ack(set_trigg_volume_txt,6);
    6cdc:	2106      	movs	r1, #6
    6cde:	48bf      	ldr	r0, [pc, #764]	; (6fdc <main+0xb00>)
    6ce0:	3040      	adds	r0, #64	; 0x40
    6ce2:	4bbf      	ldr	r3, [pc, #764]	; (6fe0 <main+0xb04>)
    6ce4:	4798      	blx	r3
							print_no(kb_value, 11);
    6ce6:	6c60      	ldr	r0, [r4, #68]	; 0x44
    6ce8:	210b      	movs	r1, #11
    6cea:	4bbe      	ldr	r3, [pc, #760]	; (6fe4 <main+0xb08>)
    6cec:	4798      	blx	r3
							printf("set volume trigg no, switch to form 6\r\n");
    6cee:	48c0      	ldr	r0, [pc, #768]	; (6ff0 <main+0xb14>)
    6cf0:	4bb3      	ldr	r3, [pc, #716]	; (6fc0 <main+0xae4>)
    6cf2:	4798      	blx	r3
						break;
    6cf4:	e64d      	b.n	6992 <main+0x4b6>
							switch_to_form(SETTINGS_2_FORM);
    6cf6:	2005      	movs	r0, #5
    6cf8:	4bb5      	ldr	r3, [pc, #724]	; (6fd0 <main+0xaf4>)
    6cfa:	4798      	blx	r3
							printf("form4 more, switch to form 5\r\n");
    6cfc:	48bd      	ldr	r0, [pc, #756]	; (6ff4 <main+0xb18>)
    6cfe:	4bb0      	ldr	r3, [pc, #704]	; (6fc0 <main+0xae4>)
    6d00:	4798      	blx	r3
						break;
    6d02:	e646      	b.n	6992 <main+0x4b6>
							switch_to_form(MENU_FORM);
    6d04:	2007      	movs	r0, #7
    6d06:	4bb2      	ldr	r3, [pc, #712]	; (6fd0 <main+0xaf4>)
    6d08:	4798      	blx	r3
							session_data.no_of_slices = session_temp.no_of_slices;
    6d0a:	4ab0      	ldr	r2, [pc, #704]	; (6fcc <main+0xaf0>)
    6d0c:	8851      	ldrh	r1, [r2, #2]
    6d0e:	4baa      	ldr	r3, [pc, #680]	; (6fb8 <main+0xadc>)
    6d10:	8259      	strh	r1, [r3, #18]
							session_data.no_of_volumes = session_temp.no_of_volumes;
    6d12:	8811      	ldrh	r1, [r2, #0]
    6d14:	8219      	strh	r1, [r3, #16]
							session_data.trig_on_slice = session_temp.trig_on_slice;
    6d16:	88d1      	ldrh	r1, [r2, #6]
    6d18:	82d9      	strh	r1, [r3, #22]
							session_data.trig_on_volume = session_temp.trig_on_volume;
    6d1a:	8891      	ldrh	r1, [r2, #4]
    6d1c:	8299      	strh	r1, [r3, #20]
							session_data.pulse_length = session_temp.pulse_length;
    6d1e:	8911      	ldrh	r1, [r2, #8]
    6d20:	8419      	strh	r1, [r3, #32]
							session_data.TR_time = session_temp.TR_time;
    6d22:	68d2      	ldr	r2, [r2, #12]
    6d24:	625a      	str	r2, [r3, #36]	; 0x24
							printf("form4 accept, switch to form 7\r\n");
    6d26:	48b4      	ldr	r0, [pc, #720]	; (6ff8 <main+0xb1c>)
    6d28:	4ca5      	ldr	r4, [pc, #660]	; (6fc0 <main+0xae4>)
    6d2a:	47a0      	blx	r4
							write_flash();
    6d2c:	4bb3      	ldr	r3, [pc, #716]	; (6ffc <main+0xb20>)
    6d2e:	4798      	blx	r3
							printf("FLASH written\r\n");
    6d30:	48b3      	ldr	r0, [pc, #716]	; (7000 <main+0xb24>)
    6d32:	47a0      	blx	r4
						break;
    6d34:	e62d      	b.n	6992 <main+0x4b6>
							switch_to_form(MENU_FORM);
    6d36:	2007      	movs	r0, #7
    6d38:	4ba5      	ldr	r3, [pc, #660]	; (6fd0 <main+0xaf4>)
    6d3a:	4798      	blx	r3
							printf("form4 cancel, switch to form 7\r\n");
    6d3c:	48b1      	ldr	r0, [pc, #708]	; (7004 <main+0xb28>)
    6d3e:	4ba0      	ldr	r3, [pc, #640]	; (6fc0 <main+0xae4>)
    6d40:	4798      	blx	r3
						break;
    6d42:	e626      	b.n	6992 <main+0x4b6>
							session_temp.parameter = SET_SLICESNO_BTN;
    6d44:	4ca1      	ldr	r4, [pc, #644]	; (6fcc <main+0xaf0>)
    6d46:	2319      	movs	r3, #25
    6d48:	7423      	strb	r3, [r4, #16]
							switch_to_form(KEYBOARD_FORM);
    6d4a:	2006      	movs	r0, #6
    6d4c:	4ba0      	ldr	r3, [pc, #640]	; (6fd0 <main+0xaf4>)
    6d4e:	4798      	blx	r3
							kb_value = session_temp.no_of_slices;
    6d50:	8863      	ldrh	r3, [r4, #2]
    6d52:	4ca0      	ldr	r4, [pc, #640]	; (6fd4 <main+0xaf8>)
    6d54:	6463      	str	r3, [r4, #68]	; 0x44
							minvalue = 1;
    6d56:	2301      	movs	r3, #1
    6d58:	64a3      	str	r3, [r4, #72]	; 0x48
							maxvalue = 999;
    6d5a:	4b9f      	ldr	r3, [pc, #636]	; (6fd8 <main+0xafc>)
    6d5c:	64e3      	str	r3, [r4, #76]	; 0x4c
							io_write_clear_ack(set_no_of_slices_txt,6);
    6d5e:	2106      	movs	r1, #6
    6d60:	489e      	ldr	r0, [pc, #632]	; (6fdc <main+0xb00>)
    6d62:	3048      	adds	r0, #72	; 0x48
    6d64:	4b9e      	ldr	r3, [pc, #632]	; (6fe0 <main+0xb04>)
    6d66:	4798      	blx	r3
							print_no(kb_value, 11);
    6d68:	6c60      	ldr	r0, [r4, #68]	; 0x44
    6d6a:	210b      	movs	r1, #11
    6d6c:	4b9d      	ldr	r3, [pc, #628]	; (6fe4 <main+0xb08>)
    6d6e:	4798      	blx	r3
							printf("set slices no, switch to form 6\r\n");
    6d70:	48a5      	ldr	r0, [pc, #660]	; (7008 <main+0xb2c>)
    6d72:	4b93      	ldr	r3, [pc, #588]	; (6fc0 <main+0xae4>)
    6d74:	4798      	blx	r3
						break;
    6d76:	e60c      	b.n	6992 <main+0x4b6>
							session_temp.parameter = SET_VOLUMESNO_BTN;
    6d78:	4c94      	ldr	r4, [pc, #592]	; (6fcc <main+0xaf0>)
    6d7a:	2318      	movs	r3, #24
    6d7c:	7423      	strb	r3, [r4, #16]
							switch_to_form(KEYBOARD_FORM);
    6d7e:	2006      	movs	r0, #6
    6d80:	4b93      	ldr	r3, [pc, #588]	; (6fd0 <main+0xaf4>)
    6d82:	4798      	blx	r3
							kb_value = session_temp.no_of_volumes;
    6d84:	8823      	ldrh	r3, [r4, #0]
    6d86:	4c93      	ldr	r4, [pc, #588]	; (6fd4 <main+0xaf8>)
    6d88:	6463      	str	r3, [r4, #68]	; 0x44
							minvalue = 1;
    6d8a:	2301      	movs	r3, #1
    6d8c:	64a3      	str	r3, [r4, #72]	; 0x48
							maxvalue = 9999;
    6d8e:	4b97      	ldr	r3, [pc, #604]	; (6fec <main+0xb10>)
    6d90:	64e3      	str	r3, [r4, #76]	; 0x4c
							io_write_clear_ack(set_no_of_volumes_txt,6);
    6d92:	2106      	movs	r1, #6
    6d94:	4891      	ldr	r0, [pc, #580]	; (6fdc <main+0xb00>)
    6d96:	3050      	adds	r0, #80	; 0x50
    6d98:	4b91      	ldr	r3, [pc, #580]	; (6fe0 <main+0xb04>)
    6d9a:	4798      	blx	r3
							print_no(kb_value, 11);
    6d9c:	6c60      	ldr	r0, [r4, #68]	; 0x44
    6d9e:	210b      	movs	r1, #11
    6da0:	4b90      	ldr	r3, [pc, #576]	; (6fe4 <main+0xb08>)
    6da2:	4798      	blx	r3
							printf("set volumes no, switch to form 6\r\n");
    6da4:	4899      	ldr	r0, [pc, #612]	; (700c <main+0xb30>)
    6da6:	4b86      	ldr	r3, [pc, #536]	; (6fc0 <main+0xae4>)
    6da8:	4798      	blx	r3
						break;
    6daa:	e5f2      	b.n	6992 <main+0x4b6>
							session_temp.parameter = PULSE_LENGTH_BTN;
    6dac:	4c87      	ldr	r4, [pc, #540]	; (6fcc <main+0xaf0>)
    6dae:	2317      	movs	r3, #23
    6db0:	7423      	strb	r3, [r4, #16]
							switch_to_form(KEYBOARD_FORM);
    6db2:	2006      	movs	r0, #6
    6db4:	4b86      	ldr	r3, [pc, #536]	; (6fd0 <main+0xaf4>)
    6db6:	4798      	blx	r3
							kb_value = session_temp.pulse_length;
    6db8:	8923      	ldrh	r3, [r4, #8]
    6dba:	4c86      	ldr	r4, [pc, #536]	; (6fd4 <main+0xaf8>)
    6dbc:	6463      	str	r3, [r4, #68]	; 0x44
							minvalue = 100;
    6dbe:	2364      	movs	r3, #100	; 0x64
    6dc0:	64a3      	str	r3, [r4, #72]	; 0x48
							maxvalue = 999;
    6dc2:	4b85      	ldr	r3, [pc, #532]	; (6fd8 <main+0xafc>)
    6dc4:	64e3      	str	r3, [r4, #76]	; 0x4c
							io_write_clear_ack(set_pulse_length_txt,6);							
    6dc6:	2106      	movs	r1, #6
    6dc8:	4884      	ldr	r0, [pc, #528]	; (6fdc <main+0xb00>)
    6dca:	3058      	adds	r0, #88	; 0x58
    6dcc:	4b84      	ldr	r3, [pc, #528]	; (6fe0 <main+0xb04>)
    6dce:	4798      	blx	r3
							print_no(kb_value, 11);							
    6dd0:	6c60      	ldr	r0, [r4, #68]	; 0x44
    6dd2:	210b      	movs	r1, #11
    6dd4:	4b83      	ldr	r3, [pc, #524]	; (6fe4 <main+0xb08>)
    6dd6:	4798      	blx	r3
							printf("set pulse length, switch to form 6\r\n");
    6dd8:	488d      	ldr	r0, [pc, #564]	; (7010 <main+0xb34>)
    6dda:	4b79      	ldr	r3, [pc, #484]	; (6fc0 <main+0xae4>)
    6ddc:	4798      	blx	r3
						break;
    6dde:	e5d8      	b.n	6992 <main+0x4b6>
							session_temp.parameter = TR_TIME_BTN;
    6de0:	4c7a      	ldr	r4, [pc, #488]	; (6fcc <main+0xaf0>)
    6de2:	2316      	movs	r3, #22
    6de4:	7423      	strb	r3, [r4, #16]
							switch_to_form(KEYBOARD_FORM);
    6de6:	2006      	movs	r0, #6
    6de8:	4b79      	ldr	r3, [pc, #484]	; (6fd0 <main+0xaf4>)
    6dea:	4798      	blx	r3
							kb_value = session_temp.TR_time;
    6dec:	4b79      	ldr	r3, [pc, #484]	; (6fd4 <main+0xaf8>)
    6dee:	68e2      	ldr	r2, [r4, #12]
    6df0:	645a      	str	r2, [r3, #68]	; 0x44
							uint32_t minvalue_long = session_temp.pulse_length * session_temp.no_of_slices;
    6df2:	8922      	ldrh	r2, [r4, #8]
    6df4:	8863      	ldrh	r3, [r4, #2]
    6df6:	4353      	muls	r3, r2
							if (minvalue_long > 999999){   // hibaellenrzs!!!!!!!!!!!!
    6df8:	4a86      	ldr	r2, [pc, #536]	; (7014 <main+0xb38>)
    6dfa:	4293      	cmp	r3, r2
    6dfc:	d911      	bls.n	6e22 <main+0x946>
								minvalue = 999999;
    6dfe:	4b75      	ldr	r3, [pc, #468]	; (6fd4 <main+0xaf8>)
    6e00:	649a      	str	r2, [r3, #72]	; 0x48
							maxvalue = 999999;
    6e02:	4c74      	ldr	r4, [pc, #464]	; (6fd4 <main+0xaf8>)
    6e04:	4b83      	ldr	r3, [pc, #524]	; (7014 <main+0xb38>)
    6e06:	64e3      	str	r3, [r4, #76]	; 0x4c
							io_write_clear_ack(set_tr_time_txt,6);							
    6e08:	2106      	movs	r1, #6
    6e0a:	4874      	ldr	r0, [pc, #464]	; (6fdc <main+0xb00>)
    6e0c:	3060      	adds	r0, #96	; 0x60
    6e0e:	4b74      	ldr	r3, [pc, #464]	; (6fe0 <main+0xb04>)
    6e10:	4798      	blx	r3
							print_no(kb_value, 11);							
    6e12:	6c60      	ldr	r0, [r4, #68]	; 0x44
    6e14:	210b      	movs	r1, #11
    6e16:	4b73      	ldr	r3, [pc, #460]	; (6fe4 <main+0xb08>)
    6e18:	4798      	blx	r3
							printf("set TR time, switchto form 6\r\n");
    6e1a:	487f      	ldr	r0, [pc, #508]	; (7018 <main+0xb3c>)
    6e1c:	4b68      	ldr	r3, [pc, #416]	; (6fc0 <main+0xae4>)
    6e1e:	4798      	blx	r3
						break;
    6e20:	e5b7      	b.n	6992 <main+0x4b6>
								minvalue = minvalue_long;
    6e22:	4a6c      	ldr	r2, [pc, #432]	; (6fd4 <main+0xaf8>)
    6e24:	6493      	str	r3, [r2, #72]	; 0x48
    6e26:	e7ec      	b.n	6e02 <main+0x926>
							switch_to_form(SETTINGS_1_FORM);
    6e28:	2004      	movs	r0, #4
    6e2a:	4b69      	ldr	r3, [pc, #420]	; (6fd0 <main+0xaf4>)
    6e2c:	4798      	blx	r3
							printf("form8 more, switch to form 8\r\n");
    6e2e:	487b      	ldr	r0, [pc, #492]	; (701c <main+0xb40>)
    6e30:	4b63      	ldr	r3, [pc, #396]	; (6fc0 <main+0xae4>)
    6e32:	4798      	blx	r3
						break;
    6e34:	e5ad      	b.n	6992 <main+0x4b6>
							switch_to_form(MENU_FORM);
    6e36:	2007      	movs	r0, #7
    6e38:	4b65      	ldr	r3, [pc, #404]	; (6fd0 <main+0xaf4>)
    6e3a:	4798      	blx	r3
							session_data.no_of_slices = session_temp.no_of_slices;
    6e3c:	4a63      	ldr	r2, [pc, #396]	; (6fcc <main+0xaf0>)
    6e3e:	8851      	ldrh	r1, [r2, #2]
    6e40:	4b5d      	ldr	r3, [pc, #372]	; (6fb8 <main+0xadc>)
    6e42:	8259      	strh	r1, [r3, #18]
							session_data.no_of_volumes = session_temp.no_of_volumes;
    6e44:	8811      	ldrh	r1, [r2, #0]
    6e46:	8219      	strh	r1, [r3, #16]
							session_data.trig_on_slice = session_temp.trig_on_slice;
    6e48:	88d1      	ldrh	r1, [r2, #6]
    6e4a:	82d9      	strh	r1, [r3, #22]
							session_data.trig_on_volume = session_temp.trig_on_volume;
    6e4c:	8891      	ldrh	r1, [r2, #4]
    6e4e:	8299      	strh	r1, [r3, #20]
							session_data.pulse_length = session_temp.pulse_length;
    6e50:	8911      	ldrh	r1, [r2, #8]
    6e52:	8419      	strh	r1, [r3, #32]
							session_data.TR_time = session_temp.TR_time;
    6e54:	68d2      	ldr	r2, [r2, #12]
    6e56:	625a      	str	r2, [r3, #36]	; 0x24
							printf("form5 accept, switch to form 7\r\n");
    6e58:	4871      	ldr	r0, [pc, #452]	; (7020 <main+0xb44>)
    6e5a:	4c59      	ldr	r4, [pc, #356]	; (6fc0 <main+0xae4>)
    6e5c:	47a0      	blx	r4
							write_flash();
    6e5e:	4b67      	ldr	r3, [pc, #412]	; (6ffc <main+0xb20>)
    6e60:	4798      	blx	r3
							printf("FLASH written\r\n");
    6e62:	4867      	ldr	r0, [pc, #412]	; (7000 <main+0xb24>)
    6e64:	47a0      	blx	r4
						break;
    6e66:	e594      	b.n	6992 <main+0x4b6>
							switch_to_form(MENU_FORM);
    6e68:	2007      	movs	r0, #7
    6e6a:	4b59      	ldr	r3, [pc, #356]	; (6fd0 <main+0xaf4>)
    6e6c:	4798      	blx	r3
							printf("form5 cancel, switch to form 7\r\n");
    6e6e:	486d      	ldr	r0, [pc, #436]	; (7024 <main+0xb48>)
    6e70:	4b53      	ldr	r3, [pc, #332]	; (6fc0 <main+0xae4>)
    6e72:	4798      	blx	r3
						break;
    6e74:	e58d      	b.n	6992 <main+0x4b6>
							session_temp.no_of_slices = session_data.no_of_slices;
    6e76:	4a50      	ldr	r2, [pc, #320]	; (6fb8 <main+0xadc>)
    6e78:	8a51      	ldrh	r1, [r2, #18]
    6e7a:	4b54      	ldr	r3, [pc, #336]	; (6fcc <main+0xaf0>)
    6e7c:	8059      	strh	r1, [r3, #2]
							session_temp.no_of_volumes = session_data.no_of_volumes;
    6e7e:	8a11      	ldrh	r1, [r2, #16]
    6e80:	8019      	strh	r1, [r3, #0]
							session_temp.trig_on_slice = session_data.trig_on_slice;
    6e82:	8ad1      	ldrh	r1, [r2, #22]
    6e84:	80d9      	strh	r1, [r3, #6]
							session_temp.trig_on_volume = session_data.trig_on_volume;
    6e86:	8a91      	ldrh	r1, [r2, #20]
    6e88:	8099      	strh	r1, [r3, #4]
							session_temp.pulse_length = session_data.pulse_length;
    6e8a:	8c11      	ldrh	r1, [r2, #32]
    6e8c:	8119      	strh	r1, [r3, #8]
							session_temp.TR_time = session_data.TR_time;
    6e8e:	6a52      	ldr	r2, [r2, #36]	; 0x24
    6e90:	60da      	str	r2, [r3, #12]
							switch_to_form(SETTINGS_1_FORM);							
    6e92:	2004      	movs	r0, #4
    6e94:	4b4e      	ldr	r3, [pc, #312]	; (6fd0 <main+0xaf4>)
    6e96:	4798      	blx	r3
							printf("settings, switch to form 4\r\n");
    6e98:	4863      	ldr	r0, [pc, #396]	; (7028 <main+0xb4c>)
    6e9a:	4b49      	ldr	r3, [pc, #292]	; (6fc0 <main+0xae4>)
    6e9c:	4798      	blx	r3
						break;
    6e9e:	e578      	b.n	6992 <main+0x4b6>
							start_simulation();
    6ea0:	4b62      	ldr	r3, [pc, #392]	; (702c <main+0xb50>)
    6ea2:	4798      	blx	r3
						break;
    6ea4:	e575      	b.n	6992 <main+0x4b6>
							start_man_trig();
    6ea6:	4b62      	ldr	r3, [pc, #392]	; (7030 <main+0xb54>)
    6ea8:	4798      	blx	r3
						break;
    6eaa:	e572      	b.n	6992 <main+0x4b6>
							switch_to_form(DEFAULT_FORM);
    6eac:	2000      	movs	r0, #0
    6eae:	4b48      	ldr	r3, [pc, #288]	; (6fd0 <main+0xaf4>)
    6eb0:	4798      	blx	r3
							printf("menu back, switch to form 0\r\n");
    6eb2:	4860      	ldr	r0, [pc, #384]	; (7034 <main+0xb58>)
    6eb4:	4b42      	ldr	r3, [pc, #264]	; (6fc0 <main+0xae4>)
    6eb6:	4798      	blx	r3
						break;
    6eb8:	e56b      	b.n	6992 <main+0x4b6>
							switch_to_form(ABOUT_FORM);
    6eba:	200a      	movs	r0, #10
    6ebc:	4b44      	ldr	r3, [pc, #272]	; (6fd0 <main+0xaf4>)
    6ebe:	4798      	blx	r3
							printf("about, switch to form 0\r\n");
    6ec0:	485d      	ldr	r0, [pc, #372]	; (7038 <main+0xb5c>)
    6ec2:	4b3f      	ldr	r3, [pc, #252]	; (6fc0 <main+0xae4>)
    6ec4:	4798      	blx	r3
						break;
    6ec6:	e564      	b.n	6992 <main+0x4b6>
							switch_to_form(SETTINGS_1_FORM);
    6ec8:	2004      	movs	r0, #4
    6eca:	4b41      	ldr	r3, [pc, #260]	; (6fd0 <main+0xaf4>)
    6ecc:	4798      	blx	r3
							printf("form4 more, switch to form 4  \r\n");
    6ece:	485b      	ldr	r0, [pc, #364]	; (703c <main+0xb60>)
    6ed0:	4b3b      	ldr	r3, [pc, #236]	; (6fc0 <main+0xae4>)
    6ed2:	4798      	blx	r3
						break;
    6ed4:	e55d      	b.n	6992 <main+0x4b6>
							switch_to_form(MENU_FORM);
    6ed6:	2007      	movs	r0, #7
    6ed8:	4b3d      	ldr	r3, [pc, #244]	; (6fd0 <main+0xaf4>)
    6eda:	4798      	blx	r3
							session_data.no_of_slices = session_temp.no_of_slices;
    6edc:	4a3b      	ldr	r2, [pc, #236]	; (6fcc <main+0xaf0>)
    6ede:	8851      	ldrh	r1, [r2, #2]
    6ee0:	4b35      	ldr	r3, [pc, #212]	; (6fb8 <main+0xadc>)
    6ee2:	8259      	strh	r1, [r3, #18]
							session_data.no_of_volumes = session_temp.no_of_volumes;
    6ee4:	8811      	ldrh	r1, [r2, #0]
    6ee6:	8219      	strh	r1, [r3, #16]
							session_data.trig_on_slice = session_temp.trig_on_slice;
    6ee8:	88d1      	ldrh	r1, [r2, #6]
    6eea:	82d9      	strh	r1, [r3, #22]
							session_data.trig_on_volume = session_temp.trig_on_volume;
    6eec:	8891      	ldrh	r1, [r2, #4]
    6eee:	8299      	strh	r1, [r3, #20]
							session_data.pulse_length = session_temp.pulse_length;
    6ef0:	8911      	ldrh	r1, [r2, #8]
    6ef2:	8419      	strh	r1, [r3, #32]
							session_data.TR_time = session_temp.TR_time;
    6ef4:	68d2      	ldr	r2, [r2, #12]
    6ef6:	625a      	str	r2, [r3, #36]	; 0x24
							printf("form4 accept, switch to form 7\r\n");
    6ef8:	483f      	ldr	r0, [pc, #252]	; (6ff8 <main+0xb1c>)
    6efa:	4c31      	ldr	r4, [pc, #196]	; (6fc0 <main+0xae4>)
    6efc:	47a0      	blx	r4
							write_flash();
    6efe:	4b3f      	ldr	r3, [pc, #252]	; (6ffc <main+0xb20>)
    6f00:	4798      	blx	r3
							printf("FLASH written\r\n");
    6f02:	483f      	ldr	r0, [pc, #252]	; (7000 <main+0xb24>)
    6f04:	47a0      	blx	r4
						break;
    6f06:	e544      	b.n	6992 <main+0x4b6>
							switch_to_form(MENU_FORM);
    6f08:	2007      	movs	r0, #7
    6f0a:	4b31      	ldr	r3, [pc, #196]	; (6fd0 <main+0xaf4>)
    6f0c:	4798      	blx	r3
							printf("form10 back, switch to menu form  \r\n");
    6f0e:	484c      	ldr	r0, [pc, #304]	; (7040 <main+0xb64>)
    6f10:	4b2b      	ldr	r3, [pc, #172]	; (6fc0 <main+0xae4>)
    6f12:	4798      	blx	r3
						break;
    6f14:	e53d      	b.n	6992 <main+0x4b6>
					printf("4dbutton pressed, index: %u, value: %u\r\n", event_report.object_index, event_report.value_lsb);
    6f16:	4c27      	ldr	r4, [pc, #156]	; (6fb4 <main+0xad8>)
    6f18:	7861      	ldrb	r1, [r4, #1]
    6f1a:	78e2      	ldrb	r2, [r4, #3]
    6f1c:	4849      	ldr	r0, [pc, #292]	; (7044 <main+0xb68>)
    6f1e:	4b4a      	ldr	r3, [pc, #296]	; (7048 <main+0xb6c>)
    6f20:	4798      	blx	r3
					click_length = CLICK_SOUND_LENGTH;
    6f22:	22bc      	movs	r2, #188	; 0xbc
    6f24:	0052      	lsls	r2, r2, #1
    6f26:	4b2b      	ldr	r3, [pc, #172]	; (6fd4 <main+0xaf8>)
    6f28:	811a      	strh	r2, [r3, #8]
					switch (event_report.object_index) {
    6f2a:	7863      	ldrb	r3, [r4, #1]
    6f2c:	2b00      	cmp	r3, #0
    6f2e:	d015      	beq.n	6f5c <main+0xa80>
    6f30:	2b01      	cmp	r3, #1
    6f32:	d000      	beq.n	6f36 <main+0xa5a>
    6f34:	e52d      	b.n	6992 <main+0x4b6>
							switch (event_report.value_lsb){
    6f36:	4b1f      	ldr	r3, [pc, #124]	; (6fb4 <main+0xad8>)
    6f38:	78db      	ldrb	r3, [r3, #3]
    6f3a:	2b00      	cmp	r3, #0
    6f3c:	d02d      	beq.n	6f9a <main+0xabe>
    6f3e:	2b01      	cmp	r3, #1
    6f40:	d000      	beq.n	6f44 <main+0xa68>
    6f42:	e526      	b.n	6992 <main+0x4b6>
									io_write_clear_ack(set_response_sound_on,6);
    6f44:	2106      	movs	r1, #6
    6f46:	4841      	ldr	r0, [pc, #260]	; (704c <main+0xb70>)
    6f48:	3040      	adds	r0, #64	; 0x40
    6f4a:	4b25      	ldr	r3, [pc, #148]	; (6fe0 <main+0xb04>)
    6f4c:	4798      	blx	r3
									session_data.response_sound = true;
    6f4e:	2201      	movs	r2, #1
    6f50:	4b19      	ldr	r3, [pc, #100]	; (6fb8 <main+0xadc>)
    6f52:	72da      	strb	r2, [r3, #11]
									printf("response snd switch is on\r\n");	
    6f54:	483e      	ldr	r0, [pc, #248]	; (7050 <main+0xb74>)
    6f56:	4b1a      	ldr	r3, [pc, #104]	; (6fc0 <main+0xae4>)
    6f58:	4798      	blx	r3
								break;
    6f5a:	e51a      	b.n	6992 <main+0x4b6>
							switch (event_report.value_lsb){
    6f5c:	4b15      	ldr	r3, [pc, #84]	; (6fb4 <main+0xad8>)
    6f5e:	78db      	ldrb	r3, [r3, #3]
    6f60:	2b00      	cmp	r3, #0
    6f62:	d00e      	beq.n	6f82 <main+0xaa6>
    6f64:	2b01      	cmp	r3, #1
    6f66:	d000      	beq.n	6f6a <main+0xa8e>
    6f68:	e513      	b.n	6992 <main+0x4b6>
									io_write_clear_ack(set_trigger_sound_on,6);
    6f6a:	2106      	movs	r1, #6
    6f6c:	4837      	ldr	r0, [pc, #220]	; (704c <main+0xb70>)
    6f6e:	3060      	adds	r0, #96	; 0x60
    6f70:	4b1b      	ldr	r3, [pc, #108]	; (6fe0 <main+0xb04>)
    6f72:	4798      	blx	r3
									session_data.trigger_sound = true;
    6f74:	2201      	movs	r2, #1
    6f76:	4b10      	ldr	r3, [pc, #64]	; (6fb8 <main+0xadc>)
    6f78:	729a      	strb	r2, [r3, #10]
									printf("trigger snd switch is on\r\n");								
    6f7a:	4836      	ldr	r0, [pc, #216]	; (7054 <main+0xb78>)
    6f7c:	4b10      	ldr	r3, [pc, #64]	; (6fc0 <main+0xae4>)
    6f7e:	4798      	blx	r3
								break;
    6f80:	e507      	b.n	6992 <main+0x4b6>
									io_write_clear_ack(set_trigger_sound_off,6);
    6f82:	2106      	movs	r1, #6
    6f84:	4831      	ldr	r0, [pc, #196]	; (704c <main+0xb70>)
    6f86:	3070      	adds	r0, #112	; 0x70
    6f88:	4b15      	ldr	r3, [pc, #84]	; (6fe0 <main+0xb04>)
    6f8a:	4798      	blx	r3
									session_data.trigger_sound = false;
    6f8c:	2200      	movs	r2, #0
    6f8e:	4b0a      	ldr	r3, [pc, #40]	; (6fb8 <main+0xadc>)
    6f90:	729a      	strb	r2, [r3, #10]
									printf("trigger snd switch is off\r\n");	
    6f92:	4831      	ldr	r0, [pc, #196]	; (7058 <main+0xb7c>)
    6f94:	4b0a      	ldr	r3, [pc, #40]	; (6fc0 <main+0xae4>)
    6f96:	4798      	blx	r3
								break;
    6f98:	e4fb      	b.n	6992 <main+0x4b6>
									io_write_clear_ack(set_response_sound_off,6);
    6f9a:	2106      	movs	r1, #6
    6f9c:	482b      	ldr	r0, [pc, #172]	; (704c <main+0xb70>)
    6f9e:	3050      	adds	r0, #80	; 0x50
    6fa0:	4b0f      	ldr	r3, [pc, #60]	; (6fe0 <main+0xb04>)
    6fa2:	4798      	blx	r3
									session_data.response_sound = false;
    6fa4:	2200      	movs	r2, #0
    6fa6:	4b04      	ldr	r3, [pc, #16]	; (6fb8 <main+0xadc>)
    6fa8:	72da      	strb	r2, [r3, #11]
									printf("response snd switch is off\r\n");	
    6faa:	482c      	ldr	r0, [pc, #176]	; (705c <main+0xb80>)
    6fac:	4b04      	ldr	r3, [pc, #16]	; (6fc0 <main+0xae4>)
    6fae:	4798      	blx	r3
								break;
    6fb0:	e4ef      	b.n	6992 <main+0x4b6>
    6fb2:	46c0      	nop			; (mov r8, r8)
    6fb4:	20000a34 	.word	0x20000a34
    6fb8:	20000a3c 	.word	0x20000a3c
    6fbc:	0000e79c 	.word	0x0000e79c
    6fc0:	00009659 	.word	0x00009659
    6fc4:	0000141d 	.word	0x0000141d
    6fc8:	00006255 	.word	0x00006255
    6fcc:	20000a68 	.word	0x20000a68
    6fd0:	00005d39 	.word	0x00005d39
    6fd4:	20000740 	.word	0x20000740
    6fd8:	000003e7 	.word	0x000003e7
    6fdc:	0000ae08 	.word	0x0000ae08
    6fe0:	00005b95 	.word	0x00005b95
    6fe4:	00005c6d 	.word	0x00005c6d
    6fe8:	0000e7c0 	.word	0x0000e7c0
    6fec:	0000270f 	.word	0x0000270f
    6ff0:	0000e7e8 	.word	0x0000e7e8
    6ff4:	0000e810 	.word	0x0000e810
    6ff8:	0000e830 	.word	0x0000e830
    6ffc:	000057ad 	.word	0x000057ad
    7000:	0000e850 	.word	0x0000e850
    7004:	0000e860 	.word	0x0000e860
    7008:	0000e880 	.word	0x0000e880
    700c:	0000e8a4 	.word	0x0000e8a4
    7010:	0000e8c8 	.word	0x0000e8c8
    7014:	000f423f 	.word	0x000f423f
    7018:	0000e8ec 	.word	0x0000e8ec
    701c:	0000e90c 	.word	0x0000e90c
    7020:	0000e92c 	.word	0x0000e92c
    7024:	0000e94c 	.word	0x0000e94c
    7028:	0000e96c 	.word	0x0000e96c
    702c:	000061c9 	.word	0x000061c9
    7030:	000062a1 	.word	0x000062a1
    7034:	0000e988 	.word	0x0000e988
    7038:	0000e9a8 	.word	0x0000e9a8
    703c:	0000e9c4 	.word	0x0000e9c4
    7040:	0000e9e4 	.word	0x0000e9e4
    7044:	0000ea08 	.word	0x0000ea08
    7048:	00009565 	.word	0x00009565
    704c:	0000daf4 	.word	0x0000daf4
    7050:	0000ea6c 	.word	0x0000ea6c
    7054:	0000ea34 	.word	0x0000ea34
    7058:	0000ea50 	.word	0x0000ea50
    705c:	0000ea88 	.word	0x0000ea88
					printf("4dbutton pressed, index: %u, value: %u\r\n", event_report.object_index, event_report.value_lsb);
    7060:	4c64      	ldr	r4, [pc, #400]	; (71f4 <main+0xd18>)
    7062:	7861      	ldrb	r1, [r4, #1]
    7064:	78e2      	ldrb	r2, [r4, #3]
    7066:	4864      	ldr	r0, [pc, #400]	; (71f8 <main+0xd1c>)
    7068:	4b64      	ldr	r3, [pc, #400]	; (71fc <main+0xd20>)
    706a:	4798      	blx	r3
					click_length = CLICK_SOUND_LENGTH;
    706c:	4b64      	ldr	r3, [pc, #400]	; (7200 <main+0xd24>)
    706e:	22bc      	movs	r2, #188	; 0xbc
    7070:	0052      	lsls	r2, r2, #1
    7072:	811a      	strh	r2, [r3, #8]
					uint32_t prev_kb_value = kb_value;
    7074:	6c5d      	ldr	r5, [r3, #68]	; 0x44
					switch (event_report.value_lsb){
    7076:	78e3      	ldrb	r3, [r4, #3]
    7078:	2b6f      	cmp	r3, #111	; 0x6f
    707a:	d030      	beq.n	70de <main+0xc02>
    707c:	2bb0      	cmp	r3, #176	; 0xb0
    707e:	d018      	beq.n	70b2 <main+0xbd6>
    7080:	2b63      	cmp	r3, #99	; 0x63
    7082:	d100      	bne.n	7086 <main+0xbaa>
    7084:	e0a9      	b.n	71da <main+0xcfe>
						if ((event_report.value_lsb>0x29) && (event_report.value_lsb<0x3a)){
    7086:	001a      	movs	r2, r3
    7088:	3a2a      	subs	r2, #42	; 0x2a
    708a:	b2d2      	uxtb	r2, r2
    708c:	2a0f      	cmp	r2, #15
    708e:	d81b      	bhi.n	70c8 <main+0xbec>
							unsigned char digit=event_report.value_lsb-0x30;
    7090:	3b30      	subs	r3, #48	; 0x30
    7092:	b2d9      	uxtb	r1, r3
							kb_value = kb_value * 10 + digit;
    7094:	00aa      	lsls	r2, r5, #2
    7096:	1952      	adds	r2, r2, r5
    7098:	0053      	lsls	r3, r2, #1
    709a:	18cb      	adds	r3, r1, r3
    709c:	4a58      	ldr	r2, [pc, #352]	; (7200 <main+0xd24>)
    709e:	6453      	str	r3, [r2, #68]	; 0x44
							if (kb_value > maxvalue){
    70a0:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
    70a2:	4293      	cmp	r3, r2
    70a4:	d901      	bls.n	70aa <main+0xbce>
								kb_value = prev_kb_value;
    70a6:	4b56      	ldr	r3, [pc, #344]	; (7200 <main+0xd24>)
    70a8:	645d      	str	r5, [r3, #68]	; 0x44
							printf("%i\r\n", digit);							
    70aa:	4856      	ldr	r0, [pc, #344]	; (7204 <main+0xd28>)
    70ac:	4b53      	ldr	r3, [pc, #332]	; (71fc <main+0xd20>)
    70ae:	4798      	blx	r3
    70b0:	e00a      	b.n	70c8 <main+0xbec>
							if (kb_value != 0){
    70b2:	2d00      	cmp	r5, #0
    70b4:	d005      	beq.n	70c2 <main+0xbe6>
								kb_value = kb_value / 10;
    70b6:	210a      	movs	r1, #10
    70b8:	0028      	movs	r0, r5
    70ba:	4b53      	ldr	r3, [pc, #332]	; (7208 <main+0xd2c>)
    70bc:	4798      	blx	r3
    70be:	4b50      	ldr	r3, [pc, #320]	; (7200 <main+0xd24>)
    70c0:	6458      	str	r0, [r3, #68]	; 0x44
							printf("back\r\n");
    70c2:	4852      	ldr	r0, [pc, #328]	; (720c <main+0xd30>)
    70c4:	4b52      	ldr	r3, [pc, #328]	; (7210 <main+0xd34>)
    70c6:	4798      	blx	r3
					printf("kb value: %lu, prev kb value: %lu\r\n", kb_value, prev_kb_value);
    70c8:	4c4d      	ldr	r4, [pc, #308]	; (7200 <main+0xd24>)
    70ca:	002a      	movs	r2, r5
    70cc:	6c61      	ldr	r1, [r4, #68]	; 0x44
    70ce:	4851      	ldr	r0, [pc, #324]	; (7214 <main+0xd38>)
    70d0:	4b4a      	ldr	r3, [pc, #296]	; (71fc <main+0xd20>)
    70d2:	4798      	blx	r3
					print_no(kb_value, 11);
    70d4:	6c60      	ldr	r0, [r4, #68]	; 0x44
    70d6:	210b      	movs	r1, #11
    70d8:	4b4f      	ldr	r3, [pc, #316]	; (7218 <main+0xd3c>)
    70da:	4798      	blx	r3
				break;
    70dc:	e459      	b.n	6992 <main+0x4b6>
							printf("keyboard ok\r\n");
    70de:	484f      	ldr	r0, [pc, #316]	; (721c <main+0xd40>)
    70e0:	4b4b      	ldr	r3, [pc, #300]	; (7210 <main+0xd34>)
    70e2:	4798      	blx	r3
							printf("kb value: %lu\r\n", kb_value);
    70e4:	4c46      	ldr	r4, [pc, #280]	; (7200 <main+0xd24>)
    70e6:	6c61      	ldr	r1, [r4, #68]	; 0x44
    70e8:	484d      	ldr	r0, [pc, #308]	; (7220 <main+0xd44>)
    70ea:	4b44      	ldr	r3, [pc, #272]	; (71fc <main+0xd20>)
    70ec:	4798      	blx	r3
							if (kb_value < minvalue){
    70ee:	6c63      	ldr	r3, [r4, #68]	; 0x44
    70f0:	6ca0      	ldr	r0, [r4, #72]	; 0x48
    70f2:	4283      	cmp	r3, r0
    70f4:	d317      	bcc.n	7126 <main+0xc4a>
							if (kb_value > maxvalue){
    70f6:	4b42      	ldr	r3, [pc, #264]	; (7200 <main+0xd24>)
    70f8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    70fa:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
    70fc:	4282      	cmp	r2, r0
    70fe:	d81c      	bhi.n	713a <main+0xc5e>
							printf("kb return value: %lu\r\n", kb_value);
    7100:	4b3f      	ldr	r3, [pc, #252]	; (7200 <main+0xd24>)
    7102:	6c59      	ldr	r1, [r3, #68]	; 0x44
    7104:	4847      	ldr	r0, [pc, #284]	; (7224 <main+0xd48>)
    7106:	4b3d      	ldr	r3, [pc, #244]	; (71fc <main+0xd20>)
    7108:	4798      	blx	r3
							switch_to_form(session_data.previous_form);							
    710a:	4b47      	ldr	r3, [pc, #284]	; (7228 <main+0xd4c>)
    710c:	7b58      	ldrb	r0, [r3, #13]
    710e:	4b47      	ldr	r3, [pc, #284]	; (722c <main+0xd50>)
    7110:	4798      	blx	r3
							switch (session_temp.parameter){
    7112:	4b47      	ldr	r3, [pc, #284]	; (7230 <main+0xd54>)
    7114:	7c1b      	ldrb	r3, [r3, #16]
    7116:	3b0e      	subs	r3, #14
    7118:	b2da      	uxtb	r2, r3
    711a:	2a0b      	cmp	r2, #11
    711c:	d827      	bhi.n	716e <main+0xc92>
    711e:	0093      	lsls	r3, r2, #2
    7120:	4a44      	ldr	r2, [pc, #272]	; (7234 <main+0xd58>)
    7122:	58d3      	ldr	r3, [r2, r3]
    7124:	469f      	mov	pc, r3
								kb_value = minvalue;
    7126:	4b36      	ldr	r3, [pc, #216]	; (7200 <main+0xd24>)
    7128:	6458      	str	r0, [r3, #68]	; 0x44
								print_no(kb_value, 11);
    712a:	210b      	movs	r1, #11
    712c:	4b3a      	ldr	r3, [pc, #232]	; (7218 <main+0xd3c>)
    712e:	4798      	blx	r3
								delay_ms(500);
    7130:	20fa      	movs	r0, #250	; 0xfa
    7132:	0040      	lsls	r0, r0, #1
    7134:	4b40      	ldr	r3, [pc, #256]	; (7238 <main+0xd5c>)
    7136:	4798      	blx	r3
    7138:	e7dd      	b.n	70f6 <main+0xc1a>
								kb_value = maxvalue;
    713a:	6458      	str	r0, [r3, #68]	; 0x44
								print_no(kb_value, 11);
    713c:	210b      	movs	r1, #11
    713e:	4b36      	ldr	r3, [pc, #216]	; (7218 <main+0xd3c>)
    7140:	4798      	blx	r3
								delay_ms(500);
    7142:	20fa      	movs	r0, #250	; 0xfa
    7144:	0040      	lsls	r0, r0, #1
    7146:	4b3c      	ldr	r3, [pc, #240]	; (7238 <main+0xd5c>)
    7148:	4798      	blx	r3
    714a:	e7d9      	b.n	7100 <main+0xc24>
									session_temp.no_of_slices = kb_value;	
    714c:	4b2c      	ldr	r3, [pc, #176]	; (7200 <main+0xd24>)
    714e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    7150:	b292      	uxth	r2, r2
    7152:	4b37      	ldr	r3, [pc, #220]	; (7230 <main+0xd54>)
    7154:	805a      	strh	r2, [r3, #2]
									if (session_temp.TR_time < (session_temp.no_of_slices * session_temp.pulse_length)){
    7156:	68d9      	ldr	r1, [r3, #12]
    7158:	891b      	ldrh	r3, [r3, #8]
    715a:	4353      	muls	r3, r2
    715c:	4299      	cmp	r1, r3
    715e:	d206      	bcs.n	716e <main+0xc92>
										session_temp.TR_time = (session_temp.no_of_slices * session_temp.pulse_length);
    7160:	4a33      	ldr	r2, [pc, #204]	; (7230 <main+0xd54>)
    7162:	60d3      	str	r3, [r2, #12]
    7164:	e003      	b.n	716e <main+0xc92>
									session_temp.no_of_volumes = kb_value;									
    7166:	4b26      	ldr	r3, [pc, #152]	; (7200 <main+0xd24>)
    7168:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    716a:	4b31      	ldr	r3, [pc, #196]	; (7230 <main+0xd54>)
    716c:	801a      	strh	r2, [r3, #0]
							print_no(session_temp.no_of_slices, SET_SLICES_STR);
    716e:	4e30      	ldr	r6, [pc, #192]	; (7230 <main+0xd54>)
    7170:	8870      	ldrh	r0, [r6, #2]
    7172:	2106      	movs	r1, #6
    7174:	4c28      	ldr	r4, [pc, #160]	; (7218 <main+0xd3c>)
    7176:	47a0      	blx	r4
							print_no(session_temp.no_of_volumes, SET_VOLUMES_STR);
    7178:	8830      	ldrh	r0, [r6, #0]
    717a:	2107      	movs	r1, #7
    717c:	47a0      	blx	r4
							print_no(session_temp.trig_on_slice, SLICE_TRIGGERNO_STR);
    717e:	88f0      	ldrh	r0, [r6, #6]
    7180:	2104      	movs	r1, #4
    7182:	47a0      	blx	r4
							print_no(session_temp.trig_on_volume, VOLUME_TRIGGERNO_STR);
    7184:	88b0      	ldrh	r0, [r6, #4]
    7186:	2105      	movs	r1, #5
    7188:	47a0      	blx	r4
							print_no(session_temp.pulse_length, PULSE_LENGTH_STR);
    718a:	8930      	ldrh	r0, [r6, #8]
    718c:	2108      	movs	r1, #8
    718e:	47a0      	blx	r4
							print_no(session_temp.TR_time, TR_TIME_STR);
    7190:	68f0      	ldr	r0, [r6, #12]
    7192:	2109      	movs	r1, #9
    7194:	47a0      	blx	r4
							printf("keyboard ok, switch back to form %u\r\n", session_data.previous_form);
    7196:	4b24      	ldr	r3, [pc, #144]	; (7228 <main+0xd4c>)
    7198:	7b59      	ldrb	r1, [r3, #13]
    719a:	4828      	ldr	r0, [pc, #160]	; (723c <main+0xd60>)
    719c:	4b17      	ldr	r3, [pc, #92]	; (71fc <main+0xd20>)
    719e:	4798      	blx	r3
						break;
    71a0:	e792      	b.n	70c8 <main+0xbec>
									session_temp.trig_on_slice = kb_value;									
    71a2:	4b17      	ldr	r3, [pc, #92]	; (7200 <main+0xd24>)
    71a4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    71a6:	4b22      	ldr	r3, [pc, #136]	; (7230 <main+0xd54>)
    71a8:	80da      	strh	r2, [r3, #6]
								break;
    71aa:	e7e0      	b.n	716e <main+0xc92>
									session_temp.trig_on_volume = kb_value;
    71ac:	4b14      	ldr	r3, [pc, #80]	; (7200 <main+0xd24>)
    71ae:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    71b0:	4b1f      	ldr	r3, [pc, #124]	; (7230 <main+0xd54>)
    71b2:	809a      	strh	r2, [r3, #4]
								break;
    71b4:	e7db      	b.n	716e <main+0xc92>
									session_temp.pulse_length = kb_value;
    71b6:	4b12      	ldr	r3, [pc, #72]	; (7200 <main+0xd24>)
    71b8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    71ba:	b29b      	uxth	r3, r3
    71bc:	4a1c      	ldr	r2, [pc, #112]	; (7230 <main+0xd54>)
    71be:	8113      	strh	r3, [r2, #8]
									if (session_temp.TR_time < (session_temp.no_of_slices * session_temp.pulse_length)){
    71c0:	68d1      	ldr	r1, [r2, #12]
    71c2:	8852      	ldrh	r2, [r2, #2]
    71c4:	4353      	muls	r3, r2
    71c6:	4299      	cmp	r1, r3
    71c8:	d2d1      	bcs.n	716e <main+0xc92>
										session_temp.TR_time = (session_temp.no_of_slices * session_temp.pulse_length);
    71ca:	4a19      	ldr	r2, [pc, #100]	; (7230 <main+0xd54>)
    71cc:	60d3      	str	r3, [r2, #12]
    71ce:	e7ce      	b.n	716e <main+0xc92>
									session_temp.TR_time = kb_value;
    71d0:	4b0b      	ldr	r3, [pc, #44]	; (7200 <main+0xd24>)
    71d2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    71d4:	4b16      	ldr	r3, [pc, #88]	; (7230 <main+0xd54>)
    71d6:	60da      	str	r2, [r3, #12]
								break;
    71d8:	e7c9      	b.n	716e <main+0xc92>
							printf("cancel\r\n");
    71da:	4819      	ldr	r0, [pc, #100]	; (7240 <main+0xd64>)
    71dc:	4b0c      	ldr	r3, [pc, #48]	; (7210 <main+0xd34>)
    71de:	4798      	blx	r3
							switch_to_form(session_data.previous_form);
    71e0:	4c11      	ldr	r4, [pc, #68]	; (7228 <main+0xd4c>)
    71e2:	7b60      	ldrb	r0, [r4, #13]
    71e4:	4b11      	ldr	r3, [pc, #68]	; (722c <main+0xd50>)
    71e6:	4798      	blx	r3
							printf("keyboard cancel, switch back to form %u\r\n", session_data.previous_form);
    71e8:	7b61      	ldrb	r1, [r4, #13]
    71ea:	4816      	ldr	r0, [pc, #88]	; (7244 <main+0xd68>)
    71ec:	4b03      	ldr	r3, [pc, #12]	; (71fc <main+0xd20>)
    71ee:	4798      	blx	r3
						break;
    71f0:	e76a      	b.n	70c8 <main+0xbec>
    71f2:	46c0      	nop			; (mov r8, r8)
    71f4:	20000a34 	.word	0x20000a34
    71f8:	0000ea08 	.word	0x0000ea08
    71fc:	00009565 	.word	0x00009565
    7200:	20000740 	.word	0x20000740
    7204:	0000eb28 	.word	0x0000eb28
    7208:	0000919d 	.word	0x0000919d
    720c:	0000ebfc 	.word	0x0000ebfc
    7210:	00009659 	.word	0x00009659
    7214:	0000eb30 	.word	0x0000eb30
    7218:	00005c6d 	.word	0x00005c6d
    721c:	0000eaa4 	.word	0x0000eaa4
    7220:	0000eb44 	.word	0x0000eb44
    7224:	0000eab4 	.word	0x0000eab4
    7228:	20000a3c 	.word	0x20000a3c
    722c:	00005d39 	.word	0x00005d39
    7230:	20000a68 	.word	0x20000a68
    7234:	0000add8 	.word	0x0000add8
    7238:	0000141d 	.word	0x0000141d
    723c:	0000eacc 	.word	0x0000eacc
    7240:	0000eaf4 	.word	0x0000eaf4
    7244:	0000eafc 	.word	0x0000eafc

00007248 <nv_init>:

/**
 * \brief Initialize non-volatile storage
 */
void nv_init(void *descr)
{
    7248:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	flash = (struct flash_descriptor *)descr;
    724a:	4c0e      	ldr	r4, [pc, #56]	; (7284 <nv_init+0x3c>)
    724c:	6020      	str	r0, [r4, #0]

	/* Storage must start at row start */
	ASSERT((CONF_STORAGE_MEMORY_START % (flash_get_page_size(flash) * 4)) == 0);
    724e:	4f0e      	ldr	r7, [pc, #56]	; (7288 <nv_init+0x40>)
    7250:	47b8      	blx	r7
    7252:	0081      	lsls	r1, r0, #2
    7254:	4e0d      	ldr	r6, [pc, #52]	; (728c <nv_init+0x44>)
    7256:	2080      	movs	r0, #128	; 0x80
    7258:	0240      	lsls	r0, r0, #9
    725a:	47b0      	blx	r6
    725c:	4248      	negs	r0, r1
    725e:	4148      	adcs	r0, r1
    7260:	b2c0      	uxtb	r0, r0
    7262:	2235      	movs	r2, #53	; 0x35
    7264:	490a      	ldr	r1, [pc, #40]	; (7290 <nv_init+0x48>)
    7266:	4d0b      	ldr	r5, [pc, #44]	; (7294 <nv_init+0x4c>)
    7268:	47a8      	blx	r5
	/* Sector must be of integer number of rows */
	ASSERT((CONF_SECTOR_SIZE % ((flash_get_page_size(flash) * 4)) == 0));
    726a:	6820      	ldr	r0, [r4, #0]
    726c:	47b8      	blx	r7
    726e:	0081      	lsls	r1, r0, #2
    7270:	2080      	movs	r0, #128	; 0x80
    7272:	0140      	lsls	r0, r0, #5
    7274:	47b0      	blx	r6
    7276:	4248      	negs	r0, r1
    7278:	4148      	adcs	r0, r1
    727a:	b2c0      	uxtb	r0, r0
    727c:	2237      	movs	r2, #55	; 0x37
    727e:	4904      	ldr	r1, [pc, #16]	; (7290 <nv_init+0x48>)
    7280:	47a8      	blx	r5
}
    7282:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7284:	20000790 	.word	0x20000790
    7288:	00001879 	.word	0x00001879
    728c:	000092a9 	.word	0x000092a9
    7290:	0000eb78 	.word	0x0000eb78
    7294:	000026c1 	.word	0x000026c1

00007298 <nv_write>:

/**
 * \brief Write data to non-volatile storage
 */
void nv_write(const uint8_t sector, const uint16_t offset, const uint8_t *const data, const uint16_t size)
{
    7298:	b570      	push	{r4, r5, r6, lr}
    729a:	0016      	movs	r6, r2
    729c:	001d      	movs	r5, r3
	uint32_t address = CONF_STORAGE_MEMORY_START + sector * CONF_SECTOR_SIZE + offset;
    729e:	3010      	adds	r0, #16
    72a0:	0304      	lsls	r4, r0, #12
    72a2:	1864      	adds	r4, r4, r1

	/* Write access must start and end within the storage and must not write
	   more than a sector. */
	ASSERT((address <= NV_MEMORY_END) && ((address + size) <= (NV_MEMORY_END + 1))
    72a4:	4b0f      	ldr	r3, [pc, #60]	; (72e4 <nv_write+0x4c>)
    72a6:	429c      	cmp	r4, r3
    72a8:	d80b      	bhi.n	72c2 <nv_write+0x2a>
    72aa:	192b      	adds	r3, r5, r4
    72ac:	2290      	movs	r2, #144	; 0x90
    72ae:	0252      	lsls	r2, r2, #9
    72b0:	4293      	cmp	r3, r2
    72b2:	d813      	bhi.n	72dc <nv_write+0x44>
    72b4:	1869      	adds	r1, r5, r1
    72b6:	2380      	movs	r3, #128	; 0x80
    72b8:	015b      	lsls	r3, r3, #5
    72ba:	4299      	cmp	r1, r3
    72bc:	dd10      	ble.n	72e0 <nv_write+0x48>
    72be:	2000      	movs	r0, #0
    72c0:	e000      	b.n	72c4 <nv_write+0x2c>
    72c2:	2000      	movs	r0, #0
    72c4:	2244      	movs	r2, #68	; 0x44
    72c6:	4908      	ldr	r1, [pc, #32]	; (72e8 <nv_write+0x50>)
    72c8:	4b08      	ldr	r3, [pc, #32]	; (72ec <nv_write+0x54>)
    72ca:	4798      	blx	r3
	       && ((offset + size) <= CONF_SECTOR_SIZE));

	flash_append(flash, address, (uint8_t *)data, size);
    72cc:	4b08      	ldr	r3, [pc, #32]	; (72f0 <nv_write+0x58>)
    72ce:	6818      	ldr	r0, [r3, #0]
    72d0:	002b      	movs	r3, r5
    72d2:	0032      	movs	r2, r6
    72d4:	0021      	movs	r1, r4
    72d6:	4c07      	ldr	r4, [pc, #28]	; (72f4 <nv_write+0x5c>)
    72d8:	47a0      	blx	r4
}
    72da:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT((address <= NV_MEMORY_END) && ((address + size) <= (NV_MEMORY_END + 1))
    72dc:	2000      	movs	r0, #0
    72de:	e7f1      	b.n	72c4 <nv_write+0x2c>
    72e0:	2001      	movs	r0, #1
    72e2:	e7ef      	b.n	72c4 <nv_write+0x2c>
    72e4:	00011fff 	.word	0x00011fff
    72e8:	0000eb78 	.word	0x0000eb78
    72ec:	000026c1 	.word	0x000026c1
    72f0:	20000790 	.word	0x20000790
    72f4:	00001755 	.word	0x00001755

000072f8 <nv_read>:

/**
 * \brief Read data from non-volatile storage
 */
void nv_read(const uint8_t sector, const uint16_t offset, uint8_t *const data, const uint16_t size)
{
    72f8:	b570      	push	{r4, r5, r6, lr}
    72fa:	0016      	movs	r6, r2
    72fc:	001d      	movs	r5, r3
	uint32_t address = CONF_STORAGE_MEMORY_START + sector * CONF_SECTOR_SIZE + offset;
    72fe:	3010      	adds	r0, #16
    7300:	0304      	lsls	r4, r0, #12
    7302:	1864      	adds	r4, r4, r1

	/* Read access must start and end within the storage and must not read more
	   than a sector. */
	ASSERT((address <= NV_MEMORY_END) && ((address + size) <= (NV_MEMORY_END + 1))
    7304:	4b0f      	ldr	r3, [pc, #60]	; (7344 <nv_read+0x4c>)
    7306:	429c      	cmp	r4, r3
    7308:	d80b      	bhi.n	7322 <nv_read+0x2a>
    730a:	192b      	adds	r3, r5, r4
    730c:	2290      	movs	r2, #144	; 0x90
    730e:	0252      	lsls	r2, r2, #9
    7310:	4293      	cmp	r3, r2
    7312:	d813      	bhi.n	733c <nv_read+0x44>
    7314:	1869      	adds	r1, r5, r1
    7316:	2380      	movs	r3, #128	; 0x80
    7318:	015b      	lsls	r3, r3, #5
    731a:	4299      	cmp	r1, r3
    731c:	dd10      	ble.n	7340 <nv_read+0x48>
    731e:	2000      	movs	r0, #0
    7320:	e000      	b.n	7324 <nv_read+0x2c>
    7322:	2000      	movs	r0, #0
    7324:	2253      	movs	r2, #83	; 0x53
    7326:	4908      	ldr	r1, [pc, #32]	; (7348 <nv_read+0x50>)
    7328:	4b08      	ldr	r3, [pc, #32]	; (734c <nv_read+0x54>)
    732a:	4798      	blx	r3
	       && ((offset + size) <= CONF_SECTOR_SIZE));

	flash_read(flash, address, data, size);
    732c:	4b08      	ldr	r3, [pc, #32]	; (7350 <nv_read+0x58>)
    732e:	6818      	ldr	r0, [r3, #0]
    7330:	002b      	movs	r3, r5
    7332:	0032      	movs	r2, r6
    7334:	0021      	movs	r1, r4
    7336:	4c07      	ldr	r4, [pc, #28]	; (7354 <nv_read+0x5c>)
    7338:	47a0      	blx	r4
}
    733a:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT((address <= NV_MEMORY_END) && ((address + size) <= (NV_MEMORY_END + 1))
    733c:	2000      	movs	r0, #0
    733e:	e7f1      	b.n	7324 <nv_read+0x2c>
    7340:	2001      	movs	r0, #1
    7342:	e7ef      	b.n	7324 <nv_read+0x2c>
    7344:	00011fff 	.word	0x00011fff
    7348:	0000eb78 	.word	0x0000eb78
    734c:	000026c1 	.word	0x000026c1
    7350:	20000790 	.word	0x20000790
    7354:	0000163d 	.word	0x0000163d

00007358 <nv_erase_sector>:

/**
 * \brief Erase a sector
 */
void nv_erase_sector(uint8_t sector)
{
    7358:	b570      	push	{r4, r5, r6, lr}
	uint32_t address = CONF_STORAGE_MEMORY_START + sector * CONF_SECTOR_SIZE;
    735a:	3010      	adds	r0, #16
    735c:	0304      	lsls	r4, r0, #12

	ASSERT(address <= NV_MEMORY_END);
    735e:	2000      	movs	r0, #0
    7360:	4b0b      	ldr	r3, [pc, #44]	; (7390 <nv_erase_sector+0x38>)
    7362:	42a3      	cmp	r3, r4
    7364:	4140      	adcs	r0, r0
    7366:	b2c0      	uxtb	r0, r0
    7368:	225f      	movs	r2, #95	; 0x5f
    736a:	490a      	ldr	r1, [pc, #40]	; (7394 <nv_erase_sector+0x3c>)
    736c:	4b0a      	ldr	r3, [pc, #40]	; (7398 <nv_erase_sector+0x40>)
    736e:	4798      	blx	r3

	flash_erase(flash, address, CONF_SECTOR_SIZE / flash_get_page_size(flash));
    7370:	4b0a      	ldr	r3, [pc, #40]	; (739c <nv_erase_sector+0x44>)
    7372:	681d      	ldr	r5, [r3, #0]
    7374:	0028      	movs	r0, r5
    7376:	4b0a      	ldr	r3, [pc, #40]	; (73a0 <nv_erase_sector+0x48>)
    7378:	4798      	blx	r3
    737a:	0001      	movs	r1, r0
    737c:	2080      	movs	r0, #128	; 0x80
    737e:	0140      	lsls	r0, r0, #5
    7380:	4b08      	ldr	r3, [pc, #32]	; (73a4 <nv_erase_sector+0x4c>)
    7382:	4798      	blx	r3
    7384:	0002      	movs	r2, r0
    7386:	0021      	movs	r1, r4
    7388:	0028      	movs	r0, r5
    738a:	4b07      	ldr	r3, [pc, #28]	; (73a8 <nv_erase_sector+0x50>)
    738c:	4798      	blx	r3
}
    738e:	bd70      	pop	{r4, r5, r6, pc}
    7390:	00011fff 	.word	0x00011fff
    7394:	0000eb78 	.word	0x0000eb78
    7398:	000026c1 	.word	0x000026c1
    739c:	20000790 	.word	0x20000790
    73a0:	00001879 	.word	0x00001879
    73a4:	0000919d 	.word	0x0000919d
    73a8:	000017ed 	.word	0x000017ed

000073ac <nv_is_equal>:

/**
 * \brief Compare given data and data stored in non-volatile storage
 */
bool nv_is_equal(const uint8_t sector, const uint16_t offset, const uint8_t *const data, const uint16_t size)
{
    73ac:	b5f0      	push	{r4, r5, r6, r7, lr}
    73ae:	46de      	mov	lr, fp
    73b0:	4657      	mov	r7, sl
    73b2:	464e      	mov	r6, r9
    73b4:	4645      	mov	r5, r8
    73b6:	b5e0      	push	{r5, r6, r7, lr}
    73b8:	b091      	sub	sp, #68	; 0x44
    73ba:	4691      	mov	r9, r2
    73bc:	001f      	movs	r7, r3
	uint8_t  tmp[64];
	uint16_t pos     = 0;
	uint32_t address = CONF_STORAGE_MEMORY_START + sector * CONF_SECTOR_SIZE + offset;
    73be:	3010      	adds	r0, #16
    73c0:	0300      	lsls	r0, r0, #12
    73c2:	4680      	mov	r8, r0
    73c4:	4488      	add	r8, r1

	/* Read access must start and end within the storage and must not read more
	   than a sector. There must be at least one byte to compare to. */
	ASSERT((address <= NV_MEMORY_END) && ((address + size) <= (NV_MEMORY_END + 1))
    73c6:	4b23      	ldr	r3, [pc, #140]	; (7454 <nv_is_equal+0xa8>)
    73c8:	4598      	cmp	r8, r3
    73ca:	d80e      	bhi.n	73ea <nv_is_equal+0x3e>
    73cc:	4643      	mov	r3, r8
    73ce:	18fb      	adds	r3, r7, r3
    73d0:	2290      	movs	r2, #144	; 0x90
    73d2:	0252      	lsls	r2, r2, #9
    73d4:	4293      	cmp	r3, r2
    73d6:	d80f      	bhi.n	73f8 <nv_is_equal+0x4c>
    73d8:	1879      	adds	r1, r7, r1
    73da:	2380      	movs	r3, #128	; 0x80
    73dc:	015b      	lsls	r3, r3, #5
    73de:	4299      	cmp	r1, r3
    73e0:	dc0c      	bgt.n	73fc <nv_is_equal+0x50>
    73e2:	2f00      	cmp	r7, #0
    73e4:	d10c      	bne.n	7400 <nv_is_equal+0x54>
    73e6:	2000      	movs	r0, #0
    73e8:	e000      	b.n	73ec <nv_is_equal+0x40>
    73ea:	2000      	movs	r0, #0
    73ec:	2270      	movs	r2, #112	; 0x70
    73ee:	491a      	ldr	r1, [pc, #104]	; (7458 <nv_is_equal+0xac>)
    73f0:	4b1a      	ldr	r3, [pc, #104]	; (745c <nv_is_equal+0xb0>)
    73f2:	4798      	blx	r3
	uint16_t pos     = 0;
    73f4:	2400      	movs	r4, #0
	       && ((offset + size) <= CONF_SECTOR_SIZE) && size);

	while (pos != size) {
    73f6:	e01b      	b.n	7430 <nv_is_equal+0x84>
	ASSERT((address <= NV_MEMORY_END) && ((address + size) <= (NV_MEMORY_END + 1))
    73f8:	2000      	movs	r0, #0
    73fa:	e7f7      	b.n	73ec <nv_is_equal+0x40>
    73fc:	2000      	movs	r0, #0
    73fe:	e7f5      	b.n	73ec <nv_is_equal+0x40>
    7400:	2001      	movs	r0, #1
    7402:	e7f3      	b.n	73ec <nv_is_equal+0x40>
		uint8_t cur_size = min(64, size - pos);
    7404:	b2da      	uxtb	r2, r3
    7406:	4693      	mov	fp, r2

		flash_read(flash, address + pos, tmp, cur_size);
    7408:	25ff      	movs	r5, #255	; 0xff
    740a:	401d      	ands	r5, r3
    740c:	4643      	mov	r3, r8
    740e:	1919      	adds	r1, r3, r4
    7410:	4b13      	ldr	r3, [pc, #76]	; (7460 <nv_is_equal+0xb4>)
    7412:	6818      	ldr	r0, [r3, #0]
    7414:	002b      	movs	r3, r5
    7416:	466a      	mov	r2, sp
    7418:	4e12      	ldr	r6, [pc, #72]	; (7464 <nv_is_equal+0xb8>)
    741a:	47b0      	blx	r6
		if (memcmp(data + pos, tmp, cur_size)) {
    741c:	464b      	mov	r3, r9
    741e:	1918      	adds	r0, r3, r4
    7420:	002a      	movs	r2, r5
    7422:	4669      	mov	r1, sp
    7424:	4b10      	ldr	r3, [pc, #64]	; (7468 <nv_is_equal+0xbc>)
    7426:	4798      	blx	r3
    7428:	2800      	cmp	r0, #0
    742a:	d110      	bne.n	744e <nv_is_equal+0xa2>
			return false;
		}

		pos += cur_size;
    742c:	445c      	add	r4, fp
    742e:	b2a4      	uxth	r4, r4
	while (pos != size) {
    7430:	42bc      	cmp	r4, r7
    7432:	d004      	beq.n	743e <nv_is_equal+0x92>
		uint8_t cur_size = min(64, size - pos);
    7434:	1b3b      	subs	r3, r7, r4
    7436:	2b40      	cmp	r3, #64	; 0x40
    7438:	dde4      	ble.n	7404 <nv_is_equal+0x58>
    743a:	2340      	movs	r3, #64	; 0x40
    743c:	e7e2      	b.n	7404 <nv_is_equal+0x58>
	}

	return true;
    743e:	2001      	movs	r0, #1
}
    7440:	b011      	add	sp, #68	; 0x44
    7442:	bc3c      	pop	{r2, r3, r4, r5}
    7444:	4690      	mov	r8, r2
    7446:	4699      	mov	r9, r3
    7448:	46a2      	mov	sl, r4
    744a:	46ab      	mov	fp, r5
    744c:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return false;
    744e:	2000      	movs	r0, #0
    7450:	e7f6      	b.n	7440 <nv_is_equal+0x94>
    7452:	46c0      	nop			; (mov r8, r8)
    7454:	00011fff 	.word	0x00011fff
    7458:	0000eb78 	.word	0x0000eb78
    745c:	000026c1 	.word	0x000026c1
    7460:	20000790 	.word	0x20000790
    7464:	0000163d 	.word	0x0000163d
    7468:	00009525 	.word	0x00009525

0000746c <nv_is_empty>:

/**
 * \brief Check if given area is empty
 */
bool nv_is_empty(const uint8_t sector, const uint16_t offset, const uint16_t size)
{
    746c:	b5f0      	push	{r4, r5, r6, r7, lr}
    746e:	46ce      	mov	lr, r9
    7470:	4647      	mov	r7, r8
    7472:	b580      	push	{r7, lr}
    7474:	b091      	sub	sp, #68	; 0x44
    7476:	0015      	movs	r5, r2
	uint8_t  tmp[64];
	uint16_t pos     = 0;
	uint32_t address = CONF_STORAGE_MEMORY_START + sector * CONF_SECTOR_SIZE + offset;
    7478:	3010      	adds	r0, #16
    747a:	0304      	lsls	r4, r0, #12
    747c:	1864      	adds	r4, r4, r1

	/* Read access must start and end within the storage and must not read more
	   than a sector. There must be at least one byte to compare to. */
	ASSERT((address <= NV_MEMORY_END) && ((address + size) <= (NV_MEMORY_END + 1))
    747e:	4b23      	ldr	r3, [pc, #140]	; (750c <nv_is_empty+0xa0>)
    7480:	429c      	cmp	r4, r3
    7482:	d80d      	bhi.n	74a0 <nv_is_empty+0x34>
    7484:	1913      	adds	r3, r2, r4
    7486:	2290      	movs	r2, #144	; 0x90
    7488:	0252      	lsls	r2, r2, #9
    748a:	4293      	cmp	r3, r2
    748c:	d82d      	bhi.n	74ea <nv_is_empty+0x7e>
    748e:	1869      	adds	r1, r5, r1
    7490:	2380      	movs	r3, #128	; 0x80
    7492:	015b      	lsls	r3, r3, #5
    7494:	4299      	cmp	r1, r3
    7496:	dc2a      	bgt.n	74ee <nv_is_empty+0x82>
    7498:	2d00      	cmp	r5, #0
    749a:	d12a      	bne.n	74f2 <nv_is_empty+0x86>
    749c:	2000      	movs	r0, #0
    749e:	e000      	b.n	74a2 <nv_is_empty+0x36>
    74a0:	2000      	movs	r0, #0
    74a2:	228c      	movs	r2, #140	; 0x8c
    74a4:	491a      	ldr	r1, [pc, #104]	; (7510 <nv_is_empty+0xa4>)
    74a6:	4b1b      	ldr	r3, [pc, #108]	; (7514 <nv_is_empty+0xa8>)
    74a8:	4798      	blx	r3
	       && ((offset + size) <= CONF_SECTOR_SIZE) && size);

	memset(tmp, 0xFF, 64);
    74aa:	2240      	movs	r2, #64	; 0x40
    74ac:	21ff      	movs	r1, #255	; 0xff
    74ae:	4668      	mov	r0, sp
    74b0:	4b19      	ldr	r3, [pc, #100]	; (7518 <nv_is_empty+0xac>)
    74b2:	4798      	blx	r3
	uint16_t pos     = 0;
    74b4:	2600      	movs	r6, #0

	while (pos != size) {
    74b6:	42ae      	cmp	r6, r5
    74b8:	d020      	beq.n	74fc <nv_is_empty+0x90>
		uint8_t cur_size = min(64, size - pos);
    74ba:	1bab      	subs	r3, r5, r6
    74bc:	2b40      	cmp	r3, #64	; 0x40
    74be:	dd00      	ble.n	74c2 <nv_is_empty+0x56>
    74c0:	2340      	movs	r3, #64	; 0x40
    74c2:	b2da      	uxtb	r2, r3
    74c4:	4691      	mov	r9, r2
		uint8_t i        = 0;

		flash_read(flash, address + pos, tmp, cur_size);
    74c6:	22ff      	movs	r2, #255	; 0xff
    74c8:	4013      	ands	r3, r2
    74ca:	1931      	adds	r1, r6, r4
    74cc:	4a13      	ldr	r2, [pc, #76]	; (751c <nv_is_empty+0xb0>)
    74ce:	6810      	ldr	r0, [r2, #0]
    74d0:	466a      	mov	r2, sp
    74d2:	4f13      	ldr	r7, [pc, #76]	; (7520 <nv_is_empty+0xb4>)
    74d4:	47b8      	blx	r7
		uint8_t i        = 0;
    74d6:	2300      	movs	r3, #0
		for (; i < 64; i++) {
    74d8:	2b3f      	cmp	r3, #63	; 0x3f
    74da:	d80c      	bhi.n	74f6 <nv_is_empty+0x8a>
			if (tmp[i] != 0xFF) {
    74dc:	466a      	mov	r2, sp
    74de:	5cd2      	ldrb	r2, [r2, r3]
    74e0:	2aff      	cmp	r2, #255	; 0xff
    74e2:	d10d      	bne.n	7500 <nv_is_empty+0x94>
		for (; i < 64; i++) {
    74e4:	3301      	adds	r3, #1
    74e6:	b2db      	uxtb	r3, r3
    74e8:	e7f6      	b.n	74d8 <nv_is_empty+0x6c>
	ASSERT((address <= NV_MEMORY_END) && ((address + size) <= (NV_MEMORY_END + 1))
    74ea:	2000      	movs	r0, #0
    74ec:	e7d9      	b.n	74a2 <nv_is_empty+0x36>
    74ee:	2000      	movs	r0, #0
    74f0:	e7d7      	b.n	74a2 <nv_is_empty+0x36>
    74f2:	2001      	movs	r0, #1
    74f4:	e7d5      	b.n	74a2 <nv_is_empty+0x36>
				return false;
			}
		}

		pos += cur_size;
    74f6:	444e      	add	r6, r9
    74f8:	b2b6      	uxth	r6, r6
    74fa:	e7dc      	b.n	74b6 <nv_is_empty+0x4a>
	}

	return true;
    74fc:	2001      	movs	r0, #1
    74fe:	e000      	b.n	7502 <nv_is_empty+0x96>
				return false;
    7500:	2000      	movs	r0, #0
}
    7502:	b011      	add	sp, #68	; 0x44
    7504:	bc0c      	pop	{r2, r3}
    7506:	4690      	mov	r8, r2
    7508:	4699      	mov	r9, r3
    750a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    750c:	00011fff 	.word	0x00011fff
    7510:	0000eb78 	.word	0x0000eb78
    7514:	000026c1 	.word	0x000026c1
    7518:	00009555 	.word	0x00009555
    751c:	20000790 	.word	0x20000790
    7520:	0000163d 	.word	0x0000163d

00007524 <nv_align_next_access_address>:
/**
 * \brief Align current point of write to actual based on type of previous write
 *        access
 */
uint16_t nv_align_next_access_address(const uint16_t address, const enum nv_alignment_type type)
{
    7524:	b510      	push	{r4, lr}
    7526:	0004      	movs	r4, r0
	switch (type) {
    7528:	2900      	cmp	r1, #0
    752a:	d005      	beq.n	7538 <nv_align_next_access_address+0x14>
    752c:	2901      	cmp	r1, #1
    752e:	d104      	bne.n	753a <nv_align_next_access_address+0x16>
	case SECTOR_HEADER_ALIGNMENT:
		return address;

	case BLOCK_WITH_DATA_ALIGNMENT:
		return (address + 127) & 0xFF80;
    7530:	347f      	adds	r4, #127	; 0x7f
    7532:	b2a0      	uxth	r0, r4
    7534:	237f      	movs	r3, #127	; 0x7f
    7536:	4398      	bics	r0, r3

	default:
		ASSERT(false);
		return address;
	}
}
    7538:	bd10      	pop	{r4, pc}
		ASSERT(false);
    753a:	22af      	movs	r2, #175	; 0xaf
    753c:	4902      	ldr	r1, [pc, #8]	; (7548 <nv_align_next_access_address+0x24>)
    753e:	2000      	movs	r0, #0
    7540:	4b02      	ldr	r3, [pc, #8]	; (754c <nv_align_next_access_address+0x28>)
    7542:	4798      	blx	r3
		return address;
    7544:	0020      	movs	r0, r4
    7546:	e7f7      	b.n	7538 <nv_align_next_access_address+0x14>
    7548:	0000eb78 	.word	0x0000eb78
    754c:	000026c1 	.word	0x000026c1

00007550 <find_item>:
 * \param[in] ID ID of the item it is required to fins
 *
 * \return Pointer to found item, or NULL
 */
static struct nv_item *find_item(const uint16_t id)
{
    7550:	b510      	push	{r4, lr}
	uint16_t i = 0;
    7552:	2300      	movs	r3, #0

	for (; i < mem.items_amount; i++) {
    7554:	4a09      	ldr	r2, [pc, #36]	; (757c <find_item+0x2c>)
    7556:	8d52      	ldrh	r2, [r2, #42]	; 0x2a
    7558:	4293      	cmp	r3, r2
    755a:	d20c      	bcs.n	7576 <find_item+0x26>
		if (mem.items[i].id == id) {
    755c:	0099      	lsls	r1, r3, #2
    755e:	4a07      	ldr	r2, [pc, #28]	; (757c <find_item+0x2c>)
    7560:	1852      	adds	r2, r2, r1
    7562:	8852      	ldrh	r2, [r2, #2]
    7564:	4282      	cmp	r2, r0
    7566:	d002      	beq.n	756e <find_item+0x1e>
	for (; i < mem.items_amount; i++) {
    7568:	3301      	adds	r3, #1
    756a:	b29b      	uxth	r3, r3
    756c:	e7f2      	b.n	7554 <find_item+0x4>
			return &mem.items[i];
    756e:	4803      	ldr	r0, [pc, #12]	; (757c <find_item+0x2c>)
    7570:	1840      	adds	r0, r0, r1
    7572:	3002      	adds	r0, #2
    7574:	e000      	b.n	7578 <find_item+0x28>
		}
	}
	return NULL;
    7576:	2000      	movs	r0, #0
}
    7578:	bd10      	pop	{r4, pc}
    757a:	46c0      	nop			; (mov r8, r8)
    757c:	20000794 	.word	0x20000794

00007580 <calculate_block_header_checksum>:
 * \param[in] header The pointer to block header to calculate checksum of
 *
 * \return Checksum of a block header
 */
static uint16_t calculate_block_header_checksum(struct block_header *header)
{
    7580:	b510      	push	{r4, lr}
    7582:	0004      	movs	r4, r0
	uint8_t *tmp = (uint8_t *)header + sizeof(header->active);
	uint16_t crc = 0xFFFF;
	uint8_t  i   = 0;
    7584:	2200      	movs	r2, #0
	uint16_t crc = 0xFFFF;
    7586:	4b0b      	ldr	r3, [pc, #44]	; (75b4 <calculate_block_header_checksum+0x34>)

	for (; i < sizeof(struct block_header) - sizeof(header->active) - sizeof(header->checksum); i++) {
    7588:	e00f      	b.n	75aa <calculate_block_header_checksum+0x2a>
		uint8_t value;

		value = (uint8_t)((crc >> 8) ^ tmp[i]);
    758a:	0a18      	lsrs	r0, r3, #8
    758c:	18a1      	adds	r1, r4, r2
    758e:	7889      	ldrb	r1, [r1, #2]
    7590:	4048      	eors	r0, r1
		value = value ^ (value >> 4);
    7592:	0901      	lsrs	r1, r0, #4
    7594:	4048      	eors	r0, r1
		crc   = (crc << 8) ^ ((uint16_t)value << 12) ^ ((uint16_t)value << 5) ^ (uint16_t)value;
    7596:	021b      	lsls	r3, r3, #8
    7598:	0301      	lsls	r1, r0, #12
    759a:	404b      	eors	r3, r1
    759c:	b21b      	sxth	r3, r3
    759e:	0141      	lsls	r1, r0, #5
    75a0:	404b      	eors	r3, r1
    75a2:	4043      	eors	r3, r0
    75a4:	b29b      	uxth	r3, r3
	for (; i < sizeof(struct block_header) - sizeof(header->active) - sizeof(header->checksum); i++) {
    75a6:	3201      	adds	r2, #1
    75a8:	b2d2      	uxtb	r2, r2
    75aa:	2a09      	cmp	r2, #9
    75ac:	d9ed      	bls.n	758a <calculate_block_header_checksum+0xa>
	}
	return crc;
}
    75ae:	0018      	movs	r0, r3
    75b0:	bd10      	pop	{r4, pc}
    75b2:	46c0      	nop			; (mov r8, r8)
    75b4:	0000ffff 	.word	0x0000ffff

000075b8 <load_data_from_sector>:
{
    75b8:	b570      	push	{r4, r5, r6, lr}
    75ba:	b084      	sub	sp, #16
    75bc:	0004      	movs	r4, r0
	mem.pow = nv_align_next_access_address(sizeof(struct sector_header), SECTOR_HEADER_ALIGNMENT);
    75be:	2100      	movs	r1, #0
    75c0:	200c      	movs	r0, #12
    75c2:	4b38      	ldr	r3, [pc, #224]	; (76a4 <load_data_from_sector+0xec>)
    75c4:	4798      	blx	r3
    75c6:	4b38      	ldr	r3, [pc, #224]	; (76a8 <load_data_from_sector+0xf0>)
    75c8:	8018      	strh	r0, [r3, #0]
    75ca:	e010      	b.n	75ee <load_data_from_sector+0x36>
		if (i == sizeof(struct block_header)) {
    75cc:	2b0e      	cmp	r3, #14
    75ce:	d05e      	beq.n	768e <load_data_from_sector+0xd6>
		} else if (header.checksum != calculate_block_header_checksum(&header)) {
    75d0:	466b      	mov	r3, sp
    75d2:	899d      	ldrh	r5, [r3, #12]
    75d4:	4668      	mov	r0, sp
    75d6:	4b35      	ldr	r3, [pc, #212]	; (76ac <load_data_from_sector+0xf4>)
    75d8:	4798      	blx	r3
    75da:	4285      	cmp	r5, r0
    75dc:	d018      	beq.n	7610 <load_data_from_sector+0x58>
			mem.pow = nv_align_next_access_address(mem.pow + sizeof(struct block_header), BLOCK_WITH_DATA_ALIGNMENT);
    75de:	4d32      	ldr	r5, [pc, #200]	; (76a8 <load_data_from_sector+0xf0>)
    75e0:	8828      	ldrh	r0, [r5, #0]
    75e2:	300e      	adds	r0, #14
    75e4:	b280      	uxth	r0, r0
    75e6:	2101      	movs	r1, #1
    75e8:	4b2e      	ldr	r3, [pc, #184]	; (76a4 <load_data_from_sector+0xec>)
    75ea:	4798      	blx	r3
    75ec:	8028      	strh	r0, [r5, #0]
		nv_read(number, mem.pow, (uint8_t *)&header, sizeof(struct block_header));
    75ee:	4b2e      	ldr	r3, [pc, #184]	; (76a8 <load_data_from_sector+0xf0>)
    75f0:	8819      	ldrh	r1, [r3, #0]
    75f2:	230e      	movs	r3, #14
    75f4:	466a      	mov	r2, sp
    75f6:	0020      	movs	r0, r4
    75f8:	4d2d      	ldr	r5, [pc, #180]	; (76b0 <load_data_from_sector+0xf8>)
    75fa:	47a8      	blx	r5
		for (i = 0; i < sizeof(struct block_header); i++) {
    75fc:	2300      	movs	r3, #0
    75fe:	2b0d      	cmp	r3, #13
    7600:	d8e4      	bhi.n	75cc <load_data_from_sector+0x14>
			if (((uint8_t *)&header)[i] != 0xFF) {
    7602:	466a      	mov	r2, sp
    7604:	5cd2      	ldrb	r2, [r2, r3]
    7606:	2aff      	cmp	r2, #255	; 0xff
    7608:	d1e0      	bne.n	75cc <load_data_from_sector+0x14>
		for (i = 0; i < sizeof(struct block_header); i++) {
    760a:	3301      	adds	r3, #1
    760c:	b2db      	uxtb	r3, r3
    760e:	e7f6      	b.n	75fe <load_data_from_sector+0x46>
		} else if (header.active) {
    7610:	466b      	mov	r3, sp
    7612:	881b      	ldrh	r3, [r3, #0]
    7614:	2b00      	cmp	r3, #0
    7616:	d00c      	beq.n	7632 <load_data_from_sector+0x7a>
			mem.pow += sizeof(struct block_header) + header.block_size;
    7618:	466b      	mov	r3, sp
    761a:	88d8      	ldrh	r0, [r3, #6]
    761c:	4d22      	ldr	r5, [pc, #136]	; (76a8 <load_data_from_sector+0xf0>)
    761e:	882b      	ldrh	r3, [r5, #0]
    7620:	18c0      	adds	r0, r0, r3
    7622:	300e      	adds	r0, #14
    7624:	b280      	uxth	r0, r0
    7626:	8028      	strh	r0, [r5, #0]
			mem.pow = nv_align_next_access_address(mem.pow, BLOCK_WITH_DATA_ALIGNMENT);
    7628:	2101      	movs	r1, #1
    762a:	4b1e      	ldr	r3, [pc, #120]	; (76a4 <load_data_from_sector+0xec>)
    762c:	4798      	blx	r3
    762e:	8028      	strh	r0, [r5, #0]
    7630:	e7dd      	b.n	75ee <load_data_from_sector+0x36>
			struct nv_item *item = find_item(header.id);
    7632:	466b      	mov	r3, sp
    7634:	885d      	ldrh	r5, [r3, #2]
    7636:	0028      	movs	r0, r5
    7638:	4b1e      	ldr	r3, [pc, #120]	; (76b4 <load_data_from_sector+0xfc>)
    763a:	4798      	blx	r3
    763c:	1e06      	subs	r6, r0, #0
			if (!item) {
    763e:	d028      	beq.n	7692 <load_data_from_sector+0xda>
			if (header.item_size == 0) {
    7640:	466b      	mov	r3, sp
    7642:	891b      	ldrh	r3, [r3, #8]
    7644:	2b00      	cmp	r3, #0
    7646:	d10b      	bne.n	7660 <load_data_from_sector+0xa8>
				*item = mem.items[--mem.items_amount];
    7648:	4917      	ldr	r1, [pc, #92]	; (76a8 <load_data_from_sector+0xf0>)
    764a:	8d4a      	ldrh	r2, [r1, #42]	; 0x2a
    764c:	3a01      	subs	r2, #1
    764e:	b293      	uxth	r3, r2
    7650:	854b      	strh	r3, [r1, #42]	; 0x2a
    7652:	009b      	lsls	r3, r3, #2
    7654:	18c9      	adds	r1, r1, r3
    7656:	3102      	adds	r1, #2
    7658:	2204      	movs	r2, #4
    765a:	0030      	movs	r0, r6
    765c:	4b16      	ldr	r3, [pc, #88]	; (76b8 <load_data_from_sector+0x100>)
    765e:	4798      	blx	r3
			item->last_block = mem.pow;
    7660:	4d11      	ldr	r5, [pc, #68]	; (76a8 <load_data_from_sector+0xf0>)
    7662:	8828      	ldrh	r0, [r5, #0]
    7664:	8070      	strh	r0, [r6, #2]
			mem.pow += sizeof(struct block_header) + header.block_size;
    7666:	466b      	mov	r3, sp
    7668:	88db      	ldrh	r3, [r3, #6]
    766a:	18c0      	adds	r0, r0, r3
    766c:	300e      	adds	r0, #14
    766e:	b280      	uxth	r0, r0
    7670:	8028      	strh	r0, [r5, #0]
			mem.pow = nv_align_next_access_address(mem.pow, BLOCK_WITH_DATA_ALIGNMENT);
    7672:	2101      	movs	r1, #1
    7674:	4b0b      	ldr	r3, [pc, #44]	; (76a4 <load_data_from_sector+0xec>)
    7676:	4798      	blx	r3
    7678:	8028      	strh	r0, [r5, #0]
			address = CONF_STORAGE_MEMORY_START + number * CONF_SECTOR_SIZE + mem.pow;
    767a:	0023      	movs	r3, r4
    767c:	3310      	adds	r3, #16
    767e:	031b      	lsls	r3, r3, #12
    7680:	1818      	adds	r0, r3, r0
			if (address >= NV_SECTOR_END(number)) {
    7682:	0023      	movs	r3, r4
    7684:	3311      	adds	r3, #17
    7686:	031b      	lsls	r3, r3, #12
    7688:	3b01      	subs	r3, #1
    768a:	4298      	cmp	r0, r3
    768c:	d3af      	bcc.n	75ee <load_data_from_sector+0x36>
}
    768e:	b004      	add	sp, #16
    7690:	bd70      	pop	{r4, r5, r6, pc}
				item     = &mem.items[mem.items_amount++];
    7692:	4b05      	ldr	r3, [pc, #20]	; (76a8 <load_data_from_sector+0xf0>)
    7694:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a
    7696:	1c51      	adds	r1, r2, #1
    7698:	8559      	strh	r1, [r3, #42]	; 0x2a
    769a:	0092      	lsls	r2, r2, #2
    769c:	189b      	adds	r3, r3, r2
    769e:	1c9e      	adds	r6, r3, #2
				item->id = header.id;
    76a0:	805d      	strh	r5, [r3, #2]
    76a2:	e7cd      	b.n	7640 <load_data_from_sector+0x88>
    76a4:	00007525 	.word	0x00007525
    76a8:	20000794 	.word	0x20000794
    76ac:	00007581 	.word	0x00007581
    76b0:	000072f9 	.word	0x000072f9
    76b4:	00007551 	.word	0x00007551
    76b8:	00009543 	.word	0x00009543

000076bc <write_and_verify>:
{
    76bc:	b5f0      	push	{r4, r5, r6, r7, lr}
    76be:	b083      	sub	sp, #12
    76c0:	9001      	str	r0, [sp, #4]
    76c2:	000d      	movs	r5, r1
    76c4:	0016      	movs	r6, r2
    76c6:	001f      	movs	r7, r3
	nv_write(sector, offset, data, size);
    76c8:	4c04      	ldr	r4, [pc, #16]	; (76dc <write_and_verify+0x20>)
    76ca:	47a0      	blx	r4
	if (!nv_is_equal(sector, offset, data, size)) {
    76cc:	003b      	movs	r3, r7
    76ce:	0032      	movs	r2, r6
    76d0:	0029      	movs	r1, r5
    76d2:	9801      	ldr	r0, [sp, #4]
    76d4:	4c02      	ldr	r4, [pc, #8]	; (76e0 <write_and_verify+0x24>)
    76d6:	47a0      	blx	r4
}
    76d8:	b003      	add	sp, #12
    76da:	bdf0      	pop	{r4, r5, r6, r7, pc}
    76dc:	00007299 	.word	0x00007299
    76e0:	000073ad 	.word	0x000073ad

000076e4 <create_sector>:
{
    76e4:	b5f0      	push	{r4, r5, r6, r7, lr}
    76e6:	b085      	sub	sp, #20
    76e8:	0006      	movs	r6, r0
    76ea:	000d      	movs	r5, r1
    76ec:	0017      	movs	r7, r2
	uint8_t              active = 0;
    76ee:	2200      	movs	r2, #0
    76f0:	466b      	mov	r3, sp
    76f2:	70da      	strb	r2, [r3, #3]
	if (!nv_is_empty(sector, 0, CONF_SECTOR_SIZE)) {
    76f4:	2280      	movs	r2, #128	; 0x80
    76f6:	0152      	lsls	r2, r2, #5
    76f8:	2100      	movs	r1, #0
    76fa:	4b20      	ldr	r3, [pc, #128]	; (777c <create_sector+0x98>)
    76fc:	4798      	blx	r3
    76fe:	2800      	cmp	r0, #0
    7700:	d10a      	bne.n	7718 <create_sector+0x34>
		nv_erase_sector(sector);
    7702:	0030      	movs	r0, r6
    7704:	4b1e      	ldr	r3, [pc, #120]	; (7780 <create_sector+0x9c>)
    7706:	4798      	blx	r3
		if (!nv_is_empty(sector, 0, CONF_SECTOR_SIZE)) {
    7708:	2280      	movs	r2, #128	; 0x80
    770a:	0152      	lsls	r2, r2, #5
    770c:	2100      	movs	r1, #0
    770e:	0030      	movs	r0, r6
    7710:	4b1a      	ldr	r3, [pc, #104]	; (777c <create_sector+0x98>)
    7712:	4798      	blx	r3
    7714:	1e04      	subs	r4, r0, #0
    7716:	d01a      	beq.n	774e <create_sector+0x6a>
	memcpy(header.signature, SECTOR_SIGNATURE, 7);
    7718:	ac01      	add	r4, sp, #4
    771a:	2207      	movs	r2, #7
    771c:	4919      	ldr	r1, [pc, #100]	; (7784 <create_sector+0xa0>)
    771e:	2009      	movs	r0, #9
    7720:	4468      	add	r0, sp
    7722:	4b19      	ldr	r3, [pc, #100]	; (7788 <create_sector+0xa4>)
    7724:	4798      	blx	r3
	header.active = 0xFF;
    7726:	23ff      	movs	r3, #255	; 0xff
    7728:	7023      	strb	r3, [r4, #0]
	header.number = number;
    772a:	466b      	mov	r3, sp
    772c:	715d      	strb	r5, [r3, #5]
    772e:	0a2a      	lsrs	r2, r5, #8
    7730:	719a      	strb	r2, [r3, #6]
    7732:	0c2a      	lsrs	r2, r5, #16
    7734:	71da      	strb	r2, [r3, #7]
    7736:	0e2d      	lsrs	r5, r5, #24
    7738:	721d      	strb	r5, [r3, #8]
	if (!write_and_verify(sector, 0, (uint8_t *)&header, sizeof(struct sector_header))) {
    773a:	230c      	movs	r3, #12
    773c:	0022      	movs	r2, r4
    773e:	2100      	movs	r1, #0
    7740:	0030      	movs	r0, r6
    7742:	4c12      	ldr	r4, [pc, #72]	; (778c <create_sector+0xa8>)
    7744:	47a0      	blx	r4
    7746:	1e04      	subs	r4, r0, #0
    7748:	d001      	beq.n	774e <create_sector+0x6a>
	if (activate) {
    774a:	2f00      	cmp	r7, #0
    774c:	d102      	bne.n	7754 <create_sector+0x70>
}
    774e:	0020      	movs	r0, r4
    7750:	b005      	add	sp, #20
    7752:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (!write_and_verify(sector, 0, &active, sizeof(active))) {
    7754:	2301      	movs	r3, #1
    7756:	466a      	mov	r2, sp
    7758:	3203      	adds	r2, #3
    775a:	2100      	movs	r1, #0
    775c:	0030      	movs	r0, r6
    775e:	4c0b      	ldr	r4, [pc, #44]	; (778c <create_sector+0xa8>)
    7760:	47a0      	blx	r4
    7762:	1e04      	subs	r4, r0, #0
    7764:	d0f3      	beq.n	774e <create_sector+0x6a>
		mem.pow           = sizeof(struct sector_header);
    7766:	4d0a      	ldr	r5, [pc, #40]	; (7790 <create_sector+0xac>)
    7768:	230c      	movs	r3, #12
    776a:	802b      	strh	r3, [r5, #0]
		mem.pow           = nv_align_next_access_address(mem.pow, SECTOR_HEADER_ALIGNMENT);
    776c:	2100      	movs	r1, #0
    776e:	200c      	movs	r0, #12
    7770:	4b08      	ldr	r3, [pc, #32]	; (7794 <create_sector+0xb0>)
    7772:	4798      	blx	r3
    7774:	8028      	strh	r0, [r5, #0]
		mem.active_sector = sector;
    7776:	232c      	movs	r3, #44	; 0x2c
    7778:	54ee      	strb	r6, [r5, r3]
    777a:	e7e8      	b.n	774e <create_sector+0x6a>
    777c:	0000746d 	.word	0x0000746d
    7780:	00007359 	.word	0x00007359
    7784:	0000eba8 	.word	0x0000eba8
    7788:	00009543 	.word	0x00009543
    778c:	000076bd 	.word	0x000076bd
    7790:	20000794 	.word	0x20000794
    7794:	00007525 	.word	0x00007525

00007798 <nv_storage_init>:
{
    7798:	b5f0      	push	{r4, r5, r6, r7, lr}
    779a:	46ce      	mov	lr, r9
    779c:	4647      	mov	r7, r8
    779e:	b580      	push	{r7, lr}
    77a0:	b085      	sub	sp, #20
	uint32_t             last_sector_number = 0;
    77a2:	2300      	movs	r3, #0
    77a4:	4699      	mov	r9, r3
	uint8_t              sector = 0, last_sector = 0xFF;
    77a6:	26ff      	movs	r6, #255	; 0xff
    77a8:	2400      	movs	r4, #0
	for (; sector < SECTOR_AMOUNT; sector++) {
    77aa:	e001      	b.n	77b0 <nv_storage_init+0x18>
    77ac:	3401      	adds	r4, #1
    77ae:	b2e4      	uxtb	r4, r4
    77b0:	2c01      	cmp	r4, #1
    77b2:	d81c      	bhi.n	77ee <nv_storage_init+0x56>
		nv_read(sector, 0, (uint8_t *)&header, sizeof(struct sector_header));
    77b4:	ad01      	add	r5, sp, #4
    77b6:	230c      	movs	r3, #12
    77b8:	002a      	movs	r2, r5
    77ba:	2100      	movs	r1, #0
    77bc:	0020      	movs	r0, r4
    77be:	4f1e      	ldr	r7, [pc, #120]	; (7838 <nv_storage_init+0xa0>)
    77c0:	47b8      	blx	r7
		if ((header.active == 0) && (memcmp(header.signature, SECTOR_SIGNATURE, 7) == 0)) {
    77c2:	782b      	ldrb	r3, [r5, #0]
    77c4:	2b00      	cmp	r3, #0
    77c6:	d1f1      	bne.n	77ac <nv_storage_init+0x14>
    77c8:	2207      	movs	r2, #7
    77ca:	491c      	ldr	r1, [pc, #112]	; (783c <nv_storage_init+0xa4>)
    77cc:	2009      	movs	r0, #9
    77ce:	4468      	add	r0, sp
    77d0:	4b1b      	ldr	r3, [pc, #108]	; (7840 <nv_storage_init+0xa8>)
    77d2:	4798      	blx	r3
    77d4:	2800      	cmp	r0, #0
    77d6:	d1e9      	bne.n	77ac <nv_storage_init+0x14>
			if (header.number >= last_sector_number) {
    77d8:	9b01      	ldr	r3, [sp, #4]
    77da:	0a1a      	lsrs	r2, r3, #8
    77dc:	ab01      	add	r3, sp, #4
    77de:	791b      	ldrb	r3, [r3, #4]
    77e0:	061b      	lsls	r3, r3, #24
    77e2:	4313      	orrs	r3, r2
    77e4:	4599      	cmp	r9, r3
    77e6:	d8e1      	bhi.n	77ac <nv_storage_init+0x14>
				last_sector_number = header.number;
    77e8:	4699      	mov	r9, r3
				last_sector        = sector;
    77ea:	0026      	movs	r6, r4
    77ec:	e7de      	b.n	77ac <nv_storage_init+0x14>
	if (last_sector == 0xFF) {
    77ee:	2eff      	cmp	r6, #255	; 0xff
    77f0:	d110      	bne.n	7814 <nv_storage_init+0x7c>
    77f2:	2400      	movs	r4, #0
    77f4:	e001      	b.n	77fa <nv_storage_init+0x62>
		for (sector = 0; sector < SECTOR_AMOUNT; sector++) {
    77f6:	3401      	adds	r4, #1
    77f8:	b2e4      	uxtb	r4, r4
    77fa:	2c01      	cmp	r4, #1
    77fc:	d808      	bhi.n	7810 <nv_storage_init+0x78>
			if (create_sector(sector, last_sector_number + 1, true)) {
    77fe:	464b      	mov	r3, r9
    7800:	1c59      	adds	r1, r3, #1
    7802:	2201      	movs	r2, #1
    7804:	0020      	movs	r0, r4
    7806:	4b0f      	ldr	r3, [pc, #60]	; (7844 <nv_storage_init+0xac>)
    7808:	4798      	blx	r3
    780a:	2800      	cmp	r0, #0
    780c:	d0f3      	beq.n	77f6 <nv_storage_init+0x5e>
    780e:	e007      	b.n	7820 <nv_storage_init+0x88>
		if (sector == SECTOR_AMOUNT) {
    7810:	2c02      	cmp	r4, #2
    7812:	d00a      	beq.n	782a <nv_storage_init+0x92>
	mem.active_sector = last_sector;
    7814:	232c      	movs	r3, #44	; 0x2c
    7816:	4a0c      	ldr	r2, [pc, #48]	; (7848 <nv_storage_init+0xb0>)
    7818:	54d6      	strb	r6, [r2, r3]
	load_data_from_sector(mem.active_sector);
    781a:	0030      	movs	r0, r6
    781c:	4b0b      	ldr	r3, [pc, #44]	; (784c <nv_storage_init+0xb4>)
    781e:	4798      	blx	r3
}
    7820:	b005      	add	sp, #20
    7822:	bc0c      	pop	{r2, r3}
    7824:	4690      	mov	r8, r2
    7826:	4699      	mov	r9, r3
    7828:	bdf0      	pop	{r4, r5, r6, r7, pc}
			ASSERT(false);
    782a:	2297      	movs	r2, #151	; 0x97
    782c:	4908      	ldr	r1, [pc, #32]	; (7850 <nv_storage_init+0xb8>)
    782e:	2000      	movs	r0, #0
    7830:	4b08      	ldr	r3, [pc, #32]	; (7854 <nv_storage_init+0xbc>)
    7832:	4798      	blx	r3
			return;
    7834:	e7f4      	b.n	7820 <nv_storage_init+0x88>
    7836:	46c0      	nop			; (mov r8, r8)
    7838:	000072f9 	.word	0x000072f9
    783c:	0000eba8 	.word	0x0000eba8
    7840:	00009525 	.word	0x00009525
    7844:	000076e5 	.word	0x000076e5
    7848:	20000794 	.word	0x20000794
    784c:	000075b9 	.word	0x000075b9
    7850:	0000ebb0 	.word	0x0000ebb0
    7854:	000026c1 	.word	0x000026c1

00007858 <persistent_storage_init>:

/**
 * \brief Initialize Persistent Storage
 */
void persistent_storage_init(void)
{
    7858:	b510      	push	{r4, lr}
	nv_init(&FLASH_0);
    785a:	4803      	ldr	r0, [pc, #12]	; (7868 <persistent_storage_init+0x10>)
    785c:	4b03      	ldr	r3, [pc, #12]	; (786c <persistent_storage_init+0x14>)
    785e:	4798      	blx	r3
	nv_storage_init();
    7860:	4b03      	ldr	r3, [pc, #12]	; (7870 <persistent_storage_init+0x18>)
    7862:	4798      	blx	r3
}
    7864:	bd10      	pop	{r4, pc}
    7866:	46c0      	nop			; (mov r8, r8)
    7868:	20000900 	.word	0x20000900
    786c:	00007249 	.word	0x00007249
    7870:	00007799 	.word	0x00007799

00007874 <_read>:
#include <stdio.h>

int __attribute__((weak)) _read(int file, char *ptr, int len); /* Remove GCC compiler warning */

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
    7874:	b510      	push	{r4, lr}
    7876:	000b      	movs	r3, r1
	int n = 0;

	if (file != 0) {
    7878:	2800      	cmp	r0, #0
    787a:	d109      	bne.n	7890 <_read+0x1c>
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
    787c:	0011      	movs	r1, r2
    787e:	0018      	movs	r0, r3
    7880:	4b05      	ldr	r3, [pc, #20]	; (7898 <_read+0x24>)
    7882:	4798      	blx	r3
	if (n < 0) {
    7884:	2800      	cmp	r0, #0
    7886:	db00      	blt.n	788a <_read+0x16>
		return -1;
	}

	return n;
}
    7888:	bd10      	pop	{r4, pc}
		return -1;
    788a:	2001      	movs	r0, #1
    788c:	4240      	negs	r0, r0
    788e:	e7fb      	b.n	7888 <_read+0x14>
		return -1;
    7890:	2001      	movs	r0, #1
    7892:	4240      	negs	r0, r0
    7894:	e7f8      	b.n	7888 <_read+0x14>
    7896:	46c0      	nop			; (mov r8, r8)
    7898:	000078f1 	.word	0x000078f1

0000789c <_write>:
#include <stdio.h>

int __attribute__((weak)) _write(int file, char *ptr, int len); /* Remove GCC compiler warning */

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
    789c:	b510      	push	{r4, lr}
    789e:	000b      	movs	r3, r1
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
    78a0:	3801      	subs	r0, #1
    78a2:	2802      	cmp	r0, #2
    78a4:	d809      	bhi.n	78ba <_write+0x1e>
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
    78a6:	0011      	movs	r1, r2
    78a8:	0018      	movs	r0, r3
    78aa:	4b05      	ldr	r3, [pc, #20]	; (78c0 <_write+0x24>)
    78ac:	4798      	blx	r3
	if (n < 0) {
    78ae:	2800      	cmp	r0, #0
    78b0:	db00      	blt.n	78b4 <_write+0x18>
		return -1;
	}

	return n;
}
    78b2:	bd10      	pop	{r4, pc}
		return -1;
    78b4:	2001      	movs	r0, #1
    78b6:	4240      	negs	r0, r0
    78b8:	e7fb      	b.n	78b2 <_write+0x16>
		return -1;
    78ba:	2001      	movs	r0, #1
    78bc:	4240      	negs	r0, r0
    78be:	e7f8      	b.n	78b2 <_write+0x16>
    78c0:	00007915 	.word	0x00007915

000078c4 <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
    78c4:	b570      	push	{r4, r5, r6, lr}
    78c6:	0006      	movs	r6, r0
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
    78c8:	4d06      	ldr	r5, [pc, #24]	; (78e4 <stdio_io_init+0x20>)
    78ca:	682b      	ldr	r3, [r5, #0]
    78cc:	6898      	ldr	r0, [r3, #8]
    78ce:	2100      	movs	r1, #0
    78d0:	4c05      	ldr	r4, [pc, #20]	; (78e8 <stdio_io_init+0x24>)
    78d2:	47a0      	blx	r4
	setbuf(stdin, NULL);
    78d4:	682b      	ldr	r3, [r5, #0]
    78d6:	6858      	ldr	r0, [r3, #4]
    78d8:	2100      	movs	r1, #0
    78da:	47a0      	blx	r4
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
    78dc:	4b03      	ldr	r3, [pc, #12]	; (78ec <stdio_io_init+0x28>)
    78de:	601e      	str	r6, [r3, #0]
}
    78e0:	bd70      	pop	{r4, r5, r6, pc}
    78e2:	46c0      	nop			; (mov r8, r8)
    78e4:	200000dc 	.word	0x200000dc
    78e8:	0000966d 	.word	0x0000966d
    78ec:	200007c4 	.word	0x200007c4

000078f0 <stdio_io_read>:
{
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
    78f0:	b510      	push	{r4, lr}
    78f2:	0004      	movs	r4, r0
	if (stdio_io == NULL) {
    78f4:	4b05      	ldr	r3, [pc, #20]	; (790c <stdio_io_read+0x1c>)
    78f6:	6818      	ldr	r0, [r3, #0]
    78f8:	2800      	cmp	r0, #0
    78fa:	d004      	beq.n	7906 <stdio_io_read+0x16>
		return 0;
	}
	return io_read(stdio_io, buf, len);
    78fc:	b28a      	uxth	r2, r1
    78fe:	0021      	movs	r1, r4
    7900:	4b03      	ldr	r3, [pc, #12]	; (7910 <stdio_io_read+0x20>)
    7902:	4798      	blx	r3
}
    7904:	bd10      	pop	{r4, pc}
		return 0;
    7906:	2000      	movs	r0, #0
    7908:	e7fc      	b.n	7904 <stdio_io_read+0x14>
    790a:	46c0      	nop			; (mov r8, r8)
    790c:	200007c4 	.word	0x200007c4
    7910:	00001981 	.word	0x00001981

00007914 <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
    7914:	b510      	push	{r4, lr}
    7916:	0004      	movs	r4, r0
	if (stdio_io == NULL) {
    7918:	4b05      	ldr	r3, [pc, #20]	; (7930 <stdio_io_write+0x1c>)
    791a:	6818      	ldr	r0, [r3, #0]
    791c:	2800      	cmp	r0, #0
    791e:	d004      	beq.n	792a <stdio_io_write+0x16>
		return 0;
	}
	return io_write(stdio_io, buf, len);
    7920:	b28a      	uxth	r2, r1
    7922:	0021      	movs	r1, r4
    7924:	4b03      	ldr	r3, [pc, #12]	; (7934 <stdio_io_write+0x20>)
    7926:	4798      	blx	r3
}
    7928:	bd10      	pop	{r4, pc}
		return 0;
    792a:	2000      	movs	r0, #0
    792c:	e7fc      	b.n	7928 <stdio_io_write+0x14>
    792e:	46c0      	nop			; (mov r8, r8)
    7930:	200007c4 	.word	0x200007c4
    7934:	00001949 	.word	0x00001949

00007938 <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
    7938:	b510      	push	{r4, lr}

	usart_sync_enable(&USART_0);
    793a:	4c04      	ldr	r4, [pc, #16]	; (794c <stdio_redirect_init+0x14>)
    793c:	0020      	movs	r0, r4
    793e:	4b04      	ldr	r3, [pc, #16]	; (7950 <stdio_redirect_init+0x18>)
    7940:	4798      	blx	r3
	stdio_io_init(&USART_0.io);
    7942:	0020      	movs	r0, r4
    7944:	4b03      	ldr	r3, [pc, #12]	; (7954 <stdio_redirect_init+0x1c>)
    7946:	4798      	blx	r3
}
    7948:	bd10      	pop	{r4, pc}
    794a:	46c0      	nop			; (mov r8, r8)
    794c:	2000099c 	.word	0x2000099c
    7950:	000020ed 	.word	0x000020ed
    7954:	000078c5 	.word	0x000078c5

00007958 <serial_rx_callback>:

extern bool ACK_received;
extern bool NAK_received;
	
void serial_rx_callback(const struct usart_async_descriptor *const io_descr)
{
    7958:	b500      	push	{lr}
    795a:	b083      	sub	sp, #12
	uint8_t ch;

	//	Read a Character
	io_read(&USART_1.io,&ch,1);
    795c:	2201      	movs	r2, #1
    795e:	466b      	mov	r3, sp
    7960:	1dd9      	adds	r1, r3, #7
    7962:	483e      	ldr	r0, [pc, #248]	; (7a5c <serial_rx_callback+0x104>)
    7964:	4b3e      	ldr	r3, [pc, #248]	; (7a60 <serial_rx_callback+0x108>)
    7966:	4798      	blx	r3

	if (!RX_in_progress)
    7968:	4b3e      	ldr	r3, [pc, #248]	; (7a64 <serial_rx_callback+0x10c>)
    796a:	781b      	ldrb	r3, [r3, #0]
    796c:	2b00      	cmp	r3, #0
    796e:	d106      	bne.n	797e <serial_rx_callback+0x26>
	{
		if (ch == ACK) {
    7970:	466b      	mov	r3, sp
    7972:	3307      	adds	r3, #7
    7974:	781b      	ldrb	r3, [r3, #0]
    7976:	2b06      	cmp	r3, #6
    7978:	d010      	beq.n	799c <serial_rx_callback+0x44>
			ACK_received = true;
			return;
		}
		else if (ch == NAK) {
    797a:	2b15      	cmp	r3, #21
    797c:	d012      	beq.n	79a4 <serial_rx_callback+0x4c>
			NAK_received = true;
			return;
		}
	}

	if (!event_report.report_valid)
    797e:	4b3a      	ldr	r3, [pc, #232]	; (7a68 <serial_rx_callback+0x110>)
    7980:	795b      	ldrb	r3, [r3, #5]
    7982:	2b00      	cmp	r3, #0
    7984:	d108      	bne.n	7998 <serial_rx_callback+0x40>
	{
		// Check for first char of Command
		if (!RX_in_progress)
    7986:	4b37      	ldr	r3, [pc, #220]	; (7a64 <serial_rx_callback+0x10c>)
    7988:	781b      	ldrb	r3, [r3, #0]
    798a:	2b00      	cmp	r3, #0
    798c:	d115      	bne.n	79ba <serial_rx_callback+0x62>
		{
			if (ch == REPORT_EVENT)
    798e:	466b      	mov	r3, sp
    7990:	3307      	adds	r3, #7
    7992:	781b      	ldrb	r3, [r3, #0]
    7994:	2b07      	cmp	r3, #7
    7996:	d009      	beq.n	79ac <serial_rx_callback+0x54>
// 	else			felesleges, az LCD ugysem csinl semmit, a doksi hazudik
// 	{
// 		ch=NAK;
//		io_write(&USART_1.io,&ch,1);
// 	}
}
    7998:	b003      	add	sp, #12
    799a:	bd00      	pop	{pc}
			ACK_received = true;
    799c:	2201      	movs	r2, #1
    799e:	4b33      	ldr	r3, [pc, #204]	; (7a6c <serial_rx_callback+0x114>)
    79a0:	701a      	strb	r2, [r3, #0]
			return;
    79a2:	e7f9      	b.n	7998 <serial_rx_callback+0x40>
			NAK_received = true;
    79a4:	2201      	movs	r2, #1
    79a6:	4b32      	ldr	r3, [pc, #200]	; (7a70 <serial_rx_callback+0x118>)
    79a8:	701a      	strb	r2, [r3, #0]
			return;
    79aa:	e7f5      	b.n	7998 <serial_rx_callback+0x40>
				RX_in_progress = true;
    79ac:	4b2d      	ldr	r3, [pc, #180]	; (7a64 <serial_rx_callback+0x10c>)
    79ae:	2201      	movs	r2, #1
    79b0:	701a      	strb	r2, [r3, #0]
				parameter = 1;
    79b2:	705a      	strb	r2, [r3, #1]
				chksum=REPORT_EVENT;
    79b4:	3206      	adds	r2, #6
    79b6:	709a      	strb	r2, [r3, #2]
    79b8:	e7ee      	b.n	7998 <serial_rx_callback+0x40>
			switch (parameter) {
    79ba:	4b2a      	ldr	r3, [pc, #168]	; (7a64 <serial_rx_callback+0x10c>)
    79bc:	785b      	ldrb	r3, [r3, #1]
    79be:	b2db      	uxtb	r3, r3
    79c0:	2b05      	cmp	r3, #5
    79c2:	d8e9      	bhi.n	7998 <serial_rx_callback+0x40>
    79c4:	009b      	lsls	r3, r3, #2
    79c6:	4a2b      	ldr	r2, [pc, #172]	; (7a74 <serial_rx_callback+0x11c>)
    79c8:	58d3      	ldr	r3, [r2, r3]
    79ca:	469f      	mov	pc, r3
					event_report.object_id=ch;
    79cc:	466b      	mov	r3, sp
    79ce:	79d9      	ldrb	r1, [r3, #7]
    79d0:	4b25      	ldr	r3, [pc, #148]	; (7a68 <serial_rx_callback+0x110>)
    79d2:	7019      	strb	r1, [r3, #0]
					chksum^=ch;
    79d4:	4a23      	ldr	r2, [pc, #140]	; (7a64 <serial_rx_callback+0x10c>)
    79d6:	7893      	ldrb	r3, [r2, #2]
    79d8:	404b      	eors	r3, r1
    79da:	7093      	strb	r3, [r2, #2]
					parameter++;
    79dc:	7853      	ldrb	r3, [r2, #1]
    79de:	3301      	adds	r3, #1
    79e0:	b2db      	uxtb	r3, r3
    79e2:	7053      	strb	r3, [r2, #1]
				break;
    79e4:	e7d8      	b.n	7998 <serial_rx_callback+0x40>
					event_report.object_index=ch;
    79e6:	466b      	mov	r3, sp
    79e8:	79d9      	ldrb	r1, [r3, #7]
    79ea:	4b1f      	ldr	r3, [pc, #124]	; (7a68 <serial_rx_callback+0x110>)
    79ec:	7059      	strb	r1, [r3, #1]
					chksum^=ch;
    79ee:	4a1d      	ldr	r2, [pc, #116]	; (7a64 <serial_rx_callback+0x10c>)
    79f0:	7893      	ldrb	r3, [r2, #2]
    79f2:	404b      	eors	r3, r1
    79f4:	7093      	strb	r3, [r2, #2]
					parameter++;
    79f6:	7853      	ldrb	r3, [r2, #1]
    79f8:	3301      	adds	r3, #1
    79fa:	b2db      	uxtb	r3, r3
    79fc:	7053      	strb	r3, [r2, #1]
				break;
    79fe:	e7cb      	b.n	7998 <serial_rx_callback+0x40>
					event_report.value_msb=ch;
    7a00:	466b      	mov	r3, sp
    7a02:	79d9      	ldrb	r1, [r3, #7]
    7a04:	4b18      	ldr	r3, [pc, #96]	; (7a68 <serial_rx_callback+0x110>)
    7a06:	7099      	strb	r1, [r3, #2]
					chksum^=ch;
    7a08:	4a16      	ldr	r2, [pc, #88]	; (7a64 <serial_rx_callback+0x10c>)
    7a0a:	7893      	ldrb	r3, [r2, #2]
    7a0c:	404b      	eors	r3, r1
    7a0e:	7093      	strb	r3, [r2, #2]
					parameter++;
    7a10:	7853      	ldrb	r3, [r2, #1]
    7a12:	3301      	adds	r3, #1
    7a14:	b2db      	uxtb	r3, r3
    7a16:	7053      	strb	r3, [r2, #1]
				break;
    7a18:	e7be      	b.n	7998 <serial_rx_callback+0x40>
					event_report.value_lsb=ch;
    7a1a:	466b      	mov	r3, sp
    7a1c:	79d9      	ldrb	r1, [r3, #7]
    7a1e:	4b12      	ldr	r3, [pc, #72]	; (7a68 <serial_rx_callback+0x110>)
    7a20:	70d9      	strb	r1, [r3, #3]
					chksum^=ch;
    7a22:	4a10      	ldr	r2, [pc, #64]	; (7a64 <serial_rx_callback+0x10c>)
    7a24:	7893      	ldrb	r3, [r2, #2]
    7a26:	404b      	eors	r3, r1
    7a28:	7093      	strb	r3, [r2, #2]
					parameter++;
    7a2a:	7853      	ldrb	r3, [r2, #1]
    7a2c:	3301      	adds	r3, #1
    7a2e:	b2db      	uxtb	r3, r3
    7a30:	7053      	strb	r3, [r2, #1]
				break;
    7a32:	e7b1      	b.n	7998 <serial_rx_callback+0x40>
					event_report.cksum=ch;
    7a34:	466b      	mov	r3, sp
    7a36:	79d9      	ldrb	r1, [r3, #7]
    7a38:	4b0b      	ldr	r3, [pc, #44]	; (7a68 <serial_rx_callback+0x110>)
    7a3a:	7119      	strb	r1, [r3, #4]
					chksum^=ch;
    7a3c:	4b09      	ldr	r3, [pc, #36]	; (7a64 <serial_rx_callback+0x10c>)
    7a3e:	789a      	ldrb	r2, [r3, #2]
    7a40:	404a      	eors	r2, r1
    7a42:	709a      	strb	r2, [r3, #2]
					if (chksum == 0) {
    7a44:	789b      	ldrb	r3, [r3, #2]
    7a46:	2b00      	cmp	r3, #0
    7a48:	d102      	bne.n	7a50 <serial_rx_callback+0xf8>
						event_report.report_valid=true;
    7a4a:	2201      	movs	r2, #1
    7a4c:	4b06      	ldr	r3, [pc, #24]	; (7a68 <serial_rx_callback+0x110>)
    7a4e:	715a      	strb	r2, [r3, #5]
					parameter=0;
    7a50:	4b04      	ldr	r3, [pc, #16]	; (7a64 <serial_rx_callback+0x10c>)
    7a52:	2200      	movs	r2, #0
    7a54:	705a      	strb	r2, [r3, #1]
					RX_in_progress=false;
    7a56:	701a      	strb	r2, [r3, #0]
				break;
    7a58:	e79e      	b.n	7998 <serial_rx_callback+0x40>
    7a5a:	46c0      	nop			; (mov r8, r8)
    7a5c:	200009a8 	.word	0x200009a8
    7a60:	00001981 	.word	0x00001981
    7a64:	200007c8 	.word	0x200007c8
    7a68:	20000a34 	.word	0x20000a34
    7a6c:	20000a64 	.word	0x20000a64
    7a70:	20000a7c 	.word	0x20000a7c
    7a74:	0000ebd4 	.word	0x0000ebd4

00007a78 <send_uart>:

void send_uart(char * message)
{
    7a78:	b570      	push	{r4, r5, r6, lr}
	//    Message different than null
	if (strlen(message) != 0)
    7a7a:	7803      	ldrb	r3, [r0, #0]
    7a7c:	2b00      	cmp	r3, #0
    7a7e:	d00b      	beq.n	7a98 <send_uart+0x20>
	{
		//    Input message into FIFO buffer
		Buffer[storage_txbuffer]=message;
    7a80:	4c1a      	ldr	r4, [pc, #104]	; (7aec <send_uart+0x74>)
    7a82:	78e3      	ldrb	r3, [r4, #3]
    7a84:	009b      	lsls	r3, r3, #2
    7a86:	18e3      	adds	r3, r4, r3
    7a88:	6058      	str	r0, [r3, #4]
		
		//    Increase tail cursor of circular buffer for next message
		storage_txbuffer = (storage_txbuffer + 1) %25;
    7a8a:	78e0      	ldrb	r0, [r4, #3]
    7a8c:	3001      	adds	r0, #1
    7a8e:	2119      	movs	r1, #25
    7a90:	4b17      	ldr	r3, [pc, #92]	; (7af0 <send_uart+0x78>)
    7a92:	4798      	blx	r3
    7a94:	b2c9      	uxtb	r1, r1
    7a96:	70e1      	strb	r1, [r4, #3]
	}
	
	//    Uart ready to transmit & there is something to transmit (head and tail pointers =/=)
	if (!TX_in_progress && (storage_txbuffer != stage_txbuffer))
    7a98:	2368      	movs	r3, #104	; 0x68
    7a9a:	4a14      	ldr	r2, [pc, #80]	; (7aec <send_uart+0x74>)
    7a9c:	5cd3      	ldrb	r3, [r2, r3]
    7a9e:	2b00      	cmp	r3, #0
    7aa0:	d122      	bne.n	7ae8 <send_uart+0x70>
    7aa2:	0013      	movs	r3, r2
    7aa4:	78d2      	ldrb	r2, [r2, #3]
    7aa6:	b2d2      	uxtb	r2, r2
    7aa8:	2169      	movs	r1, #105	; 0x69
    7aaa:	5c5b      	ldrb	r3, [r3, r1]
    7aac:	b2db      	uxtb	r3, r3
    7aae:	429a      	cmp	r2, r3
    7ab0:	d01a      	beq.n	7ae8 <send_uart+0x70>
	{
		//    Get length of message
		int length = strlen(Buffer[stage_txbuffer]);
    7ab2:	4c0e      	ldr	r4, [pc, #56]	; (7aec <send_uart+0x74>)
    7ab4:	2569      	movs	r5, #105	; 0x69
    7ab6:	5d63      	ldrb	r3, [r4, r5]
    7ab8:	009b      	lsls	r3, r3, #2
    7aba:	18e3      	adds	r3, r4, r3
    7abc:	6858      	ldr	r0, [r3, #4]
    7abe:	4b0d      	ldr	r3, [pc, #52]	; (7af4 <send_uart+0x7c>)
    7ac0:	4798      	blx	r3
		
		//    Set transmitting flag
		TX_in_progress = true;
    7ac2:	2201      	movs	r2, #1
    7ac4:	2368      	movs	r3, #104	; 0x68
    7ac6:	54e2      	strb	r2, [r4, r3]
		
		//    Write message
		io_write(io,(uint8_t*)Buffer[stage_txbuffer],length);
    7ac8:	5d63      	ldrb	r3, [r4, r5]
    7aca:	009b      	lsls	r3, r3, #2
    7acc:	18e3      	adds	r3, r4, r3
    7ace:	6859      	ldr	r1, [r3, #4]
    7ad0:	b282      	uxth	r2, r0
    7ad2:	4b09      	ldr	r3, [pc, #36]	; (7af8 <send_uart+0x80>)
    7ad4:	6818      	ldr	r0, [r3, #0]
    7ad6:	4b09      	ldr	r3, [pc, #36]	; (7afc <send_uart+0x84>)
    7ad8:	4798      	blx	r3
		
		//    Increase head cursor of circular buffer
		stage_txbuffer = (stage_txbuffer + 1) %25;
    7ada:	5d60      	ldrb	r0, [r4, r5]
    7adc:	3001      	adds	r0, #1
    7ade:	2119      	movs	r1, #25
    7ae0:	4b03      	ldr	r3, [pc, #12]	; (7af0 <send_uart+0x78>)
    7ae2:	4798      	blx	r3
    7ae4:	b2c9      	uxtb	r1, r1
    7ae6:	5561      	strb	r1, [r4, r5]
	}
}
    7ae8:	bd70      	pop	{r4, r5, r6, pc}
    7aea:	46c0      	nop			; (mov r8, r8)
    7aec:	200007c8 	.word	0x200007c8
    7af0:	0000947d 	.word	0x0000947d
    7af4:	0000983d 	.word	0x0000983d
    7af8:	20000ac4 	.word	0x20000ac4
    7afc:	00001949 	.word	0x00001949

00007b00 <serial_tx_callback>:

void serial_tx_callback(const struct usart_async_descriptor *const io_descr)
{
    7b00:	b510      	push	{r4, lr}
	TX_in_progress = false;
    7b02:	2100      	movs	r1, #0
    7b04:	2368      	movs	r3, #104	; 0x68
    7b06:	4a03      	ldr	r2, [pc, #12]	; (7b14 <serial_tx_callback+0x14>)
    7b08:	54d1      	strb	r1, [r2, r3]
	send_uart("");
    7b0a:	4803      	ldr	r0, [pc, #12]	; (7b18 <serial_tx_callback+0x18>)
    7b0c:	4b03      	ldr	r3, [pc, #12]	; (7b1c <serial_tx_callback+0x1c>)
    7b0e:	4798      	blx	r3
}
    7b10:	bd10      	pop	{r4, pc}
    7b12:	46c0      	nop			; (mov r8, r8)
    7b14:	200007c8 	.word	0x200007c8
    7b18:	0000e2f4 	.word	0x0000e2f4
    7b1c:	00007a79 	.word	0x00007a79

00007b20 <uart_init>:

void uart_init()
{
    7b20:	b570      	push	{r4, r5, r6, lr}
	printf("register rx callback\r\n");
    7b22:	480c      	ldr	r0, [pc, #48]	; (7b54 <uart_init+0x34>)
    7b24:	4d0c      	ldr	r5, [pc, #48]	; (7b58 <uart_init+0x38>)
    7b26:	47a8      	blx	r5
	//	Setup RX callback
	usart_async_register_callback(&USART_1, USART_ASYNC_RXC_CB, serial_rx_callback);
    7b28:	4c0c      	ldr	r4, [pc, #48]	; (7b5c <uart_init+0x3c>)
    7b2a:	4a0d      	ldr	r2, [pc, #52]	; (7b60 <uart_init+0x40>)
    7b2c:	2100      	movs	r1, #0
    7b2e:	0020      	movs	r0, r4
    7b30:	4e0c      	ldr	r6, [pc, #48]	; (7b64 <uart_init+0x44>)
    7b32:	47b0      	blx	r6

	printf("register tx callback\r\n");
    7b34:	480c      	ldr	r0, [pc, #48]	; (7b68 <uart_init+0x48>)
    7b36:	47a8      	blx	r5
	//	Setup TX callback
	usart_async_register_callback(&USART_1, USART_ASYNC_TXC_CB, serial_tx_callback);
    7b38:	4a0c      	ldr	r2, [pc, #48]	; (7b6c <uart_init+0x4c>)
    7b3a:	2101      	movs	r1, #1
    7b3c:	0020      	movs	r0, r4
    7b3e:	47b0      	blx	r6
	// 	usart_async_register_callback(&USART_1, USART_ASYNC_ERROR_CB, err_cb);

	//	Setup USART
	usart_async_get_io_descriptor(&USART_1, &io);
    7b40:	490b      	ldr	r1, [pc, #44]	; (7b70 <uart_init+0x50>)
    7b42:	0020      	movs	r0, r4
    7b44:	4b0b      	ldr	r3, [pc, #44]	; (7b74 <uart_init+0x54>)
    7b46:	4798      	blx	r3
	printf("Enable uart1\r\n");
    7b48:	480b      	ldr	r0, [pc, #44]	; (7b78 <uart_init+0x58>)
    7b4a:	47a8      	blx	r5
	usart_async_enable(&USART_1);
    7b4c:	0020      	movs	r0, r4
    7b4e:	4b0b      	ldr	r3, [pc, #44]	; (7b7c <uart_init+0x5c>)
    7b50:	4798      	blx	r3
    7b52:	bd70      	pop	{r4, r5, r6, pc}
    7b54:	0000ebec 	.word	0x0000ebec
    7b58:	00009659 	.word	0x00009659
    7b5c:	200009a8 	.word	0x200009a8
    7b60:	00007959 	.word	0x00007959
    7b64:	00001f21 	.word	0x00001f21
    7b68:	0000ec04 	.word	0x0000ec04
    7b6c:	00007b01 	.word	0x00007b01
    7b70:	20000ac4 	.word	0x20000ac4
    7b74:	00001ef1 	.word	0x00001ef1
    7b78:	0000ec1c 	.word	0x0000ec1c
    7b7c:	00001ec5 	.word	0x00001ec5

00007b80 <cdcdf_acm_get_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t cdcdf_acm_get_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    7b80:	b510      	push	{r4, lr}
	uint16_t len = req->wLength;
    7b82:	798b      	ldrb	r3, [r1, #6]
    7b84:	79cc      	ldrb	r4, [r1, #7]
    7b86:	0224      	lsls	r4, r4, #8
    7b88:	431c      	orrs	r4, r3

	if (USB_DATA_STAGE == stage) {
    7b8a:	2a01      	cmp	r2, #1
    7b8c:	d00a      	beq.n	7ba4 <cdcdf_acm_get_req+0x24>
		return ERR_NONE;
	}

	switch (req->bRequest) {
    7b8e:	784b      	ldrb	r3, [r1, #1]
    7b90:	2b21      	cmp	r3, #33	; 0x21
    7b92:	d109      	bne.n	7ba8 <cdcdf_acm_get_req+0x28>
	case USB_REQ_CDC_GET_LINE_CODING:
		if (sizeof(struct usb_cdc_line_coding) != len) {
    7b94:	2c07      	cmp	r4, #7
    7b96:	d10a      	bne.n	7bae <cdcdf_acm_get_req+0x2e>
			return ERR_INVALID_DATA;
		}
		return usbdc_xfer(ep, (uint8_t *)&usbd_cdc_line_coding, len, false);
    7b98:	2300      	movs	r3, #0
    7b9a:	0022      	movs	r2, r4
    7b9c:	4905      	ldr	r1, [pc, #20]	; (7bb4 <cdcdf_acm_get_req+0x34>)
    7b9e:	4c06      	ldr	r4, [pc, #24]	; (7bb8 <cdcdf_acm_get_req+0x38>)
    7ba0:	47a0      	blx	r4
	default:
		return ERR_INVALID_ARG;
	}
}
    7ba2:	bd10      	pop	{r4, pc}
		return ERR_NONE;
    7ba4:	2000      	movs	r0, #0
    7ba6:	e7fc      	b.n	7ba2 <cdcdf_acm_get_req+0x22>
		return ERR_INVALID_ARG;
    7ba8:	200d      	movs	r0, #13
    7baa:	4240      	negs	r0, r0
    7bac:	e7f9      	b.n	7ba2 <cdcdf_acm_get_req+0x22>
			return ERR_INVALID_DATA;
    7bae:	2001      	movs	r0, #1
    7bb0:	4240      	negs	r0, r0
    7bb2:	e7f6      	b.n	7ba2 <cdcdf_acm_get_req+0x22>
    7bb4:	20000834 	.word	0x20000834
    7bb8:	00008629 	.word	0x00008629

00007bbc <cdcdf_acm_set_req>:
{
    7bbc:	b5f0      	push	{r4, r5, r6, r7, lr}
    7bbe:	b083      	sub	sp, #12
    7bc0:	0005      	movs	r5, r0
    7bc2:	000f      	movs	r7, r1
    7bc4:	0014      	movs	r4, r2
	uint16_t                   len      = req->wLength;
    7bc6:	798e      	ldrb	r6, [r1, #6]
    7bc8:	79cb      	ldrb	r3, [r1, #7]
    7bca:	021b      	lsls	r3, r3, #8
    7bcc:	431e      	orrs	r6, r3
	uint8_t *                  ctrl_buf = usbdc_get_ctrl_buffer();
    7bce:	4b23      	ldr	r3, [pc, #140]	; (7c5c <cdcdf_acm_set_req+0xa0>)
    7bd0:	4798      	blx	r3
	switch (req->bRequest) {
    7bd2:	787b      	ldrb	r3, [r7, #1]
    7bd4:	2b20      	cmp	r3, #32
    7bd6:	d005      	beq.n	7be4 <cdcdf_acm_set_req+0x28>
    7bd8:	2b22      	cmp	r3, #34	; 0x22
    7bda:	d026      	beq.n	7c2a <cdcdf_acm_set_req+0x6e>
		return ERR_INVALID_ARG;
    7bdc:	200d      	movs	r0, #13
    7bde:	4240      	negs	r0, r0
}
    7be0:	b003      	add	sp, #12
    7be2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (sizeof(struct usb_cdc_line_coding) != len) {
    7be4:	2e07      	cmp	r6, #7
    7be6:	d131      	bne.n	7c4c <cdcdf_acm_set_req+0x90>
		if (USB_SETUP_STAGE == stage) {
    7be8:	2c00      	cmp	r4, #0
    7bea:	d017      	beq.n	7c1c <cdcdf_acm_set_req+0x60>
			memcpy(&line_coding_tmp, ctrl_buf, sizeof(struct usb_cdc_line_coding));
    7bec:	2207      	movs	r2, #7
    7bee:	0001      	movs	r1, r0
    7bf0:	4668      	mov	r0, sp
    7bf2:	4b1b      	ldr	r3, [pc, #108]	; (7c60 <cdcdf_acm_set_req+0xa4>)
    7bf4:	4798      	blx	r3
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    7bf6:	4b1b      	ldr	r3, [pc, #108]	; (7c64 <cdcdf_acm_set_req+0xa8>)
    7bf8:	689b      	ldr	r3, [r3, #8]
    7bfa:	2b00      	cmp	r3, #0
    7bfc:	d003      	beq.n	7c06 <cdcdf_acm_set_req+0x4a>
    7bfe:	4668      	mov	r0, sp
    7c00:	4798      	blx	r3
    7c02:	2800      	cmp	r0, #0
    7c04:	d025      	beq.n	7c52 <cdcdf_acm_set_req+0x96>
				usbd_cdc_line_coding = line_coding_tmp;
    7c06:	4b17      	ldr	r3, [pc, #92]	; (7c64 <cdcdf_acm_set_req+0xa8>)
    7c08:	9a00      	ldr	r2, [sp, #0]
    7c0a:	601a      	str	r2, [r3, #0]
    7c0c:	466a      	mov	r2, sp
    7c0e:	8892      	ldrh	r2, [r2, #4]
    7c10:	809a      	strh	r2, [r3, #4]
    7c12:	466a      	mov	r2, sp
    7c14:	7992      	ldrb	r2, [r2, #6]
    7c16:	719a      	strb	r2, [r3, #6]
			return ERR_NONE;
    7c18:	2000      	movs	r0, #0
    7c1a:	e7e1      	b.n	7be0 <cdcdf_acm_set_req+0x24>
			return usbdc_xfer(ep, ctrl_buf, len, false);
    7c1c:	2300      	movs	r3, #0
    7c1e:	0032      	movs	r2, r6
    7c20:	0001      	movs	r1, r0
    7c22:	0028      	movs	r0, r5
    7c24:	4c10      	ldr	r4, [pc, #64]	; (7c68 <cdcdf_acm_set_req+0xac>)
    7c26:	47a0      	blx	r4
    7c28:	e7da      	b.n	7be0 <cdcdf_acm_set_req+0x24>
		usbdc_xfer(0, NULL, 0, 0);
    7c2a:	2300      	movs	r3, #0
    7c2c:	2200      	movs	r2, #0
    7c2e:	2100      	movs	r1, #0
    7c30:	2000      	movs	r0, #0
    7c32:	4c0d      	ldr	r4, [pc, #52]	; (7c68 <cdcdf_acm_set_req+0xac>)
    7c34:	47a0      	blx	r4
		if (NULL != cdcdf_acm_notify_state) {
    7c36:	4b0b      	ldr	r3, [pc, #44]	; (7c64 <cdcdf_acm_set_req+0xa8>)
    7c38:	68db      	ldr	r3, [r3, #12]
    7c3a:	2b00      	cmp	r3, #0
    7c3c:	d00b      	beq.n	7c56 <cdcdf_acm_set_req+0x9a>
			cdcdf_acm_notify_state(req->wValue);
    7c3e:	78ba      	ldrb	r2, [r7, #2]
    7c40:	78f8      	ldrb	r0, [r7, #3]
    7c42:	0200      	lsls	r0, r0, #8
    7c44:	4310      	orrs	r0, r2
    7c46:	4798      	blx	r3
		return ERR_NONE;
    7c48:	2000      	movs	r0, #0
    7c4a:	e7c9      	b.n	7be0 <cdcdf_acm_set_req+0x24>
			return ERR_INVALID_DATA;
    7c4c:	2001      	movs	r0, #1
    7c4e:	4240      	negs	r0, r0
    7c50:	e7c6      	b.n	7be0 <cdcdf_acm_set_req+0x24>
			return ERR_NONE;
    7c52:	2000      	movs	r0, #0
    7c54:	e7c4      	b.n	7be0 <cdcdf_acm_set_req+0x24>
		return ERR_NONE;
    7c56:	2000      	movs	r0, #0
    7c58:	e7c2      	b.n	7be0 <cdcdf_acm_set_req+0x24>
    7c5a:	46c0      	nop			; (mov r8, r8)
    7c5c:	00008bb5 	.word	0x00008bb5
    7c60:	00009543 	.word	0x00009543
    7c64:	20000834 	.word	0x20000834
    7c68:	00008629 	.word	0x00008629

00007c6c <cdcdf_acm_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t cdcdf_acm_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    7c6c:	b570      	push	{r4, r5, r6, lr}
	if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    7c6e:	780c      	ldrb	r4, [r1, #0]
    7c70:	0965      	lsrs	r5, r4, #5
    7c72:	2303      	movs	r3, #3
    7c74:	402b      	ands	r3, r5
    7c76:	2b01      	cmp	r3, #1
    7c78:	d114      	bne.n	7ca4 <cdcdf_acm_req+0x38>
		return ERR_NOT_FOUND;
	}
	if ((req->wIndex == _cdcdf_acm_funcd.func_iface[0]) || (req->wIndex == _cdcdf_acm_funcd.func_iface[1])) {
    7c7a:	790d      	ldrb	r5, [r1, #4]
    7c7c:	794b      	ldrb	r3, [r1, #5]
    7c7e:	021b      	lsls	r3, r3, #8
    7c80:	432b      	orrs	r3, r5
    7c82:	4d0b      	ldr	r5, [pc, #44]	; (7cb0 <cdcdf_acm_req+0x44>)
    7c84:	7c2d      	ldrb	r5, [r5, #16]
    7c86:	42ab      	cmp	r3, r5
    7c88:	d003      	beq.n	7c92 <cdcdf_acm_req+0x26>
    7c8a:	4d09      	ldr	r5, [pc, #36]	; (7cb0 <cdcdf_acm_req+0x44>)
    7c8c:	7c6d      	ldrb	r5, [r5, #17]
    7c8e:	42ab      	cmp	r3, r5
    7c90:	d10b      	bne.n	7caa <cdcdf_acm_req+0x3e>
		if (req->bmRequestType & USB_EP_DIR_IN) {
    7c92:	b264      	sxtb	r4, r4
    7c94:	2c00      	cmp	r4, #0
    7c96:	db02      	blt.n	7c9e <cdcdf_acm_req+0x32>
			return cdcdf_acm_get_req(ep, req, stage);
		} else {
			return cdcdf_acm_set_req(ep, req, stage);
    7c98:	4b06      	ldr	r3, [pc, #24]	; (7cb4 <cdcdf_acm_req+0x48>)
    7c9a:	4798      	blx	r3
		}
	} else {
		return ERR_NOT_FOUND;
	}
}
    7c9c:	bd70      	pop	{r4, r5, r6, pc}
			return cdcdf_acm_get_req(ep, req, stage);
    7c9e:	4b06      	ldr	r3, [pc, #24]	; (7cb8 <cdcdf_acm_req+0x4c>)
    7ca0:	4798      	blx	r3
    7ca2:	e7fb      	b.n	7c9c <cdcdf_acm_req+0x30>
		return ERR_NOT_FOUND;
    7ca4:	200a      	movs	r0, #10
    7ca6:	4240      	negs	r0, r0
    7ca8:	e7f8      	b.n	7c9c <cdcdf_acm_req+0x30>
		return ERR_NOT_FOUND;
    7caa:	200a      	movs	r0, #10
    7cac:	4240      	negs	r0, r0
    7cae:	e7f5      	b.n	7c9c <cdcdf_acm_req+0x30>
    7cb0:	20000834 	.word	0x20000834
    7cb4:	00007bbd 	.word	0x00007bbd
    7cb8:	00007b81 	.word	0x00007b81

00007cbc <cdcdf_acm_enable>:
{
    7cbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7cbe:	46ce      	mov	lr, r9
    7cc0:	4647      	mov	r7, r8
    7cc2:	b580      	push	{r7, lr}
    7cc4:	000e      	movs	r6, r1
	struct cdcdf_acm_func_data *func_data = (struct cdcdf_acm_func_data *)(drv->func_data);
    7cc6:	6887      	ldr	r7, [r0, #8]
	ifc = desc->sod;
    7cc8:	6808      	ldr	r0, [r1, #0]
	for (i = 0; i < 2; i++) {
    7cca:	2300      	movs	r3, #0
    7ccc:	4698      	mov	r8, r3
    7cce:	4643      	mov	r3, r8
    7cd0:	2b01      	cmp	r3, #1
    7cd2:	d845      	bhi.n	7d60 <cdcdf_acm_enable+0xa4>
		if (NULL == ifc) {
    7cd4:	2800      	cmp	r0, #0
    7cd6:	d04b      	beq.n	7d70 <cdcdf_acm_enable+0xb4>
		ifc_desc.bInterfaceNumber = ifc[2];
    7cd8:	7883      	ldrb	r3, [r0, #2]
		ifc_desc.bInterfaceClass  = ifc[5];
    7cda:	7942      	ldrb	r2, [r0, #5]
		if ((CDC_CLASS_COMM == ifc_desc.bInterfaceClass) || (CDC_CLASS_DATA == ifc_desc.bInterfaceClass)) {
    7cdc:	2a02      	cmp	r2, #2
    7cde:	d001      	beq.n	7ce4 <cdcdf_acm_enable+0x28>
    7ce0:	2a0a      	cmp	r2, #10
    7ce2:	d148      	bne.n	7d76 <cdcdf_acm_enable+0xba>
			if (func_data->func_iface[i] == ifc_desc.bInterfaceNumber) { // Initialized
    7ce4:	46c1      	mov	r9, r8
    7ce6:	4642      	mov	r2, r8
    7ce8:	5cba      	ldrb	r2, [r7, r2]
    7cea:	4293      	cmp	r3, r2
    7cec:	d046      	beq.n	7d7c <cdcdf_acm_enable+0xc0>
			} else if (func_data->func_iface[i] != 0xFF) { // Occupied
    7cee:	2aff      	cmp	r2, #255	; 0xff
    7cf0:	d147      	bne.n	7d82 <cdcdf_acm_enable+0xc6>
				func_data->func_iface[i] = ifc_desc.bInterfaceNumber;
    7cf2:	4642      	mov	r2, r8
    7cf4:	54bb      	strb	r3, [r7, r2]
		ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    7cf6:	2205      	movs	r2, #5
    7cf8:	6871      	ldr	r1, [r6, #4]
    7cfa:	4b25      	ldr	r3, [pc, #148]	; (7d90 <cdcdf_acm_enable+0xd4>)
    7cfc:	4798      	blx	r3
    7cfe:	0004      	movs	r4, r0
		while (NULL != ep) {
    7d00:	e00c      	b.n	7d1c <cdcdf_acm_enable+0x60>
				func_data->func_ep_in[i] = ep_desc.bEndpointAddress;
    7d02:	464b      	mov	r3, r9
    7d04:	18fb      	adds	r3, r7, r3
    7d06:	709d      	strb	r5, [r3, #2]
				usb_d_ep_enable(func_data->func_ep_in[i]);
    7d08:	0028      	movs	r0, r5
    7d0a:	4b22      	ldr	r3, [pc, #136]	; (7d94 <cdcdf_acm_enable+0xd8>)
    7d0c:	4798      	blx	r3
			desc->sod = ep;
    7d0e:	6034      	str	r4, [r6, #0]
 *  \param[in] desc Byte pointer to the descriptor start address
 *  \return descriptor length
 */
static inline uint8_t usb_desc_len(const uint8_t *desc)
{
	return desc[0];
    7d10:	7820      	ldrb	r0, [r4, #0]
 *  \param[in] desc Byte pointer to the descriptor start address
 *  \return Byte pointer to the next descriptor
 */
static inline uint8_t *usb_desc_next(uint8_t *desc)
{
	return (desc + usb_desc_len(desc));
    7d12:	1820      	adds	r0, r4, r0
			ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    7d14:	6871      	ldr	r1, [r6, #4]
    7d16:	4b20      	ldr	r3, [pc, #128]	; (7d98 <cdcdf_acm_enable+0xdc>)
    7d18:	4798      	blx	r3
    7d1a:	0004      	movs	r4, r0
		while (NULL != ep) {
    7d1c:	2c00      	cmp	r4, #0
    7d1e:	d013      	beq.n	7d48 <cdcdf_acm_enable+0x8c>
			ep_desc.bEndpointAddress = ep[2];
    7d20:	78a5      	ldrb	r5, [r4, #2]
			ep_desc.bmAttributes     = ep[3];
    7d22:	78e1      	ldrb	r1, [r4, #3]
	return (ptr[0] + (ptr[1] << 8));
    7d24:	7922      	ldrb	r2, [r4, #4]
    7d26:	7963      	ldrb	r3, [r4, #5]
    7d28:	021b      	lsls	r3, r3, #8
    7d2a:	18d2      	adds	r2, r2, r3
    7d2c:	b292      	uxth	r2, r2
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    7d2e:	0028      	movs	r0, r5
    7d30:	4b1a      	ldr	r3, [pc, #104]	; (7d9c <cdcdf_acm_enable+0xe0>)
    7d32:	4798      	blx	r3
    7d34:	2800      	cmp	r0, #0
    7d36:	d127      	bne.n	7d88 <cdcdf_acm_enable+0xcc>
			if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    7d38:	b26b      	sxtb	r3, r5
    7d3a:	2b00      	cmp	r3, #0
    7d3c:	dbe1      	blt.n	7d02 <cdcdf_acm_enable+0x46>
				func_data->func_ep_out = ep_desc.bEndpointAddress;
    7d3e:	713d      	strb	r5, [r7, #4]
				usb_d_ep_enable(func_data->func_ep_out);
    7d40:	0028      	movs	r0, r5
    7d42:	4b14      	ldr	r3, [pc, #80]	; (7d94 <cdcdf_acm_enable+0xd8>)
    7d44:	4798      	blx	r3
    7d46:	e7e2      	b.n	7d0e <cdcdf_acm_enable+0x52>
		ifc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_INTERFACE);
    7d48:	6830      	ldr	r0, [r6, #0]
	return desc[0];
    7d4a:	7803      	ldrb	r3, [r0, #0]
	return (desc + usb_desc_len(desc));
    7d4c:	18c0      	adds	r0, r0, r3
    7d4e:	2204      	movs	r2, #4
    7d50:	6871      	ldr	r1, [r6, #4]
    7d52:	4b0f      	ldr	r3, [pc, #60]	; (7d90 <cdcdf_acm_enable+0xd4>)
    7d54:	4798      	blx	r3
	for (i = 0; i < 2; i++) {
    7d56:	4643      	mov	r3, r8
    7d58:	3301      	adds	r3, #1
    7d5a:	b2db      	uxtb	r3, r3
    7d5c:	4698      	mov	r8, r3
    7d5e:	e7b6      	b.n	7cce <cdcdf_acm_enable+0x12>
	_cdcdf_acm_funcd.enabled = true;
    7d60:	2201      	movs	r2, #1
    7d62:	4b0f      	ldr	r3, [pc, #60]	; (7da0 <cdcdf_acm_enable+0xe4>)
    7d64:	755a      	strb	r2, [r3, #21]
	return ERR_NONE;
    7d66:	2000      	movs	r0, #0
}
    7d68:	bc0c      	pop	{r2, r3}
    7d6a:	4690      	mov	r8, r2
    7d6c:	4699      	mov	r9, r3
    7d6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return ERR_NOT_FOUND;
    7d70:	200a      	movs	r0, #10
    7d72:	4240      	negs	r0, r0
    7d74:	e7f8      	b.n	7d68 <cdcdf_acm_enable+0xac>
			return ERR_NOT_FOUND;
    7d76:	200a      	movs	r0, #10
    7d78:	4240      	negs	r0, r0
    7d7a:	e7f5      	b.n	7d68 <cdcdf_acm_enable+0xac>
				return ERR_ALREADY_INITIALIZED;
    7d7c:	2012      	movs	r0, #18
    7d7e:	4240      	negs	r0, r0
    7d80:	e7f2      	b.n	7d68 <cdcdf_acm_enable+0xac>
				return ERR_NO_RESOURCE;
    7d82:	201c      	movs	r0, #28
    7d84:	4240      	negs	r0, r0
    7d86:	e7ef      	b.n	7d68 <cdcdf_acm_enable+0xac>
				return ERR_NOT_INITIALIZED;
    7d88:	2014      	movs	r0, #20
    7d8a:	4240      	negs	r0, r0
    7d8c:	e7ec      	b.n	7d68 <cdcdf_acm_enable+0xac>
    7d8e:	46c0      	nop			; (mov r8, r8)
    7d90:	00008bd1 	.word	0x00008bd1
    7d94:	00002495 	.word	0x00002495
    7d98:	00008bef 	.word	0x00008bef
    7d9c:	00002401 	.word	0x00002401
    7da0:	20000834 	.word	0x20000834

00007da4 <cdcdf_acm_disable>:
{
    7da4:	b570      	push	{r4, r5, r6, lr}
	struct cdcdf_acm_func_data *func_data = (struct cdcdf_acm_func_data *)(drv->func_data);
    7da6:	6885      	ldr	r5, [r0, #8]
	if (desc) {
    7da8:	2900      	cmp	r1, #0
    7daa:	d01a      	beq.n	7de2 <cdcdf_acm_disable+0x3e>
		ifc_desc.bInterfaceClass = desc->sod[5];
    7dac:	680b      	ldr	r3, [r1, #0]
    7dae:	795b      	ldrb	r3, [r3, #5]
		if ((ifc_desc.bInterfaceClass != CDC_CLASS_COMM) && (ifc_desc.bInterfaceClass != CDC_CLASS_DATA)) {
    7db0:	2b02      	cmp	r3, #2
    7db2:	d018      	beq.n	7de6 <cdcdf_acm_disable+0x42>
    7db4:	2b0a      	cmp	r3, #10
    7db6:	d124      	bne.n	7e02 <cdcdf_acm_disable+0x5e>
    7db8:	2400      	movs	r4, #0
    7dba:	e001      	b.n	7dc0 <cdcdf_acm_disable+0x1c>
	for (i = 0; i < 2; i++) {
    7dbc:	3401      	adds	r4, #1
    7dbe:	b2e4      	uxtb	r4, r4
    7dc0:	2c01      	cmp	r4, #1
    7dc2:	d812      	bhi.n	7dea <cdcdf_acm_disable+0x46>
		if (func_data->func_iface[i] == 0xFF) {
    7dc4:	5d2b      	ldrb	r3, [r5, r4]
    7dc6:	2bff      	cmp	r3, #255	; 0xff
    7dc8:	d0f8      	beq.n	7dbc <cdcdf_acm_disable+0x18>
			func_data->func_iface[i] = 0xFF;
    7dca:	23ff      	movs	r3, #255	; 0xff
    7dcc:	552b      	strb	r3, [r5, r4]
			if (func_data->func_ep_in[i] != 0xFF) {
    7dce:	192b      	adds	r3, r5, r4
    7dd0:	7898      	ldrb	r0, [r3, #2]
    7dd2:	28ff      	cmp	r0, #255	; 0xff
    7dd4:	d0f2      	beq.n	7dbc <cdcdf_acm_disable+0x18>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
    7dd6:	4b0c      	ldr	r3, [pc, #48]	; (7e08 <cdcdf_acm_disable+0x64>)
    7dd8:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
    7dda:	192e      	adds	r6, r5, r4
    7ddc:	22ff      	movs	r2, #255	; 0xff
    7dde:	70b2      	strb	r2, [r6, #2]
    7de0:	e7ec      	b.n	7dbc <cdcdf_acm_disable+0x18>
    7de2:	2400      	movs	r4, #0
    7de4:	e7ec      	b.n	7dc0 <cdcdf_acm_disable+0x1c>
    7de6:	2400      	movs	r4, #0
    7de8:	e7ea      	b.n	7dc0 <cdcdf_acm_disable+0x1c>
	if (func_data->func_ep_out != 0xFF) {
    7dea:	7928      	ldrb	r0, [r5, #4]
    7dec:	28ff      	cmp	r0, #255	; 0xff
    7dee:	d003      	beq.n	7df8 <cdcdf_acm_disable+0x54>
		usb_d_ep_deinit(func_data->func_ep_out);
    7df0:	4b05      	ldr	r3, [pc, #20]	; (7e08 <cdcdf_acm_disable+0x64>)
    7df2:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    7df4:	23ff      	movs	r3, #255	; 0xff
    7df6:	712b      	strb	r3, [r5, #4]
	_cdcdf_acm_funcd.enabled = false;
    7df8:	2200      	movs	r2, #0
    7dfa:	4b04      	ldr	r3, [pc, #16]	; (7e0c <cdcdf_acm_disable+0x68>)
    7dfc:	755a      	strb	r2, [r3, #21]
	return ERR_NONE;
    7dfe:	2000      	movs	r0, #0
}
    7e00:	bd70      	pop	{r4, r5, r6, pc}
			return ERR_NOT_FOUND;
    7e02:	200a      	movs	r0, #10
    7e04:	4240      	negs	r0, r0
    7e06:	e7fb      	b.n	7e00 <cdcdf_acm_disable+0x5c>
    7e08:	00002469 	.word	0x00002469
    7e0c:	20000834 	.word	0x20000834

00007e10 <cdcdf_acm_ctrl>:
{
    7e10:	b510      	push	{r4, lr}
	switch (ctrl) {
    7e12:	2901      	cmp	r1, #1
    7e14:	d00a      	beq.n	7e2c <cdcdf_acm_ctrl+0x1c>
    7e16:	2900      	cmp	r1, #0
    7e18:	d004      	beq.n	7e24 <cdcdf_acm_ctrl+0x14>
    7e1a:	2902      	cmp	r1, #2
    7e1c:	d10a      	bne.n	7e34 <cdcdf_acm_ctrl+0x24>
		return ERR_UNSUPPORTED_OP;
    7e1e:	201b      	movs	r0, #27
    7e20:	4240      	negs	r0, r0
}
    7e22:	bd10      	pop	{r4, pc}
		return cdcdf_acm_enable(drv, (struct usbd_descriptors *)param);
    7e24:	0011      	movs	r1, r2
    7e26:	4b05      	ldr	r3, [pc, #20]	; (7e3c <cdcdf_acm_ctrl+0x2c>)
    7e28:	4798      	blx	r3
    7e2a:	e7fa      	b.n	7e22 <cdcdf_acm_ctrl+0x12>
		return cdcdf_acm_disable(drv, (struct usbd_descriptors *)param);
    7e2c:	0011      	movs	r1, r2
    7e2e:	4b04      	ldr	r3, [pc, #16]	; (7e40 <cdcdf_acm_ctrl+0x30>)
    7e30:	4798      	blx	r3
    7e32:	e7f6      	b.n	7e22 <cdcdf_acm_ctrl+0x12>
		return ERR_INVALID_ARG;
    7e34:	200d      	movs	r0, #13
    7e36:	4240      	negs	r0, r0
    7e38:	e7f3      	b.n	7e22 <cdcdf_acm_ctrl+0x12>
    7e3a:	46c0      	nop			; (mov r8, r8)
    7e3c:	00007cbd 	.word	0x00007cbd
    7e40:	00007da5 	.word	0x00007da5

00007e44 <cdcdf_acm_init>:

/**
 * \brief Initialize the USB CDC ACM Function Driver
 */
int32_t cdcdf_acm_init(void)
{
    7e44:	b510      	push	{r4, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    7e46:	4b0b      	ldr	r3, [pc, #44]	; (7e74 <cdcdf_acm_init+0x30>)
    7e48:	4798      	blx	r3
    7e4a:	2801      	cmp	r0, #1
    7e4c:	d80e      	bhi.n	7e6c <cdcdf_acm_init+0x28>
		return ERR_DENIED;
	}

	_cdcdf_acm.ctrl      = cdcdf_acm_ctrl;
    7e4e:	480a      	ldr	r0, [pc, #40]	; (7e78 <cdcdf_acm_init+0x34>)
    7e50:	4b0a      	ldr	r3, [pc, #40]	; (7e7c <cdcdf_acm_init+0x38>)
    7e52:	61c3      	str	r3, [r0, #28]
	_cdcdf_acm.func_data = &_cdcdf_acm_funcd;
    7e54:	0003      	movs	r3, r0
    7e56:	3310      	adds	r3, #16
    7e58:	6203      	str	r3, [r0, #32]

	usbdc_register_function(&_cdcdf_acm);
    7e5a:	3018      	adds	r0, #24
    7e5c:	4b08      	ldr	r3, [pc, #32]	; (7e80 <cdcdf_acm_init+0x3c>)
    7e5e:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &cdcdf_acm_req_h);
    7e60:	4908      	ldr	r1, [pc, #32]	; (7e84 <cdcdf_acm_init+0x40>)
    7e62:	2001      	movs	r0, #1
    7e64:	4b08      	ldr	r3, [pc, #32]	; (7e88 <cdcdf_acm_init+0x44>)
    7e66:	4798      	blx	r3
	return ERR_NONE;
    7e68:	2000      	movs	r0, #0
}
    7e6a:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
    7e6c:	2011      	movs	r0, #17
    7e6e:	4240      	negs	r0, r0
    7e70:	e7fb      	b.n	7e6a <cdcdf_acm_init+0x26>
    7e72:	46c0      	nop			; (mov r8, r8)
    7e74:	00008bc1 	.word	0x00008bc1
    7e78:	20000834 	.word	0x20000834
    7e7c:	00007e11 	.word	0x00007e11
    7e80:	00008b59 	.word	0x00008b59
    7e84:	2000000c 	.word	0x2000000c
    7e88:	00008ac1 	.word	0x00008ac1

00007e8c <hid_keyboard_get_desc>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t hid_keyboard_get_desc(uint8_t ep, struct usb_req *req)
{
    7e8c:	b510      	push	{r4, lr}
	switch (req->wValue >> 8) {
    7e8e:	78cb      	ldrb	r3, [r1, #3]
    7e90:	2b21      	cmp	r3, #33	; 0x21
    7e92:	d004      	beq.n	7e9e <hid_keyboard_get_desc+0x12>
    7e94:	2b22      	cmp	r3, #34	; 0x22
    7e96:	d009      	beq.n	7eac <hid_keyboard_get_desc+0x20>
	case USB_DT_HID:
		return usbdc_xfer(ep, _hiddf_keyboard_funcd.hid_desc, _hiddf_keyboard_funcd.hid_desc[0], false);
	case USB_DT_HID_REPORT:
		return usbdc_xfer(ep, (uint8_t *)keyboard_report_desc, KEYBOARD_REPORT_DESC_LEN, false);
	default:
		return ERR_INVALID_ARG;
    7e98:	200d      	movs	r0, #13
    7e9a:	4240      	negs	r0, r0
    7e9c:	e005      	b.n	7eaa <hid_keyboard_get_desc+0x1e>
		return usbdc_xfer(ep, _hiddf_keyboard_funcd.hid_desc, _hiddf_keyboard_funcd.hid_desc[0], false);
    7e9e:	4b06      	ldr	r3, [pc, #24]	; (7eb8 <hid_keyboard_get_desc+0x2c>)
    7ea0:	6819      	ldr	r1, [r3, #0]
    7ea2:	780a      	ldrb	r2, [r1, #0]
    7ea4:	2300      	movs	r3, #0
    7ea6:	4c05      	ldr	r4, [pc, #20]	; (7ebc <hid_keyboard_get_desc+0x30>)
    7ea8:	47a0      	blx	r4
	}
}
    7eaa:	bd10      	pop	{r4, pc}
		return usbdc_xfer(ep, (uint8_t *)keyboard_report_desc, KEYBOARD_REPORT_DESC_LEN, false);
    7eac:	2300      	movs	r3, #0
    7eae:	223b      	movs	r2, #59	; 0x3b
    7eb0:	4903      	ldr	r1, [pc, #12]	; (7ec0 <hid_keyboard_get_desc+0x34>)
    7eb2:	4c02      	ldr	r4, [pc, #8]	; (7ebc <hid_keyboard_get_desc+0x30>)
    7eb4:	47a0      	blx	r4
    7eb6:	e7f8      	b.n	7eaa <hid_keyboard_get_desc+0x1e>
    7eb8:	20000858 	.word	0x20000858
    7ebc:	00008629 	.word	0x00008629
    7ec0:	0000ec2c 	.word	0x0000ec2c

00007ec4 <hid_keyboard_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t hid_keyboard_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    7ec4:	b510      	push	{r4, lr}
	if ((0x81 == req->bmRequestType) && (0x06 == req->bRequest) && (req->wIndex == _hiddf_keyboard_funcd.func_iface)) {
    7ec6:	780b      	ldrb	r3, [r1, #0]
    7ec8:	2b81      	cmp	r3, #129	; 0x81
    7eca:	d014      	beq.n	7ef6 <hid_keyboard_req+0x32>
		return hid_keyboard_get_desc(ep, req);
	} else {
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    7ecc:	095b      	lsrs	r3, r3, #5
    7ece:	2203      	movs	r2, #3
    7ed0:	4013      	ands	r3, r2
    7ed2:	2b01      	cmp	r3, #1
    7ed4:	d12d      	bne.n	7f32 <hid_keyboard_req+0x6e>
			return ERR_NOT_FOUND;
		}
		if (req->wIndex == _hiddf_keyboard_funcd.func_iface) {
    7ed6:	790a      	ldrb	r2, [r1, #4]
    7ed8:	794b      	ldrb	r3, [r1, #5]
    7eda:	021b      	lsls	r3, r3, #8
    7edc:	4313      	orrs	r3, r2
    7ede:	4a18      	ldr	r2, [pc, #96]	; (7f40 <hid_keyboard_req+0x7c>)
    7ee0:	7b12      	ldrb	r2, [r2, #12]
    7ee2:	4293      	cmp	r3, r2
    7ee4:	d128      	bne.n	7f38 <hid_keyboard_req+0x74>
			switch (req->bRequest) {
    7ee6:	784b      	ldrb	r3, [r1, #1]
    7ee8:	2b03      	cmp	r3, #3
    7eea:	d012      	beq.n	7f12 <hid_keyboard_req+0x4e>
    7eec:	2b0b      	cmp	r3, #11
    7eee:	d017      	beq.n	7f20 <hid_keyboard_req+0x5c>
				return usbdc_xfer(ep, &_hiddf_keyboard_funcd.protocol, 1, 0);
			case 0x0B: /* Set Protocol */
				_hiddf_keyboard_funcd.protocol = req->wValue;
				return usbdc_xfer(ep, NULL, 0, 0);
			default:
				return ERR_INVALID_ARG;
    7ef0:	200d      	movs	r0, #13
    7ef2:	4240      	negs	r0, r0
    7ef4:	e013      	b.n	7f1e <hid_keyboard_req+0x5a>
	if ((0x81 == req->bmRequestType) && (0x06 == req->bRequest) && (req->wIndex == _hiddf_keyboard_funcd.func_iface)) {
    7ef6:	784a      	ldrb	r2, [r1, #1]
    7ef8:	2a06      	cmp	r2, #6
    7efa:	d1e7      	bne.n	7ecc <hid_keyboard_req+0x8>
    7efc:	790c      	ldrb	r4, [r1, #4]
    7efe:	794a      	ldrb	r2, [r1, #5]
    7f00:	0212      	lsls	r2, r2, #8
    7f02:	4322      	orrs	r2, r4
    7f04:	4c0e      	ldr	r4, [pc, #56]	; (7f40 <hid_keyboard_req+0x7c>)
    7f06:	7b24      	ldrb	r4, [r4, #12]
    7f08:	42a2      	cmp	r2, r4
    7f0a:	d1df      	bne.n	7ecc <hid_keyboard_req+0x8>
		return hid_keyboard_get_desc(ep, req);
    7f0c:	4b0d      	ldr	r3, [pc, #52]	; (7f44 <hid_keyboard_req+0x80>)
    7f0e:	4798      	blx	r3
    7f10:	e005      	b.n	7f1e <hid_keyboard_req+0x5a>
				return usbdc_xfer(ep, &_hiddf_keyboard_funcd.protocol, 1, 0);
    7f12:	2300      	movs	r3, #0
    7f14:	2201      	movs	r2, #1
    7f16:	490a      	ldr	r1, [pc, #40]	; (7f40 <hid_keyboard_req+0x7c>)
    7f18:	310f      	adds	r1, #15
    7f1a:	4c0b      	ldr	r4, [pc, #44]	; (7f48 <hid_keyboard_req+0x84>)
    7f1c:	47a0      	blx	r4
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    7f1e:	bd10      	pop	{r4, pc}
				_hiddf_keyboard_funcd.protocol = req->wValue;
    7f20:	788a      	ldrb	r2, [r1, #2]
    7f22:	4b07      	ldr	r3, [pc, #28]	; (7f40 <hid_keyboard_req+0x7c>)
    7f24:	73da      	strb	r2, [r3, #15]
				return usbdc_xfer(ep, NULL, 0, 0);
    7f26:	2300      	movs	r3, #0
    7f28:	2200      	movs	r2, #0
    7f2a:	2100      	movs	r1, #0
    7f2c:	4c06      	ldr	r4, [pc, #24]	; (7f48 <hid_keyboard_req+0x84>)
    7f2e:	47a0      	blx	r4
    7f30:	e7f5      	b.n	7f1e <hid_keyboard_req+0x5a>
			return ERR_NOT_FOUND;
    7f32:	200a      	movs	r0, #10
    7f34:	4240      	negs	r0, r0
    7f36:	e7f2      	b.n	7f1e <hid_keyboard_req+0x5a>
			return ERR_NOT_FOUND;
    7f38:	200a      	movs	r0, #10
    7f3a:	4240      	negs	r0, r0
    7f3c:	e7ef      	b.n	7f1e <hid_keyboard_req+0x5a>
    7f3e:	46c0      	nop			; (mov r8, r8)
    7f40:	20000858 	.word	0x20000858
    7f44:	00007e8d 	.word	0x00007e8d
    7f48:	00008629 	.word	0x00008629

00007f4c <hid_keyboard_enable>:
{
    7f4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7f4e:	000e      	movs	r6, r1
	struct hiddf_keyboard_func_data *func_data = (struct hiddf_keyboard_func_data *)(drv->func_data);
    7f50:	6887      	ldr	r7, [r0, #8]
	ifc = desc->sod;
    7f52:	680b      	ldr	r3, [r1, #0]
	if (NULL == ifc) {
    7f54:	2b00      	cmp	r3, #0
    7f56:	d03f      	beq.n	7fd8 <hid_keyboard_enable+0x8c>
	ifc_desc.bInterfaceNumber = ifc[2];
    7f58:	789a      	ldrb	r2, [r3, #2]
	ifc_desc.bInterfaceClass  = ifc[5];
    7f5a:	795b      	ldrb	r3, [r3, #5]
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    7f5c:	2b03      	cmp	r3, #3
    7f5e:	d13e      	bne.n	7fde <hid_keyboard_enable+0x92>
		if (func_data->func_iface == ifc_desc.bInterfaceNumber) { // Initialized
    7f60:	7b3b      	ldrb	r3, [r7, #12]
    7f62:	429a      	cmp	r2, r3
    7f64:	d03e      	beq.n	7fe4 <hid_keyboard_enable+0x98>
		} else if (func_data->func_iface != 0xFF) { // Occupied
    7f66:	2bff      	cmp	r3, #255	; 0xff
    7f68:	d13f      	bne.n	7fea <hid_keyboard_enable+0x9e>
			func_data->func_iface = ifc_desc.bInterfaceNumber;
    7f6a:	733a      	strb	r2, [r7, #12]
	_hiddf_keyboard_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    7f6c:	6808      	ldr	r0, [r1, #0]
	return desc[0];
    7f6e:	7803      	ldrb	r3, [r0, #0]
	return (desc + usb_desc_len(desc));
    7f70:	18c0      	adds	r0, r0, r3
    7f72:	2221      	movs	r2, #33	; 0x21
    7f74:	6849      	ldr	r1, [r1, #4]
    7f76:	4b21      	ldr	r3, [pc, #132]	; (7ffc <hid_keyboard_enable+0xb0>)
    7f78:	4798      	blx	r3
    7f7a:	4b21      	ldr	r3, [pc, #132]	; (8000 <hid_keyboard_enable+0xb4>)
    7f7c:	6018      	str	r0, [r3, #0]
	for (i = 0; i < 2; i++) {
    7f7e:	2400      	movs	r4, #0
    7f80:	e005      	b.n	7f8e <hid_keyboard_enable+0x42>
				func_data->func_ep_in = ep_desc.bEndpointAddress;
    7f82:	737d      	strb	r5, [r7, #13]
				usb_d_ep_enable(func_data->func_ep_in);
    7f84:	0028      	movs	r0, r5
    7f86:	4b1f      	ldr	r3, [pc, #124]	; (8004 <hid_keyboard_enable+0xb8>)
    7f88:	4798      	blx	r3
	for (i = 0; i < 2; i++) {
    7f8a:	3401      	adds	r4, #1
    7f8c:	b2e4      	uxtb	r4, r4
    7f8e:	2c01      	cmp	r4, #1
    7f90:	d81c      	bhi.n	7fcc <hid_keyboard_enable+0x80>
		ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    7f92:	6830      	ldr	r0, [r6, #0]
	return desc[0];
    7f94:	7803      	ldrb	r3, [r0, #0]
	return (desc + usb_desc_len(desc));
    7f96:	18c0      	adds	r0, r0, r3
    7f98:	6871      	ldr	r1, [r6, #4]
    7f9a:	4b1b      	ldr	r3, [pc, #108]	; (8008 <hid_keyboard_enable+0xbc>)
    7f9c:	4798      	blx	r3
		desc->sod = ep;
    7f9e:	6030      	str	r0, [r6, #0]
		if (NULL != ep) {
    7fa0:	2800      	cmp	r0, #0
    7fa2:	d025      	beq.n	7ff0 <hid_keyboard_enable+0xa4>
			ep_desc.bEndpointAddress = ep[2];
    7fa4:	7885      	ldrb	r5, [r0, #2]
			ep_desc.bmAttributes     = ep[3];
    7fa6:	78c1      	ldrb	r1, [r0, #3]
	return (ptr[0] + (ptr[1] << 8));
    7fa8:	7902      	ldrb	r2, [r0, #4]
    7faa:	7943      	ldrb	r3, [r0, #5]
    7fac:	021b      	lsls	r3, r3, #8
    7fae:	18d2      	adds	r2, r2, r3
    7fb0:	b292      	uxth	r2, r2
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    7fb2:	0028      	movs	r0, r5
    7fb4:	4b15      	ldr	r3, [pc, #84]	; (800c <hid_keyboard_enable+0xc0>)
    7fb6:	4798      	blx	r3
    7fb8:	2800      	cmp	r0, #0
    7fba:	d11c      	bne.n	7ff6 <hid_keyboard_enable+0xaa>
			if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    7fbc:	b26b      	sxtb	r3, r5
    7fbe:	2b00      	cmp	r3, #0
    7fc0:	dbdf      	blt.n	7f82 <hid_keyboard_enable+0x36>
				func_data->func_ep_out = ep_desc.bEndpointAddress;
    7fc2:	73bd      	strb	r5, [r7, #14]
				usb_d_ep_enable(func_data->func_ep_out);
    7fc4:	0028      	movs	r0, r5
    7fc6:	4b0f      	ldr	r3, [pc, #60]	; (8004 <hid_keyboard_enable+0xb8>)
    7fc8:	4798      	blx	r3
    7fca:	e7de      	b.n	7f8a <hid_keyboard_enable+0x3e>
	_hiddf_keyboard_funcd.protocol = 1;
    7fcc:	4b0c      	ldr	r3, [pc, #48]	; (8000 <hid_keyboard_enable+0xb4>)
    7fce:	2201      	movs	r2, #1
    7fd0:	73da      	strb	r2, [r3, #15]
	_hiddf_keyboard_funcd.enabled  = true;
    7fd2:	741a      	strb	r2, [r3, #16]
	return ERR_NONE;
    7fd4:	2000      	movs	r0, #0
}
    7fd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return ERR_NOT_FOUND;
    7fd8:	200a      	movs	r0, #10
    7fda:	4240      	negs	r0, r0
    7fdc:	e7fb      	b.n	7fd6 <hid_keyboard_enable+0x8a>
		return ERR_NOT_FOUND;
    7fde:	200a      	movs	r0, #10
    7fe0:	4240      	negs	r0, r0
    7fe2:	e7f8      	b.n	7fd6 <hid_keyboard_enable+0x8a>
			return ERR_ALREADY_INITIALIZED;
    7fe4:	2012      	movs	r0, #18
    7fe6:	4240      	negs	r0, r0
    7fe8:	e7f5      	b.n	7fd6 <hid_keyboard_enable+0x8a>
			return ERR_NO_RESOURCE;
    7fea:	201c      	movs	r0, #28
    7fec:	4240      	negs	r0, r0
    7fee:	e7f2      	b.n	7fd6 <hid_keyboard_enable+0x8a>
			return ERR_NOT_FOUND;
    7ff0:	200a      	movs	r0, #10
    7ff2:	4240      	negs	r0, r0
    7ff4:	e7ef      	b.n	7fd6 <hid_keyboard_enable+0x8a>
				return ERR_NOT_INITIALIZED;
    7ff6:	2014      	movs	r0, #20
    7ff8:	4240      	negs	r0, r0
    7ffa:	e7ec      	b.n	7fd6 <hid_keyboard_enable+0x8a>
    7ffc:	00008bd1 	.word	0x00008bd1
    8000:	20000858 	.word	0x20000858
    8004:	00002495 	.word	0x00002495
    8008:	00008bef 	.word	0x00008bef
    800c:	00002401 	.word	0x00002401

00008010 <hid_keyboard_disable>:
{
    8010:	b510      	push	{r4, lr}
	struct hiddf_keyboard_func_data *func_data = (struct hiddf_keyboard_func_data *)(drv->func_data);
    8012:	6884      	ldr	r4, [r0, #8]
	if (desc) {
    8014:	2900      	cmp	r1, #0
    8016:	d003      	beq.n	8020 <hid_keyboard_disable+0x10>
		ifc_desc.bInterfaceClass = desc->sod[5];
    8018:	680b      	ldr	r3, [r1, #0]
    801a:	795b      	ldrb	r3, [r3, #5]
		if (ifc_desc.bInterfaceClass != HID_CLASS) {
    801c:	2b03      	cmp	r3, #3
    801e:	d117      	bne.n	8050 <hid_keyboard_disable+0x40>
	if (func_data->func_iface != 0xFF) {
    8020:	7b23      	ldrb	r3, [r4, #12]
    8022:	2bff      	cmp	r3, #255	; 0xff
    8024:	d001      	beq.n	802a <hid_keyboard_disable+0x1a>
		func_data->func_iface = 0xFF;
    8026:	23ff      	movs	r3, #255	; 0xff
    8028:	7323      	strb	r3, [r4, #12]
	if (func_data->func_ep_in != 0xFF) {
    802a:	7b60      	ldrb	r0, [r4, #13]
    802c:	28ff      	cmp	r0, #255	; 0xff
    802e:	d003      	beq.n	8038 <hid_keyboard_disable+0x28>
		usb_d_ep_deinit(func_data->func_ep_in);
    8030:	4b09      	ldr	r3, [pc, #36]	; (8058 <hid_keyboard_disable+0x48>)
    8032:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    8034:	23ff      	movs	r3, #255	; 0xff
    8036:	7363      	strb	r3, [r4, #13]
	if (func_data->func_ep_out != 0xFF) {
    8038:	7ba0      	ldrb	r0, [r4, #14]
    803a:	28ff      	cmp	r0, #255	; 0xff
    803c:	d003      	beq.n	8046 <hid_keyboard_disable+0x36>
		usb_d_ep_deinit(func_data->func_ep_out);
    803e:	4b06      	ldr	r3, [pc, #24]	; (8058 <hid_keyboard_disable+0x48>)
    8040:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    8042:	23ff      	movs	r3, #255	; 0xff
    8044:	73a3      	strb	r3, [r4, #14]
	_hiddf_keyboard_funcd.enabled = false;
    8046:	2200      	movs	r2, #0
    8048:	4b04      	ldr	r3, [pc, #16]	; (805c <hid_keyboard_disable+0x4c>)
    804a:	741a      	strb	r2, [r3, #16]
	return ERR_NONE;
    804c:	2000      	movs	r0, #0
}
    804e:	bd10      	pop	{r4, pc}
			return ERR_NOT_FOUND;
    8050:	200a      	movs	r0, #10
    8052:	4240      	negs	r0, r0
    8054:	e7fb      	b.n	804e <hid_keyboard_disable+0x3e>
    8056:	46c0      	nop			; (mov r8, r8)
    8058:	00002469 	.word	0x00002469
    805c:	20000858 	.word	0x20000858

00008060 <hid_keyboard_ctrl>:
{
    8060:	b510      	push	{r4, lr}
	switch (ctrl) {
    8062:	2901      	cmp	r1, #1
    8064:	d00a      	beq.n	807c <hid_keyboard_ctrl+0x1c>
    8066:	2900      	cmp	r1, #0
    8068:	d004      	beq.n	8074 <hid_keyboard_ctrl+0x14>
    806a:	2902      	cmp	r1, #2
    806c:	d10a      	bne.n	8084 <hid_keyboard_ctrl+0x24>
		return ERR_UNSUPPORTED_OP;
    806e:	201b      	movs	r0, #27
    8070:	4240      	negs	r0, r0
}
    8072:	bd10      	pop	{r4, pc}
		return hid_keyboard_enable(drv, (struct usbd_descriptors *)param);
    8074:	0011      	movs	r1, r2
    8076:	4b05      	ldr	r3, [pc, #20]	; (808c <hid_keyboard_ctrl+0x2c>)
    8078:	4798      	blx	r3
    807a:	e7fa      	b.n	8072 <hid_keyboard_ctrl+0x12>
		return hid_keyboard_disable(drv, (struct usbd_descriptors *)param);
    807c:	0011      	movs	r1, r2
    807e:	4b04      	ldr	r3, [pc, #16]	; (8090 <hid_keyboard_ctrl+0x30>)
    8080:	4798      	blx	r3
    8082:	e7f6      	b.n	8072 <hid_keyboard_ctrl+0x12>
		return ERR_INVALID_ARG;
    8084:	200d      	movs	r0, #13
    8086:	4240      	negs	r0, r0
    8088:	e7f3      	b.n	8072 <hid_keyboard_ctrl+0x12>
    808a:	46c0      	nop			; (mov r8, r8)
    808c:	00007f4d 	.word	0x00007f4d
    8090:	00008011 	.word	0x00008011

00008094 <hiddf_keyboard_init>:

/**
 * \brief Initialize the USB HID Keyboard Function Driver
 */
int32_t hiddf_keyboard_init(void)
{
    8094:	b510      	push	{r4, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    8096:	4b0a      	ldr	r3, [pc, #40]	; (80c0 <hiddf_keyboard_init+0x2c>)
    8098:	4798      	blx	r3
    809a:	2801      	cmp	r0, #1
    809c:	d80c      	bhi.n	80b8 <hiddf_keyboard_init+0x24>
		return ERR_DENIED;
	}

	_hiddf_keyboard.ctrl      = hid_keyboard_ctrl;
    809e:	4809      	ldr	r0, [pc, #36]	; (80c4 <hiddf_keyboard_init+0x30>)
    80a0:	4b09      	ldr	r3, [pc, #36]	; (80c8 <hiddf_keyboard_init+0x34>)
    80a2:	6183      	str	r3, [r0, #24]
	_hiddf_keyboard.func_data = &_hiddf_keyboard_funcd;
    80a4:	61c0      	str	r0, [r0, #28]

	usbdc_register_function(&_hiddf_keyboard);
    80a6:	3014      	adds	r0, #20
    80a8:	4b08      	ldr	r3, [pc, #32]	; (80cc <hiddf_keyboard_init+0x38>)
    80aa:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &hid_keyboard_req_h);
    80ac:	4908      	ldr	r1, [pc, #32]	; (80d0 <hiddf_keyboard_init+0x3c>)
    80ae:	2001      	movs	r0, #1
    80b0:	4b08      	ldr	r3, [pc, #32]	; (80d4 <hiddf_keyboard_init+0x40>)
    80b2:	4798      	blx	r3
	return ERR_NONE;
    80b4:	2000      	movs	r0, #0
}
    80b6:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
    80b8:	2011      	movs	r0, #17
    80ba:	4240      	negs	r0, r0
    80bc:	e7fb      	b.n	80b6 <hiddf_keyboard_init+0x22>
    80be:	46c0      	nop			; (mov r8, r8)
    80c0:	00008bc1 	.word	0x00008bc1
    80c4:	20000858 	.word	0x20000858
    80c8:	00008061 	.word	0x00008061
    80cc:	00008b59 	.word	0x00008b59
    80d0:	20000014 	.word	0x20000014
    80d4:	00008ac1 	.word	0x00008ac1

000080d8 <hiddf_keyboard_is_enabled>:
/**
 * \brief Check whether HID Keyboard Function is enabled
 */
bool hiddf_keyboard_is_enabled(void)
{
	return _hiddf_keyboard_funcd.enabled;
    80d8:	4b01      	ldr	r3, [pc, #4]	; (80e0 <hiddf_keyboard_is_enabled+0x8>)
    80da:	7c18      	ldrb	r0, [r3, #16]
}
    80dc:	4770      	bx	lr
    80de:	46c0      	nop			; (mov r8, r8)
    80e0:	20000858 	.word	0x20000858

000080e4 <hiddf_keyboard_keys_state_change>:
 * \param keys_desc[]  keys_descriptor array for state changing
 * \param keys_count   total keys amount for state changing
 * \return Operation status.
 */
int32_t hiddf_keyboard_keys_state_change(struct hiddf_kb_key_descriptors keys_desc[], uint8_t keys_count)
{
    80e4:	b570      	push	{r4, r5, r6, lr}
    80e6:	0005      	movs	r5, r0
    80e8:	000c      	movs	r4, r1
	uint8_t i, j;
	uint8_t modifier_keys, regular_keys;

	if (!hiddf_keyboard_is_enabled()) {
    80ea:	4b25      	ldr	r3, [pc, #148]	; (8180 <hiddf_keyboard_keys_state_change+0x9c>)
    80ec:	4798      	blx	r3
    80ee:	2800      	cmp	r0, #0
    80f0:	d043      	beq.n	817a <hiddf_keyboard_keys_state_change+0x96>
		return ERR_DENIED;
	}

	memset(_hiddf_keyboard_funcd.kb_report, 0x00, 8);
    80f2:	2208      	movs	r2, #8
    80f4:	2100      	movs	r1, #0
    80f6:	4823      	ldr	r0, [pc, #140]	; (8184 <hiddf_keyboard_keys_state_change+0xa0>)
    80f8:	3004      	adds	r0, #4
    80fa:	4b23      	ldr	r3, [pc, #140]	; (8188 <hiddf_keyboard_keys_state_change+0xa4>)
    80fc:	4798      	blx	r3
	modifier_keys = 0;
    80fe:	2100      	movs	r1, #0

	for (i = 0; i < keys_count; i++) {
    8100:	2300      	movs	r3, #0
    8102:	e001      	b.n	8108 <hiddf_keyboard_keys_state_change+0x24>
    8104:	3301      	adds	r3, #1
    8106:	b2db      	uxtb	r3, r3
    8108:	42a3      	cmp	r3, r4
    810a:	d208      	bcs.n	811e <hiddf_keyboard_keys_state_change+0x3a>
		if (true == keys_desc[i].b_modifier) {
    810c:	005a      	lsls	r2, r3, #1
    810e:	18d2      	adds	r2, r2, r3
    8110:	18aa      	adds	r2, r5, r2
    8112:	7852      	ldrb	r2, [r2, #1]
    8114:	2a00      	cmp	r2, #0
    8116:	d0f5      	beq.n	8104 <hiddf_keyboard_keys_state_change+0x20>
			modifier_keys++;
    8118:	3101      	adds	r1, #1
    811a:	b2c9      	uxtb	r1, r1
    811c:	e7f2      	b.n	8104 <hiddf_keyboard_keys_state_change+0x20>
		}
	}

	regular_keys = keys_count - modifier_keys;
    811e:	1a61      	subs	r1, r4, r1
    8120:	b2c9      	uxtb	r1, r1

	if (regular_keys > 6) {
    8122:	2906      	cmp	r1, #6
    8124:	d802      	bhi.n	812c <hiddf_keyboard_keys_state_change+0x48>
    8126:	2300      	movs	r3, #0
    8128:	2002      	movs	r0, #2
    812a:	e015      	b.n	8158 <hiddf_keyboard_keys_state_change+0x74>
		memset(&_hiddf_keyboard_funcd.kb_report[2], 0xFF, 6);
    812c:	2206      	movs	r2, #6
    812e:	21ff      	movs	r1, #255	; 0xff
    8130:	4814      	ldr	r0, [pc, #80]	; (8184 <hiddf_keyboard_keys_state_change+0xa0>)
    8132:	3006      	adds	r0, #6
    8134:	4b14      	ldr	r3, [pc, #80]	; (8188 <hiddf_keyboard_keys_state_change+0xa4>)
    8136:	4798      	blx	r3
					_hiddf_keyboard_funcd.kb_report[i++] = keys_desc[j].key_id;
				}
			}
		}
	}
	return usbdc_xfer(_hiddf_keyboard_funcd.func_ep_in, &_hiddf_keyboard_funcd.kb_report[0], 8, false);
    8138:	4b12      	ldr	r3, [pc, #72]	; (8184 <hiddf_keyboard_keys_state_change+0xa0>)
    813a:	1d19      	adds	r1, r3, #4
    813c:	7b58      	ldrb	r0, [r3, #13]
    813e:	2300      	movs	r3, #0
    8140:	2208      	movs	r2, #8
    8142:	4c12      	ldr	r4, [pc, #72]	; (818c <hiddf_keyboard_keys_state_change+0xa8>)
    8144:	47a0      	blx	r4
}
    8146:	bd70      	pop	{r4, r5, r6, pc}
					_hiddf_keyboard_funcd.kb_report[i++] = keys_desc[j].key_id;
    8148:	1c41      	adds	r1, r0, #1
    814a:	7816      	ldrb	r6, [r2, #0]
    814c:	4a0d      	ldr	r2, [pc, #52]	; (8184 <hiddf_keyboard_keys_state_change+0xa0>)
    814e:	1812      	adds	r2, r2, r0
    8150:	7116      	strb	r6, [r2, #4]
    8152:	b2c8      	uxtb	r0, r1
		for (j = 0; j < keys_count; j++) {
    8154:	3301      	adds	r3, #1
    8156:	b2db      	uxtb	r3, r3
    8158:	42a3      	cmp	r3, r4
    815a:	d2ed      	bcs.n	8138 <hiddf_keyboard_keys_state_change+0x54>
			if (HID_KB_KEY_DOWN == keys_desc[j].state) {
    815c:	005a      	lsls	r2, r3, #1
    815e:	18d2      	adds	r2, r2, r3
    8160:	18aa      	adds	r2, r5, r2
    8162:	7891      	ldrb	r1, [r2, #2]
    8164:	2901      	cmp	r1, #1
    8166:	d1f5      	bne.n	8154 <hiddf_keyboard_keys_state_change+0x70>
				if (true == keys_desc[j].b_modifier) {
    8168:	7851      	ldrb	r1, [r2, #1]
    816a:	2900      	cmp	r1, #0
    816c:	d0ec      	beq.n	8148 <hiddf_keyboard_keys_state_change+0x64>
					_hiddf_keyboard_funcd.kb_report[0] |= keys_desc[j].key_id;
    816e:	7811      	ldrb	r1, [r2, #0]
    8170:	4a04      	ldr	r2, [pc, #16]	; (8184 <hiddf_keyboard_keys_state_change+0xa0>)
    8172:	7916      	ldrb	r6, [r2, #4]
    8174:	4331      	orrs	r1, r6
    8176:	7111      	strb	r1, [r2, #4]
    8178:	e7ec      	b.n	8154 <hiddf_keyboard_keys_state_change+0x70>
		return ERR_DENIED;
    817a:	2011      	movs	r0, #17
    817c:	4240      	negs	r0, r0
    817e:	e7e2      	b.n	8146 <hiddf_keyboard_keys_state_change+0x62>
    8180:	000080d9 	.word	0x000080d9
    8184:	20000858 	.word	0x20000858
    8188:	00009555 	.word	0x00009555
    818c:	00008629 	.word	0x00008629

00008190 <hid_mouse_get_desc>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t hid_mouse_get_desc(uint8_t ep, struct usb_req *req)
{
    8190:	b510      	push	{r4, lr}
	switch (req->wValue >> 8) {
    8192:	78cb      	ldrb	r3, [r1, #3]
    8194:	2b21      	cmp	r3, #33	; 0x21
    8196:	d004      	beq.n	81a2 <hid_mouse_get_desc+0x12>
    8198:	2b22      	cmp	r3, #34	; 0x22
    819a:	d009      	beq.n	81b0 <hid_mouse_get_desc+0x20>
	case USB_DT_HID:
		return usbdc_xfer(ep, _hiddf_mouse_funcd.hid_desc, _hiddf_mouse_funcd.hid_desc[0], false);
	case USB_DT_HID_REPORT:
		return usbdc_xfer(ep, (uint8_t *)mouse_report_desc, MOUSE_REPORT_DESC_LEN, false);
	default:
		return ERR_INVALID_ARG;
    819c:	200d      	movs	r0, #13
    819e:	4240      	negs	r0, r0
    81a0:	e005      	b.n	81ae <hid_mouse_get_desc+0x1e>
		return usbdc_xfer(ep, _hiddf_mouse_funcd.hid_desc, _hiddf_mouse_funcd.hid_desc[0], false);
    81a2:	4b06      	ldr	r3, [pc, #24]	; (81bc <hid_mouse_get_desc+0x2c>)
    81a4:	6819      	ldr	r1, [r3, #0]
    81a6:	780a      	ldrb	r2, [r1, #0]
    81a8:	2300      	movs	r3, #0
    81aa:	4c05      	ldr	r4, [pc, #20]	; (81c0 <hid_mouse_get_desc+0x30>)
    81ac:	47a0      	blx	r4
	}
}
    81ae:	bd10      	pop	{r4, pc}
		return usbdc_xfer(ep, (uint8_t *)mouse_report_desc, MOUSE_REPORT_DESC_LEN, false);
    81b0:	2300      	movs	r3, #0
    81b2:	2234      	movs	r2, #52	; 0x34
    81b4:	4903      	ldr	r1, [pc, #12]	; (81c4 <hid_mouse_get_desc+0x34>)
    81b6:	4c02      	ldr	r4, [pc, #8]	; (81c0 <hid_mouse_get_desc+0x30>)
    81b8:	47a0      	blx	r4
    81ba:	e7f8      	b.n	81ae <hid_mouse_get_desc+0x1e>
    81bc:	20000878 	.word	0x20000878
    81c0:	00008629 	.word	0x00008629
    81c4:	0000ec68 	.word	0x0000ec68

000081c8 <hid_mouse_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t hid_mouse_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    81c8:	b510      	push	{r4, lr}
	if ((0x81 == req->bmRequestType) && (0x06 == req->bRequest) && (req->wIndex == _hiddf_mouse_funcd.func_iface)) {
    81ca:	780b      	ldrb	r3, [r1, #0]
    81cc:	2b81      	cmp	r3, #129	; 0x81
    81ce:	d014      	beq.n	81fa <hid_mouse_req+0x32>
		return hid_mouse_get_desc(ep, req);
	} else {
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    81d0:	095b      	lsrs	r3, r3, #5
    81d2:	2203      	movs	r2, #3
    81d4:	4013      	ands	r3, r2
    81d6:	2b01      	cmp	r3, #1
    81d8:	d12d      	bne.n	8236 <hid_mouse_req+0x6e>
			return ERR_NOT_FOUND;
		}
		if (req->wIndex == _hiddf_mouse_funcd.func_iface) {
    81da:	790a      	ldrb	r2, [r1, #4]
    81dc:	794b      	ldrb	r3, [r1, #5]
    81de:	021b      	lsls	r3, r3, #8
    81e0:	4313      	orrs	r3, r2
    81e2:	4a18      	ldr	r2, [pc, #96]	; (8244 <hid_mouse_req+0x7c>)
    81e4:	7a12      	ldrb	r2, [r2, #8]
    81e6:	4293      	cmp	r3, r2
    81e8:	d128      	bne.n	823c <hid_mouse_req+0x74>
			switch (req->bRequest) {
    81ea:	784b      	ldrb	r3, [r1, #1]
    81ec:	2b03      	cmp	r3, #3
    81ee:	d012      	beq.n	8216 <hid_mouse_req+0x4e>
    81f0:	2b0b      	cmp	r3, #11
    81f2:	d017      	beq.n	8224 <hid_mouse_req+0x5c>
				return usbdc_xfer(ep, &_hiddf_mouse_funcd.protocol, 1, 0);
			case 0x0B: /* Set Protocol */
				_hiddf_mouse_funcd.protocol = req->wValue;
				return usbdc_xfer(ep, NULL, 0, 0);
			default:
				return ERR_INVALID_ARG;
    81f4:	200d      	movs	r0, #13
    81f6:	4240      	negs	r0, r0
    81f8:	e013      	b.n	8222 <hid_mouse_req+0x5a>
	if ((0x81 == req->bmRequestType) && (0x06 == req->bRequest) && (req->wIndex == _hiddf_mouse_funcd.func_iface)) {
    81fa:	784a      	ldrb	r2, [r1, #1]
    81fc:	2a06      	cmp	r2, #6
    81fe:	d1e7      	bne.n	81d0 <hid_mouse_req+0x8>
    8200:	790c      	ldrb	r4, [r1, #4]
    8202:	794a      	ldrb	r2, [r1, #5]
    8204:	0212      	lsls	r2, r2, #8
    8206:	4322      	orrs	r2, r4
    8208:	4c0e      	ldr	r4, [pc, #56]	; (8244 <hid_mouse_req+0x7c>)
    820a:	7a24      	ldrb	r4, [r4, #8]
    820c:	42a2      	cmp	r2, r4
    820e:	d1df      	bne.n	81d0 <hid_mouse_req+0x8>
		return hid_mouse_get_desc(ep, req);
    8210:	4b0d      	ldr	r3, [pc, #52]	; (8248 <hid_mouse_req+0x80>)
    8212:	4798      	blx	r3
    8214:	e005      	b.n	8222 <hid_mouse_req+0x5a>
				return usbdc_xfer(ep, &_hiddf_mouse_funcd.protocol, 1, 0);
    8216:	2300      	movs	r3, #0
    8218:	2201      	movs	r2, #1
    821a:	490a      	ldr	r1, [pc, #40]	; (8244 <hid_mouse_req+0x7c>)
    821c:	310a      	adds	r1, #10
    821e:	4c0b      	ldr	r4, [pc, #44]	; (824c <hid_mouse_req+0x84>)
    8220:	47a0      	blx	r4
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    8222:	bd10      	pop	{r4, pc}
				_hiddf_mouse_funcd.protocol = req->wValue;
    8224:	788a      	ldrb	r2, [r1, #2]
    8226:	4b07      	ldr	r3, [pc, #28]	; (8244 <hid_mouse_req+0x7c>)
    8228:	729a      	strb	r2, [r3, #10]
				return usbdc_xfer(ep, NULL, 0, 0);
    822a:	2300      	movs	r3, #0
    822c:	2200      	movs	r2, #0
    822e:	2100      	movs	r1, #0
    8230:	4c06      	ldr	r4, [pc, #24]	; (824c <hid_mouse_req+0x84>)
    8232:	47a0      	blx	r4
    8234:	e7f5      	b.n	8222 <hid_mouse_req+0x5a>
			return ERR_NOT_FOUND;
    8236:	200a      	movs	r0, #10
    8238:	4240      	negs	r0, r0
    823a:	e7f2      	b.n	8222 <hid_mouse_req+0x5a>
			return ERR_NOT_FOUND;
    823c:	200a      	movs	r0, #10
    823e:	4240      	negs	r0, r0
    8240:	e7ef      	b.n	8222 <hid_mouse_req+0x5a>
    8242:	46c0      	nop			; (mov r8, r8)
    8244:	20000878 	.word	0x20000878
    8248:	00008191 	.word	0x00008191
    824c:	00008629 	.word	0x00008629

00008250 <hid_mouse_enable>:
{
    8250:	b570      	push	{r4, r5, r6, lr}
    8252:	000c      	movs	r4, r1
	struct hiddf_mouse_func_data *func_data = (struct hiddf_mouse_func_data *)(drv->func_data);
    8254:	6885      	ldr	r5, [r0, #8]
	ifc = desc->sod;
    8256:	680b      	ldr	r3, [r1, #0]
	if (NULL == ifc) {
    8258:	2b00      	cmp	r3, #0
    825a:	d034      	beq.n	82c6 <hid_mouse_enable+0x76>
	ifc_desc.bInterfaceNumber = ifc[2];
    825c:	789a      	ldrb	r2, [r3, #2]
	ifc_desc.bInterfaceClass  = ifc[5];
    825e:	795b      	ldrb	r3, [r3, #5]
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    8260:	2b03      	cmp	r3, #3
    8262:	d133      	bne.n	82cc <hid_mouse_enable+0x7c>
		if (func_data->func_iface == ifc_desc.bInterfaceNumber) { // Initialized
    8264:	7a2b      	ldrb	r3, [r5, #8]
    8266:	429a      	cmp	r2, r3
    8268:	d033      	beq.n	82d2 <hid_mouse_enable+0x82>
		} else if (func_data->func_iface != 0xFF) { // Occupied
    826a:	2bff      	cmp	r3, #255	; 0xff
    826c:	d134      	bne.n	82d8 <hid_mouse_enable+0x88>
			func_data->func_iface = ifc_desc.bInterfaceNumber;
    826e:	722a      	strb	r2, [r5, #8]
	_hiddf_mouse_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    8270:	6808      	ldr	r0, [r1, #0]
	return desc[0];
    8272:	7803      	ldrb	r3, [r0, #0]
	return (desc + usb_desc_len(desc));
    8274:	18c0      	adds	r0, r0, r3
    8276:	2221      	movs	r2, #33	; 0x21
    8278:	6849      	ldr	r1, [r1, #4]
    827a:	4b1d      	ldr	r3, [pc, #116]	; (82f0 <hid_mouse_enable+0xa0>)
    827c:	4798      	blx	r3
    827e:	4b1d      	ldr	r3, [pc, #116]	; (82f4 <hid_mouse_enable+0xa4>)
    8280:	6018      	str	r0, [r3, #0]
	ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    8282:	6820      	ldr	r0, [r4, #0]
	return desc[0];
    8284:	7803      	ldrb	r3, [r0, #0]
	return (desc + usb_desc_len(desc));
    8286:	18c0      	adds	r0, r0, r3
    8288:	6861      	ldr	r1, [r4, #4]
    828a:	4b1b      	ldr	r3, [pc, #108]	; (82f8 <hid_mouse_enable+0xa8>)
    828c:	4798      	blx	r3
	desc->sod = ep;
    828e:	6020      	str	r0, [r4, #0]
	if (NULL != ep) {
    8290:	2800      	cmp	r0, #0
    8292:	d024      	beq.n	82de <hid_mouse_enable+0x8e>
		ep_desc.bEndpointAddress = ep[2];
    8294:	7884      	ldrb	r4, [r0, #2]
		ep_desc.bmAttributes     = ep[3];
    8296:	78c1      	ldrb	r1, [r0, #3]
	return (ptr[0] + (ptr[1] << 8));
    8298:	7902      	ldrb	r2, [r0, #4]
    829a:	7943      	ldrb	r3, [r0, #5]
    829c:	021b      	lsls	r3, r3, #8
    829e:	18d2      	adds	r2, r2, r3
    82a0:	b292      	uxth	r2, r2
		if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    82a2:	0020      	movs	r0, r4
    82a4:	4b15      	ldr	r3, [pc, #84]	; (82fc <hid_mouse_enable+0xac>)
    82a6:	4798      	blx	r3
    82a8:	1e06      	subs	r6, r0, #0
    82aa:	d11b      	bne.n	82e4 <hid_mouse_enable+0x94>
		if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    82ac:	b263      	sxtb	r3, r4
    82ae:	2b00      	cmp	r3, #0
    82b0:	da1b      	bge.n	82ea <hid_mouse_enable+0x9a>
			func_data->func_ep_in = ep_desc.bEndpointAddress;
    82b2:	726c      	strb	r4, [r5, #9]
			usb_d_ep_enable(func_data->func_ep_in);
    82b4:	0020      	movs	r0, r4
    82b6:	4b12      	ldr	r3, [pc, #72]	; (8300 <hid_mouse_enable+0xb0>)
    82b8:	4798      	blx	r3
	_hiddf_mouse_funcd.protocol = 1;
    82ba:	4b0e      	ldr	r3, [pc, #56]	; (82f4 <hid_mouse_enable+0xa4>)
    82bc:	2201      	movs	r2, #1
    82be:	729a      	strb	r2, [r3, #10]
	_hiddf_mouse_funcd.enabled  = true;
    82c0:	72da      	strb	r2, [r3, #11]
}
    82c2:	0030      	movs	r0, r6
    82c4:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_NOT_FOUND;
    82c6:	260a      	movs	r6, #10
    82c8:	4276      	negs	r6, r6
    82ca:	e7fa      	b.n	82c2 <hid_mouse_enable+0x72>
		return ERR_NOT_FOUND;
    82cc:	260a      	movs	r6, #10
    82ce:	4276      	negs	r6, r6
    82d0:	e7f7      	b.n	82c2 <hid_mouse_enable+0x72>
			return ERR_ALREADY_INITIALIZED;
    82d2:	2612      	movs	r6, #18
    82d4:	4276      	negs	r6, r6
    82d6:	e7f4      	b.n	82c2 <hid_mouse_enable+0x72>
			return ERR_NO_RESOURCE;
    82d8:	261c      	movs	r6, #28
    82da:	4276      	negs	r6, r6
    82dc:	e7f1      	b.n	82c2 <hid_mouse_enable+0x72>
		return ERR_NOT_FOUND;
    82de:	260a      	movs	r6, #10
    82e0:	4276      	negs	r6, r6
    82e2:	e7ee      	b.n	82c2 <hid_mouse_enable+0x72>
			return ERR_NOT_INITIALIZED;
    82e4:	2614      	movs	r6, #20
    82e6:	4276      	negs	r6, r6
    82e8:	e7eb      	b.n	82c2 <hid_mouse_enable+0x72>
			return ERR_INVALID_DATA;
    82ea:	2601      	movs	r6, #1
    82ec:	4276      	negs	r6, r6
    82ee:	e7e8      	b.n	82c2 <hid_mouse_enable+0x72>
    82f0:	00008bd1 	.word	0x00008bd1
    82f4:	20000878 	.word	0x20000878
    82f8:	00008bef 	.word	0x00008bef
    82fc:	00002401 	.word	0x00002401
    8300:	00002495 	.word	0x00002495

00008304 <hid_mouse_disable>:
{
    8304:	b510      	push	{r4, lr}
	struct hiddf_mouse_func_data *func_data = (struct hiddf_mouse_func_data *)(drv->func_data);
    8306:	6884      	ldr	r4, [r0, #8]
	if (desc) {
    8308:	2900      	cmp	r1, #0
    830a:	d003      	beq.n	8314 <hid_mouse_disable+0x10>
		ifc_desc.bInterfaceClass = desc->sod[5];
    830c:	680b      	ldr	r3, [r1, #0]
    830e:	795b      	ldrb	r3, [r3, #5]
		if (ifc_desc.bInterfaceClass != HID_CLASS) {
    8310:	2b03      	cmp	r3, #3
    8312:	d110      	bne.n	8336 <hid_mouse_disable+0x32>
	if (func_data->func_iface != 0xFF) {
    8314:	7a23      	ldrb	r3, [r4, #8]
    8316:	2bff      	cmp	r3, #255	; 0xff
    8318:	d001      	beq.n	831e <hid_mouse_disable+0x1a>
		func_data->func_iface = 0xFF;
    831a:	23ff      	movs	r3, #255	; 0xff
    831c:	7223      	strb	r3, [r4, #8]
	if (func_data->func_ep_in != 0xFF) {
    831e:	7a60      	ldrb	r0, [r4, #9]
    8320:	28ff      	cmp	r0, #255	; 0xff
    8322:	d003      	beq.n	832c <hid_mouse_disable+0x28>
		usb_d_ep_deinit(func_data->func_ep_in);
    8324:	4b05      	ldr	r3, [pc, #20]	; (833c <hid_mouse_disable+0x38>)
    8326:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    8328:	23ff      	movs	r3, #255	; 0xff
    832a:	7263      	strb	r3, [r4, #9]
	_hiddf_mouse_funcd.enabled = false;
    832c:	2200      	movs	r2, #0
    832e:	4b04      	ldr	r3, [pc, #16]	; (8340 <hid_mouse_disable+0x3c>)
    8330:	72da      	strb	r2, [r3, #11]
	return ERR_NONE;
    8332:	2000      	movs	r0, #0
}
    8334:	bd10      	pop	{r4, pc}
			return ERR_NOT_FOUND;
    8336:	200a      	movs	r0, #10
    8338:	4240      	negs	r0, r0
    833a:	e7fb      	b.n	8334 <hid_mouse_disable+0x30>
    833c:	00002469 	.word	0x00002469
    8340:	20000878 	.word	0x20000878

00008344 <hid_mouse_ctrl>:
{
    8344:	b510      	push	{r4, lr}
	switch (ctrl) {
    8346:	2901      	cmp	r1, #1
    8348:	d00a      	beq.n	8360 <hid_mouse_ctrl+0x1c>
    834a:	2900      	cmp	r1, #0
    834c:	d004      	beq.n	8358 <hid_mouse_ctrl+0x14>
    834e:	2902      	cmp	r1, #2
    8350:	d10a      	bne.n	8368 <hid_mouse_ctrl+0x24>
		return ERR_UNSUPPORTED_OP;
    8352:	201b      	movs	r0, #27
    8354:	4240      	negs	r0, r0
}
    8356:	bd10      	pop	{r4, pc}
		return hid_mouse_enable(drv, (struct usbd_descriptors *)param);
    8358:	0011      	movs	r1, r2
    835a:	4b05      	ldr	r3, [pc, #20]	; (8370 <hid_mouse_ctrl+0x2c>)
    835c:	4798      	blx	r3
    835e:	e7fa      	b.n	8356 <hid_mouse_ctrl+0x12>
		return hid_mouse_disable(drv, (struct usbd_descriptors *)param);
    8360:	0011      	movs	r1, r2
    8362:	4b04      	ldr	r3, [pc, #16]	; (8374 <hid_mouse_ctrl+0x30>)
    8364:	4798      	blx	r3
    8366:	e7f6      	b.n	8356 <hid_mouse_ctrl+0x12>
		return ERR_INVALID_ARG;
    8368:	200d      	movs	r0, #13
    836a:	4240      	negs	r0, r0
    836c:	e7f3      	b.n	8356 <hid_mouse_ctrl+0x12>
    836e:	46c0      	nop			; (mov r8, r8)
    8370:	00008251 	.word	0x00008251
    8374:	00008305 	.word	0x00008305

00008378 <hiddf_mouse_init>:

/**
 * \brief Initialize the USB HID Mouse Function Driver
 */
int32_t hiddf_mouse_init(void)
{
    8378:	b510      	push	{r4, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    837a:	4b0a      	ldr	r3, [pc, #40]	; (83a4 <hiddf_mouse_init+0x2c>)
    837c:	4798      	blx	r3
    837e:	2801      	cmp	r0, #1
    8380:	d80c      	bhi.n	839c <hiddf_mouse_init+0x24>
		return ERR_DENIED;
	}

	_hiddf_mouse.ctrl      = hid_mouse_ctrl;
    8382:	4809      	ldr	r0, [pc, #36]	; (83a8 <hiddf_mouse_init+0x30>)
    8384:	4b09      	ldr	r3, [pc, #36]	; (83ac <hiddf_mouse_init+0x34>)
    8386:	6103      	str	r3, [r0, #16]
	_hiddf_mouse.func_data = &_hiddf_mouse_funcd;
    8388:	6140      	str	r0, [r0, #20]

	usbdc_register_function(&_hiddf_mouse);
    838a:	300c      	adds	r0, #12
    838c:	4b08      	ldr	r3, [pc, #32]	; (83b0 <hiddf_mouse_init+0x38>)
    838e:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &hid_mouse_req_h);
    8390:	4908      	ldr	r1, [pc, #32]	; (83b4 <hiddf_mouse_init+0x3c>)
    8392:	2001      	movs	r0, #1
    8394:	4b08      	ldr	r3, [pc, #32]	; (83b8 <hiddf_mouse_init+0x40>)
    8396:	4798      	blx	r3
	return ERR_NONE;
    8398:	2000      	movs	r0, #0
}
    839a:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
    839c:	2011      	movs	r0, #17
    839e:	4240      	negs	r0, r0
    83a0:	e7fb      	b.n	839a <hiddf_mouse_init+0x22>
    83a2:	46c0      	nop			; (mov r8, r8)
    83a4:	00008bc1 	.word	0x00008bc1
    83a8:	20000878 	.word	0x20000878
    83ac:	00008345 	.word	0x00008345
    83b0:	00008b59 	.word	0x00008b59
    83b4:	2000001c 	.word	0x2000001c
    83b8:	00008ac1 	.word	0x00008ac1

000083bc <usbdc_unconfig>:

/**
 * \brief Unconfig, close all interfaces
 */
static void usbdc_unconfig(void)
{
    83bc:	b510      	push	{r4, lr}
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
    83be:	4b06      	ldr	r3, [pc, #24]	; (83d8 <usbdc_unconfig+0x1c>)
    83c0:	691c      	ldr	r4, [r3, #16]
	while (NULL != func) {
    83c2:	e005      	b.n	83d0 <usbdc_unconfig+0x14>
		func->ctrl(func, USBDF_DISABLE, NULL);
    83c4:	2200      	movs	r2, #0
    83c6:	2101      	movs	r1, #1
    83c8:	0020      	movs	r0, r4
    83ca:	6863      	ldr	r3, [r4, #4]
    83cc:	4798      	blx	r3
		func = func->next;
    83ce:	6824      	ldr	r4, [r4, #0]
	while (NULL != func) {
    83d0:	2c00      	cmp	r4, #0
    83d2:	d1f7      	bne.n	83c4 <usbdc_unconfig+0x8>
	}
}
    83d4:	bd10      	pop	{r4, pc}
    83d6:	46c0      	nop			; (mov r8, r8)
    83d8:	20000890 	.word	0x20000890

000083dc <usbdc_sof_notify>:
	}
}

/** Invoke all registered SOF callbacks. */
static void usbdc_sof_notify(void)
{
    83dc:	b510      	push	{r4, lr}
	struct usbdc_sof_handler *sof = (struct usbdc_sof_handler *)usbdc.handlers.sof_list.head;
    83de:	4b06      	ldr	r3, [pc, #24]	; (83f8 <usbdc_sof_notify+0x1c>)
    83e0:	685c      	ldr	r4, [r3, #4]

	while (sof != NULL) {
    83e2:	e000      	b.n	83e6 <usbdc_sof_notify+0xa>
		if (NULL != sof->cb) {
			sof->cb();
		}
		sof = sof->next;
    83e4:	6824      	ldr	r4, [r4, #0]
	while (sof != NULL) {
    83e6:	2c00      	cmp	r4, #0
    83e8:	d004      	beq.n	83f4 <usbdc_sof_notify+0x18>
		if (NULL != sof->cb) {
    83ea:	6863      	ldr	r3, [r4, #4]
    83ec:	2b00      	cmp	r3, #0
    83ee:	d0f9      	beq.n	83e4 <usbdc_sof_notify+0x8>
			sof->cb();
    83f0:	4798      	blx	r3
    83f2:	e7f7      	b.n	83e4 <usbdc_sof_notify+0x8>
	}
}
    83f4:	bd10      	pop	{r4, pc}
    83f6:	46c0      	nop			; (mov r8, r8)
    83f8:	20000890 	.word	0x20000890

000083fc <usbdc_change_notify>:

/** Invoke all registered Change notification callbacks. */
static void usbdc_change_notify(enum usbdc_change_type change, uint32_t value)
{
    83fc:	b570      	push	{r4, r5, r6, lr}
    83fe:	0006      	movs	r6, r0
    8400:	000d      	movs	r5, r1
	struct usbdc_change_handler *cg = (struct usbdc_change_handler *)usbdc.handlers.change_list.head;
    8402:	4b07      	ldr	r3, [pc, #28]	; (8420 <usbdc_change_notify+0x24>)
    8404:	68dc      	ldr	r4, [r3, #12]

	while (cg != NULL) {
    8406:	e000      	b.n	840a <usbdc_change_notify+0xe>
		if (NULL != cg->cb) {
			cg->cb(change, value);
		}
		cg = cg->next;
    8408:	6824      	ldr	r4, [r4, #0]
	while (cg != NULL) {
    840a:	2c00      	cmp	r4, #0
    840c:	d006      	beq.n	841c <usbdc_change_notify+0x20>
		if (NULL != cg->cb) {
    840e:	6863      	ldr	r3, [r4, #4]
    8410:	2b00      	cmp	r3, #0
    8412:	d0f9      	beq.n	8408 <usbdc_change_notify+0xc>
			cg->cb(change, value);
    8414:	0029      	movs	r1, r5
    8416:	0030      	movs	r0, r6
    8418:	4798      	blx	r3
    841a:	e7f5      	b.n	8408 <usbdc_change_notify+0xc>
	}
}
    841c:	bd70      	pop	{r4, r5, r6, pc}
    841e:	46c0      	nop			; (mov r8, r8)
    8420:	20000890 	.word	0x20000890

00008424 <usbdc_request_handler>:

/** Invoke all registered request callbacks until request handled. */
static int32_t usbdc_request_handler(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    8424:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8426:	0007      	movs	r7, r0
    8428:	000e      	movs	r6, r1
    842a:	0015      	movs	r5, r2
	struct usbdc_req_handler *h = (struct usbdc_req_handler *)usbdc.handlers.req_list.head;
    842c:	4b0b      	ldr	r3, [pc, #44]	; (845c <usbdc_request_handler+0x38>)
    842e:	689c      	ldr	r4, [r3, #8]
	int32_t                   rc;

	while (h != NULL) {
    8430:	e000      	b.n	8434 <usbdc_request_handler+0x10>
				return true;
			} else if (ERR_NOT_FOUND != rc) {
				return -1;
			}
		}
		h = h->next;
    8432:	6824      	ldr	r4, [r4, #0]
	while (h != NULL) {
    8434:	2c00      	cmp	r4, #0
    8436:	d00d      	beq.n	8454 <usbdc_request_handler+0x30>
		if (NULL != h->cb) {
    8438:	6863      	ldr	r3, [r4, #4]
    843a:	2b00      	cmp	r3, #0
    843c:	d0f9      	beq.n	8432 <usbdc_request_handler+0xe>
			rc = h->cb(ep, req, stage);
    843e:	002a      	movs	r2, r5
    8440:	0031      	movs	r1, r6
    8442:	0038      	movs	r0, r7
    8444:	4798      	blx	r3
			if (0 == rc) {
    8446:	2800      	cmp	r0, #0
    8448:	d006      	beq.n	8458 <usbdc_request_handler+0x34>
			} else if (ERR_NOT_FOUND != rc) {
    844a:	300a      	adds	r0, #10
    844c:	d0f1      	beq.n	8432 <usbdc_request_handler+0xe>
				return -1;
    844e:	2001      	movs	r0, #1
    8450:	4240      	negs	r0, r0
    8452:	e000      	b.n	8456 <usbdc_request_handler+0x32>
	}
	return false;
    8454:	2000      	movs	r0, #0
}
    8456:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				return true;
    8458:	2001      	movs	r0, #1
    845a:	e7fc      	b.n	8456 <usbdc_request_handler+0x32>
    845c:	20000890 	.word	0x20000890

00008460 <usbd_sof_cb>:

/**
 * \brief Callback invoked on USB device SOF
 */
static void usbd_sof_cb(void)
{
    8460:	b510      	push	{r4, lr}
	usbdc_sof_notify();
    8462:	4b01      	ldr	r3, [pc, #4]	; (8468 <usbd_sof_cb+0x8>)
    8464:	4798      	blx	r3
}
    8466:	bd10      	pop	{r4, pc}
    8468:	000083dd 	.word	0x000083dd

0000846c <usbdc_ctrl_data_end>:
/**
 * \brief When control data stage is end
 * \param[in] req Pointer to the request.
 */
static bool usbdc_ctrl_data_end(struct usb_req *req)
{
    846c:	b510      	push	{r4, lr}
    846e:	0001      	movs	r1, r0
	usbdc_request_handler(0, req, USB_DATA_STAGE);
    8470:	2201      	movs	r2, #1
    8472:	2000      	movs	r0, #0
    8474:	4b01      	ldr	r3, [pc, #4]	; (847c <usbdc_ctrl_data_end+0x10>)
    8476:	4798      	blx	r3
	return false;
}
    8478:	2000      	movs	r0, #0
    847a:	bd10      	pop	{r4, pc}
    847c:	00008425 	.word	0x00008425

00008480 <usbdc_set_address>:
{
    8480:	b510      	push	{r4, lr}
	usb_d_set_address(addr);
    8482:	4b01      	ldr	r3, [pc, #4]	; (8488 <usbdc_set_address+0x8>)
    8484:	4798      	blx	r3
}
    8486:	bd10      	pop	{r4, pc}
    8488:	000023f5 	.word	0x000023f5

0000848c <usbdc_ctrl_status_end>:
{
    848c:	b510      	push	{r4, lr}
    848e:	0004      	movs	r4, r0
	if (req->bmRequestType != USB_REQT_TYPE_STANDARD) {
    8490:	7803      	ldrb	r3, [r0, #0]
    8492:	2b00      	cmp	r3, #0
    8494:	d112      	bne.n	84bc <usbdc_ctrl_status_end+0x30>
	switch (req->bRequest) {
    8496:	7843      	ldrb	r3, [r0, #1]
    8498:	2b05      	cmp	r3, #5
    849a:	d012      	beq.n	84c2 <usbdc_ctrl_status_end+0x36>
    849c:	2b09      	cmp	r3, #9
    849e:	d10d      	bne.n	84bc <usbdc_ctrl_status_end+0x30>
		usbdc.cfg_value = req->wValue;
    84a0:	7882      	ldrb	r2, [r0, #2]
    84a2:	4b10      	ldr	r3, [pc, #64]	; (84e4 <usbdc_ctrl_status_end+0x58>)
    84a4:	76da      	strb	r2, [r3, #27]
		usbdc.state     = req->wValue ? USBD_S_CONFIG : USBD_S_ADDRESS;
    84a6:	7882      	ldrb	r2, [r0, #2]
    84a8:	78c3      	ldrb	r3, [r0, #3]
    84aa:	021b      	lsls	r3, r3, #8
    84ac:	4313      	orrs	r3, r2
    84ae:	d106      	bne.n	84be <usbdc_ctrl_status_end+0x32>
    84b0:	2103      	movs	r1, #3
    84b2:	4b0c      	ldr	r3, [pc, #48]	; (84e4 <usbdc_ctrl_status_end+0x58>)
    84b4:	7699      	strb	r1, [r3, #26]
		usbdc_change_notify(USBDC_C_STATE, usbdc.state);
    84b6:	2001      	movs	r0, #1
    84b8:	4b0b      	ldr	r3, [pc, #44]	; (84e8 <usbdc_ctrl_status_end+0x5c>)
    84ba:	4798      	blx	r3
}
    84bc:	bd10      	pop	{r4, pc}
		usbdc.state     = req->wValue ? USBD_S_CONFIG : USBD_S_ADDRESS;
    84be:	2104      	movs	r1, #4
    84c0:	e7f7      	b.n	84b2 <usbdc_ctrl_status_end+0x26>
		usbdc_set_address(req->wValue);
    84c2:	7880      	ldrb	r0, [r0, #2]
    84c4:	4b09      	ldr	r3, [pc, #36]	; (84ec <usbdc_ctrl_status_end+0x60>)
    84c6:	4798      	blx	r3
		usbdc.state = req->wValue ? USBD_S_ADDRESS : USBD_S_DEFAULT;
    84c8:	78a2      	ldrb	r2, [r4, #2]
    84ca:	78e3      	ldrb	r3, [r4, #3]
    84cc:	021b      	lsls	r3, r3, #8
    84ce:	4313      	orrs	r3, r2
    84d0:	d006      	beq.n	84e0 <usbdc_ctrl_status_end+0x54>
    84d2:	2103      	movs	r1, #3
    84d4:	4b03      	ldr	r3, [pc, #12]	; (84e4 <usbdc_ctrl_status_end+0x58>)
    84d6:	7699      	strb	r1, [r3, #26]
		usbdc_change_notify(USBDC_C_STATE, usbdc.state);
    84d8:	2001      	movs	r0, #1
    84da:	4b03      	ldr	r3, [pc, #12]	; (84e8 <usbdc_ctrl_status_end+0x5c>)
    84dc:	4798      	blx	r3
		break;
    84de:	e7ed      	b.n	84bc <usbdc_ctrl_status_end+0x30>
		usbdc.state = req->wValue ? USBD_S_ADDRESS : USBD_S_DEFAULT;
    84e0:	2102      	movs	r1, #2
    84e2:	e7f7      	b.n	84d4 <usbdc_ctrl_status_end+0x48>
    84e4:	20000890 	.word	0x20000890
    84e8:	000083fd 	.word	0x000083fd
    84ec:	00008481 	.word	0x00008481

000084f0 <usbdc_cb_ctl_done>:
 * \return Data has error or not.
 * \retval true There is data error, protocol error.
 * \retval false There is no data error.
 */
static bool usbdc_cb_ctl_done(const uint8_t ep, const enum usb_xfer_code code, struct usb_req *req)
{
    84f0:	b510      	push	{r4, lr}
	(void)ep;

	switch (code) {
    84f2:	2900      	cmp	r1, #0
    84f4:	d003      	beq.n	84fe <usbdc_cb_ctl_done+0xe>
    84f6:	2901      	cmp	r1, #1
    84f8:	d006      	beq.n	8508 <usbdc_cb_ctl_done+0x18>
	case USB_XFER_DATA:
		return usbdc_ctrl_data_end(req);
	default:
		break;
	}
	return false;
    84fa:	2000      	movs	r0, #0
    84fc:	e003      	b.n	8506 <usbdc_cb_ctl_done+0x16>
		usbdc_ctrl_status_end(req);
    84fe:	0010      	movs	r0, r2
    8500:	4b03      	ldr	r3, [pc, #12]	; (8510 <usbdc_cb_ctl_done+0x20>)
    8502:	4798      	blx	r3
	return false;
    8504:	2000      	movs	r0, #0
}
    8506:	bd10      	pop	{r4, pc}
		return usbdc_ctrl_data_end(req);
    8508:	0010      	movs	r0, r2
    850a:	4b02      	ldr	r3, [pc, #8]	; (8514 <usbdc_cb_ctl_done+0x24>)
    850c:	4798      	blx	r3
    850e:	e7fa      	b.n	8506 <usbdc_cb_ctl_done+0x16>
    8510:	0000848d 	.word	0x0000848d
    8514:	0000846d 	.word	0x0000846d

00008518 <usbdc_set_config>:
{
    8518:	b530      	push	{r4, r5, lr}
    851a:	b083      	sub	sp, #12
    851c:	1e02      	subs	r2, r0, #0
	if (cfg_value == 0) {
    851e:	d014      	beq.n	854a <usbdc_set_config+0x32>
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, cfg_value);
    8520:	4b1e      	ldr	r3, [pc, #120]	; (859c <usbdc_set_config+0x84>)
    8522:	681b      	ldr	r3, [r3, #0]
    8524:	6818      	ldr	r0, [r3, #0]
    8526:	6859      	ldr	r1, [r3, #4]
    8528:	4b1d      	ldr	r3, [pc, #116]	; (85a0 <usbdc_set_config+0x88>)
    852a:	4798      	blx	r3
	if (NULL == cfg_desc) {
    852c:	2800      	cmp	r0, #0
    852e:	d032      	beq.n	8596 <usbdc_set_config+0x7e>
    8530:	7881      	ldrb	r1, [r0, #2]
    8532:	78c3      	ldrb	r3, [r0, #3]
    8534:	021b      	lsls	r3, r3, #8
    8536:	18c9      	adds	r1, r1, r3
    8538:	b289      	uxth	r1, r1
	desc.eod  = cfg_desc + total_len;
    853a:	1841      	adds	r1, r0, r1
    853c:	9101      	str	r1, [sp, #4]
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
    853e:	2204      	movs	r2, #4
    8540:	4b18      	ldr	r3, [pc, #96]	; (85a4 <usbdc_set_config+0x8c>)
    8542:	4798      	blx	r3
    8544:	9000      	str	r0, [sp, #0]
	uint8_t                 last_iface = 0xFF;
    8546:	24ff      	movs	r4, #255	; 0xff
	while (NULL != desc.sod) {
    8548:	e00d      	b.n	8566 <usbdc_set_config+0x4e>
		usbdc_unconfig();
    854a:	4b17      	ldr	r3, [pc, #92]	; (85a8 <usbdc_set_config+0x90>)
    854c:	4798      	blx	r3
		return true;
    854e:	2001      	movs	r0, #1
    8550:	e01f      	b.n	8592 <usbdc_set_config+0x7a>
			last_iface = desc.sod[2];
    8552:	002c      	movs	r4, r5
		desc.sod = usb_desc_next(desc.sod);
    8554:	9800      	ldr	r0, [sp, #0]
	return desc[0];
    8556:	7803      	ldrb	r3, [r0, #0]
	return (desc + usb_desc_len(desc));
    8558:	18c0      	adds	r0, r0, r3
    855a:	9000      	str	r0, [sp, #0]
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
    855c:	2204      	movs	r2, #4
    855e:	9901      	ldr	r1, [sp, #4]
    8560:	4b10      	ldr	r3, [pc, #64]	; (85a4 <usbdc_set_config+0x8c>)
    8562:	4798      	blx	r3
    8564:	9000      	str	r0, [sp, #0]
	while (NULL != desc.sod) {
    8566:	9b00      	ldr	r3, [sp, #0]
    8568:	2b00      	cmp	r3, #0
    856a:	d011      	beq.n	8590 <usbdc_set_config+0x78>
		if (last_iface != desc.sod[2] /* bInterfaceNumber */) {
    856c:	789d      	ldrb	r5, [r3, #2]
    856e:	42ac      	cmp	r4, r5
    8570:	d0f0      	beq.n	8554 <usbdc_set_config+0x3c>
			func       = (struct usbdf_driver *)usbdc.func_list.head;
    8572:	4b0a      	ldr	r3, [pc, #40]	; (859c <usbdc_set_config+0x84>)
    8574:	691c      	ldr	r4, [r3, #16]
			while (NULL != func) {
    8576:	2c00      	cmp	r4, #0
    8578:	d0eb      	beq.n	8552 <usbdc_set_config+0x3a>
				if (func->ctrl(func, USBDF_ENABLE, &desc)) {
    857a:	466a      	mov	r2, sp
    857c:	2100      	movs	r1, #0
    857e:	0020      	movs	r0, r4
    8580:	6863      	ldr	r3, [r4, #4]
    8582:	4798      	blx	r3
    8584:	2800      	cmp	r0, #0
    8586:	d001      	beq.n	858c <usbdc_set_config+0x74>
					func = func->next;
    8588:	6824      	ldr	r4, [r4, #0]
    858a:	e7f4      	b.n	8576 <usbdc_set_config+0x5e>
			last_iface = desc.sod[2];
    858c:	002c      	movs	r4, r5
    858e:	e7e1      	b.n	8554 <usbdc_set_config+0x3c>
	return true;
    8590:	2001      	movs	r0, #1
}
    8592:	b003      	add	sp, #12
    8594:	bd30      	pop	{r4, r5, pc}
		return false;
    8596:	2000      	movs	r0, #0
    8598:	e7fb      	b.n	8592 <usbdc_set_config+0x7a>
    859a:	46c0      	nop			; (mov r8, r8)
    859c:	20000890 	.word	0x20000890
    85a0:	00008c15 	.word	0x00008c15
    85a4:	00008bd1 	.word	0x00008bd1
    85a8:	000083bd 	.word	0x000083bd

000085ac <usbdc_reset>:

/**
 * \brief USB Device Core Reset
 */
void usbdc_reset(void)
{
    85ac:	b510      	push	{r4, lr}
	usbdc_unconfig();
    85ae:	4b0d      	ldr	r3, [pc, #52]	; (85e4 <usbdc_reset+0x38>)
    85b0:	4798      	blx	r3

	usbdc.state       = USBD_S_DEFAULT;
    85b2:	4c0d      	ldr	r4, [pc, #52]	; (85e8 <usbdc_reset+0x3c>)
    85b4:	2302      	movs	r3, #2
    85b6:	76a3      	strb	r3, [r4, #26]
	usbdc.cfg_value   = 0;
    85b8:	2300      	movs	r3, #0
    85ba:	76e3      	strb	r3, [r4, #27]
	usbdc.ifc_alt_map = 0;
    85bc:	7763      	strb	r3, [r4, #29]

	// Setup EP0
	usb_d_ep_deinit(0);
    85be:	2000      	movs	r0, #0
    85c0:	4b0a      	ldr	r3, [pc, #40]	; (85ec <usbdc_reset+0x40>)
    85c2:	4798      	blx	r3
	usb_d_ep0_init(usbdc.ctrl_size);
    85c4:	7f20      	ldrb	r0, [r4, #28]
    85c6:	4b0a      	ldr	r3, [pc, #40]	; (85f0 <usbdc_reset+0x44>)
    85c8:	4798      	blx	r3
	usb_d_ep_register_callback(0, USB_D_EP_CB_SETUP, (FUNC_PTR)usbdc_cb_ctl_req);
    85ca:	4a0a      	ldr	r2, [pc, #40]	; (85f4 <usbdc_reset+0x48>)
    85cc:	2100      	movs	r1, #0
    85ce:	2000      	movs	r0, #0
    85d0:	4c09      	ldr	r4, [pc, #36]	; (85f8 <usbdc_reset+0x4c>)
    85d2:	47a0      	blx	r4
	usb_d_ep_register_callback(0, USB_D_EP_CB_XFER, (FUNC_PTR)usbdc_cb_ctl_done);
    85d4:	4a09      	ldr	r2, [pc, #36]	; (85fc <usbdc_reset+0x50>)
    85d6:	2102      	movs	r1, #2
    85d8:	2000      	movs	r0, #0
    85da:	47a0      	blx	r4
	usb_d_ep_enable(0);
    85dc:	2000      	movs	r0, #0
    85de:	4b08      	ldr	r3, [pc, #32]	; (8600 <usbdc_reset+0x54>)
    85e0:	4798      	blx	r3
}
    85e2:	bd10      	pop	{r4, pc}
    85e4:	000083bd 	.word	0x000083bd
    85e8:	20000890 	.word	0x20000890
    85ec:	00002469 	.word	0x00002469
    85f0:	00002455 	.word	0x00002455
    85f4:	00008a75 	.word	0x00008a75
    85f8:	00002671 	.word	0x00002671
    85fc:	000084f1 	.word	0x000084f1
    8600:	00002495 	.word	0x00002495

00008604 <usbd_event_cb>:
 * \brief Callback invoked on USB device events
 * \param[in] ev Event code.
 * \param[in] param Event parameter for event handling.
 */
static void usbd_event_cb(const enum usb_event ev, const uint32_t param)
{
    8604:	b510      	push	{r4, lr}
	(void)param;

	switch (ev) {
    8606:	2800      	cmp	r0, #0
    8608:	d002      	beq.n	8610 <usbd_event_cb+0xc>
    860a:	2801      	cmp	r0, #1
    860c:	d004      	beq.n	8618 <usbd_event_cb+0x14>
		break;

	default:
		break;
	}
}
    860e:	bd10      	pop	{r4, pc}
		usbdc_change_notify(USBDC_C_CONN, param);
    8610:	2000      	movs	r0, #0
    8612:	4b03      	ldr	r3, [pc, #12]	; (8620 <usbd_event_cb+0x1c>)
    8614:	4798      	blx	r3
		break;
    8616:	e7fa      	b.n	860e <usbd_event_cb+0xa>
		usbdc_reset();
    8618:	4b02      	ldr	r3, [pc, #8]	; (8624 <usbd_event_cb+0x20>)
    861a:	4798      	blx	r3
}
    861c:	e7f7      	b.n	860e <usbd_event_cb+0xa>
    861e:	46c0      	nop			; (mov r8, r8)
    8620:	000083fd 	.word	0x000083fd
    8624:	000085ad 	.word	0x000085ad

00008628 <usbdc_xfer>:

/**
 * \brief Issue USB device transfer
 */
int32_t usbdc_xfer(uint8_t ep, uint8_t *buf, uint32_t size, bool zlp)
{
    8628:	b510      	push	{r4, lr}
    862a:	b084      	sub	sp, #16
	struct usb_d_transfer xfer = {(uint8_t *)buf, size, ep, zlp};
    862c:	ac01      	add	r4, sp, #4
    862e:	9101      	str	r1, [sp, #4]
    8630:	9202      	str	r2, [sp, #8]
    8632:	7220      	strb	r0, [r4, #8]
    8634:	7263      	strb	r3, [r4, #9]
	return usb_d_ep_transfer(&xfer);
    8636:	0020      	movs	r0, r4
    8638:	4b01      	ldr	r3, [pc, #4]	; (8640 <usbdc_xfer+0x18>)
    863a:	4798      	blx	r3
}
    863c:	b004      	add	sp, #16
    863e:	bd10      	pop	{r4, pc}
    8640:	000024e5 	.word	0x000024e5

00008644 <usbdc_clear_ftr_req>:
{
    8644:	b510      	push	{r4, lr}
    8646:	0004      	movs	r4, r0
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
    8648:	780a      	ldrb	r2, [r1, #0]
    864a:	231f      	movs	r3, #31
    864c:	4013      	ands	r3, r2
    864e:	2b02      	cmp	r3, #2
    8650:	d112      	bne.n	8678 <usbdc_clear_ftr_req+0x34>
		if (req->wLength != 0) {
    8652:	798a      	ldrb	r2, [r1, #6]
    8654:	79cb      	ldrb	r3, [r1, #7]
    8656:	021b      	lsls	r3, r3, #8
    8658:	4313      	orrs	r3, r2
    865a:	d001      	beq.n	8660 <usbdc_clear_ftr_req+0x1c>
			return false;
    865c:	2000      	movs	r0, #0
    865e:	e00c      	b.n	867a <usbdc_clear_ftr_req+0x36>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_CLR);
    8660:	7908      	ldrb	r0, [r1, #4]
    8662:	2100      	movs	r1, #0
    8664:	4b05      	ldr	r3, [pc, #20]	; (867c <usbdc_clear_ftr_req+0x38>)
    8666:	4798      	blx	r3
		usbdc_xfer(ep, NULL, 0, true);
    8668:	2301      	movs	r3, #1
    866a:	2200      	movs	r2, #0
    866c:	2100      	movs	r1, #0
    866e:	0020      	movs	r0, r4
    8670:	4c03      	ldr	r4, [pc, #12]	; (8680 <usbdc_clear_ftr_req+0x3c>)
    8672:	47a0      	blx	r4
		return true;
    8674:	2001      	movs	r0, #1
    8676:	e000      	b.n	867a <usbdc_clear_ftr_req+0x36>
		return false;
    8678:	2000      	movs	r0, #0
}
    867a:	bd10      	pop	{r4, pc}
    867c:	00002609 	.word	0x00002609
    8680:	00008629 	.word	0x00008629

00008684 <usbdc_set_ftr_req>:
{
    8684:	b510      	push	{r4, lr}
    8686:	0004      	movs	r4, r0
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
    8688:	780a      	ldrb	r2, [r1, #0]
    868a:	231f      	movs	r3, #31
    868c:	4013      	ands	r3, r2
    868e:	2b02      	cmp	r3, #2
    8690:	d112      	bne.n	86b8 <usbdc_set_ftr_req+0x34>
		if (req->wLength != 0) {
    8692:	798a      	ldrb	r2, [r1, #6]
    8694:	79cb      	ldrb	r3, [r1, #7]
    8696:	021b      	lsls	r3, r3, #8
    8698:	4313      	orrs	r3, r2
    869a:	d001      	beq.n	86a0 <usbdc_set_ftr_req+0x1c>
			return false;
    869c:	2000      	movs	r0, #0
    869e:	e00c      	b.n	86ba <usbdc_set_ftr_req+0x36>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_SET);
    86a0:	7908      	ldrb	r0, [r1, #4]
    86a2:	2101      	movs	r1, #1
    86a4:	4b05      	ldr	r3, [pc, #20]	; (86bc <usbdc_set_ftr_req+0x38>)
    86a6:	4798      	blx	r3
		usbdc_xfer(ep, NULL, 0, true);
    86a8:	2301      	movs	r3, #1
    86aa:	2200      	movs	r2, #0
    86ac:	2100      	movs	r1, #0
    86ae:	0020      	movs	r0, r4
    86b0:	4c03      	ldr	r4, [pc, #12]	; (86c0 <usbdc_set_ftr_req+0x3c>)
    86b2:	47a0      	blx	r4
		return true;
    86b4:	2001      	movs	r0, #1
    86b6:	e000      	b.n	86ba <usbdc_set_ftr_req+0x36>
		return false;
    86b8:	2000      	movs	r0, #0
}
    86ba:	bd10      	pop	{r4, pc}
    86bc:	00002609 	.word	0x00002609
    86c0:	00008629 	.word	0x00008629

000086c4 <usbdc_set_interface>:
{
    86c4:	b570      	push	{r4, r5, r6, lr}
    86c6:	b082      	sub	sp, #8
    86c8:	0005      	movs	r5, r0
    86ca:	000c      	movs	r4, r1
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
    86cc:	4b2a      	ldr	r3, [pc, #168]	; (8778 <usbdc_set_interface+0xb4>)
    86ce:	681a      	ldr	r2, [r3, #0]
    86d0:	6810      	ldr	r0, [r2, #0]
    86d2:	6851      	ldr	r1, [r2, #4]
    86d4:	7eda      	ldrb	r2, [r3, #27]
    86d6:	4b29      	ldr	r3, [pc, #164]	; (877c <usbdc_set_interface+0xb8>)
    86d8:	4798      	blx	r3
	if (NULL == ifc) {
    86da:	2800      	cmp	r0, #0
    86dc:	d045      	beq.n	876a <usbdc_set_interface+0xa6>
	desc.sod = ifc;
    86de:	9000      	str	r0, [sp, #0]
	return (ptr[0] + (ptr[1] << 8));
    86e0:	7881      	ldrb	r1, [r0, #2]
    86e2:	78c3      	ldrb	r3, [r0, #3]
    86e4:	021b      	lsls	r3, r3, #8
    86e6:	18c9      	adds	r1, r1, r3
    86e8:	b289      	uxth	r1, r1
	desc.eod = ifc + usb_cfg_desc_total_len(ifc);
    86ea:	1841      	adds	r1, r0, r1
    86ec:	9101      	str	r1, [sp, #4]
	if (NULL == (ifc = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE))) {
    86ee:	2204      	movs	r2, #4
    86f0:	4b23      	ldr	r3, [pc, #140]	; (8780 <usbdc_set_interface+0xbc>)
    86f2:	4798      	blx	r3
    86f4:	2800      	cmp	r0, #0
    86f6:	d10b      	bne.n	8710 <usbdc_set_interface+0x4c>
		return false;
    86f8:	2000      	movs	r0, #0
    86fa:	e039      	b.n	8770 <usbdc_set_interface+0xac>
		desc.sod = usb_desc_next(desc.sod);
    86fc:	9800      	ldr	r0, [sp, #0]
	return desc[0];
    86fe:	7803      	ldrb	r3, [r0, #0]
	return (desc + usb_desc_len(desc));
    8700:	18c0      	adds	r0, r0, r3
    8702:	9000      	str	r0, [sp, #0]
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
    8704:	2204      	movs	r2, #4
    8706:	9901      	ldr	r1, [sp, #4]
    8708:	4b1d      	ldr	r3, [pc, #116]	; (8780 <usbdc_set_interface+0xbc>)
    870a:	4798      	blx	r3
		if (NULL == ifc) {
    870c:	2800      	cmp	r0, #0
    870e:	d02e      	beq.n	876e <usbdc_set_interface+0xaa>
	while (ifc[2] != ifc_id || ifc[3] != alt_set) {
    8710:	7883      	ldrb	r3, [r0, #2]
    8712:	42a3      	cmp	r3, r4
    8714:	d1f2      	bne.n	86fc <usbdc_set_interface+0x38>
    8716:	78c3      	ldrb	r3, [r0, #3]
    8718:	42ab      	cmp	r3, r5
    871a:	d1ef      	bne.n	86fc <usbdc_set_interface+0x38>
	desc.sod = ifc;
    871c:	9000      	str	r0, [sp, #0]
	func     = (struct usbdf_driver *)usbdc.func_list.head;
    871e:	4b16      	ldr	r3, [pc, #88]	; (8778 <usbdc_set_interface+0xb4>)
    8720:	691e      	ldr	r6, [r3, #16]
	while (NULL != func) {
    8722:	2e00      	cmp	r6, #0
    8724:	d01f      	beq.n	8766 <usbdc_set_interface+0xa2>
		if (func->ctrl(func, USBDF_DISABLE, &desc)) {
    8726:	466a      	mov	r2, sp
    8728:	2101      	movs	r1, #1
    872a:	0030      	movs	r0, r6
    872c:	6873      	ldr	r3, [r6, #4]
    872e:	4798      	blx	r3
    8730:	2800      	cmp	r0, #0
    8732:	d001      	beq.n	8738 <usbdc_set_interface+0x74>
			func = func->next;
    8734:	6836      	ldr	r6, [r6, #0]
    8736:	e7f4      	b.n	8722 <usbdc_set_interface+0x5e>
		} else if (ERR_NONE == func->ctrl(func, USBDF_ENABLE, &desc)) {
    8738:	6873      	ldr	r3, [r6, #4]
    873a:	466a      	mov	r2, sp
    873c:	2100      	movs	r1, #0
    873e:	0030      	movs	r0, r6
    8740:	4798      	blx	r3
    8742:	2800      	cmp	r0, #0
    8744:	d116      	bne.n	8774 <usbdc_set_interface+0xb0>
			if (alt_set) {
    8746:	2d00      	cmp	r5, #0
    8748:	d005      	beq.n	8756 <usbdc_set_interface+0x92>
				usbdc.ifc_alt_map |= 1 << ifc_id;
    874a:	2201      	movs	r2, #1
    874c:	40a2      	lsls	r2, r4
    874e:	490a      	ldr	r1, [pc, #40]	; (8778 <usbdc_set_interface+0xb4>)
    8750:	7f4b      	ldrb	r3, [r1, #29]
    8752:	4313      	orrs	r3, r2
    8754:	774b      	strb	r3, [r1, #29]
			usbdc_xfer(0, NULL, 0, 0);
    8756:	2300      	movs	r3, #0
    8758:	2200      	movs	r2, #0
    875a:	2100      	movs	r1, #0
    875c:	2000      	movs	r0, #0
    875e:	4c09      	ldr	r4, [pc, #36]	; (8784 <usbdc_set_interface+0xc0>)
    8760:	47a0      	blx	r4
			return true;
    8762:	2001      	movs	r0, #1
    8764:	e004      	b.n	8770 <usbdc_set_interface+0xac>
	return false;
    8766:	2000      	movs	r0, #0
    8768:	e002      	b.n	8770 <usbdc_set_interface+0xac>
		return false;
    876a:	2000      	movs	r0, #0
    876c:	e000      	b.n	8770 <usbdc_set_interface+0xac>
			return false;
    876e:	2000      	movs	r0, #0
}
    8770:	b002      	add	sp, #8
    8772:	bd70      	pop	{r4, r5, r6, pc}
			return false;
    8774:	2000      	movs	r0, #0
    8776:	e7fb      	b.n	8770 <usbdc_set_interface+0xac>
    8778:	20000890 	.word	0x20000890
    877c:	00008c15 	.word	0x00008c15
    8780:	00008bd1 	.word	0x00008bd1
    8784:	00008629 	.word	0x00008629

00008788 <usbdc_set_req>:
{
    8788:	b510      	push	{r4, lr}
    878a:	0004      	movs	r4, r0
	switch (req->bRequest) {
    878c:	784b      	ldrb	r3, [r1, #1]
    878e:	2b0b      	cmp	r3, #11
    8790:	d82d      	bhi.n	87ee <usbdc_set_req+0x66>
    8792:	009b      	lsls	r3, r3, #2
    8794:	4a17      	ldr	r2, [pc, #92]	; (87f4 <usbdc_set_req+0x6c>)
    8796:	58d3      	ldr	r3, [r2, r3]
    8798:	469f      	mov	pc, r3
		return (ERR_NONE == usbdc_xfer(ep, NULL, 0, true));
    879a:	2301      	movs	r3, #1
    879c:	2200      	movs	r2, #0
    879e:	2100      	movs	r1, #0
    87a0:	4c15      	ldr	r4, [pc, #84]	; (87f8 <usbdc_set_req+0x70>)
    87a2:	47a0      	blx	r4
    87a4:	4243      	negs	r3, r0
    87a6:	4158      	adcs	r0, r3
    87a8:	b2c0      	uxtb	r0, r0
}
    87aa:	bd10      	pop	{r4, pc}
		if (!usbdc_set_config(req->wValue)) {
    87ac:	7888      	ldrb	r0, [r1, #2]
    87ae:	4b13      	ldr	r3, [pc, #76]	; (87fc <usbdc_set_req+0x74>)
    87b0:	4798      	blx	r3
    87b2:	2800      	cmp	r0, #0
    87b4:	d0f9      	beq.n	87aa <usbdc_set_req+0x22>
		return (ERR_NONE == usbdc_xfer(ep, NULL, 0, true));
    87b6:	2301      	movs	r3, #1
    87b8:	2200      	movs	r2, #0
    87ba:	2100      	movs	r1, #0
    87bc:	0020      	movs	r0, r4
    87be:	4c0e      	ldr	r4, [pc, #56]	; (87f8 <usbdc_set_req+0x70>)
    87c0:	47a0      	blx	r4
    87c2:	4243      	negs	r3, r0
    87c4:	4158      	adcs	r0, r3
    87c6:	b2c0      	uxtb	r0, r0
    87c8:	e7ef      	b.n	87aa <usbdc_set_req+0x22>
		return usbdc_clear_ftr_req(ep, req);
    87ca:	4b0d      	ldr	r3, [pc, #52]	; (8800 <usbdc_set_req+0x78>)
    87cc:	4798      	blx	r3
    87ce:	e7ec      	b.n	87aa <usbdc_set_req+0x22>
		return usbdc_set_ftr_req(ep, req);
    87d0:	4b0c      	ldr	r3, [pc, #48]	; (8804 <usbdc_set_req+0x7c>)
    87d2:	4798      	blx	r3
    87d4:	e7e9      	b.n	87aa <usbdc_set_req+0x22>
		return usbdc_set_interface(req->wValue, req->wIndex);
    87d6:	790a      	ldrb	r2, [r1, #4]
    87d8:	794b      	ldrb	r3, [r1, #5]
    87da:	021b      	lsls	r3, r3, #8
    87dc:	4313      	orrs	r3, r2
    87de:	788a      	ldrb	r2, [r1, #2]
    87e0:	78c8      	ldrb	r0, [r1, #3]
    87e2:	0200      	lsls	r0, r0, #8
    87e4:	4310      	orrs	r0, r2
    87e6:	0019      	movs	r1, r3
    87e8:	4b07      	ldr	r3, [pc, #28]	; (8808 <usbdc_set_req+0x80>)
    87ea:	4798      	blx	r3
    87ec:	e7dd      	b.n	87aa <usbdc_set_req+0x22>
		return false;
    87ee:	2000      	movs	r0, #0
    87f0:	e7db      	b.n	87aa <usbdc_set_req+0x22>
    87f2:	46c0      	nop			; (mov r8, r8)
    87f4:	0000ec9c 	.word	0x0000ec9c
    87f8:	00008629 	.word	0x00008629
    87fc:	00008519 	.word	0x00008519
    8800:	00008645 	.word	0x00008645
    8804:	00008685 	.word	0x00008685
    8808:	000086c5 	.word	0x000086c5

0000880c <usbdc_get_dev_desc>:
{
    880c:	b570      	push	{r4, r5, r6, lr}
    880e:	0005      	movs	r5, r0
	uint16_t length   = req->wLength;
    8810:	798b      	ldrb	r3, [r1, #6]
    8812:	79cc      	ldrb	r4, [r1, #7]
    8814:	0224      	lsls	r4, r4, #8
    8816:	431c      	orrs	r4, r3
	if (length > 0x12) {
    8818:	2c12      	cmp	r4, #18
    881a:	d900      	bls.n	881e <usbdc_get_dev_desc+0x12>
		length = 0x12;
    881c:	2412      	movs	r4, #18
		dev_desc = usb_find_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, USB_DT_DEVICE);
    881e:	4b0b      	ldr	r3, [pc, #44]	; (884c <usbdc_get_dev_desc+0x40>)
    8820:	681b      	ldr	r3, [r3, #0]
    8822:	6818      	ldr	r0, [r3, #0]
    8824:	6859      	ldr	r1, [r3, #4]
    8826:	2201      	movs	r2, #1
    8828:	4b09      	ldr	r3, [pc, #36]	; (8850 <usbdc_get_dev_desc+0x44>)
    882a:	4798      	blx	r3
	if (!dev_desc) {
    882c:	2800      	cmp	r0, #0
    882e:	d00b      	beq.n	8848 <usbdc_get_dev_desc+0x3c>
	if (ERR_NONE != usbdc_xfer(ep, dev_desc, length, false)) {
    8830:	2300      	movs	r3, #0
    8832:	0022      	movs	r2, r4
    8834:	0001      	movs	r1, r0
    8836:	0028      	movs	r0, r5
    8838:	4c06      	ldr	r4, [pc, #24]	; (8854 <usbdc_get_dev_desc+0x48>)
    883a:	47a0      	blx	r4
    883c:	2800      	cmp	r0, #0
    883e:	d101      	bne.n	8844 <usbdc_get_dev_desc+0x38>
	return true;
    8840:	2001      	movs	r0, #1
}
    8842:	bd70      	pop	{r4, r5, r6, pc}
		return false;
    8844:	2000      	movs	r0, #0
    8846:	e7fc      	b.n	8842 <usbdc_get_dev_desc+0x36>
		return false;
    8848:	2000      	movs	r0, #0
    884a:	e7fa      	b.n	8842 <usbdc_get_dev_desc+0x36>
    884c:	20000890 	.word	0x20000890
    8850:	00008bd1 	.word	0x00008bd1
    8854:	00008629 	.word	0x00008629

00008858 <usbdc_get_cfg_desc>:
{
    8858:	b570      	push	{r4, r5, r6, lr}
    885a:	0005      	movs	r5, r0
	uint16_t length   = req->wLength;
    885c:	798b      	ldrb	r3, [r1, #6]
    885e:	79ce      	ldrb	r6, [r1, #7]
    8860:	0236      	lsls	r6, r6, #8
    8862:	431e      	orrs	r6, r3
	uint8_t  index    = req->wValue & 0x00FF;
    8864:	788a      	ldrb	r2, [r1, #2]
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
    8866:	4b13      	ldr	r3, [pc, #76]	; (88b4 <usbdc_get_cfg_desc+0x5c>)
    8868:	7f1c      	ldrb	r4, [r3, #28]
    886a:	3c01      	subs	r4, #1
    886c:	4034      	ands	r4, r6
    886e:	4261      	negs	r1, r4
    8870:	414c      	adcs	r4, r1
    8872:	b2e4      	uxtb	r4, r4
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index + 1);
    8874:	681b      	ldr	r3, [r3, #0]
    8876:	6818      	ldr	r0, [r3, #0]
    8878:	6859      	ldr	r1, [r3, #4]
    887a:	3201      	adds	r2, #1
    887c:	b2d2      	uxtb	r2, r2
    887e:	4b0e      	ldr	r3, [pc, #56]	; (88b8 <usbdc_get_cfg_desc+0x60>)
    8880:	4798      	blx	r3
	if (NULL == cfg_desc) {
    8882:	2800      	cmp	r0, #0
    8884:	d013      	beq.n	88ae <usbdc_get_cfg_desc+0x56>
	return (ptr[0] + (ptr[1] << 8));
    8886:	7882      	ldrb	r2, [r0, #2]
    8888:	78c3      	ldrb	r3, [r0, #3]
    888a:	021b      	lsls	r3, r3, #8
    888c:	18d2      	adds	r2, r2, r3
    888e:	b292      	uxth	r2, r2
	if (length <= total_len) {
    8890:	4296      	cmp	r6, r2
    8892:	d801      	bhi.n	8898 <usbdc_get_cfg_desc+0x40>
	uint16_t length   = req->wLength;
    8894:	0032      	movs	r2, r6
		need_zlp = false;
    8896:	2400      	movs	r4, #0
	if (ERR_NONE != usbdc_xfer(ep, cfg_desc, length, need_zlp)) {
    8898:	0023      	movs	r3, r4
    889a:	0001      	movs	r1, r0
    889c:	0028      	movs	r0, r5
    889e:	4c07      	ldr	r4, [pc, #28]	; (88bc <usbdc_get_cfg_desc+0x64>)
    88a0:	47a0      	blx	r4
    88a2:	2800      	cmp	r0, #0
    88a4:	d101      	bne.n	88aa <usbdc_get_cfg_desc+0x52>
	return true;
    88a6:	2001      	movs	r0, #1
}
    88a8:	bd70      	pop	{r4, r5, r6, pc}
		return false;
    88aa:	2000      	movs	r0, #0
    88ac:	e7fc      	b.n	88a8 <usbdc_get_cfg_desc+0x50>
		return false;
    88ae:	2000      	movs	r0, #0
    88b0:	e7fa      	b.n	88a8 <usbdc_get_cfg_desc+0x50>
    88b2:	46c0      	nop			; (mov r8, r8)
    88b4:	20000890 	.word	0x20000890
    88b8:	00008c15 	.word	0x00008c15
    88bc:	00008629 	.word	0x00008629

000088c0 <usbdc_get_str_desc>:
{
    88c0:	b570      	push	{r4, r5, r6, lr}
    88c2:	0005      	movs	r5, r0
	uint16_t length   = req->wLength;
    88c4:	798b      	ldrb	r3, [r1, #6]
    88c6:	79ce      	ldrb	r6, [r1, #7]
    88c8:	0236      	lsls	r6, r6, #8
    88ca:	431e      	orrs	r6, r3
	uint8_t  index    = req->wValue & 0x00FF;
    88cc:	788a      	ldrb	r2, [r1, #2]
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
    88ce:	4b10      	ldr	r3, [pc, #64]	; (8910 <usbdc_get_str_desc+0x50>)
    88d0:	7f1c      	ldrb	r4, [r3, #28]
    88d2:	3c01      	subs	r4, #1
    88d4:	4034      	ands	r4, r6
    88d6:	4261      	negs	r1, r4
    88d8:	414c      	adcs	r4, r1
    88da:	b2e4      	uxtb	r4, r4
	str_desc = usb_find_str_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index);
    88dc:	681b      	ldr	r3, [r3, #0]
    88de:	6818      	ldr	r0, [r3, #0]
    88e0:	6859      	ldr	r1, [r3, #4]
    88e2:	4b0c      	ldr	r3, [pc, #48]	; (8914 <usbdc_get_str_desc+0x54>)
    88e4:	4798      	blx	r3
	if (NULL == str_desc) {
    88e6:	2800      	cmp	r0, #0
    88e8:	d00f      	beq.n	890a <usbdc_get_str_desc+0x4a>
	if (length <= str_desc[0]) {
    88ea:	7802      	ldrb	r2, [r0, #0]
    88ec:	4296      	cmp	r6, r2
    88ee:	d801      	bhi.n	88f4 <usbdc_get_str_desc+0x34>
	uint16_t length   = req->wLength;
    88f0:	0032      	movs	r2, r6
		need_zlp = false;
    88f2:	2400      	movs	r4, #0
	if (ERR_NONE != usbdc_xfer(ep, str_desc, length, need_zlp)) {
    88f4:	0023      	movs	r3, r4
    88f6:	0001      	movs	r1, r0
    88f8:	0028      	movs	r0, r5
    88fa:	4c07      	ldr	r4, [pc, #28]	; (8918 <usbdc_get_str_desc+0x58>)
    88fc:	47a0      	blx	r4
    88fe:	2800      	cmp	r0, #0
    8900:	d101      	bne.n	8906 <usbdc_get_str_desc+0x46>
	return true;
    8902:	2001      	movs	r0, #1
}
    8904:	bd70      	pop	{r4, r5, r6, pc}
		return false;
    8906:	2000      	movs	r0, #0
    8908:	e7fc      	b.n	8904 <usbdc_get_str_desc+0x44>
		return false;
    890a:	2000      	movs	r0, #0
    890c:	e7fa      	b.n	8904 <usbdc_get_str_desc+0x44>
    890e:	46c0      	nop			; (mov r8, r8)
    8910:	20000890 	.word	0x20000890
    8914:	00008c59 	.word	0x00008c59
    8918:	00008629 	.word	0x00008629

0000891c <usbdc_get_desc_req>:
{
    891c:	b510      	push	{r4, lr}
	uint8_t type = (uint8_t)(req->wValue >> 8);
    891e:	78cb      	ldrb	r3, [r1, #3]
	switch (type) {
    8920:	2b02      	cmp	r3, #2
    8922:	d008      	beq.n	8936 <usbdc_get_desc_req+0x1a>
    8924:	2b03      	cmp	r3, #3
    8926:	d009      	beq.n	893c <usbdc_get_desc_req+0x20>
    8928:	2b01      	cmp	r3, #1
    892a:	d001      	beq.n	8930 <usbdc_get_desc_req+0x14>
	return false;
    892c:	2000      	movs	r0, #0
    892e:	e001      	b.n	8934 <usbdc_get_desc_req+0x18>
		return usbdc_get_dev_desc(ep, req);
    8930:	4b04      	ldr	r3, [pc, #16]	; (8944 <usbdc_get_desc_req+0x28>)
    8932:	4798      	blx	r3
}
    8934:	bd10      	pop	{r4, pc}
		return usbdc_get_cfg_desc(ep, req);
    8936:	4b04      	ldr	r3, [pc, #16]	; (8948 <usbdc_get_desc_req+0x2c>)
    8938:	4798      	blx	r3
    893a:	e7fb      	b.n	8934 <usbdc_get_desc_req+0x18>
		return usbdc_get_str_desc(ep, req);
    893c:	4b03      	ldr	r3, [pc, #12]	; (894c <usbdc_get_desc_req+0x30>)
    893e:	4798      	blx	r3
    8940:	e7f8      	b.n	8934 <usbdc_get_desc_req+0x18>
    8942:	46c0      	nop			; (mov r8, r8)
    8944:	0000880d 	.word	0x0000880d
    8948:	00008859 	.word	0x00008859
    894c:	000088c1 	.word	0x000088c1

00008950 <usbdc_get_status_req>:
{
    8950:	b530      	push	{r4, r5, lr}
    8952:	b083      	sub	sp, #12
    8954:	0004      	movs	r4, r0
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
    8956:	780a      	ldrb	r2, [r1, #0]
    8958:	231f      	movs	r3, #31
    895a:	4013      	ands	r3, r2
    895c:	b2da      	uxtb	r2, r3
    895e:	2a01      	cmp	r2, #1
    8960:	d903      	bls.n	896a <usbdc_get_status_req+0x1a>
    8962:	2b02      	cmp	r3, #2
    8964:	d012      	beq.n	898c <usbdc_get_status_req+0x3c>
		return false;
    8966:	2000      	movs	r0, #0
    8968:	e00e      	b.n	8988 <usbdc_get_status_req+0x38>
		st = 0;
    896a:	2300      	movs	r3, #0
    896c:	9301      	str	r3, [sp, #4]
	memcpy(usbdc.ctrl_buf, &st, 2);
    896e:	4d0d      	ldr	r5, [pc, #52]	; (89a4 <usbdc_get_status_req+0x54>)
    8970:	2202      	movs	r2, #2
    8972:	a901      	add	r1, sp, #4
    8974:	6968      	ldr	r0, [r5, #20]
    8976:	4b0c      	ldr	r3, [pc, #48]	; (89a8 <usbdc_get_status_req+0x58>)
    8978:	4798      	blx	r3
	usbdc_xfer(ep, usbdc.ctrl_buf, 2, false);
    897a:	6969      	ldr	r1, [r5, #20]
    897c:	2300      	movs	r3, #0
    897e:	2202      	movs	r2, #2
    8980:	0020      	movs	r0, r4
    8982:	4c0a      	ldr	r4, [pc, #40]	; (89ac <usbdc_get_status_req+0x5c>)
    8984:	47a0      	blx	r4
	return true;
    8986:	2001      	movs	r0, #1
}
    8988:	b003      	add	sp, #12
    898a:	bd30      	pop	{r4, r5, pc}
		st = usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_GET);
    898c:	7908      	ldrb	r0, [r1, #4]
    898e:	2102      	movs	r1, #2
    8990:	4b07      	ldr	r3, [pc, #28]	; (89b0 <usbdc_get_status_req+0x60>)
    8992:	4798      	blx	r3
		if (st < 0) {
    8994:	2800      	cmp	r0, #0
    8996:	db03      	blt.n	89a0 <usbdc_get_status_req+0x50>
		st = st & 0x1;
    8998:	2301      	movs	r3, #1
    899a:	4018      	ands	r0, r3
    899c:	9001      	str	r0, [sp, #4]
		break;
    899e:	e7e6      	b.n	896e <usbdc_get_status_req+0x1e>
			return false;
    89a0:	2000      	movs	r0, #0
    89a2:	e7f1      	b.n	8988 <usbdc_get_status_req+0x38>
    89a4:	20000890 	.word	0x20000890
    89a8:	00009543 	.word	0x00009543
    89ac:	00008629 	.word	0x00008629
    89b0:	00002609 	.word	0x00002609

000089b4 <usbdc_get_interface>:
{
    89b4:	b570      	push	{r4, r5, r6, lr}
    89b6:	0005      	movs	r5, r0
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
    89b8:	4b16      	ldr	r3, [pc, #88]	; (8a14 <usbdc_get_interface+0x60>)
    89ba:	691c      	ldr	r4, [r3, #16]
	if (!(usbdc.ifc_alt_map & (1 << req->wIndex))) {
    89bc:	7f5a      	ldrb	r2, [r3, #29]
    89be:	7901      	ldrb	r1, [r0, #4]
    89c0:	7943      	ldrb	r3, [r0, #5]
    89c2:	021b      	lsls	r3, r3, #8
    89c4:	430b      	orrs	r3, r1
    89c6:	411a      	asrs	r2, r3
    89c8:	07d3      	lsls	r3, r2, #31
    89ca:	d50a      	bpl.n	89e2 <usbdc_get_interface+0x2e>
	while (NULL != func) {
    89cc:	2c00      	cmp	r4, #0
    89ce:	d01f      	beq.n	8a10 <usbdc_get_interface+0x5c>
		if (0 > (rc = func->ctrl(func, USBDF_GET_IFACE, req))) {
    89d0:	002a      	movs	r2, r5
    89d2:	2102      	movs	r1, #2
    89d4:	0020      	movs	r0, r4
    89d6:	6863      	ldr	r3, [r4, #4]
    89d8:	4798      	blx	r3
    89da:	2800      	cmp	r0, #0
    89dc:	da0d      	bge.n	89fa <usbdc_get_interface+0x46>
			func = func->next;
    89de:	6824      	ldr	r4, [r4, #0]
    89e0:	e7f4      	b.n	89cc <usbdc_get_interface+0x18>
		usbdc.ctrl_buf[0] = 0;
    89e2:	4b0c      	ldr	r3, [pc, #48]	; (8a14 <usbdc_get_interface+0x60>)
    89e4:	2200      	movs	r2, #0
    89e6:	6959      	ldr	r1, [r3, #20]
    89e8:	700a      	strb	r2, [r1, #0]
		usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
    89ea:	6959      	ldr	r1, [r3, #20]
    89ec:	2300      	movs	r3, #0
    89ee:	3201      	adds	r2, #1
    89f0:	2000      	movs	r0, #0
    89f2:	4c09      	ldr	r4, [pc, #36]	; (8a18 <usbdc_get_interface+0x64>)
    89f4:	47a0      	blx	r4
		return true;
    89f6:	2001      	movs	r0, #1
    89f8:	e00b      	b.n	8a12 <usbdc_get_interface+0x5e>
			usbdc.ctrl_buf[0] = (uint8_t)rc;
    89fa:	4b06      	ldr	r3, [pc, #24]	; (8a14 <usbdc_get_interface+0x60>)
    89fc:	695a      	ldr	r2, [r3, #20]
    89fe:	7010      	strb	r0, [r2, #0]
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
    8a00:	6959      	ldr	r1, [r3, #20]
    8a02:	2300      	movs	r3, #0
    8a04:	2201      	movs	r2, #1
    8a06:	2000      	movs	r0, #0
    8a08:	4c03      	ldr	r4, [pc, #12]	; (8a18 <usbdc_get_interface+0x64>)
    8a0a:	47a0      	blx	r4
			return true;
    8a0c:	2001      	movs	r0, #1
    8a0e:	e000      	b.n	8a12 <usbdc_get_interface+0x5e>
	return false;
    8a10:	2000      	movs	r0, #0
}
    8a12:	bd70      	pop	{r4, r5, r6, pc}
    8a14:	20000890 	.word	0x20000890
    8a18:	00008629 	.word	0x00008629

00008a1c <usbdc_get_req>:
{
    8a1c:	b510      	push	{r4, lr}
	switch (req->bRequest) {
    8a1e:	784b      	ldrb	r3, [r1, #1]
    8a20:	2b06      	cmp	r3, #6
    8a22:	d00d      	beq.n	8a40 <usbdc_get_req+0x24>
    8a24:	d907      	bls.n	8a36 <usbdc_get_req+0x1a>
    8a26:	2b08      	cmp	r3, #8
    8a28:	d00d      	beq.n	8a46 <usbdc_get_req+0x2a>
    8a2a:	2b0a      	cmp	r3, #10
    8a2c:	d116      	bne.n	8a5c <usbdc_get_req+0x40>
		return usbdc_get_interface(req);
    8a2e:	0008      	movs	r0, r1
    8a30:	4b0b      	ldr	r3, [pc, #44]	; (8a60 <usbdc_get_req+0x44>)
    8a32:	4798      	blx	r3
    8a34:	e006      	b.n	8a44 <usbdc_get_req+0x28>
	switch (req->bRequest) {
    8a36:	2b00      	cmp	r3, #0
    8a38:	d110      	bne.n	8a5c <usbdc_get_req+0x40>
		return usbdc_get_status_req(ep, req);
    8a3a:	4b0a      	ldr	r3, [pc, #40]	; (8a64 <usbdc_get_req+0x48>)
    8a3c:	4798      	blx	r3
    8a3e:	e001      	b.n	8a44 <usbdc_get_req+0x28>
		return usbdc_get_desc_req(ep, req);
    8a40:	4b09      	ldr	r3, [pc, #36]	; (8a68 <usbdc_get_req+0x4c>)
    8a42:	4798      	blx	r3
}
    8a44:	bd10      	pop	{r4, pc}
		*(uint8_t *)usbdc.ctrl_buf = usbdc.cfg_value;
    8a46:	4b09      	ldr	r3, [pc, #36]	; (8a6c <usbdc_get_req+0x50>)
    8a48:	7eda      	ldrb	r2, [r3, #27]
    8a4a:	6959      	ldr	r1, [r3, #20]
    8a4c:	700a      	strb	r2, [r1, #0]
		usbdc_xfer(ep, usbdc.ctrl_buf, 1, false);
    8a4e:	6959      	ldr	r1, [r3, #20]
    8a50:	2300      	movs	r3, #0
    8a52:	2201      	movs	r2, #1
    8a54:	4c06      	ldr	r4, [pc, #24]	; (8a70 <usbdc_get_req+0x54>)
    8a56:	47a0      	blx	r4
		return true;
    8a58:	2001      	movs	r0, #1
    8a5a:	e7f3      	b.n	8a44 <usbdc_get_req+0x28>
		return false;
    8a5c:	2000      	movs	r0, #0
    8a5e:	e7f1      	b.n	8a44 <usbdc_get_req+0x28>
    8a60:	000089b5 	.word	0x000089b5
    8a64:	00008951 	.word	0x00008951
    8a68:	0000891d 	.word	0x0000891d
    8a6c:	20000890 	.word	0x20000890
    8a70:	00008629 	.word	0x00008629

00008a74 <usbdc_cb_ctl_req>:
{
    8a74:	b570      	push	{r4, r5, r6, lr}
    8a76:	0005      	movs	r5, r0
    8a78:	000c      	movs	r4, r1
	switch (usbdc_request_handler(ep, req, USB_SETUP_STAGE)) {
    8a7a:	2200      	movs	r2, #0
    8a7c:	4b0d      	ldr	r3, [pc, #52]	; (8ab4 <usbdc_cb_ctl_req+0x40>)
    8a7e:	4798      	blx	r3
    8a80:	1c43      	adds	r3, r0, #1
    8a82:	d014      	beq.n	8aae <usbdc_cb_ctl_req+0x3a>
    8a84:	2801      	cmp	r0, #1
    8a86:	d013      	beq.n	8ab0 <usbdc_cb_ctl_req+0x3c>
	switch (req->bmRequestType & (USB_REQT_TYPE_MASK | USB_REQT_DIR_IN)) {
    8a88:	7823      	ldrb	r3, [r4, #0]
    8a8a:	221f      	movs	r2, #31
    8a8c:	4393      	bics	r3, r2
    8a8e:	d004      	beq.n	8a9a <usbdc_cb_ctl_req+0x26>
    8a90:	b2db      	uxtb	r3, r3
    8a92:	2b80      	cmp	r3, #128	; 0x80
    8a94:	d006      	beq.n	8aa4 <usbdc_cb_ctl_req+0x30>
		return false;
    8a96:	2000      	movs	r0, #0
    8a98:	e00a      	b.n	8ab0 <usbdc_cb_ctl_req+0x3c>
		return usbdc_set_req(ep, req);
    8a9a:	0021      	movs	r1, r4
    8a9c:	0028      	movs	r0, r5
    8a9e:	4b06      	ldr	r3, [pc, #24]	; (8ab8 <usbdc_cb_ctl_req+0x44>)
    8aa0:	4798      	blx	r3
    8aa2:	e005      	b.n	8ab0 <usbdc_cb_ctl_req+0x3c>
		return usbdc_get_req(ep, req);
    8aa4:	0021      	movs	r1, r4
    8aa6:	0028      	movs	r0, r5
    8aa8:	4b04      	ldr	r3, [pc, #16]	; (8abc <usbdc_cb_ctl_req+0x48>)
    8aaa:	4798      	blx	r3
    8aac:	e000      	b.n	8ab0 <usbdc_cb_ctl_req+0x3c>
		return false;
    8aae:	2000      	movs	r0, #0
}
    8ab0:	bd70      	pop	{r4, r5, r6, pc}
    8ab2:	46c0      	nop			; (mov r8, r8)
    8ab4:	00008425 	.word	0x00008425
    8ab8:	00008789 	.word	0x00008789
    8abc:	00008a1d 	.word	0x00008a1d

00008ac0 <usbdc_register_handler>:

/**
 * \brief Register the handler
 */
void usbdc_register_handler(enum usbdc_handler_type type, const struct usbdc_handler *h)
{
    8ac0:	b510      	push	{r4, lr}
	switch (type) {
    8ac2:	2801      	cmp	r0, #1
    8ac4:	d009      	beq.n	8ada <usbdc_register_handler+0x1a>
    8ac6:	2800      	cmp	r0, #0
    8ac8:	d002      	beq.n	8ad0 <usbdc_register_handler+0x10>
    8aca:	2802      	cmp	r0, #2
    8acc:	d00a      	beq.n	8ae4 <usbdc_register_handler+0x24>
		list_insert_at_end(&usbdc.handlers.change_list, (void *)h);
		break;
	default:
		break;
	}
}
    8ace:	bd10      	pop	{r4, pc}
		list_insert_at_end(&usbdc.handlers.sof_list, (void *)h);
    8ad0:	4807      	ldr	r0, [pc, #28]	; (8af0 <usbdc_register_handler+0x30>)
    8ad2:	3004      	adds	r0, #4
    8ad4:	4b07      	ldr	r3, [pc, #28]	; (8af4 <usbdc_register_handler+0x34>)
    8ad6:	4798      	blx	r3
		break;
    8ad8:	e7f9      	b.n	8ace <usbdc_register_handler+0xe>
		list_insert_at_end(&usbdc.handlers.req_list, (void *)h);
    8ada:	4805      	ldr	r0, [pc, #20]	; (8af0 <usbdc_register_handler+0x30>)
    8adc:	3008      	adds	r0, #8
    8ade:	4b05      	ldr	r3, [pc, #20]	; (8af4 <usbdc_register_handler+0x34>)
    8ae0:	4798      	blx	r3
		break;
    8ae2:	e7f4      	b.n	8ace <usbdc_register_handler+0xe>
		list_insert_at_end(&usbdc.handlers.change_list, (void *)h);
    8ae4:	4802      	ldr	r0, [pc, #8]	; (8af0 <usbdc_register_handler+0x30>)
    8ae6:	300c      	adds	r0, #12
    8ae8:	4b02      	ldr	r3, [pc, #8]	; (8af4 <usbdc_register_handler+0x34>)
    8aea:	4798      	blx	r3
}
    8aec:	e7ef      	b.n	8ace <usbdc_register_handler+0xe>
    8aee:	46c0      	nop			; (mov r8, r8)
    8af0:	20000890 	.word	0x20000890
    8af4:	00002715 	.word	0x00002715

00008af8 <usbdc_init>:

/**
 * \brief Initialize the USB device core driver
 */
int32_t usbdc_init(uint8_t *ctrl_buf)
{
    8af8:	b570      	push	{r4, r5, r6, lr}
    8afa:	0004      	movs	r4, r0
	ASSERT(ctrl_buf);
    8afc:	1e43      	subs	r3, r0, #1
    8afe:	4198      	sbcs	r0, r3
    8b00:	b2c0      	uxtb	r0, r0
    8b02:	4a0c      	ldr	r2, [pc, #48]	; (8b34 <usbdc_init+0x3c>)
    8b04:	490c      	ldr	r1, [pc, #48]	; (8b38 <usbdc_init+0x40>)
    8b06:	4b0d      	ldr	r3, [pc, #52]	; (8b3c <usbdc_init+0x44>)
    8b08:	4798      	blx	r3

	int32_t rc;

	rc = usb_d_init();
    8b0a:	4b0d      	ldr	r3, [pc, #52]	; (8b40 <usbdc_init+0x48>)
    8b0c:	4798      	blx	r3
	if (rc < 0) {
    8b0e:	2800      	cmp	r0, #0
    8b10:	db0e      	blt.n	8b30 <usbdc_init+0x38>
		return rc;
	}

	memset(&usbdc, 0, sizeof(usbdc));
    8b12:	4d0c      	ldr	r5, [pc, #48]	; (8b44 <usbdc_init+0x4c>)
    8b14:	2220      	movs	r2, #32
    8b16:	2100      	movs	r1, #0
    8b18:	0028      	movs	r0, r5
    8b1a:	4b0b      	ldr	r3, [pc, #44]	; (8b48 <usbdc_init+0x50>)
    8b1c:	4798      	blx	r3
	usbdc.ctrl_buf = ctrl_buf;
    8b1e:	616c      	str	r4, [r5, #20]
	usb_d_register_callback(USB_D_CB_SOF, (FUNC_PTR)usbd_sof_cb);
    8b20:	490a      	ldr	r1, [pc, #40]	; (8b4c <usbdc_init+0x54>)
    8b22:	2000      	movs	r0, #0
    8b24:	4c0a      	ldr	r4, [pc, #40]	; (8b50 <usbdc_init+0x58>)
    8b26:	47a0      	blx	r4
	usb_d_register_callback(USB_D_CB_EVENT, (FUNC_PTR)usbd_event_cb);
    8b28:	490a      	ldr	r1, [pc, #40]	; (8b54 <usbdc_init+0x5c>)
    8b2a:	2001      	movs	r0, #1
    8b2c:	47a0      	blx	r4

	return 0;
    8b2e:	2000      	movs	r0, #0
}
    8b30:	bd70      	pop	{r4, r5, r6, pc}
    8b32:	46c0      	nop			; (mov r8, r8)
    8b34:	00000355 	.word	0x00000355
    8b38:	0000eccc 	.word	0x0000eccc
    8b3c:	000026c1 	.word	0x000026c1
    8b40:	00002365 	.word	0x00002365
    8b44:	20000890 	.word	0x20000890
    8b48:	00009555 	.word	0x00009555
    8b4c:	00008461 	.word	0x00008461
    8b50:	000023d1 	.word	0x000023d1
    8b54:	00008605 	.word	0x00008605

00008b58 <usbdc_register_function>:
 * \brief Register/unregister function support of a USB device function
 *
 * Must be invoked when USB device is stopped.
 */
void usbdc_register_function(struct usbdf_driver *func)
{
    8b58:	b510      	push	{r4, lr}
    8b5a:	0001      	movs	r1, r0
	list_insert_at_end(&usbdc.func_list, func);
    8b5c:	4802      	ldr	r0, [pc, #8]	; (8b68 <usbdc_register_function+0x10>)
    8b5e:	3010      	adds	r0, #16
    8b60:	4b02      	ldr	r3, [pc, #8]	; (8b6c <usbdc_register_function+0x14>)
    8b62:	4798      	blx	r3
}
    8b64:	bd10      	pop	{r4, pc}
    8b66:	46c0      	nop			; (mov r8, r8)
    8b68:	20000890 	.word	0x20000890
    8b6c:	00002715 	.word	0x00002715

00008b70 <usbdc_start>:

/**
 * \brief Start the USB device driver with specific descriptors set
 */
int32_t usbdc_start(struct usbd_descriptors *desces)
{
    8b70:	b510      	push	{r4, lr}
	if (usbdc.state >= USBD_S_POWER) {
    8b72:	4b0b      	ldr	r3, [pc, #44]	; (8ba0 <usbdc_start+0x30>)
    8b74:	7e9b      	ldrb	r3, [r3, #26]
    8b76:	2b00      	cmp	r3, #0
    8b78:	d10c      	bne.n	8b94 <usbdc_start+0x24>
		return ERR_BUSY;
	}

	if (desces) {
    8b7a:	2800      	cmp	r0, #0
    8b7c:	d00d      	beq.n	8b9a <usbdc_start+0x2a>
		usbdc.desces.ls_fs = desces;
    8b7e:	4b08      	ldr	r3, [pc, #32]	; (8ba0 <usbdc_start+0x30>)
    8b80:	6018      	str	r0, [r3, #0]
#endif
	} else {
		return ERR_BAD_DATA;
	}

	usbdc.ctrl_size = desces->sod[7];
    8b82:	6802      	ldr	r2, [r0, #0]
    8b84:	79d2      	ldrb	r2, [r2, #7]
    8b86:	771a      	strb	r2, [r3, #28]
	usbdc.state     = USBD_S_POWER;
    8b88:	2201      	movs	r2, #1
    8b8a:	769a      	strb	r2, [r3, #26]
	usb_d_enable();
    8b8c:	4b05      	ldr	r3, [pc, #20]	; (8ba4 <usbdc_start+0x34>)
    8b8e:	4798      	blx	r3
	return ERR_NONE;
    8b90:	2000      	movs	r0, #0
}
    8b92:	bd10      	pop	{r4, pc}
		return ERR_BUSY;
    8b94:	2004      	movs	r0, #4
    8b96:	4240      	negs	r0, r0
    8b98:	e7fb      	b.n	8b92 <usbdc_start+0x22>
		return ERR_BAD_DATA;
    8b9a:	2009      	movs	r0, #9
    8b9c:	4240      	negs	r0, r0
    8b9e:	e7f8      	b.n	8b92 <usbdc_start+0x22>
    8ba0:	20000890 	.word	0x20000890
    8ba4:	000023dd 	.word	0x000023dd

00008ba8 <usbdc_attach>:

/**
 * \brief Attach the USB device to host
 */
void usbdc_attach(void)
{
    8ba8:	b510      	push	{r4, lr}
	usb_d_attach();
    8baa:	4b01      	ldr	r3, [pc, #4]	; (8bb0 <usbdc_attach+0x8>)
    8bac:	4798      	blx	r3
}
    8bae:	bd10      	pop	{r4, pc}
    8bb0:	000023e9 	.word	0x000023e9

00008bb4 <usbdc_get_ctrl_buffer>:
/**
 * \brief Return USB Device endpoint0 buffer
 */
uint8_t *usbdc_get_ctrl_buffer(void)
{
	return usbdc.ctrl_buf;
    8bb4:	4b01      	ldr	r3, [pc, #4]	; (8bbc <usbdc_get_ctrl_buffer+0x8>)
    8bb6:	6958      	ldr	r0, [r3, #20]
}
    8bb8:	4770      	bx	lr
    8bba:	46c0      	nop			; (mov r8, r8)
    8bbc:	20000890 	.word	0x20000890

00008bc0 <usbdc_get_state>:
/**
 * \brief Return current USB state
 */
uint8_t usbdc_get_state(void)
{
	if (usbdc.state & USBD_S_SUSPEND) {
    8bc0:	4b02      	ldr	r3, [pc, #8]	; (8bcc <usbdc_get_state+0xc>)
    8bc2:	7e98      	ldrb	r0, [r3, #26]
    8bc4:	06c3      	lsls	r3, r0, #27
    8bc6:	d500      	bpl.n	8bca <usbdc_get_state+0xa>
		return USBD_S_SUSPEND;
    8bc8:	2010      	movs	r0, #16
	}
	return usbdc.state;
}
    8bca:	4770      	bx	lr
    8bcc:	20000890 	.word	0x20000890

00008bd0 <usb_find_desc>:
#define _param_error_check(cond) ASSERT(cond)
#define _desc_len_check() ASSERT(usb_desc_len(desc) >= 2)
#endif

uint8_t *usb_find_desc(uint8_t *desc, uint8_t *eof, uint8_t type)
{
    8bd0:	b510      	push	{r4, lr}
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
    8bd2:	4288      	cmp	r0, r1
    8bd4:	d207      	bcs.n	8be6 <usb_find_desc+0x16>
	return desc[0];
    8bd6:	7803      	ldrb	r3, [r0, #0]
		_desc_len_check();
    8bd8:	2b01      	cmp	r3, #1
    8bda:	d906      	bls.n	8bea <usb_find_desc+0x1a>
	return desc[1];
    8bdc:	7844      	ldrb	r4, [r0, #1]
		if (type == usb_desc_type(desc)) {
    8bde:	4294      	cmp	r4, r2
    8be0:	d002      	beq.n	8be8 <usb_find_desc+0x18>
	return (desc + usb_desc_len(desc));
    8be2:	18c0      	adds	r0, r0, r3
    8be4:	e7f5      	b.n	8bd2 <usb_find_desc+0x2>
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
    8be6:	2000      	movs	r0, #0
}
    8be8:	bd10      	pop	{r4, pc}
		_desc_len_check();
    8bea:	2000      	movs	r0, #0
    8bec:	e7fc      	b.n	8be8 <usb_find_desc+0x18>

00008bee <usb_find_ep_desc>:

uint8_t *usb_find_ep_desc(uint8_t *desc, uint8_t *eof)
{
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
    8bee:	4288      	cmp	r0, r1
    8bf0:	d209      	bcs.n	8c06 <usb_find_ep_desc+0x18>
	return desc[0];
    8bf2:	7803      	ldrb	r3, [r0, #0]
		_desc_len_check();
    8bf4:	2b01      	cmp	r3, #1
    8bf6:	d908      	bls.n	8c0a <usb_find_ep_desc+0x1c>
	return desc[1];
    8bf8:	7842      	ldrb	r2, [r0, #1]
		if (USB_DT_INTERFACE == usb_desc_type(desc)) {
    8bfa:	2a04      	cmp	r2, #4
    8bfc:	d007      	beq.n	8c0e <usb_find_ep_desc+0x20>
			break;
		}
		if (USB_DT_ENDPOINT == usb_desc_type(desc)) {
    8bfe:	2a05      	cmp	r2, #5
    8c00:	d002      	beq.n	8c08 <usb_find_ep_desc+0x1a>
	return (desc + usb_desc_len(desc));
    8c02:	18c0      	adds	r0, r0, r3
    8c04:	e7f3      	b.n	8bee <usb_find_ep_desc>
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
    8c06:	2000      	movs	r0, #0
}
    8c08:	4770      	bx	lr
		_desc_len_check();
    8c0a:	2000      	movs	r0, #0
    8c0c:	e7fc      	b.n	8c08 <usb_find_ep_desc+0x1a>
	return NULL;
    8c0e:	2000      	movs	r0, #0
    8c10:	e7fa      	b.n	8c08 <usb_find_ep_desc+0x1a>
	...

00008c14 <usb_find_cfg_desc>:

uint8_t *usb_find_cfg_desc(uint8_t *desc, uint8_t *eof, uint8_t cfg_value)
{
    8c14:	b570      	push	{r4, r5, r6, lr}
    8c16:	000c      	movs	r4, r1
    8c18:	0015      	movs	r5, r2
	_param_error_check(desc && eof && (desc < eof));

	desc = usb_find_desc(desc, eof, USB_DT_CONFIG);
    8c1a:	2202      	movs	r2, #2
    8c1c:	4b0d      	ldr	r3, [pc, #52]	; (8c54 <usb_find_cfg_desc+0x40>)
    8c1e:	4798      	blx	r3
	if (!desc) {
    8c20:	2800      	cmp	r0, #0
    8c22:	d012      	beq.n	8c4a <usb_find_cfg_desc+0x36>
		return NULL;
	}
	while (desc < eof) {
    8c24:	42a0      	cmp	r0, r4
    8c26:	d20f      	bcs.n	8c48 <usb_find_cfg_desc+0x34>
	return desc[0];
    8c28:	7803      	ldrb	r3, [r0, #0]
		_desc_len_check();
    8c2a:	2b01      	cmp	r3, #1
    8c2c:	d90e      	bls.n	8c4c <usb_find_cfg_desc+0x38>
		if (desc[1] != USB_DT_CONFIG) {
    8c2e:	7843      	ldrb	r3, [r0, #1]
    8c30:	2b02      	cmp	r3, #2
    8c32:	d10d      	bne.n	8c50 <usb_find_cfg_desc+0x3c>
			break;
		}
		if (desc[5] == cfg_value) {
    8c34:	7943      	ldrb	r3, [r0, #5]
    8c36:	42ab      	cmp	r3, r5
    8c38:	d007      	beq.n	8c4a <usb_find_cfg_desc+0x36>
	return (ptr[0] + (ptr[1] << 8));
    8c3a:	7883      	ldrb	r3, [r0, #2]
    8c3c:	78c2      	ldrb	r2, [r0, #3]
    8c3e:	0212      	lsls	r2, r2, #8
    8c40:	189b      	adds	r3, r3, r2
    8c42:	b29b      	uxth	r3, r3
 *  \param[in] cfg_desc Byte pointer to the descriptor start address
 *  \return Byte pointer to descriptor after configuration end
 */
static inline uint8_t *usb_cfg_desc_next(uint8_t *cfg_desc)
{
	return (cfg_desc + usb_cfg_desc_total_len(cfg_desc));
    8c44:	18c0      	adds	r0, r0, r3
    8c46:	e7ed      	b.n	8c24 <usb_find_cfg_desc+0x10>
			return desc;
		}
		desc = usb_cfg_desc_next(desc);
	}
	return NULL;
    8c48:	2000      	movs	r0, #0
}
    8c4a:	bd70      	pop	{r4, r5, r6, pc}
		_desc_len_check();
    8c4c:	2000      	movs	r0, #0
    8c4e:	e7fc      	b.n	8c4a <usb_find_cfg_desc+0x36>
	return NULL;
    8c50:	2000      	movs	r0, #0
    8c52:	e7fa      	b.n	8c4a <usb_find_cfg_desc+0x36>
    8c54:	00008bd1 	.word	0x00008bd1

00008c58 <usb_find_str_desc>:
	}
	return NULL;
}

uint8_t *usb_find_str_desc(uint8_t *desc, uint8_t *eof, uint8_t str_index)
{
    8c58:	b570      	push	{r4, r5, r6, lr}
    8c5a:	000d      	movs	r5, r1
    8c5c:	0016      	movs	r6, r2
	uint8_t i;

	_param_error_check(desc && eof && (desc < eof));

	for (i = 0; desc < eof;) {
    8c5e:	2400      	movs	r4, #0
    8c60:	42a8      	cmp	r0, r5
    8c62:	d20e      	bcs.n	8c82 <usb_find_str_desc+0x2a>
		desc = usb_find_desc(desc, eof, USB_DT_STRING);
    8c64:	2203      	movs	r2, #3
    8c66:	0029      	movs	r1, r5
    8c68:	4b08      	ldr	r3, [pc, #32]	; (8c8c <usb_find_str_desc+0x34>)
    8c6a:	4798      	blx	r3
		if (desc) {
    8c6c:	2800      	cmp	r0, #0
    8c6e:	d009      	beq.n	8c84 <usb_find_str_desc+0x2c>
	return desc[0];
    8c70:	7803      	ldrb	r3, [r0, #0]
			_desc_len_check();
    8c72:	2b01      	cmp	r3, #1
    8c74:	d907      	bls.n	8c86 <usb_find_str_desc+0x2e>
			if (i == str_index) {
    8c76:	42b4      	cmp	r4, r6
    8c78:	d004      	beq.n	8c84 <usb_find_str_desc+0x2c>
				return desc;
			}
			i++;
    8c7a:	3401      	adds	r4, #1
    8c7c:	b2e4      	uxtb	r4, r4
	return (desc + usb_desc_len(desc));
    8c7e:	18c0      	adds	r0, r0, r3
    8c80:	e7ee      	b.n	8c60 <usb_find_str_desc+0x8>
			desc = usb_desc_next(desc);
		} else {
			return NULL;
		}
	}
	return NULL;
    8c82:	2000      	movs	r0, #0
}
    8c84:	bd70      	pop	{r4, r5, r6, pc}
			_desc_len_check();
    8c86:	2000      	movs	r0, #0
    8c88:	e7fc      	b.n	8c84 <usb_find_str_desc+0x2c>
    8c8a:	46c0      	nop			; (mov r8, r8)
    8c8c:	00008bd1 	.word	0x00008bd1

00008c90 <hiddf_sof_event>:
	cdcdf_demo_buf = bulk_packet_buffer;
	cdcdf_acm_register_callback(CDCDF_ACM_CB_STATE_C, (FUNC_PTR)cdcdf_demo_cb_state_c);
}

static void hiddf_sof_event(void)
{
    8c90:	b510      	push	{r4, lr}
    8c92:	b084      	sub	sp, #16
	if (repress_delay){
    8c94:	4bc0      	ldr	r3, [pc, #768]	; (8f98 <hiddf_sof_event+0x308>)
    8c96:	791b      	ldrb	r3, [r3, #4]
    8c98:	2b00      	cmp	r3, #0
    8c9a:	d002      	beq.n	8ca2 <hiddf_sof_event+0x12>
		repress_delay --;
    8c9c:	3b01      	subs	r3, #1
    8c9e:	4abe      	ldr	r2, [pc, #760]	; (8f98 <hiddf_sof_event+0x308>)
    8ca0:	7113      	strb	r3, [r2, #4]
	}
	if (usb_disconnected){
    8ca2:	4bbe      	ldr	r3, [pc, #760]	; (8f9c <hiddf_sof_event+0x30c>)
    8ca4:	881b      	ldrh	r3, [r3, #0]
    8ca6:	2b00      	cmp	r3, #0
    8ca8:	d002      	beq.n	8cb0 <hiddf_sof_event+0x20>
		usb_disconnected --;
    8caa:	3b01      	subs	r3, #1
    8cac:	4abb      	ldr	r2, [pc, #748]	; (8f9c <hiddf_sof_event+0x30c>)
    8cae:	8013      	strh	r3, [r2, #0]
	}
	
	if (session_data.session_running) {		
    8cb0:	4bbb      	ldr	r3, [pc, #748]	; (8fa0 <hiddf_sof_event+0x310>)
    8cb2:	789b      	ldrb	r3, [r3, #2]
    8cb4:	2b00      	cmp	r3, #0
    8cb6:	d100      	bne.n	8cba <hiddf_sof_event+0x2a>
    8cb8:	e108      	b.n	8ecc <hiddf_sof_event+0x23c>

		if (session_data.trigger){
    8cba:	4bb9      	ldr	r3, [pc, #740]	; (8fa0 <hiddf_sof_event+0x310>)
    8cbc:	795b      	ldrb	r3, [r3, #5]
    8cbe:	2b00      	cmp	r3, #0
    8cc0:	d019      	beq.n	8cf6 <hiddf_sof_event+0x66>
			if (key_array[4].state == HID_KB_KEY_UP){
    8cc2:	4bb8      	ldr	r3, [pc, #736]	; (8fa4 <hiddf_sof_event+0x314>)
    8cc4:	7b9b      	ldrb	r3, [r3, #14]
    8cc6:	2b00      	cmp	r3, #0
    8cc8:	d108      	bne.n	8cdc <hiddf_sof_event+0x4c>
				key_array[4].state = HID_KB_KEY_DOWN;
    8cca:	3301      	adds	r3, #1
    8ccc:	4ab5      	ldr	r2, [pc, #724]	; (8fa4 <hiddf_sof_event+0x314>)
    8cce:	7393      	strb	r3, [r2, #14]
				key_changed=true;
    8cd0:	4ab1      	ldr	r2, [pc, #708]	; (8f98 <hiddf_sof_event+0x308>)
    8cd2:	7153      	strb	r3, [r2, #5]
				sync_beep_length = SYNC_BEEP_LENGTH;
    8cd4:	4ab4      	ldr	r2, [pc, #720]	; (8fa8 <hiddf_sof_event+0x318>)
    8cd6:	4bb5      	ldr	r3, [pc, #724]	; (8fac <hiddf_sof_event+0x31c>)
    8cd8:	801a      	strh	r2, [r3, #0]
    8cda:	e014      	b.n	8d06 <hiddf_sof_event+0x76>
			}
			else{
				trigger_delay += 1;
    8cdc:	4aae      	ldr	r2, [pc, #696]	; (8f98 <hiddf_sof_event+0x308>)
    8cde:	7993      	ldrb	r3, [r2, #6]
    8ce0:	3301      	adds	r3, #1
    8ce2:	b2db      	uxtb	r3, r3
    8ce4:	7193      	strb	r3, [r2, #6]
				if (trigger_delay > 10){
    8ce6:	2b0a      	cmp	r3, #10
    8ce8:	d90d      	bls.n	8d06 <hiddf_sof_event+0x76>
					session_data.trigger = false;
    8cea:	2300      	movs	r3, #0
    8cec:	4aac      	ldr	r2, [pc, #688]	; (8fa0 <hiddf_sof_event+0x310>)
    8cee:	7153      	strb	r3, [r2, #5]
					trigger_delay = 0;
    8cf0:	4aa9      	ldr	r2, [pc, #676]	; (8f98 <hiddf_sof_event+0x308>)
    8cf2:	7193      	strb	r3, [r2, #6]
    8cf4:	e007      	b.n	8d06 <hiddf_sof_event+0x76>
				}
			}
		}			
				
		else if (key_array[4].state == HID_KB_KEY_DOWN){
    8cf6:	4bab      	ldr	r3, [pc, #684]	; (8fa4 <hiddf_sof_event+0x314>)
    8cf8:	7b9b      	ldrb	r3, [r3, #14]
    8cfa:	2b01      	cmp	r3, #1
    8cfc:	d00a      	beq.n	8d14 <hiddf_sof_event+0x84>
			key_array[3].state = HID_KB_KEY_UP;
			key_changed=true;
			repress_delay=10;
		}				
					
		else if (!repress_delay){ 
    8cfe:	4ba6      	ldr	r3, [pc, #664]	; (8f98 <hiddf_sof_event+0x308>)
    8d00:	791b      	ldrb	r3, [r3, #4]
    8d02:	2b00      	cmp	r3, #0
    8d04:	d013      	beq.n	8d2e <hiddf_sof_event+0x9e>
			key_array[4].state = HID_KB_KEY_UP;
			key_changed=true;			
		}
	}
	
	if (key_changed) {
    8d06:	4ba4      	ldr	r3, [pc, #656]	; (8f98 <hiddf_sof_event+0x308>)
    8d08:	795b      	ldrb	r3, [r3, #5]
    8d0a:	2b00      	cmp	r3, #0
    8d0c:	d000      	beq.n	8d10 <hiddf_sof_event+0x80>
    8d0e:	e1d5      	b.n	90bc <hiddf_sof_event+0x42c>
		hiddf_keyboard_keys_state_change(key_array, 5);
		key_changed = false;
	}
}
    8d10:	b004      	add	sp, #16
    8d12:	bd10      	pop	{r4, pc}
			key_array[4].state = HID_KB_KEY_UP;
    8d14:	4ba3      	ldr	r3, [pc, #652]	; (8fa4 <hiddf_sof_event+0x314>)
    8d16:	2200      	movs	r2, #0
    8d18:	739a      	strb	r2, [r3, #14]
			key_array[0].state = HID_KB_KEY_UP;
    8d1a:	709a      	strb	r2, [r3, #2]
			key_array[1].state = HID_KB_KEY_UP;
    8d1c:	715a      	strb	r2, [r3, #5]
			key_array[2].state = HID_KB_KEY_UP;
    8d1e:	721a      	strb	r2, [r3, #8]
			key_array[3].state = HID_KB_KEY_UP;
    8d20:	72da      	strb	r2, [r3, #11]
			key_changed=true;
    8d22:	4b9d      	ldr	r3, [pc, #628]	; (8f98 <hiddf_sof_event+0x308>)
    8d24:	3201      	adds	r2, #1
    8d26:	715a      	strb	r2, [r3, #5]
			repress_delay=10;
    8d28:	3209      	adds	r2, #9
    8d2a:	711a      	strb	r2, [r3, #4]
    8d2c:	e7eb      	b.n	8d06 <hiddf_sof_event+0x76>
 */
static inline uint32_t _gpio_get_level(const enum gpio_port port)
{
	uint32_t tmp;

	CRITICAL_SECTION_ENTER();
    8d2e:	4668      	mov	r0, sp
    8d30:	4b9f      	ldr	r3, [pc, #636]	; (8fb0 <hiddf_sof_event+0x320>)
    8d32:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    8d34:	23c0      	movs	r3, #192	; 0xc0
    8d36:	05db      	lsls	r3, r3, #23
    8d38:	2280      	movs	r2, #128	; 0x80
    8d3a:	589c      	ldr	r4, [r3, r2]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    8d3c:	3220      	adds	r2, #32
    8d3e:	499d      	ldr	r1, [pc, #628]	; (8fb4 <hiddf_sof_event+0x324>)
    8d40:	588a      	ldr	r2, [r1, r2]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    8d42:	2190      	movs	r1, #144	; 0x90
    8d44:	585b      	ldr	r3, [r3, r1]

	uint32_t dir_tmp = hri_port_read_DIR_reg(PORT_IOBUS, port);

	tmp = hri_port_read_IN_reg(PORT, port) & ~dir_tmp;
	tmp |= hri_port_read_OUT_reg(PORT_IOBUS, port) & dir_tmp;
    8d46:	4053      	eors	r3, r2
    8d48:	401c      	ands	r4, r3
    8d4a:	4054      	eors	r4, r2

	CRITICAL_SECTION_LEAVE();
    8d4c:	4668      	mov	r0, sp
    8d4e:	4b9a      	ldr	r3, [pc, #616]	; (8fb8 <hiddf_sof_event+0x328>)
    8d50:	4798      	blx	r3
			if (gpio_get_pin_level(I1) == true){
    8d52:	05e3      	lsls	r3, r4, #23
    8d54:	d513      	bpl.n	8d7e <hiddf_sof_event+0xee>
				if ((key_array[0].state == HID_KB_KEY_UP) && (key_array[4].state == HID_KB_KEY_UP)){		//****************************** ksleltets!!!!!!!!!!!!!!!!!!!!!
    8d56:	4b93      	ldr	r3, [pc, #588]	; (8fa4 <hiddf_sof_event+0x314>)
    8d58:	789b      	ldrb	r3, [r3, #2]
    8d5a:	2b00      	cmp	r3, #0
    8d5c:	d113      	bne.n	8d86 <hiddf_sof_event+0xf6>
    8d5e:	4b91      	ldr	r3, [pc, #580]	; (8fa4 <hiddf_sof_event+0x314>)
    8d60:	7b9b      	ldrb	r3, [r3, #14]
    8d62:	2b00      	cmp	r3, #0
    8d64:	d10f      	bne.n	8d86 <hiddf_sof_event+0xf6>
					key_array[0].state = HID_KB_KEY_DOWN;
    8d66:	3301      	adds	r3, #1
    8d68:	4a8e      	ldr	r2, [pc, #568]	; (8fa4 <hiddf_sof_event+0x314>)
    8d6a:	7093      	strb	r3, [r2, #2]
					session_data.simulated_A=false;
    8d6c:	2100      	movs	r1, #0
    8d6e:	4a8c      	ldr	r2, [pc, #560]	; (8fa0 <hiddf_sof_event+0x310>)
    8d70:	7191      	strb	r1, [r2, #6]
					key_changed=true;
    8d72:	4a89      	ldr	r2, [pc, #548]	; (8f98 <hiddf_sof_event+0x308>)
    8d74:	7153      	strb	r3, [r2, #5]
					beep_sound_length = BEEP_SOUND_LENGTH;
    8d76:	4a91      	ldr	r2, [pc, #580]	; (8fbc <hiddf_sof_event+0x32c>)
    8d78:	4b91      	ldr	r3, [pc, #580]	; (8fc0 <hiddf_sof_event+0x330>)
    8d7a:	801a      	strh	r2, [r3, #0]
    8d7c:	e003      	b.n	8d86 <hiddf_sof_event+0xf6>
				if (key_array[0].state == HID_KB_KEY_DOWN){
    8d7e:	4b89      	ldr	r3, [pc, #548]	; (8fa4 <hiddf_sof_event+0x314>)
    8d80:	789b      	ldrb	r3, [r3, #2]
    8d82:	2b01      	cmp	r3, #1
    8d84:	d027      	beq.n	8dd6 <hiddf_sof_event+0x146>
	CRITICAL_SECTION_ENTER();
    8d86:	a801      	add	r0, sp, #4
    8d88:	4b89      	ldr	r3, [pc, #548]	; (8fb0 <hiddf_sof_event+0x320>)
    8d8a:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    8d8c:	23c0      	movs	r3, #192	; 0xc0
    8d8e:	05db      	lsls	r3, r3, #23
    8d90:	2280      	movs	r2, #128	; 0x80
    8d92:	589c      	ldr	r4, [r3, r2]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    8d94:	3220      	adds	r2, #32
    8d96:	4987      	ldr	r1, [pc, #540]	; (8fb4 <hiddf_sof_event+0x324>)
    8d98:	588a      	ldr	r2, [r1, r2]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    8d9a:	2190      	movs	r1, #144	; 0x90
    8d9c:	585b      	ldr	r3, [r3, r1]
	tmp |= hri_port_read_OUT_reg(PORT_IOBUS, port) & dir_tmp;
    8d9e:	4053      	eors	r3, r2
    8da0:	401c      	ands	r4, r3
    8da2:	4054      	eors	r4, r2
	CRITICAL_SECTION_LEAVE();
    8da4:	a801      	add	r0, sp, #4
    8da6:	4b84      	ldr	r3, [pc, #528]	; (8fb8 <hiddf_sof_event+0x328>)
    8da8:	4798      	blx	r3
			if (gpio_get_pin_level(I2) == true){
    8daa:	0423      	lsls	r3, r4, #16
    8dac:	d51a      	bpl.n	8de4 <hiddf_sof_event+0x154>
				if ((key_array[1].state == HID_KB_KEY_UP) && (key_array[4].state == HID_KB_KEY_UP)){		//****************************** ksleltets!!!!!!!!!!!!!!!!!!!!!
    8dae:	4b7d      	ldr	r3, [pc, #500]	; (8fa4 <hiddf_sof_event+0x314>)
    8db0:	795b      	ldrb	r3, [r3, #5]
    8db2:	2b00      	cmp	r3, #0
    8db4:	d11a      	bne.n	8dec <hiddf_sof_event+0x15c>
    8db6:	4b7b      	ldr	r3, [pc, #492]	; (8fa4 <hiddf_sof_event+0x314>)
    8db8:	7b9b      	ldrb	r3, [r3, #14]
    8dba:	2b00      	cmp	r3, #0
    8dbc:	d116      	bne.n	8dec <hiddf_sof_event+0x15c>
					key_array[1].state = HID_KB_KEY_DOWN;
    8dbe:	3301      	adds	r3, #1
    8dc0:	4a78      	ldr	r2, [pc, #480]	; (8fa4 <hiddf_sof_event+0x314>)
    8dc2:	7153      	strb	r3, [r2, #5]
					session_data.simulated_B=false;
    8dc4:	2100      	movs	r1, #0
    8dc6:	4a76      	ldr	r2, [pc, #472]	; (8fa0 <hiddf_sof_event+0x310>)
    8dc8:	71d1      	strb	r1, [r2, #7]
					key_changed=true;
    8dca:	4a73      	ldr	r2, [pc, #460]	; (8f98 <hiddf_sof_event+0x308>)
    8dcc:	7153      	strb	r3, [r2, #5]
					beep_sound_length = BEEP_SOUND_LENGTH;
    8dce:	4a7b      	ldr	r2, [pc, #492]	; (8fbc <hiddf_sof_event+0x32c>)
    8dd0:	4b7b      	ldr	r3, [pc, #492]	; (8fc0 <hiddf_sof_event+0x330>)
    8dd2:	801a      	strh	r2, [r3, #0]
    8dd4:	e00a      	b.n	8dec <hiddf_sof_event+0x15c>
					key_array[0].state = HID_KB_KEY_UP;				//****************************** ksleltets!!!!!!!!!!!!!!!!!!!!!
    8dd6:	2200      	movs	r2, #0
    8dd8:	4b72      	ldr	r3, [pc, #456]	; (8fa4 <hiddf_sof_event+0x314>)
    8dda:	709a      	strb	r2, [r3, #2]
					key_changed=true;
    8ddc:	3201      	adds	r2, #1
    8dde:	4b6e      	ldr	r3, [pc, #440]	; (8f98 <hiddf_sof_event+0x308>)
    8de0:	715a      	strb	r2, [r3, #5]
    8de2:	e7d0      	b.n	8d86 <hiddf_sof_event+0xf6>
				if (key_array[1].state == HID_KB_KEY_DOWN){
    8de4:	4b6f      	ldr	r3, [pc, #444]	; (8fa4 <hiddf_sof_event+0x314>)
    8de6:	795b      	ldrb	r3, [r3, #5]
    8de8:	2b01      	cmp	r3, #1
    8dea:	d027      	beq.n	8e3c <hiddf_sof_event+0x1ac>
	CRITICAL_SECTION_ENTER();
    8dec:	a802      	add	r0, sp, #8
    8dee:	4b70      	ldr	r3, [pc, #448]	; (8fb0 <hiddf_sof_event+0x320>)
    8df0:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    8df2:	23c0      	movs	r3, #192	; 0xc0
    8df4:	05db      	lsls	r3, r3, #23
    8df6:	2280      	movs	r2, #128	; 0x80
    8df8:	589c      	ldr	r4, [r3, r2]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    8dfa:	3220      	adds	r2, #32
    8dfc:	496d      	ldr	r1, [pc, #436]	; (8fb4 <hiddf_sof_event+0x324>)
    8dfe:	588a      	ldr	r2, [r1, r2]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    8e00:	2190      	movs	r1, #144	; 0x90
    8e02:	585b      	ldr	r3, [r3, r1]
	tmp |= hri_port_read_OUT_reg(PORT_IOBUS, port) & dir_tmp;
    8e04:	4053      	eors	r3, r2
    8e06:	401c      	ands	r4, r3
    8e08:	4054      	eors	r4, r2
	CRITICAL_SECTION_LEAVE();
    8e0a:	a802      	add	r0, sp, #8
    8e0c:	4b6a      	ldr	r3, [pc, #424]	; (8fb8 <hiddf_sof_event+0x328>)
    8e0e:	4798      	blx	r3
				if (gpio_get_pin_level(I3) == true){
    8e10:	05a3      	lsls	r3, r4, #22
    8e12:	d51a      	bpl.n	8e4a <hiddf_sof_event+0x1ba>
					if ((key_array[2].state == HID_KB_KEY_UP) && (key_array[4].state == HID_KB_KEY_UP)){
    8e14:	4b63      	ldr	r3, [pc, #396]	; (8fa4 <hiddf_sof_event+0x314>)
    8e16:	7a1b      	ldrb	r3, [r3, #8]
    8e18:	2b00      	cmp	r3, #0
    8e1a:	d11a      	bne.n	8e52 <hiddf_sof_event+0x1c2>
    8e1c:	4b61      	ldr	r3, [pc, #388]	; (8fa4 <hiddf_sof_event+0x314>)
    8e1e:	7b9b      	ldrb	r3, [r3, #14]
    8e20:	2b00      	cmp	r3, #0
    8e22:	d116      	bne.n	8e52 <hiddf_sof_event+0x1c2>
						key_array[2].state = HID_KB_KEY_DOWN;
    8e24:	3301      	adds	r3, #1
    8e26:	4a5f      	ldr	r2, [pc, #380]	; (8fa4 <hiddf_sof_event+0x314>)
    8e28:	7213      	strb	r3, [r2, #8]
						session_data.simulated_C=false;
    8e2a:	2100      	movs	r1, #0
    8e2c:	4a5c      	ldr	r2, [pc, #368]	; (8fa0 <hiddf_sof_event+0x310>)
    8e2e:	7211      	strb	r1, [r2, #8]
						key_changed=true;
    8e30:	4a59      	ldr	r2, [pc, #356]	; (8f98 <hiddf_sof_event+0x308>)
    8e32:	7153      	strb	r3, [r2, #5]
						beep_sound_length = BEEP_SOUND_LENGTH;
    8e34:	4a61      	ldr	r2, [pc, #388]	; (8fbc <hiddf_sof_event+0x32c>)
    8e36:	4b62      	ldr	r3, [pc, #392]	; (8fc0 <hiddf_sof_event+0x330>)
    8e38:	801a      	strh	r2, [r3, #0]
    8e3a:	e00a      	b.n	8e52 <hiddf_sof_event+0x1c2>
					key_array[1].state = HID_KB_KEY_UP;				//****************************** ksleltets!!!!!!!!!!!!!!!!!!!!!
    8e3c:	2200      	movs	r2, #0
    8e3e:	4b59      	ldr	r3, [pc, #356]	; (8fa4 <hiddf_sof_event+0x314>)
    8e40:	715a      	strb	r2, [r3, #5]
					key_changed=true;
    8e42:	3201      	adds	r2, #1
    8e44:	4b54      	ldr	r3, [pc, #336]	; (8f98 <hiddf_sof_event+0x308>)
    8e46:	715a      	strb	r2, [r3, #5]
    8e48:	e7d0      	b.n	8dec <hiddf_sof_event+0x15c>
					if (key_array[2].state == HID_KB_KEY_DOWN){
    8e4a:	4b56      	ldr	r3, [pc, #344]	; (8fa4 <hiddf_sof_event+0x314>)
    8e4c:	7a1b      	ldrb	r3, [r3, #8]
    8e4e:	2b01      	cmp	r3, #1
    8e50:	d029      	beq.n	8ea6 <hiddf_sof_event+0x216>
	CRITICAL_SECTION_ENTER();
    8e52:	a803      	add	r0, sp, #12
    8e54:	4b56      	ldr	r3, [pc, #344]	; (8fb0 <hiddf_sof_event+0x320>)
    8e56:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    8e58:	23c0      	movs	r3, #192	; 0xc0
    8e5a:	05db      	lsls	r3, r3, #23
    8e5c:	2280      	movs	r2, #128	; 0x80
    8e5e:	589c      	ldr	r4, [r3, r2]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    8e60:	3220      	adds	r2, #32
    8e62:	4954      	ldr	r1, [pc, #336]	; (8fb4 <hiddf_sof_event+0x324>)
    8e64:	588a      	ldr	r2, [r1, r2]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    8e66:	2190      	movs	r1, #144	; 0x90
    8e68:	585b      	ldr	r3, [r3, r1]
	tmp |= hri_port_read_OUT_reg(PORT_IOBUS, port) & dir_tmp;
    8e6a:	4053      	eors	r3, r2
    8e6c:	401c      	ands	r4, r3
    8e6e:	4054      	eors	r4, r2
	CRITICAL_SECTION_LEAVE();
    8e70:	a803      	add	r0, sp, #12
    8e72:	4b51      	ldr	r3, [pc, #324]	; (8fb8 <hiddf_sof_event+0x328>)
    8e74:	4798      	blx	r3
			if (gpio_get_pin_level(I4) == true){
    8e76:	0463      	lsls	r3, r4, #17
    8e78:	d51c      	bpl.n	8eb4 <hiddf_sof_event+0x224>
				if ((key_array[3].state == HID_KB_KEY_UP) && (key_array[4].state == HID_KB_KEY_UP)){
    8e7a:	4b4a      	ldr	r3, [pc, #296]	; (8fa4 <hiddf_sof_event+0x314>)
    8e7c:	7adb      	ldrb	r3, [r3, #11]
    8e7e:	2b00      	cmp	r3, #0
    8e80:	d000      	beq.n	8e84 <hiddf_sof_event+0x1f4>
    8e82:	e740      	b.n	8d06 <hiddf_sof_event+0x76>
    8e84:	4b47      	ldr	r3, [pc, #284]	; (8fa4 <hiddf_sof_event+0x314>)
    8e86:	7b9b      	ldrb	r3, [r3, #14]
    8e88:	2b00      	cmp	r3, #0
    8e8a:	d000      	beq.n	8e8e <hiddf_sof_event+0x1fe>
    8e8c:	e73b      	b.n	8d06 <hiddf_sof_event+0x76>
					key_array[3].state = HID_KB_KEY_DOWN;
    8e8e:	3301      	adds	r3, #1
    8e90:	4a44      	ldr	r2, [pc, #272]	; (8fa4 <hiddf_sof_event+0x314>)
    8e92:	72d3      	strb	r3, [r2, #11]
					session_data.simulated_D=false;
    8e94:	2100      	movs	r1, #0
    8e96:	4a42      	ldr	r2, [pc, #264]	; (8fa0 <hiddf_sof_event+0x310>)
    8e98:	7251      	strb	r1, [r2, #9]
					key_changed=true;
    8e9a:	4a3f      	ldr	r2, [pc, #252]	; (8f98 <hiddf_sof_event+0x308>)
    8e9c:	7153      	strb	r3, [r2, #5]
					beep_sound_length = BEEP_SOUND_LENGTH;
    8e9e:	4a47      	ldr	r2, [pc, #284]	; (8fbc <hiddf_sof_event+0x32c>)
    8ea0:	4b47      	ldr	r3, [pc, #284]	; (8fc0 <hiddf_sof_event+0x330>)
    8ea2:	801a      	strh	r2, [r3, #0]
    8ea4:	e72f      	b.n	8d06 <hiddf_sof_event+0x76>
						key_array[2].state = HID_KB_KEY_UP;
    8ea6:	2200      	movs	r2, #0
    8ea8:	4b3e      	ldr	r3, [pc, #248]	; (8fa4 <hiddf_sof_event+0x314>)
    8eaa:	721a      	strb	r2, [r3, #8]
						key_changed=true;
    8eac:	3201      	adds	r2, #1
    8eae:	4b3a      	ldr	r3, [pc, #232]	; (8f98 <hiddf_sof_event+0x308>)
    8eb0:	715a      	strb	r2, [r3, #5]
    8eb2:	e7ce      	b.n	8e52 <hiddf_sof_event+0x1c2>
				if (key_array[3].state == HID_KB_KEY_DOWN){
    8eb4:	4b3b      	ldr	r3, [pc, #236]	; (8fa4 <hiddf_sof_event+0x314>)
    8eb6:	7adb      	ldrb	r3, [r3, #11]
    8eb8:	2b01      	cmp	r3, #1
    8eba:	d000      	beq.n	8ebe <hiddf_sof_event+0x22e>
    8ebc:	e723      	b.n	8d06 <hiddf_sof_event+0x76>
					key_array[3].state = HID_KB_KEY_UP;
    8ebe:	2200      	movs	r2, #0
    8ec0:	4b38      	ldr	r3, [pc, #224]	; (8fa4 <hiddf_sof_event+0x314>)
    8ec2:	72da      	strb	r2, [r3, #11]
					key_changed=true;
    8ec4:	3201      	adds	r2, #1
    8ec6:	4b34      	ldr	r3, [pc, #208]	; (8f98 <hiddf_sof_event+0x308>)
    8ec8:	715a      	strb	r2, [r3, #5]
    8eca:	e71c      	b.n	8d06 <hiddf_sof_event+0x76>
	else if ((session_data.manual_trigger) || (session_data.simulation_mode)) {		
    8ecc:	4b34      	ldr	r3, [pc, #208]	; (8fa0 <hiddf_sof_event+0x310>)
    8ece:	791b      	ldrb	r3, [r3, #4]
    8ed0:	2b00      	cmp	r3, #0
    8ed2:	d104      	bne.n	8ede <hiddf_sof_event+0x24e>
    8ed4:	4b32      	ldr	r3, [pc, #200]	; (8fa0 <hiddf_sof_event+0x310>)
    8ed6:	78db      	ldrb	r3, [r3, #3]
    8ed8:	2b00      	cmp	r3, #0
    8eda:	d100      	bne.n	8ede <hiddf_sof_event+0x24e>
    8edc:	e0b6      	b.n	904c <hiddf_sof_event+0x3bc>
		if (session_data.trigger){
    8ede:	4b30      	ldr	r3, [pc, #192]	; (8fa0 <hiddf_sof_event+0x310>)
    8ee0:	795b      	ldrb	r3, [r3, #5]
    8ee2:	2b00      	cmp	r3, #0
    8ee4:	d017      	beq.n	8f16 <hiddf_sof_event+0x286>
			if (key_array[4].state == HID_KB_KEY_UP){
    8ee6:	4b2f      	ldr	r3, [pc, #188]	; (8fa4 <hiddf_sof_event+0x314>)
    8ee8:	7b9b      	ldrb	r3, [r3, #14]
    8eea:	2b00      	cmp	r3, #0
    8eec:	d105      	bne.n	8efa <hiddf_sof_event+0x26a>
				key_array[4].state = HID_KB_KEY_DOWN;
    8eee:	3301      	adds	r3, #1
    8ef0:	4a2c      	ldr	r2, [pc, #176]	; (8fa4 <hiddf_sof_event+0x314>)
    8ef2:	7393      	strb	r3, [r2, #14]
				key_changed=true;
    8ef4:	4a28      	ldr	r2, [pc, #160]	; (8f98 <hiddf_sof_event+0x308>)
    8ef6:	7153      	strb	r3, [r2, #5]
    8ef8:	e705      	b.n	8d06 <hiddf_sof_event+0x76>
				trigger_delay += 1;
    8efa:	4a27      	ldr	r2, [pc, #156]	; (8f98 <hiddf_sof_event+0x308>)
    8efc:	7993      	ldrb	r3, [r2, #6]
    8efe:	3301      	adds	r3, #1
    8f00:	b2db      	uxtb	r3, r3
    8f02:	7193      	strb	r3, [r2, #6]
				if (trigger_delay > 10){
    8f04:	2b0a      	cmp	r3, #10
    8f06:	d800      	bhi.n	8f0a <hiddf_sof_event+0x27a>
    8f08:	e6fd      	b.n	8d06 <hiddf_sof_event+0x76>
					session_data.trigger = false;
    8f0a:	2300      	movs	r3, #0
    8f0c:	4a24      	ldr	r2, [pc, #144]	; (8fa0 <hiddf_sof_event+0x310>)
    8f0e:	7153      	strb	r3, [r2, #5]
					trigger_delay = 0;
    8f10:	4a21      	ldr	r2, [pc, #132]	; (8f98 <hiddf_sof_event+0x308>)
    8f12:	7193      	strb	r3, [r2, #6]
    8f14:	e6f7      	b.n	8d06 <hiddf_sof_event+0x76>
		else if (key_array[4].state == HID_KB_KEY_DOWN){
    8f16:	4b23      	ldr	r3, [pc, #140]	; (8fa4 <hiddf_sof_event+0x314>)
    8f18:	7b9b      	ldrb	r3, [r3, #14]
    8f1a:	2b01      	cmp	r3, #1
    8f1c:	d014      	beq.n	8f48 <hiddf_sof_event+0x2b8>
		else if (!repress_delay){ 
    8f1e:	4a1e      	ldr	r2, [pc, #120]	; (8f98 <hiddf_sof_event+0x308>)
    8f20:	7912      	ldrb	r2, [r2, #4]
    8f22:	2a00      	cmp	r2, #0
    8f24:	d000      	beq.n	8f28 <hiddf_sof_event+0x298>
    8f26:	e6ee      	b.n	8d06 <hiddf_sof_event+0x76>
			if  (session_data.simulated_A){
    8f28:	4a1d      	ldr	r2, [pc, #116]	; (8fa0 <hiddf_sof_event+0x310>)
    8f2a:	7992      	ldrb	r2, [r2, #6]
    8f2c:	2a00      	cmp	r2, #0
    8f2e:	d018      	beq.n	8f62 <hiddf_sof_event+0x2d2>
				if ((key_array[0].state == HID_KB_KEY_UP) && (key_array[4].state == HID_KB_KEY_UP)){		//****************************** ksleltets!!!!!!!!!!!!!!!!!!!!!
    8f30:	4a1c      	ldr	r2, [pc, #112]	; (8fa4 <hiddf_sof_event+0x314>)
    8f32:	7892      	ldrb	r2, [r2, #2]
    8f34:	2a00      	cmp	r2, #0
    8f36:	d118      	bne.n	8f6a <hiddf_sof_event+0x2da>
    8f38:	2b00      	cmp	r3, #0
    8f3a:	d116      	bne.n	8f6a <hiddf_sof_event+0x2da>
					key_array[0].state = HID_KB_KEY_DOWN;
    8f3c:	3201      	adds	r2, #1
    8f3e:	4919      	ldr	r1, [pc, #100]	; (8fa4 <hiddf_sof_event+0x314>)
    8f40:	708a      	strb	r2, [r1, #2]
					key_changed=true;
    8f42:	4915      	ldr	r1, [pc, #84]	; (8f98 <hiddf_sof_event+0x308>)
    8f44:	714a      	strb	r2, [r1, #5]
    8f46:	e010      	b.n	8f6a <hiddf_sof_event+0x2da>
			key_array[4].state = HID_KB_KEY_UP;
    8f48:	4b16      	ldr	r3, [pc, #88]	; (8fa4 <hiddf_sof_event+0x314>)
    8f4a:	2200      	movs	r2, #0
    8f4c:	739a      	strb	r2, [r3, #14]
			key_array[0].state = HID_KB_KEY_UP;
    8f4e:	709a      	strb	r2, [r3, #2]
			key_array[1].state = HID_KB_KEY_UP;
    8f50:	715a      	strb	r2, [r3, #5]
			key_array[2].state = HID_KB_KEY_UP;
    8f52:	721a      	strb	r2, [r3, #8]
			key_array[3].state = HID_KB_KEY_UP;
    8f54:	72da      	strb	r2, [r3, #11]
			key_changed=true;
    8f56:	4b10      	ldr	r3, [pc, #64]	; (8f98 <hiddf_sof_event+0x308>)
    8f58:	3201      	adds	r2, #1
    8f5a:	715a      	strb	r2, [r3, #5]
			repress_delay=10;
    8f5c:	3209      	adds	r2, #9
    8f5e:	711a      	strb	r2, [r3, #4]
    8f60:	e6d1      	b.n	8d06 <hiddf_sof_event+0x76>
				if (key_array[0].state == HID_KB_KEY_DOWN){
    8f62:	4a10      	ldr	r2, [pc, #64]	; (8fa4 <hiddf_sof_event+0x314>)
    8f64:	7892      	ldrb	r2, [r2, #2]
    8f66:	2a01      	cmp	r2, #1
    8f68:	d00f      	beq.n	8f8a <hiddf_sof_event+0x2fa>
			if (session_data.simulated_B){
    8f6a:	4a0d      	ldr	r2, [pc, #52]	; (8fa0 <hiddf_sof_event+0x310>)
    8f6c:	79d2      	ldrb	r2, [r2, #7]
    8f6e:	2a00      	cmp	r2, #0
    8f70:	d028      	beq.n	8fc4 <hiddf_sof_event+0x334>
				if ((key_array[1].state == HID_KB_KEY_UP) && (key_array[4].state == HID_KB_KEY_UP)){		//****************************** ksleltets!!!!!!!!!!!!!!!!!!!!!
    8f72:	4a0c      	ldr	r2, [pc, #48]	; (8fa4 <hiddf_sof_event+0x314>)
    8f74:	7952      	ldrb	r2, [r2, #5]
    8f76:	2a00      	cmp	r2, #0
    8f78:	d128      	bne.n	8fcc <hiddf_sof_event+0x33c>
    8f7a:	2b00      	cmp	r3, #0
    8f7c:	d126      	bne.n	8fcc <hiddf_sof_event+0x33c>
					key_array[1].state = HID_KB_KEY_DOWN;
    8f7e:	3201      	adds	r2, #1
    8f80:	4908      	ldr	r1, [pc, #32]	; (8fa4 <hiddf_sof_event+0x314>)
    8f82:	714a      	strb	r2, [r1, #5]
					key_changed=true;
    8f84:	4904      	ldr	r1, [pc, #16]	; (8f98 <hiddf_sof_event+0x308>)
    8f86:	714a      	strb	r2, [r1, #5]
    8f88:	e020      	b.n	8fcc <hiddf_sof_event+0x33c>
					key_array[0].state = HID_KB_KEY_UP;				//****************************** ksleltets!!!!!!!!!!!!!!!!!!!!!
    8f8a:	2100      	movs	r1, #0
    8f8c:	4a05      	ldr	r2, [pc, #20]	; (8fa4 <hiddf_sof_event+0x314>)
    8f8e:	7091      	strb	r1, [r2, #2]
					key_changed=true;
    8f90:	3101      	adds	r1, #1
    8f92:	4a01      	ldr	r2, [pc, #4]	; (8f98 <hiddf_sof_event+0x308>)
    8f94:	7151      	strb	r1, [r2, #5]
    8f96:	e7e8      	b.n	8f6a <hiddf_sof_event+0x2da>
    8f98:	200008b0 	.word	0x200008b0
    8f9c:	20000180 	.word	0x20000180
    8fa0:	20000a3c 	.word	0x20000a3c
    8fa4:	20000024 	.word	0x20000024
    8fa8:	000003d6 	.word	0x000003d6
    8fac:	20000182 	.word	0x20000182
    8fb0:	00001271 	.word	0x00001271
    8fb4:	41004400 	.word	0x41004400
    8fb8:	0000127f 	.word	0x0000127f
    8fbc:	0000047c 	.word	0x0000047c
    8fc0:	20000184 	.word	0x20000184
				if (key_array[1].state == HID_KB_KEY_DOWN){
    8fc4:	4a41      	ldr	r2, [pc, #260]	; (90cc <hiddf_sof_event+0x43c>)
    8fc6:	7952      	ldrb	r2, [r2, #5]
    8fc8:	2a01      	cmp	r2, #1
    8fca:	d00f      	beq.n	8fec <hiddf_sof_event+0x35c>
				if (session_data.simulated_C){
    8fcc:	4a40      	ldr	r2, [pc, #256]	; (90d0 <hiddf_sof_event+0x440>)
    8fce:	7a12      	ldrb	r2, [r2, #8]
    8fd0:	2a00      	cmp	r2, #0
    8fd2:	d012      	beq.n	8ffa <hiddf_sof_event+0x36a>
					if ((key_array[2].state == HID_KB_KEY_UP) && (key_array[4].state == HID_KB_KEY_UP)){
    8fd4:	4a3d      	ldr	r2, [pc, #244]	; (90cc <hiddf_sof_event+0x43c>)
    8fd6:	7a12      	ldrb	r2, [r2, #8]
    8fd8:	2a00      	cmp	r2, #0
    8fda:	d112      	bne.n	9002 <hiddf_sof_event+0x372>
    8fdc:	2b00      	cmp	r3, #0
    8fde:	d110      	bne.n	9002 <hiddf_sof_event+0x372>
						key_array[2].state = HID_KB_KEY_DOWN;
    8fe0:	3201      	adds	r2, #1
    8fe2:	493a      	ldr	r1, [pc, #232]	; (90cc <hiddf_sof_event+0x43c>)
    8fe4:	720a      	strb	r2, [r1, #8]
						key_changed=true;
    8fe6:	493b      	ldr	r1, [pc, #236]	; (90d4 <hiddf_sof_event+0x444>)
    8fe8:	714a      	strb	r2, [r1, #5]
    8fea:	e00a      	b.n	9002 <hiddf_sof_event+0x372>
					key_array[1].state = HID_KB_KEY_UP;				//****************************** ksleltets!!!!!!!!!!!!!!!!!!!!!
    8fec:	2100      	movs	r1, #0
    8fee:	4a37      	ldr	r2, [pc, #220]	; (90cc <hiddf_sof_event+0x43c>)
    8ff0:	7151      	strb	r1, [r2, #5]
					key_changed=true;
    8ff2:	3101      	adds	r1, #1
    8ff4:	4a37      	ldr	r2, [pc, #220]	; (90d4 <hiddf_sof_event+0x444>)
    8ff6:	7151      	strb	r1, [r2, #5]
    8ff8:	e7e8      	b.n	8fcc <hiddf_sof_event+0x33c>
					if (key_array[2].state == HID_KB_KEY_DOWN){
    8ffa:	4a34      	ldr	r2, [pc, #208]	; (90cc <hiddf_sof_event+0x43c>)
    8ffc:	7a12      	ldrb	r2, [r2, #8]
    8ffe:	2a01      	cmp	r2, #1
    9000:	d011      	beq.n	9026 <hiddf_sof_event+0x396>
			if (session_data.simulated_D){
    9002:	4a33      	ldr	r2, [pc, #204]	; (90d0 <hiddf_sof_event+0x440>)
    9004:	7a52      	ldrb	r2, [r2, #9]
    9006:	2a00      	cmp	r2, #0
    9008:	d014      	beq.n	9034 <hiddf_sof_event+0x3a4>
				if ((key_array[3].state == HID_KB_KEY_UP) && (key_array[4].state == HID_KB_KEY_UP)){
    900a:	4a30      	ldr	r2, [pc, #192]	; (90cc <hiddf_sof_event+0x43c>)
    900c:	7ad2      	ldrb	r2, [r2, #11]
    900e:	2a00      	cmp	r2, #0
    9010:	d000      	beq.n	9014 <hiddf_sof_event+0x384>
    9012:	e678      	b.n	8d06 <hiddf_sof_event+0x76>
    9014:	2b00      	cmp	r3, #0
    9016:	d000      	beq.n	901a <hiddf_sof_event+0x38a>
    9018:	e675      	b.n	8d06 <hiddf_sof_event+0x76>
					key_array[3].state = HID_KB_KEY_DOWN;
    901a:	3301      	adds	r3, #1
    901c:	4a2b      	ldr	r2, [pc, #172]	; (90cc <hiddf_sof_event+0x43c>)
    901e:	72d3      	strb	r3, [r2, #11]
					key_changed=true;
    9020:	4a2c      	ldr	r2, [pc, #176]	; (90d4 <hiddf_sof_event+0x444>)
    9022:	7153      	strb	r3, [r2, #5]
    9024:	e66f      	b.n	8d06 <hiddf_sof_event+0x76>
						key_array[2].state = HID_KB_KEY_UP;
    9026:	2100      	movs	r1, #0
    9028:	4a28      	ldr	r2, [pc, #160]	; (90cc <hiddf_sof_event+0x43c>)
    902a:	7211      	strb	r1, [r2, #8]
						key_changed=true;
    902c:	3101      	adds	r1, #1
    902e:	4a29      	ldr	r2, [pc, #164]	; (90d4 <hiddf_sof_event+0x444>)
    9030:	7151      	strb	r1, [r2, #5]
    9032:	e7e6      	b.n	9002 <hiddf_sof_event+0x372>
				if (key_array[3].state == HID_KB_KEY_DOWN){
    9034:	4b25      	ldr	r3, [pc, #148]	; (90cc <hiddf_sof_event+0x43c>)
    9036:	7adb      	ldrb	r3, [r3, #11]
    9038:	2b01      	cmp	r3, #1
    903a:	d000      	beq.n	903e <hiddf_sof_event+0x3ae>
    903c:	e663      	b.n	8d06 <hiddf_sof_event+0x76>
					key_array[3].state = HID_KB_KEY_UP;
    903e:	2200      	movs	r2, #0
    9040:	4b22      	ldr	r3, [pc, #136]	; (90cc <hiddf_sof_event+0x43c>)
    9042:	72da      	strb	r2, [r3, #11]
					key_changed=true;
    9044:	3201      	adds	r2, #1
    9046:	4b23      	ldr	r3, [pc, #140]	; (90d4 <hiddf_sof_event+0x444>)
    9048:	715a      	strb	r2, [r3, #5]
    904a:	e65c      	b.n	8d06 <hiddf_sof_event+0x76>
		if (key_array[0].state == HID_KB_KEY_DOWN){
    904c:	4b1f      	ldr	r3, [pc, #124]	; (90cc <hiddf_sof_event+0x43c>)
    904e:	789b      	ldrb	r3, [r3, #2]
    9050:	2b01      	cmp	r3, #1
    9052:	d017      	beq.n	9084 <hiddf_sof_event+0x3f4>
		if (key_array[1].state == HID_KB_KEY_DOWN){
    9054:	4b1d      	ldr	r3, [pc, #116]	; (90cc <hiddf_sof_event+0x43c>)
    9056:	795b      	ldrb	r3, [r3, #5]
    9058:	2b01      	cmp	r3, #1
    905a:	d01a      	beq.n	9092 <hiddf_sof_event+0x402>
		if (key_array[2].state == HID_KB_KEY_DOWN){
    905c:	4b1b      	ldr	r3, [pc, #108]	; (90cc <hiddf_sof_event+0x43c>)
    905e:	7a1b      	ldrb	r3, [r3, #8]
    9060:	2b01      	cmp	r3, #1
    9062:	d01d      	beq.n	90a0 <hiddf_sof_event+0x410>
		if (key_array[3].state == HID_KB_KEY_DOWN){
    9064:	4b19      	ldr	r3, [pc, #100]	; (90cc <hiddf_sof_event+0x43c>)
    9066:	7adb      	ldrb	r3, [r3, #11]
    9068:	2b01      	cmp	r3, #1
    906a:	d020      	beq.n	90ae <hiddf_sof_event+0x41e>
		if (key_array[4].state == HID_KB_KEY_DOWN){
    906c:	4b17      	ldr	r3, [pc, #92]	; (90cc <hiddf_sof_event+0x43c>)
    906e:	7b9b      	ldrb	r3, [r3, #14]
    9070:	2b01      	cmp	r3, #1
    9072:	d000      	beq.n	9076 <hiddf_sof_event+0x3e6>
    9074:	e647      	b.n	8d06 <hiddf_sof_event+0x76>
			key_array[4].state = HID_KB_KEY_UP;
    9076:	2200      	movs	r2, #0
    9078:	4b14      	ldr	r3, [pc, #80]	; (90cc <hiddf_sof_event+0x43c>)
    907a:	739a      	strb	r2, [r3, #14]
			key_changed=true;			
    907c:	3201      	adds	r2, #1
    907e:	4b15      	ldr	r3, [pc, #84]	; (90d4 <hiddf_sof_event+0x444>)
    9080:	715a      	strb	r2, [r3, #5]
    9082:	e640      	b.n	8d06 <hiddf_sof_event+0x76>
			key_array[0].state = HID_KB_KEY_UP;
    9084:	2200      	movs	r2, #0
    9086:	4b11      	ldr	r3, [pc, #68]	; (90cc <hiddf_sof_event+0x43c>)
    9088:	709a      	strb	r2, [r3, #2]
			key_changed=true;
    908a:	3201      	adds	r2, #1
    908c:	4b11      	ldr	r3, [pc, #68]	; (90d4 <hiddf_sof_event+0x444>)
    908e:	715a      	strb	r2, [r3, #5]
    9090:	e7e0      	b.n	9054 <hiddf_sof_event+0x3c4>
			key_array[1].state = HID_KB_KEY_UP;
    9092:	2200      	movs	r2, #0
    9094:	4b0d      	ldr	r3, [pc, #52]	; (90cc <hiddf_sof_event+0x43c>)
    9096:	715a      	strb	r2, [r3, #5]
			key_changed=true;
    9098:	3201      	adds	r2, #1
    909a:	4b0e      	ldr	r3, [pc, #56]	; (90d4 <hiddf_sof_event+0x444>)
    909c:	715a      	strb	r2, [r3, #5]
    909e:	e7dd      	b.n	905c <hiddf_sof_event+0x3cc>
			key_array[2].state = HID_KB_KEY_UP;
    90a0:	2200      	movs	r2, #0
    90a2:	4b0a      	ldr	r3, [pc, #40]	; (90cc <hiddf_sof_event+0x43c>)
    90a4:	721a      	strb	r2, [r3, #8]
			key_changed=true;
    90a6:	3201      	adds	r2, #1
    90a8:	4b0a      	ldr	r3, [pc, #40]	; (90d4 <hiddf_sof_event+0x444>)
    90aa:	715a      	strb	r2, [r3, #5]
    90ac:	e7da      	b.n	9064 <hiddf_sof_event+0x3d4>
			key_array[3].state = HID_KB_KEY_UP;
    90ae:	2200      	movs	r2, #0
    90b0:	4b06      	ldr	r3, [pc, #24]	; (90cc <hiddf_sof_event+0x43c>)
    90b2:	72da      	strb	r2, [r3, #11]
			key_changed=true;			
    90b4:	3201      	adds	r2, #1
    90b6:	4b07      	ldr	r3, [pc, #28]	; (90d4 <hiddf_sof_event+0x444>)
    90b8:	715a      	strb	r2, [r3, #5]
    90ba:	e7d7      	b.n	906c <hiddf_sof_event+0x3dc>
		hiddf_keyboard_keys_state_change(key_array, 5);
    90bc:	2105      	movs	r1, #5
    90be:	4803      	ldr	r0, [pc, #12]	; (90cc <hiddf_sof_event+0x43c>)
    90c0:	4b05      	ldr	r3, [pc, #20]	; (90d8 <hiddf_sof_event+0x448>)
    90c2:	4798      	blx	r3
		key_changed = false;
    90c4:	2200      	movs	r2, #0
    90c6:	4b03      	ldr	r3, [pc, #12]	; (90d4 <hiddf_sof_event+0x444>)
    90c8:	715a      	strb	r2, [r3, #5]
}
    90ca:	e621      	b.n	8d10 <hiddf_sof_event+0x80>
    90cc:	20000024 	.word	0x20000024
    90d0:	20000a3c 	.word	0x20000a3c
    90d4:	200008b0 	.word	0x200008b0
    90d8:	000080e5 	.word	0x000080e5

000090dc <hiddf_init>:


static struct usbdc_handler hiddf_sof_event_h = {NULL, (FUNC_PTR)hiddf_sof_event};

void hiddf_init()
{
    90dc:	b510      	push	{r4, lr}
	usbdc_register_handler(USBDC_HDL_SOF, &hiddf_sof_event_h);
    90de:	4903      	ldr	r1, [pc, #12]	; (90ec <hiddf_init+0x10>)
    90e0:	3110      	adds	r1, #16
    90e2:	2000      	movs	r0, #0
    90e4:	4b02      	ldr	r3, [pc, #8]	; (90f0 <hiddf_init+0x14>)
    90e6:	4798      	blx	r3
}
    90e8:	bd10      	pop	{r4, pc}
    90ea:	46c0      	nop			; (mov r8, r8)
    90ec:	20000024 	.word	0x20000024
    90f0:	00008ac1 	.word	0x00008ac1

000090f4 <composite_device_init>:

void composite_device_init(void)
{
    90f4:	b570      	push	{r4, r5, r6, lr}
	printf("\r\nusbdc init\r\n");
    90f6:	480b      	ldr	r0, [pc, #44]	; (9124 <composite_device_init+0x30>)
    90f8:	4c0b      	ldr	r4, [pc, #44]	; (9128 <composite_device_init+0x34>)
    90fa:	47a0      	blx	r4
	/* usb stack init */
	usbdc_init(ctrl_buffer);
    90fc:	4d0b      	ldr	r5, [pc, #44]	; (912c <composite_device_init+0x38>)
    90fe:	0028      	movs	r0, r5
    9100:	3008      	adds	r0, #8
    9102:	4b0b      	ldr	r3, [pc, #44]	; (9130 <composite_device_init+0x3c>)
    9104:	4798      	blx	r3

	/* usbdc_register_funcion inside */
	printf("\r\ncdcf_acm init\r\n");
    9106:	480b      	ldr	r0, [pc, #44]	; (9134 <composite_device_init+0x40>)
    9108:	47a0      	blx	r4
	cdcdf_acm_init();
    910a:	4b0b      	ldr	r3, [pc, #44]	; (9138 <composite_device_init+0x44>)
    910c:	4798      	blx	r3

	hiddf_mouse_init(); //kell!!!!!!
    910e:	4b0b      	ldr	r3, [pc, #44]	; (913c <composite_device_init+0x48>)
    9110:	4798      	blx	r3
	printf("\r\nkeyboard init\r\n");
    9112:	480b      	ldr	r0, [pc, #44]	; (9140 <composite_device_init+0x4c>)
    9114:	47a0      	blx	r4
	key_changed=false;
    9116:	2300      	movs	r3, #0
    9118:	716b      	strb	r3, [r5, #5]
	hiddf_keyboard_init();
    911a:	4b0a      	ldr	r3, [pc, #40]	; (9144 <composite_device_init+0x50>)
    911c:	4798      	blx	r3
	hiddf_init();
    911e:	4b0a      	ldr	r3, [pc, #40]	; (9148 <composite_device_init+0x54>)
    9120:	4798      	blx	r3
}
    9122:	bd70      	pop	{r4, r5, r6, pc}
    9124:	0000ece4 	.word	0x0000ece4
    9128:	00009659 	.word	0x00009659
    912c:	200008b0 	.word	0x200008b0
    9130:	00008af9 	.word	0x00008af9
    9134:	0000ecf4 	.word	0x0000ecf4
    9138:	00007e45 	.word	0x00007e45
    913c:	00008379 	.word	0x00008379
    9140:	0000ed08 	.word	0x0000ed08
    9144:	00008095 	.word	0x00008095
    9148:	000090dd 	.word	0x000090dd

0000914c <composite_device_start>:

void composite_device_start(void)
{
    914c:	b510      	push	{r4, lr}
	printf("\r\nusbdc start\r\n");
    914e:	4806      	ldr	r0, [pc, #24]	; (9168 <composite_device_start+0x1c>)
    9150:	4c06      	ldr	r4, [pc, #24]	; (916c <composite_device_start+0x20>)
    9152:	47a0      	blx	r4
	usbdc_start(multi_desc);
    9154:	4806      	ldr	r0, [pc, #24]	; (9170 <composite_device_start+0x24>)
    9156:	3018      	adds	r0, #24
    9158:	4b06      	ldr	r3, [pc, #24]	; (9174 <composite_device_start+0x28>)
    915a:	4798      	blx	r3
	printf("\r\nusbdc attach\r\n");
    915c:	4806      	ldr	r0, [pc, #24]	; (9178 <composite_device_start+0x2c>)
    915e:	47a0      	blx	r4
	usbdc_attach();
    9160:	4b06      	ldr	r3, [pc, #24]	; (917c <composite_device_start+0x30>)
    9162:	4798      	blx	r3
}
    9164:	bd10      	pop	{r4, pc}
    9166:	46c0      	nop			; (mov r8, r8)
    9168:	0000ed1c 	.word	0x0000ed1c
    916c:	00009659 	.word	0x00009659
    9170:	20000024 	.word	0x20000024
    9174:	00008b71 	.word	0x00008b71
    9178:	0000ed2c 	.word	0x0000ed2c
    917c:	00008ba9 	.word	0x00008ba9

00009180 <usb_init>:

void usb_init(void)
{
    9180:	b510      	push	{r4, lr}
	printf("\r\ncomposite device init\r\n");
    9182:	4803      	ldr	r0, [pc, #12]	; (9190 <usb_init+0x10>)
    9184:	4b03      	ldr	r3, [pc, #12]	; (9194 <usb_init+0x14>)
    9186:	4798      	blx	r3
	composite_device_init();
    9188:	4b03      	ldr	r3, [pc, #12]	; (9198 <usb_init+0x18>)
    918a:	4798      	blx	r3
}
    918c:	bd10      	pop	{r4, pc}
    918e:	46c0      	nop			; (mov r8, r8)
    9190:	0000ed3c 	.word	0x0000ed3c
    9194:	00009659 	.word	0x00009659
    9198:	000090f5 	.word	0x000090f5

0000919c <__udivsi3>:
    919c:	2200      	movs	r2, #0
    919e:	0843      	lsrs	r3, r0, #1
    91a0:	428b      	cmp	r3, r1
    91a2:	d374      	bcc.n	928e <__udivsi3+0xf2>
    91a4:	0903      	lsrs	r3, r0, #4
    91a6:	428b      	cmp	r3, r1
    91a8:	d35f      	bcc.n	926a <__udivsi3+0xce>
    91aa:	0a03      	lsrs	r3, r0, #8
    91ac:	428b      	cmp	r3, r1
    91ae:	d344      	bcc.n	923a <__udivsi3+0x9e>
    91b0:	0b03      	lsrs	r3, r0, #12
    91b2:	428b      	cmp	r3, r1
    91b4:	d328      	bcc.n	9208 <__udivsi3+0x6c>
    91b6:	0c03      	lsrs	r3, r0, #16
    91b8:	428b      	cmp	r3, r1
    91ba:	d30d      	bcc.n	91d8 <__udivsi3+0x3c>
    91bc:	22ff      	movs	r2, #255	; 0xff
    91be:	0209      	lsls	r1, r1, #8
    91c0:	ba12      	rev	r2, r2
    91c2:	0c03      	lsrs	r3, r0, #16
    91c4:	428b      	cmp	r3, r1
    91c6:	d302      	bcc.n	91ce <__udivsi3+0x32>
    91c8:	1212      	asrs	r2, r2, #8
    91ca:	0209      	lsls	r1, r1, #8
    91cc:	d065      	beq.n	929a <__udivsi3+0xfe>
    91ce:	0b03      	lsrs	r3, r0, #12
    91d0:	428b      	cmp	r3, r1
    91d2:	d319      	bcc.n	9208 <__udivsi3+0x6c>
    91d4:	e000      	b.n	91d8 <__udivsi3+0x3c>
    91d6:	0a09      	lsrs	r1, r1, #8
    91d8:	0bc3      	lsrs	r3, r0, #15
    91da:	428b      	cmp	r3, r1
    91dc:	d301      	bcc.n	91e2 <__udivsi3+0x46>
    91de:	03cb      	lsls	r3, r1, #15
    91e0:	1ac0      	subs	r0, r0, r3
    91e2:	4152      	adcs	r2, r2
    91e4:	0b83      	lsrs	r3, r0, #14
    91e6:	428b      	cmp	r3, r1
    91e8:	d301      	bcc.n	91ee <__udivsi3+0x52>
    91ea:	038b      	lsls	r3, r1, #14
    91ec:	1ac0      	subs	r0, r0, r3
    91ee:	4152      	adcs	r2, r2
    91f0:	0b43      	lsrs	r3, r0, #13
    91f2:	428b      	cmp	r3, r1
    91f4:	d301      	bcc.n	91fa <__udivsi3+0x5e>
    91f6:	034b      	lsls	r3, r1, #13
    91f8:	1ac0      	subs	r0, r0, r3
    91fa:	4152      	adcs	r2, r2
    91fc:	0b03      	lsrs	r3, r0, #12
    91fe:	428b      	cmp	r3, r1
    9200:	d301      	bcc.n	9206 <__udivsi3+0x6a>
    9202:	030b      	lsls	r3, r1, #12
    9204:	1ac0      	subs	r0, r0, r3
    9206:	4152      	adcs	r2, r2
    9208:	0ac3      	lsrs	r3, r0, #11
    920a:	428b      	cmp	r3, r1
    920c:	d301      	bcc.n	9212 <__udivsi3+0x76>
    920e:	02cb      	lsls	r3, r1, #11
    9210:	1ac0      	subs	r0, r0, r3
    9212:	4152      	adcs	r2, r2
    9214:	0a83      	lsrs	r3, r0, #10
    9216:	428b      	cmp	r3, r1
    9218:	d301      	bcc.n	921e <__udivsi3+0x82>
    921a:	028b      	lsls	r3, r1, #10
    921c:	1ac0      	subs	r0, r0, r3
    921e:	4152      	adcs	r2, r2
    9220:	0a43      	lsrs	r3, r0, #9
    9222:	428b      	cmp	r3, r1
    9224:	d301      	bcc.n	922a <__udivsi3+0x8e>
    9226:	024b      	lsls	r3, r1, #9
    9228:	1ac0      	subs	r0, r0, r3
    922a:	4152      	adcs	r2, r2
    922c:	0a03      	lsrs	r3, r0, #8
    922e:	428b      	cmp	r3, r1
    9230:	d301      	bcc.n	9236 <__udivsi3+0x9a>
    9232:	020b      	lsls	r3, r1, #8
    9234:	1ac0      	subs	r0, r0, r3
    9236:	4152      	adcs	r2, r2
    9238:	d2cd      	bcs.n	91d6 <__udivsi3+0x3a>
    923a:	09c3      	lsrs	r3, r0, #7
    923c:	428b      	cmp	r3, r1
    923e:	d301      	bcc.n	9244 <__udivsi3+0xa8>
    9240:	01cb      	lsls	r3, r1, #7
    9242:	1ac0      	subs	r0, r0, r3
    9244:	4152      	adcs	r2, r2
    9246:	0983      	lsrs	r3, r0, #6
    9248:	428b      	cmp	r3, r1
    924a:	d301      	bcc.n	9250 <__udivsi3+0xb4>
    924c:	018b      	lsls	r3, r1, #6
    924e:	1ac0      	subs	r0, r0, r3
    9250:	4152      	adcs	r2, r2
    9252:	0943      	lsrs	r3, r0, #5
    9254:	428b      	cmp	r3, r1
    9256:	d301      	bcc.n	925c <__udivsi3+0xc0>
    9258:	014b      	lsls	r3, r1, #5
    925a:	1ac0      	subs	r0, r0, r3
    925c:	4152      	adcs	r2, r2
    925e:	0903      	lsrs	r3, r0, #4
    9260:	428b      	cmp	r3, r1
    9262:	d301      	bcc.n	9268 <__udivsi3+0xcc>
    9264:	010b      	lsls	r3, r1, #4
    9266:	1ac0      	subs	r0, r0, r3
    9268:	4152      	adcs	r2, r2
    926a:	08c3      	lsrs	r3, r0, #3
    926c:	428b      	cmp	r3, r1
    926e:	d301      	bcc.n	9274 <__udivsi3+0xd8>
    9270:	00cb      	lsls	r3, r1, #3
    9272:	1ac0      	subs	r0, r0, r3
    9274:	4152      	adcs	r2, r2
    9276:	0883      	lsrs	r3, r0, #2
    9278:	428b      	cmp	r3, r1
    927a:	d301      	bcc.n	9280 <__udivsi3+0xe4>
    927c:	008b      	lsls	r3, r1, #2
    927e:	1ac0      	subs	r0, r0, r3
    9280:	4152      	adcs	r2, r2
    9282:	0843      	lsrs	r3, r0, #1
    9284:	428b      	cmp	r3, r1
    9286:	d301      	bcc.n	928c <__udivsi3+0xf0>
    9288:	004b      	lsls	r3, r1, #1
    928a:	1ac0      	subs	r0, r0, r3
    928c:	4152      	adcs	r2, r2
    928e:	1a41      	subs	r1, r0, r1
    9290:	d200      	bcs.n	9294 <__udivsi3+0xf8>
    9292:	4601      	mov	r1, r0
    9294:	4152      	adcs	r2, r2
    9296:	4610      	mov	r0, r2
    9298:	4770      	bx	lr
    929a:	e7ff      	b.n	929c <__udivsi3+0x100>
    929c:	b501      	push	{r0, lr}
    929e:	2000      	movs	r0, #0
    92a0:	f000 f8f0 	bl	9484 <__aeabi_idiv0>
    92a4:	bd02      	pop	{r1, pc}
    92a6:	46c0      	nop			; (mov r8, r8)

000092a8 <__aeabi_uidivmod>:
    92a8:	2900      	cmp	r1, #0
    92aa:	d0f7      	beq.n	929c <__udivsi3+0x100>
    92ac:	e776      	b.n	919c <__udivsi3>
    92ae:	4770      	bx	lr

000092b0 <__divsi3>:
    92b0:	4603      	mov	r3, r0
    92b2:	430b      	orrs	r3, r1
    92b4:	d47f      	bmi.n	93b6 <__divsi3+0x106>
    92b6:	2200      	movs	r2, #0
    92b8:	0843      	lsrs	r3, r0, #1
    92ba:	428b      	cmp	r3, r1
    92bc:	d374      	bcc.n	93a8 <__divsi3+0xf8>
    92be:	0903      	lsrs	r3, r0, #4
    92c0:	428b      	cmp	r3, r1
    92c2:	d35f      	bcc.n	9384 <__divsi3+0xd4>
    92c4:	0a03      	lsrs	r3, r0, #8
    92c6:	428b      	cmp	r3, r1
    92c8:	d344      	bcc.n	9354 <__divsi3+0xa4>
    92ca:	0b03      	lsrs	r3, r0, #12
    92cc:	428b      	cmp	r3, r1
    92ce:	d328      	bcc.n	9322 <__divsi3+0x72>
    92d0:	0c03      	lsrs	r3, r0, #16
    92d2:	428b      	cmp	r3, r1
    92d4:	d30d      	bcc.n	92f2 <__divsi3+0x42>
    92d6:	22ff      	movs	r2, #255	; 0xff
    92d8:	0209      	lsls	r1, r1, #8
    92da:	ba12      	rev	r2, r2
    92dc:	0c03      	lsrs	r3, r0, #16
    92de:	428b      	cmp	r3, r1
    92e0:	d302      	bcc.n	92e8 <__divsi3+0x38>
    92e2:	1212      	asrs	r2, r2, #8
    92e4:	0209      	lsls	r1, r1, #8
    92e6:	d065      	beq.n	93b4 <__divsi3+0x104>
    92e8:	0b03      	lsrs	r3, r0, #12
    92ea:	428b      	cmp	r3, r1
    92ec:	d319      	bcc.n	9322 <__divsi3+0x72>
    92ee:	e000      	b.n	92f2 <__divsi3+0x42>
    92f0:	0a09      	lsrs	r1, r1, #8
    92f2:	0bc3      	lsrs	r3, r0, #15
    92f4:	428b      	cmp	r3, r1
    92f6:	d301      	bcc.n	92fc <__divsi3+0x4c>
    92f8:	03cb      	lsls	r3, r1, #15
    92fa:	1ac0      	subs	r0, r0, r3
    92fc:	4152      	adcs	r2, r2
    92fe:	0b83      	lsrs	r3, r0, #14
    9300:	428b      	cmp	r3, r1
    9302:	d301      	bcc.n	9308 <__divsi3+0x58>
    9304:	038b      	lsls	r3, r1, #14
    9306:	1ac0      	subs	r0, r0, r3
    9308:	4152      	adcs	r2, r2
    930a:	0b43      	lsrs	r3, r0, #13
    930c:	428b      	cmp	r3, r1
    930e:	d301      	bcc.n	9314 <__divsi3+0x64>
    9310:	034b      	lsls	r3, r1, #13
    9312:	1ac0      	subs	r0, r0, r3
    9314:	4152      	adcs	r2, r2
    9316:	0b03      	lsrs	r3, r0, #12
    9318:	428b      	cmp	r3, r1
    931a:	d301      	bcc.n	9320 <__divsi3+0x70>
    931c:	030b      	lsls	r3, r1, #12
    931e:	1ac0      	subs	r0, r0, r3
    9320:	4152      	adcs	r2, r2
    9322:	0ac3      	lsrs	r3, r0, #11
    9324:	428b      	cmp	r3, r1
    9326:	d301      	bcc.n	932c <__divsi3+0x7c>
    9328:	02cb      	lsls	r3, r1, #11
    932a:	1ac0      	subs	r0, r0, r3
    932c:	4152      	adcs	r2, r2
    932e:	0a83      	lsrs	r3, r0, #10
    9330:	428b      	cmp	r3, r1
    9332:	d301      	bcc.n	9338 <__divsi3+0x88>
    9334:	028b      	lsls	r3, r1, #10
    9336:	1ac0      	subs	r0, r0, r3
    9338:	4152      	adcs	r2, r2
    933a:	0a43      	lsrs	r3, r0, #9
    933c:	428b      	cmp	r3, r1
    933e:	d301      	bcc.n	9344 <__divsi3+0x94>
    9340:	024b      	lsls	r3, r1, #9
    9342:	1ac0      	subs	r0, r0, r3
    9344:	4152      	adcs	r2, r2
    9346:	0a03      	lsrs	r3, r0, #8
    9348:	428b      	cmp	r3, r1
    934a:	d301      	bcc.n	9350 <__divsi3+0xa0>
    934c:	020b      	lsls	r3, r1, #8
    934e:	1ac0      	subs	r0, r0, r3
    9350:	4152      	adcs	r2, r2
    9352:	d2cd      	bcs.n	92f0 <__divsi3+0x40>
    9354:	09c3      	lsrs	r3, r0, #7
    9356:	428b      	cmp	r3, r1
    9358:	d301      	bcc.n	935e <__divsi3+0xae>
    935a:	01cb      	lsls	r3, r1, #7
    935c:	1ac0      	subs	r0, r0, r3
    935e:	4152      	adcs	r2, r2
    9360:	0983      	lsrs	r3, r0, #6
    9362:	428b      	cmp	r3, r1
    9364:	d301      	bcc.n	936a <__divsi3+0xba>
    9366:	018b      	lsls	r3, r1, #6
    9368:	1ac0      	subs	r0, r0, r3
    936a:	4152      	adcs	r2, r2
    936c:	0943      	lsrs	r3, r0, #5
    936e:	428b      	cmp	r3, r1
    9370:	d301      	bcc.n	9376 <__divsi3+0xc6>
    9372:	014b      	lsls	r3, r1, #5
    9374:	1ac0      	subs	r0, r0, r3
    9376:	4152      	adcs	r2, r2
    9378:	0903      	lsrs	r3, r0, #4
    937a:	428b      	cmp	r3, r1
    937c:	d301      	bcc.n	9382 <__divsi3+0xd2>
    937e:	010b      	lsls	r3, r1, #4
    9380:	1ac0      	subs	r0, r0, r3
    9382:	4152      	adcs	r2, r2
    9384:	08c3      	lsrs	r3, r0, #3
    9386:	428b      	cmp	r3, r1
    9388:	d301      	bcc.n	938e <__divsi3+0xde>
    938a:	00cb      	lsls	r3, r1, #3
    938c:	1ac0      	subs	r0, r0, r3
    938e:	4152      	adcs	r2, r2
    9390:	0883      	lsrs	r3, r0, #2
    9392:	428b      	cmp	r3, r1
    9394:	d301      	bcc.n	939a <__divsi3+0xea>
    9396:	008b      	lsls	r3, r1, #2
    9398:	1ac0      	subs	r0, r0, r3
    939a:	4152      	adcs	r2, r2
    939c:	0843      	lsrs	r3, r0, #1
    939e:	428b      	cmp	r3, r1
    93a0:	d301      	bcc.n	93a6 <__divsi3+0xf6>
    93a2:	004b      	lsls	r3, r1, #1
    93a4:	1ac0      	subs	r0, r0, r3
    93a6:	4152      	adcs	r2, r2
    93a8:	1a41      	subs	r1, r0, r1
    93aa:	d200      	bcs.n	93ae <__divsi3+0xfe>
    93ac:	4601      	mov	r1, r0
    93ae:	4152      	adcs	r2, r2
    93b0:	4610      	mov	r0, r2
    93b2:	4770      	bx	lr
    93b4:	e05d      	b.n	9472 <__divsi3+0x1c2>
    93b6:	0fca      	lsrs	r2, r1, #31
    93b8:	d000      	beq.n	93bc <__divsi3+0x10c>
    93ba:	4249      	negs	r1, r1
    93bc:	1003      	asrs	r3, r0, #32
    93be:	d300      	bcc.n	93c2 <__divsi3+0x112>
    93c0:	4240      	negs	r0, r0
    93c2:	4053      	eors	r3, r2
    93c4:	2200      	movs	r2, #0
    93c6:	469c      	mov	ip, r3
    93c8:	0903      	lsrs	r3, r0, #4
    93ca:	428b      	cmp	r3, r1
    93cc:	d32d      	bcc.n	942a <__divsi3+0x17a>
    93ce:	0a03      	lsrs	r3, r0, #8
    93d0:	428b      	cmp	r3, r1
    93d2:	d312      	bcc.n	93fa <__divsi3+0x14a>
    93d4:	22fc      	movs	r2, #252	; 0xfc
    93d6:	0189      	lsls	r1, r1, #6
    93d8:	ba12      	rev	r2, r2
    93da:	0a03      	lsrs	r3, r0, #8
    93dc:	428b      	cmp	r3, r1
    93de:	d30c      	bcc.n	93fa <__divsi3+0x14a>
    93e0:	0189      	lsls	r1, r1, #6
    93e2:	1192      	asrs	r2, r2, #6
    93e4:	428b      	cmp	r3, r1
    93e6:	d308      	bcc.n	93fa <__divsi3+0x14a>
    93e8:	0189      	lsls	r1, r1, #6
    93ea:	1192      	asrs	r2, r2, #6
    93ec:	428b      	cmp	r3, r1
    93ee:	d304      	bcc.n	93fa <__divsi3+0x14a>
    93f0:	0189      	lsls	r1, r1, #6
    93f2:	d03a      	beq.n	946a <__divsi3+0x1ba>
    93f4:	1192      	asrs	r2, r2, #6
    93f6:	e000      	b.n	93fa <__divsi3+0x14a>
    93f8:	0989      	lsrs	r1, r1, #6
    93fa:	09c3      	lsrs	r3, r0, #7
    93fc:	428b      	cmp	r3, r1
    93fe:	d301      	bcc.n	9404 <__divsi3+0x154>
    9400:	01cb      	lsls	r3, r1, #7
    9402:	1ac0      	subs	r0, r0, r3
    9404:	4152      	adcs	r2, r2
    9406:	0983      	lsrs	r3, r0, #6
    9408:	428b      	cmp	r3, r1
    940a:	d301      	bcc.n	9410 <__divsi3+0x160>
    940c:	018b      	lsls	r3, r1, #6
    940e:	1ac0      	subs	r0, r0, r3
    9410:	4152      	adcs	r2, r2
    9412:	0943      	lsrs	r3, r0, #5
    9414:	428b      	cmp	r3, r1
    9416:	d301      	bcc.n	941c <__divsi3+0x16c>
    9418:	014b      	lsls	r3, r1, #5
    941a:	1ac0      	subs	r0, r0, r3
    941c:	4152      	adcs	r2, r2
    941e:	0903      	lsrs	r3, r0, #4
    9420:	428b      	cmp	r3, r1
    9422:	d301      	bcc.n	9428 <__divsi3+0x178>
    9424:	010b      	lsls	r3, r1, #4
    9426:	1ac0      	subs	r0, r0, r3
    9428:	4152      	adcs	r2, r2
    942a:	08c3      	lsrs	r3, r0, #3
    942c:	428b      	cmp	r3, r1
    942e:	d301      	bcc.n	9434 <__divsi3+0x184>
    9430:	00cb      	lsls	r3, r1, #3
    9432:	1ac0      	subs	r0, r0, r3
    9434:	4152      	adcs	r2, r2
    9436:	0883      	lsrs	r3, r0, #2
    9438:	428b      	cmp	r3, r1
    943a:	d301      	bcc.n	9440 <__divsi3+0x190>
    943c:	008b      	lsls	r3, r1, #2
    943e:	1ac0      	subs	r0, r0, r3
    9440:	4152      	adcs	r2, r2
    9442:	d2d9      	bcs.n	93f8 <__divsi3+0x148>
    9444:	0843      	lsrs	r3, r0, #1
    9446:	428b      	cmp	r3, r1
    9448:	d301      	bcc.n	944e <__divsi3+0x19e>
    944a:	004b      	lsls	r3, r1, #1
    944c:	1ac0      	subs	r0, r0, r3
    944e:	4152      	adcs	r2, r2
    9450:	1a41      	subs	r1, r0, r1
    9452:	d200      	bcs.n	9456 <__divsi3+0x1a6>
    9454:	4601      	mov	r1, r0
    9456:	4663      	mov	r3, ip
    9458:	4152      	adcs	r2, r2
    945a:	105b      	asrs	r3, r3, #1
    945c:	4610      	mov	r0, r2
    945e:	d301      	bcc.n	9464 <__divsi3+0x1b4>
    9460:	4240      	negs	r0, r0
    9462:	2b00      	cmp	r3, #0
    9464:	d500      	bpl.n	9468 <__divsi3+0x1b8>
    9466:	4249      	negs	r1, r1
    9468:	4770      	bx	lr
    946a:	4663      	mov	r3, ip
    946c:	105b      	asrs	r3, r3, #1
    946e:	d300      	bcc.n	9472 <__divsi3+0x1c2>
    9470:	4240      	negs	r0, r0
    9472:	b501      	push	{r0, lr}
    9474:	2000      	movs	r0, #0
    9476:	f000 f805 	bl	9484 <__aeabi_idiv0>
    947a:	bd02      	pop	{r1, pc}

0000947c <__aeabi_idivmod>:
    947c:	2900      	cmp	r1, #0
    947e:	d0f8      	beq.n	9472 <__divsi3+0x1c2>
    9480:	e716      	b.n	92b0 <__divsi3>
    9482:	4770      	bx	lr

00009484 <__aeabi_idiv0>:
    9484:	4770      	bx	lr
    9486:	46c0      	nop			; (mov r8, r8)

00009488 <__ffssi2>:
    9488:	b510      	push	{r4, lr}
    948a:	2300      	movs	r3, #0
    948c:	2800      	cmp	r0, #0
    948e:	d002      	beq.n	9496 <__ffssi2+0xe>
    9490:	f000 f804 	bl	949c <__ctzsi2>
    9494:	1c43      	adds	r3, r0, #1
    9496:	0018      	movs	r0, r3
    9498:	bd10      	pop	{r4, pc}
    949a:	46c0      	nop			; (mov r8, r8)

0000949c <__ctzsi2>:
    949c:	4241      	negs	r1, r0
    949e:	4008      	ands	r0, r1
    94a0:	211c      	movs	r1, #28
    94a2:	2301      	movs	r3, #1
    94a4:	041b      	lsls	r3, r3, #16
    94a6:	4298      	cmp	r0, r3
    94a8:	d301      	bcc.n	94ae <__ctzsi2+0x12>
    94aa:	0c00      	lsrs	r0, r0, #16
    94ac:	3910      	subs	r1, #16
    94ae:	0a1b      	lsrs	r3, r3, #8
    94b0:	4298      	cmp	r0, r3
    94b2:	d301      	bcc.n	94b8 <__ctzsi2+0x1c>
    94b4:	0a00      	lsrs	r0, r0, #8
    94b6:	3908      	subs	r1, #8
    94b8:	091b      	lsrs	r3, r3, #4
    94ba:	4298      	cmp	r0, r3
    94bc:	d301      	bcc.n	94c2 <__ctzsi2+0x26>
    94be:	0900      	lsrs	r0, r0, #4
    94c0:	3904      	subs	r1, #4
    94c2:	a202      	add	r2, pc, #8	; (adr r2, 94cc <__ctzsi2+0x30>)
    94c4:	5c10      	ldrb	r0, [r2, r0]
    94c6:	1a40      	subs	r0, r0, r1
    94c8:	4770      	bx	lr
    94ca:	46c0      	nop			; (mov r8, r8)
    94cc:	1d1d1c1b 	.word	0x1d1d1c1b
    94d0:	1e1e1e1e 	.word	0x1e1e1e1e
    94d4:	1f1f1f1f 	.word	0x1f1f1f1f
    94d8:	1f1f1f1f 	.word	0x1f1f1f1f

000094dc <__libc_init_array>:
    94dc:	b570      	push	{r4, r5, r6, lr}
    94de:	2600      	movs	r6, #0
    94e0:	4d0c      	ldr	r5, [pc, #48]	; (9514 <__libc_init_array+0x38>)
    94e2:	4c0d      	ldr	r4, [pc, #52]	; (9518 <__libc_init_array+0x3c>)
    94e4:	1b64      	subs	r4, r4, r5
    94e6:	10a4      	asrs	r4, r4, #2
    94e8:	42a6      	cmp	r6, r4
    94ea:	d109      	bne.n	9500 <__libc_init_array+0x24>
    94ec:	2600      	movs	r6, #0
    94ee:	f005 fc7f 	bl	edf0 <_init>
    94f2:	4d0a      	ldr	r5, [pc, #40]	; (951c <__libc_init_array+0x40>)
    94f4:	4c0a      	ldr	r4, [pc, #40]	; (9520 <__libc_init_array+0x44>)
    94f6:	1b64      	subs	r4, r4, r5
    94f8:	10a4      	asrs	r4, r4, #2
    94fa:	42a6      	cmp	r6, r4
    94fc:	d105      	bne.n	950a <__libc_init_array+0x2e>
    94fe:	bd70      	pop	{r4, r5, r6, pc}
    9500:	00b3      	lsls	r3, r6, #2
    9502:	58eb      	ldr	r3, [r5, r3]
    9504:	4798      	blx	r3
    9506:	3601      	adds	r6, #1
    9508:	e7ee      	b.n	94e8 <__libc_init_array+0xc>
    950a:	00b3      	lsls	r3, r6, #2
    950c:	58eb      	ldr	r3, [r5, r3]
    950e:	4798      	blx	r3
    9510:	3601      	adds	r6, #1
    9512:	e7f2      	b.n	94fa <__libc_init_array+0x1e>
    9514:	0000edfc 	.word	0x0000edfc
    9518:	0000edfc 	.word	0x0000edfc
    951c:	0000edfc 	.word	0x0000edfc
    9520:	0000ee00 	.word	0x0000ee00

00009524 <memcmp>:
    9524:	b530      	push	{r4, r5, lr}
    9526:	2400      	movs	r4, #0
    9528:	42a2      	cmp	r2, r4
    952a:	d101      	bne.n	9530 <memcmp+0xc>
    952c:	2000      	movs	r0, #0
    952e:	e005      	b.n	953c <memcmp+0x18>
    9530:	5d03      	ldrb	r3, [r0, r4]
    9532:	1c65      	adds	r5, r4, #1
    9534:	5d0c      	ldrb	r4, [r1, r4]
    9536:	42a3      	cmp	r3, r4
    9538:	d001      	beq.n	953e <memcmp+0x1a>
    953a:	1b18      	subs	r0, r3, r4
    953c:	bd30      	pop	{r4, r5, pc}
    953e:	002c      	movs	r4, r5
    9540:	e7f2      	b.n	9528 <memcmp+0x4>

00009542 <memcpy>:
    9542:	2300      	movs	r3, #0
    9544:	b510      	push	{r4, lr}
    9546:	429a      	cmp	r2, r3
    9548:	d100      	bne.n	954c <memcpy+0xa>
    954a:	bd10      	pop	{r4, pc}
    954c:	5ccc      	ldrb	r4, [r1, r3]
    954e:	54c4      	strb	r4, [r0, r3]
    9550:	3301      	adds	r3, #1
    9552:	e7f8      	b.n	9546 <memcpy+0x4>

00009554 <memset>:
    9554:	0003      	movs	r3, r0
    9556:	1882      	adds	r2, r0, r2
    9558:	4293      	cmp	r3, r2
    955a:	d100      	bne.n	955e <memset+0xa>
    955c:	4770      	bx	lr
    955e:	7019      	strb	r1, [r3, #0]
    9560:	3301      	adds	r3, #1
    9562:	e7f9      	b.n	9558 <memset+0x4>

00009564 <iprintf>:
    9564:	b40f      	push	{r0, r1, r2, r3}
    9566:	4b0b      	ldr	r3, [pc, #44]	; (9594 <iprintf+0x30>)
    9568:	b513      	push	{r0, r1, r4, lr}
    956a:	681c      	ldr	r4, [r3, #0]
    956c:	2c00      	cmp	r4, #0
    956e:	d005      	beq.n	957c <iprintf+0x18>
    9570:	69a3      	ldr	r3, [r4, #24]
    9572:	2b00      	cmp	r3, #0
    9574:	d102      	bne.n	957c <iprintf+0x18>
    9576:	0020      	movs	r0, r4
    9578:	f000 fb2c 	bl	9bd4 <__sinit>
    957c:	ab05      	add	r3, sp, #20
    957e:	9a04      	ldr	r2, [sp, #16]
    9580:	68a1      	ldr	r1, [r4, #8]
    9582:	0020      	movs	r0, r4
    9584:	9301      	str	r3, [sp, #4]
    9586:	f000 fe67 	bl	a258 <_vfiprintf_r>
    958a:	bc16      	pop	{r1, r2, r4}
    958c:	bc08      	pop	{r3}
    958e:	b004      	add	sp, #16
    9590:	4718      	bx	r3
    9592:	46c0      	nop			; (mov r8, r8)
    9594:	200000dc 	.word	0x200000dc

00009598 <_puts_r>:
    9598:	b570      	push	{r4, r5, r6, lr}
    959a:	0005      	movs	r5, r0
    959c:	000e      	movs	r6, r1
    959e:	2800      	cmp	r0, #0
    95a0:	d004      	beq.n	95ac <_puts_r+0x14>
    95a2:	6983      	ldr	r3, [r0, #24]
    95a4:	2b00      	cmp	r3, #0
    95a6:	d101      	bne.n	95ac <_puts_r+0x14>
    95a8:	f000 fb14 	bl	9bd4 <__sinit>
    95ac:	69ab      	ldr	r3, [r5, #24]
    95ae:	68ac      	ldr	r4, [r5, #8]
    95b0:	2b00      	cmp	r3, #0
    95b2:	d102      	bne.n	95ba <_puts_r+0x22>
    95b4:	0028      	movs	r0, r5
    95b6:	f000 fb0d 	bl	9bd4 <__sinit>
    95ba:	4b24      	ldr	r3, [pc, #144]	; (964c <_puts_r+0xb4>)
    95bc:	429c      	cmp	r4, r3
    95be:	d10f      	bne.n	95e0 <_puts_r+0x48>
    95c0:	686c      	ldr	r4, [r5, #4]
    95c2:	89a3      	ldrh	r3, [r4, #12]
    95c4:	071b      	lsls	r3, r3, #28
    95c6:	d502      	bpl.n	95ce <_puts_r+0x36>
    95c8:	6923      	ldr	r3, [r4, #16]
    95ca:	2b00      	cmp	r3, #0
    95cc:	d120      	bne.n	9610 <_puts_r+0x78>
    95ce:	0021      	movs	r1, r4
    95d0:	0028      	movs	r0, r5
    95d2:	f000 f991 	bl	98f8 <__swsetup_r>
    95d6:	2800      	cmp	r0, #0
    95d8:	d01a      	beq.n	9610 <_puts_r+0x78>
    95da:	2001      	movs	r0, #1
    95dc:	4240      	negs	r0, r0
    95de:	bd70      	pop	{r4, r5, r6, pc}
    95e0:	4b1b      	ldr	r3, [pc, #108]	; (9650 <_puts_r+0xb8>)
    95e2:	429c      	cmp	r4, r3
    95e4:	d101      	bne.n	95ea <_puts_r+0x52>
    95e6:	68ac      	ldr	r4, [r5, #8]
    95e8:	e7eb      	b.n	95c2 <_puts_r+0x2a>
    95ea:	4b1a      	ldr	r3, [pc, #104]	; (9654 <_puts_r+0xbc>)
    95ec:	429c      	cmp	r4, r3
    95ee:	d1e8      	bne.n	95c2 <_puts_r+0x2a>
    95f0:	68ec      	ldr	r4, [r5, #12]
    95f2:	e7e6      	b.n	95c2 <_puts_r+0x2a>
    95f4:	3b01      	subs	r3, #1
    95f6:	3601      	adds	r6, #1
    95f8:	60a3      	str	r3, [r4, #8]
    95fa:	2b00      	cmp	r3, #0
    95fc:	da04      	bge.n	9608 <_puts_r+0x70>
    95fe:	69a2      	ldr	r2, [r4, #24]
    9600:	4293      	cmp	r3, r2
    9602:	db16      	blt.n	9632 <_puts_r+0x9a>
    9604:	290a      	cmp	r1, #10
    9606:	d014      	beq.n	9632 <_puts_r+0x9a>
    9608:	6823      	ldr	r3, [r4, #0]
    960a:	1c5a      	adds	r2, r3, #1
    960c:	6022      	str	r2, [r4, #0]
    960e:	7019      	strb	r1, [r3, #0]
    9610:	7831      	ldrb	r1, [r6, #0]
    9612:	68a3      	ldr	r3, [r4, #8]
    9614:	2900      	cmp	r1, #0
    9616:	d1ed      	bne.n	95f4 <_puts_r+0x5c>
    9618:	3b01      	subs	r3, #1
    961a:	60a3      	str	r3, [r4, #8]
    961c:	2b00      	cmp	r3, #0
    961e:	da0f      	bge.n	9640 <_puts_r+0xa8>
    9620:	0022      	movs	r2, r4
    9622:	310a      	adds	r1, #10
    9624:	0028      	movs	r0, r5
    9626:	f000 f911 	bl	984c <__swbuf_r>
    962a:	1c43      	adds	r3, r0, #1
    962c:	d0d5      	beq.n	95da <_puts_r+0x42>
    962e:	200a      	movs	r0, #10
    9630:	e7d5      	b.n	95de <_puts_r+0x46>
    9632:	0022      	movs	r2, r4
    9634:	0028      	movs	r0, r5
    9636:	f000 f909 	bl	984c <__swbuf_r>
    963a:	1c43      	adds	r3, r0, #1
    963c:	d1e8      	bne.n	9610 <_puts_r+0x78>
    963e:	e7cc      	b.n	95da <_puts_r+0x42>
    9640:	200a      	movs	r0, #10
    9642:	6823      	ldr	r3, [r4, #0]
    9644:	1c5a      	adds	r2, r3, #1
    9646:	6022      	str	r2, [r4, #0]
    9648:	7018      	strb	r0, [r3, #0]
    964a:	e7c8      	b.n	95de <_puts_r+0x46>
    964c:	0000ed7c 	.word	0x0000ed7c
    9650:	0000ed9c 	.word	0x0000ed9c
    9654:	0000ed5c 	.word	0x0000ed5c

00009658 <puts>:
    9658:	b510      	push	{r4, lr}
    965a:	4b03      	ldr	r3, [pc, #12]	; (9668 <puts+0x10>)
    965c:	0001      	movs	r1, r0
    965e:	6818      	ldr	r0, [r3, #0]
    9660:	f7ff ff9a 	bl	9598 <_puts_r>
    9664:	bd10      	pop	{r4, pc}
    9666:	46c0      	nop			; (mov r8, r8)
    9668:	200000dc 	.word	0x200000dc

0000966c <setbuf>:
    966c:	424a      	negs	r2, r1
    966e:	414a      	adcs	r2, r1
    9670:	2380      	movs	r3, #128	; 0x80
    9672:	b510      	push	{r4, lr}
    9674:	0052      	lsls	r2, r2, #1
    9676:	00db      	lsls	r3, r3, #3
    9678:	f000 f802 	bl	9680 <setvbuf>
    967c:	bd10      	pop	{r4, pc}
	...

00009680 <setvbuf>:
    9680:	b5f0      	push	{r4, r5, r6, r7, lr}
    9682:	001d      	movs	r5, r3
    9684:	4b4f      	ldr	r3, [pc, #316]	; (97c4 <setvbuf+0x144>)
    9686:	b085      	sub	sp, #20
    9688:	681e      	ldr	r6, [r3, #0]
    968a:	0004      	movs	r4, r0
    968c:	000f      	movs	r7, r1
    968e:	9200      	str	r2, [sp, #0]
    9690:	2e00      	cmp	r6, #0
    9692:	d005      	beq.n	96a0 <setvbuf+0x20>
    9694:	69b3      	ldr	r3, [r6, #24]
    9696:	2b00      	cmp	r3, #0
    9698:	d102      	bne.n	96a0 <setvbuf+0x20>
    969a:	0030      	movs	r0, r6
    969c:	f000 fa9a 	bl	9bd4 <__sinit>
    96a0:	4b49      	ldr	r3, [pc, #292]	; (97c8 <setvbuf+0x148>)
    96a2:	429c      	cmp	r4, r3
    96a4:	d150      	bne.n	9748 <setvbuf+0xc8>
    96a6:	6874      	ldr	r4, [r6, #4]
    96a8:	9b00      	ldr	r3, [sp, #0]
    96aa:	2b02      	cmp	r3, #2
    96ac:	d005      	beq.n	96ba <setvbuf+0x3a>
    96ae:	2b01      	cmp	r3, #1
    96b0:	d900      	bls.n	96b4 <setvbuf+0x34>
    96b2:	e084      	b.n	97be <setvbuf+0x13e>
    96b4:	2d00      	cmp	r5, #0
    96b6:	da00      	bge.n	96ba <setvbuf+0x3a>
    96b8:	e081      	b.n	97be <setvbuf+0x13e>
    96ba:	0021      	movs	r1, r4
    96bc:	0030      	movs	r0, r6
    96be:	f000 fa1b 	bl	9af8 <_fflush_r>
    96c2:	6b61      	ldr	r1, [r4, #52]	; 0x34
    96c4:	2900      	cmp	r1, #0
    96c6:	d008      	beq.n	96da <setvbuf+0x5a>
    96c8:	0023      	movs	r3, r4
    96ca:	3344      	adds	r3, #68	; 0x44
    96cc:	4299      	cmp	r1, r3
    96ce:	d002      	beq.n	96d6 <setvbuf+0x56>
    96d0:	0030      	movs	r0, r6
    96d2:	f000 fb8b 	bl	9dec <_free_r>
    96d6:	2300      	movs	r3, #0
    96d8:	6363      	str	r3, [r4, #52]	; 0x34
    96da:	2300      	movs	r3, #0
    96dc:	61a3      	str	r3, [r4, #24]
    96de:	6063      	str	r3, [r4, #4]
    96e0:	89a3      	ldrh	r3, [r4, #12]
    96e2:	061b      	lsls	r3, r3, #24
    96e4:	d503      	bpl.n	96ee <setvbuf+0x6e>
    96e6:	6921      	ldr	r1, [r4, #16]
    96e8:	0030      	movs	r0, r6
    96ea:	f000 fb7f 	bl	9dec <_free_r>
    96ee:	89a3      	ldrh	r3, [r4, #12]
    96f0:	4a36      	ldr	r2, [pc, #216]	; (97cc <setvbuf+0x14c>)
    96f2:	4013      	ands	r3, r2
    96f4:	81a3      	strh	r3, [r4, #12]
    96f6:	9b00      	ldr	r3, [sp, #0]
    96f8:	2b02      	cmp	r3, #2
    96fa:	d05a      	beq.n	97b2 <setvbuf+0x132>
    96fc:	ab03      	add	r3, sp, #12
    96fe:	aa02      	add	r2, sp, #8
    9700:	0021      	movs	r1, r4
    9702:	0030      	movs	r0, r6
    9704:	f000 fafc 	bl	9d00 <__swhatbuf_r>
    9708:	89a3      	ldrh	r3, [r4, #12]
    970a:	4318      	orrs	r0, r3
    970c:	81a0      	strh	r0, [r4, #12]
    970e:	2d00      	cmp	r5, #0
    9710:	d124      	bne.n	975c <setvbuf+0xdc>
    9712:	9d02      	ldr	r5, [sp, #8]
    9714:	0028      	movs	r0, r5
    9716:	f000 fb5f 	bl	9dd8 <malloc>
    971a:	9501      	str	r5, [sp, #4]
    971c:	1e07      	subs	r7, r0, #0
    971e:	d142      	bne.n	97a6 <setvbuf+0x126>
    9720:	9b02      	ldr	r3, [sp, #8]
    9722:	9301      	str	r3, [sp, #4]
    9724:	42ab      	cmp	r3, r5
    9726:	d139      	bne.n	979c <setvbuf+0x11c>
    9728:	2001      	movs	r0, #1
    972a:	4240      	negs	r0, r0
    972c:	2302      	movs	r3, #2
    972e:	89a2      	ldrh	r2, [r4, #12]
    9730:	4313      	orrs	r3, r2
    9732:	81a3      	strh	r3, [r4, #12]
    9734:	2300      	movs	r3, #0
    9736:	60a3      	str	r3, [r4, #8]
    9738:	0023      	movs	r3, r4
    973a:	3347      	adds	r3, #71	; 0x47
    973c:	6023      	str	r3, [r4, #0]
    973e:	6123      	str	r3, [r4, #16]
    9740:	2301      	movs	r3, #1
    9742:	6163      	str	r3, [r4, #20]
    9744:	b005      	add	sp, #20
    9746:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9748:	4b21      	ldr	r3, [pc, #132]	; (97d0 <setvbuf+0x150>)
    974a:	429c      	cmp	r4, r3
    974c:	d101      	bne.n	9752 <setvbuf+0xd2>
    974e:	68b4      	ldr	r4, [r6, #8]
    9750:	e7aa      	b.n	96a8 <setvbuf+0x28>
    9752:	4b20      	ldr	r3, [pc, #128]	; (97d4 <setvbuf+0x154>)
    9754:	429c      	cmp	r4, r3
    9756:	d1a7      	bne.n	96a8 <setvbuf+0x28>
    9758:	68f4      	ldr	r4, [r6, #12]
    975a:	e7a5      	b.n	96a8 <setvbuf+0x28>
    975c:	2f00      	cmp	r7, #0
    975e:	d0d9      	beq.n	9714 <setvbuf+0x94>
    9760:	69b3      	ldr	r3, [r6, #24]
    9762:	2b00      	cmp	r3, #0
    9764:	d102      	bne.n	976c <setvbuf+0xec>
    9766:	0030      	movs	r0, r6
    9768:	f000 fa34 	bl	9bd4 <__sinit>
    976c:	9b00      	ldr	r3, [sp, #0]
    976e:	2b01      	cmp	r3, #1
    9770:	d103      	bne.n	977a <setvbuf+0xfa>
    9772:	89a3      	ldrh	r3, [r4, #12]
    9774:	9a00      	ldr	r2, [sp, #0]
    9776:	431a      	orrs	r2, r3
    9778:	81a2      	strh	r2, [r4, #12]
    977a:	2008      	movs	r0, #8
    977c:	89a3      	ldrh	r3, [r4, #12]
    977e:	6027      	str	r7, [r4, #0]
    9780:	6127      	str	r7, [r4, #16]
    9782:	6165      	str	r5, [r4, #20]
    9784:	4018      	ands	r0, r3
    9786:	d018      	beq.n	97ba <setvbuf+0x13a>
    9788:	2001      	movs	r0, #1
    978a:	4018      	ands	r0, r3
    978c:	2300      	movs	r3, #0
    978e:	4298      	cmp	r0, r3
    9790:	d011      	beq.n	97b6 <setvbuf+0x136>
    9792:	426d      	negs	r5, r5
    9794:	60a3      	str	r3, [r4, #8]
    9796:	61a5      	str	r5, [r4, #24]
    9798:	0018      	movs	r0, r3
    979a:	e7d3      	b.n	9744 <setvbuf+0xc4>
    979c:	9801      	ldr	r0, [sp, #4]
    979e:	f000 fb1b 	bl	9dd8 <malloc>
    97a2:	1e07      	subs	r7, r0, #0
    97a4:	d0c0      	beq.n	9728 <setvbuf+0xa8>
    97a6:	2380      	movs	r3, #128	; 0x80
    97a8:	89a2      	ldrh	r2, [r4, #12]
    97aa:	9d01      	ldr	r5, [sp, #4]
    97ac:	4313      	orrs	r3, r2
    97ae:	81a3      	strh	r3, [r4, #12]
    97b0:	e7d6      	b.n	9760 <setvbuf+0xe0>
    97b2:	2000      	movs	r0, #0
    97b4:	e7ba      	b.n	972c <setvbuf+0xac>
    97b6:	60a5      	str	r5, [r4, #8]
    97b8:	e7c4      	b.n	9744 <setvbuf+0xc4>
    97ba:	60a0      	str	r0, [r4, #8]
    97bc:	e7c2      	b.n	9744 <setvbuf+0xc4>
    97be:	2001      	movs	r0, #1
    97c0:	4240      	negs	r0, r0
    97c2:	e7bf      	b.n	9744 <setvbuf+0xc4>
    97c4:	200000dc 	.word	0x200000dc
    97c8:	0000ed7c 	.word	0x0000ed7c
    97cc:	fffff35c 	.word	0xfffff35c
    97d0:	0000ed9c 	.word	0x0000ed9c
    97d4:	0000ed5c 	.word	0x0000ed5c

000097d8 <sniprintf>:
    97d8:	b40c      	push	{r2, r3}
    97da:	b530      	push	{r4, r5, lr}
    97dc:	4b16      	ldr	r3, [pc, #88]	; (9838 <sniprintf+0x60>)
    97de:	b09d      	sub	sp, #116	; 0x74
    97e0:	1e0c      	subs	r4, r1, #0
    97e2:	681d      	ldr	r5, [r3, #0]
    97e4:	da08      	bge.n	97f8 <sniprintf+0x20>
    97e6:	238b      	movs	r3, #139	; 0x8b
    97e8:	2001      	movs	r0, #1
    97ea:	602b      	str	r3, [r5, #0]
    97ec:	4240      	negs	r0, r0
    97ee:	b01d      	add	sp, #116	; 0x74
    97f0:	bc30      	pop	{r4, r5}
    97f2:	bc08      	pop	{r3}
    97f4:	b002      	add	sp, #8
    97f6:	4718      	bx	r3
    97f8:	2382      	movs	r3, #130	; 0x82
    97fa:	a902      	add	r1, sp, #8
    97fc:	009b      	lsls	r3, r3, #2
    97fe:	818b      	strh	r3, [r1, #12]
    9800:	2300      	movs	r3, #0
    9802:	9002      	str	r0, [sp, #8]
    9804:	6108      	str	r0, [r1, #16]
    9806:	429c      	cmp	r4, r3
    9808:	d000      	beq.n	980c <sniprintf+0x34>
    980a:	1e63      	subs	r3, r4, #1
    980c:	608b      	str	r3, [r1, #8]
    980e:	614b      	str	r3, [r1, #20]
    9810:	2301      	movs	r3, #1
    9812:	425b      	negs	r3, r3
    9814:	81cb      	strh	r3, [r1, #14]
    9816:	9a20      	ldr	r2, [sp, #128]	; 0x80
    9818:	ab21      	add	r3, sp, #132	; 0x84
    981a:	0028      	movs	r0, r5
    981c:	9301      	str	r3, [sp, #4]
    981e:	f000 fbef 	bl	a000 <_svfiprintf_r>
    9822:	1c43      	adds	r3, r0, #1
    9824:	da01      	bge.n	982a <sniprintf+0x52>
    9826:	238b      	movs	r3, #139	; 0x8b
    9828:	602b      	str	r3, [r5, #0]
    982a:	2c00      	cmp	r4, #0
    982c:	d0df      	beq.n	97ee <sniprintf+0x16>
    982e:	2300      	movs	r3, #0
    9830:	9a02      	ldr	r2, [sp, #8]
    9832:	7013      	strb	r3, [r2, #0]
    9834:	e7db      	b.n	97ee <sniprintf+0x16>
    9836:	46c0      	nop			; (mov r8, r8)
    9838:	200000dc 	.word	0x200000dc

0000983c <strlen>:
    983c:	2300      	movs	r3, #0
    983e:	5cc2      	ldrb	r2, [r0, r3]
    9840:	3301      	adds	r3, #1
    9842:	2a00      	cmp	r2, #0
    9844:	d1fb      	bne.n	983e <strlen+0x2>
    9846:	1e58      	subs	r0, r3, #1
    9848:	4770      	bx	lr
	...

0000984c <__swbuf_r>:
    984c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    984e:	0005      	movs	r5, r0
    9850:	000e      	movs	r6, r1
    9852:	0014      	movs	r4, r2
    9854:	2800      	cmp	r0, #0
    9856:	d004      	beq.n	9862 <__swbuf_r+0x16>
    9858:	6983      	ldr	r3, [r0, #24]
    985a:	2b00      	cmp	r3, #0
    985c:	d101      	bne.n	9862 <__swbuf_r+0x16>
    985e:	f000 f9b9 	bl	9bd4 <__sinit>
    9862:	4b22      	ldr	r3, [pc, #136]	; (98ec <__swbuf_r+0xa0>)
    9864:	429c      	cmp	r4, r3
    9866:	d12d      	bne.n	98c4 <__swbuf_r+0x78>
    9868:	686c      	ldr	r4, [r5, #4]
    986a:	69a3      	ldr	r3, [r4, #24]
    986c:	60a3      	str	r3, [r4, #8]
    986e:	89a3      	ldrh	r3, [r4, #12]
    9870:	071b      	lsls	r3, r3, #28
    9872:	d531      	bpl.n	98d8 <__swbuf_r+0x8c>
    9874:	6923      	ldr	r3, [r4, #16]
    9876:	2b00      	cmp	r3, #0
    9878:	d02e      	beq.n	98d8 <__swbuf_r+0x8c>
    987a:	6823      	ldr	r3, [r4, #0]
    987c:	6922      	ldr	r2, [r4, #16]
    987e:	b2f7      	uxtb	r7, r6
    9880:	1a98      	subs	r0, r3, r2
    9882:	6963      	ldr	r3, [r4, #20]
    9884:	b2f6      	uxtb	r6, r6
    9886:	4298      	cmp	r0, r3
    9888:	db05      	blt.n	9896 <__swbuf_r+0x4a>
    988a:	0021      	movs	r1, r4
    988c:	0028      	movs	r0, r5
    988e:	f000 f933 	bl	9af8 <_fflush_r>
    9892:	2800      	cmp	r0, #0
    9894:	d126      	bne.n	98e4 <__swbuf_r+0x98>
    9896:	68a3      	ldr	r3, [r4, #8]
    9898:	3001      	adds	r0, #1
    989a:	3b01      	subs	r3, #1
    989c:	60a3      	str	r3, [r4, #8]
    989e:	6823      	ldr	r3, [r4, #0]
    98a0:	1c5a      	adds	r2, r3, #1
    98a2:	6022      	str	r2, [r4, #0]
    98a4:	701f      	strb	r7, [r3, #0]
    98a6:	6963      	ldr	r3, [r4, #20]
    98a8:	4298      	cmp	r0, r3
    98aa:	d004      	beq.n	98b6 <__swbuf_r+0x6a>
    98ac:	89a3      	ldrh	r3, [r4, #12]
    98ae:	07db      	lsls	r3, r3, #31
    98b0:	d51a      	bpl.n	98e8 <__swbuf_r+0x9c>
    98b2:	2e0a      	cmp	r6, #10
    98b4:	d118      	bne.n	98e8 <__swbuf_r+0x9c>
    98b6:	0021      	movs	r1, r4
    98b8:	0028      	movs	r0, r5
    98ba:	f000 f91d 	bl	9af8 <_fflush_r>
    98be:	2800      	cmp	r0, #0
    98c0:	d012      	beq.n	98e8 <__swbuf_r+0x9c>
    98c2:	e00f      	b.n	98e4 <__swbuf_r+0x98>
    98c4:	4b0a      	ldr	r3, [pc, #40]	; (98f0 <__swbuf_r+0xa4>)
    98c6:	429c      	cmp	r4, r3
    98c8:	d101      	bne.n	98ce <__swbuf_r+0x82>
    98ca:	68ac      	ldr	r4, [r5, #8]
    98cc:	e7cd      	b.n	986a <__swbuf_r+0x1e>
    98ce:	4b09      	ldr	r3, [pc, #36]	; (98f4 <__swbuf_r+0xa8>)
    98d0:	429c      	cmp	r4, r3
    98d2:	d1ca      	bne.n	986a <__swbuf_r+0x1e>
    98d4:	68ec      	ldr	r4, [r5, #12]
    98d6:	e7c8      	b.n	986a <__swbuf_r+0x1e>
    98d8:	0021      	movs	r1, r4
    98da:	0028      	movs	r0, r5
    98dc:	f000 f80c 	bl	98f8 <__swsetup_r>
    98e0:	2800      	cmp	r0, #0
    98e2:	d0ca      	beq.n	987a <__swbuf_r+0x2e>
    98e4:	2601      	movs	r6, #1
    98e6:	4276      	negs	r6, r6
    98e8:	0030      	movs	r0, r6
    98ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    98ec:	0000ed7c 	.word	0x0000ed7c
    98f0:	0000ed9c 	.word	0x0000ed9c
    98f4:	0000ed5c 	.word	0x0000ed5c

000098f8 <__swsetup_r>:
    98f8:	4b36      	ldr	r3, [pc, #216]	; (99d4 <__swsetup_r+0xdc>)
    98fa:	b570      	push	{r4, r5, r6, lr}
    98fc:	681d      	ldr	r5, [r3, #0]
    98fe:	0006      	movs	r6, r0
    9900:	000c      	movs	r4, r1
    9902:	2d00      	cmp	r5, #0
    9904:	d005      	beq.n	9912 <__swsetup_r+0x1a>
    9906:	69ab      	ldr	r3, [r5, #24]
    9908:	2b00      	cmp	r3, #0
    990a:	d102      	bne.n	9912 <__swsetup_r+0x1a>
    990c:	0028      	movs	r0, r5
    990e:	f000 f961 	bl	9bd4 <__sinit>
    9912:	4b31      	ldr	r3, [pc, #196]	; (99d8 <__swsetup_r+0xe0>)
    9914:	429c      	cmp	r4, r3
    9916:	d10f      	bne.n	9938 <__swsetup_r+0x40>
    9918:	686c      	ldr	r4, [r5, #4]
    991a:	230c      	movs	r3, #12
    991c:	5ee2      	ldrsh	r2, [r4, r3]
    991e:	b293      	uxth	r3, r2
    9920:	0719      	lsls	r1, r3, #28
    9922:	d42d      	bmi.n	9980 <__swsetup_r+0x88>
    9924:	06d9      	lsls	r1, r3, #27
    9926:	d411      	bmi.n	994c <__swsetup_r+0x54>
    9928:	2309      	movs	r3, #9
    992a:	2001      	movs	r0, #1
    992c:	6033      	str	r3, [r6, #0]
    992e:	3337      	adds	r3, #55	; 0x37
    9930:	4313      	orrs	r3, r2
    9932:	81a3      	strh	r3, [r4, #12]
    9934:	4240      	negs	r0, r0
    9936:	bd70      	pop	{r4, r5, r6, pc}
    9938:	4b28      	ldr	r3, [pc, #160]	; (99dc <__swsetup_r+0xe4>)
    993a:	429c      	cmp	r4, r3
    993c:	d101      	bne.n	9942 <__swsetup_r+0x4a>
    993e:	68ac      	ldr	r4, [r5, #8]
    9940:	e7eb      	b.n	991a <__swsetup_r+0x22>
    9942:	4b27      	ldr	r3, [pc, #156]	; (99e0 <__swsetup_r+0xe8>)
    9944:	429c      	cmp	r4, r3
    9946:	d1e8      	bne.n	991a <__swsetup_r+0x22>
    9948:	68ec      	ldr	r4, [r5, #12]
    994a:	e7e6      	b.n	991a <__swsetup_r+0x22>
    994c:	075b      	lsls	r3, r3, #29
    994e:	d513      	bpl.n	9978 <__swsetup_r+0x80>
    9950:	6b61      	ldr	r1, [r4, #52]	; 0x34
    9952:	2900      	cmp	r1, #0
    9954:	d008      	beq.n	9968 <__swsetup_r+0x70>
    9956:	0023      	movs	r3, r4
    9958:	3344      	adds	r3, #68	; 0x44
    995a:	4299      	cmp	r1, r3
    995c:	d002      	beq.n	9964 <__swsetup_r+0x6c>
    995e:	0030      	movs	r0, r6
    9960:	f000 fa44 	bl	9dec <_free_r>
    9964:	2300      	movs	r3, #0
    9966:	6363      	str	r3, [r4, #52]	; 0x34
    9968:	2224      	movs	r2, #36	; 0x24
    996a:	89a3      	ldrh	r3, [r4, #12]
    996c:	4393      	bics	r3, r2
    996e:	81a3      	strh	r3, [r4, #12]
    9970:	2300      	movs	r3, #0
    9972:	6063      	str	r3, [r4, #4]
    9974:	6923      	ldr	r3, [r4, #16]
    9976:	6023      	str	r3, [r4, #0]
    9978:	2308      	movs	r3, #8
    997a:	89a2      	ldrh	r2, [r4, #12]
    997c:	4313      	orrs	r3, r2
    997e:	81a3      	strh	r3, [r4, #12]
    9980:	6923      	ldr	r3, [r4, #16]
    9982:	2b00      	cmp	r3, #0
    9984:	d10b      	bne.n	999e <__swsetup_r+0xa6>
    9986:	21a0      	movs	r1, #160	; 0xa0
    9988:	2280      	movs	r2, #128	; 0x80
    998a:	89a3      	ldrh	r3, [r4, #12]
    998c:	0089      	lsls	r1, r1, #2
    998e:	0092      	lsls	r2, r2, #2
    9990:	400b      	ands	r3, r1
    9992:	4293      	cmp	r3, r2
    9994:	d003      	beq.n	999e <__swsetup_r+0xa6>
    9996:	0021      	movs	r1, r4
    9998:	0030      	movs	r0, r6
    999a:	f000 f9d9 	bl	9d50 <__smakebuf_r>
    999e:	2301      	movs	r3, #1
    99a0:	89a2      	ldrh	r2, [r4, #12]
    99a2:	4013      	ands	r3, r2
    99a4:	d011      	beq.n	99ca <__swsetup_r+0xd2>
    99a6:	2300      	movs	r3, #0
    99a8:	60a3      	str	r3, [r4, #8]
    99aa:	6963      	ldr	r3, [r4, #20]
    99ac:	425b      	negs	r3, r3
    99ae:	61a3      	str	r3, [r4, #24]
    99b0:	2000      	movs	r0, #0
    99b2:	6923      	ldr	r3, [r4, #16]
    99b4:	4283      	cmp	r3, r0
    99b6:	d1be      	bne.n	9936 <__swsetup_r+0x3e>
    99b8:	230c      	movs	r3, #12
    99ba:	5ee2      	ldrsh	r2, [r4, r3]
    99bc:	0613      	lsls	r3, r2, #24
    99be:	d5ba      	bpl.n	9936 <__swsetup_r+0x3e>
    99c0:	2340      	movs	r3, #64	; 0x40
    99c2:	4313      	orrs	r3, r2
    99c4:	81a3      	strh	r3, [r4, #12]
    99c6:	3801      	subs	r0, #1
    99c8:	e7b5      	b.n	9936 <__swsetup_r+0x3e>
    99ca:	0792      	lsls	r2, r2, #30
    99cc:	d400      	bmi.n	99d0 <__swsetup_r+0xd8>
    99ce:	6963      	ldr	r3, [r4, #20]
    99d0:	60a3      	str	r3, [r4, #8]
    99d2:	e7ed      	b.n	99b0 <__swsetup_r+0xb8>
    99d4:	200000dc 	.word	0x200000dc
    99d8:	0000ed7c 	.word	0x0000ed7c
    99dc:	0000ed9c 	.word	0x0000ed9c
    99e0:	0000ed5c 	.word	0x0000ed5c

000099e4 <__sflush_r>:
    99e4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    99e6:	898a      	ldrh	r2, [r1, #12]
    99e8:	0005      	movs	r5, r0
    99ea:	000c      	movs	r4, r1
    99ec:	0713      	lsls	r3, r2, #28
    99ee:	d460      	bmi.n	9ab2 <__sflush_r+0xce>
    99f0:	684b      	ldr	r3, [r1, #4]
    99f2:	2b00      	cmp	r3, #0
    99f4:	dc04      	bgt.n	9a00 <__sflush_r+0x1c>
    99f6:	6c0b      	ldr	r3, [r1, #64]	; 0x40
    99f8:	2b00      	cmp	r3, #0
    99fa:	dc01      	bgt.n	9a00 <__sflush_r+0x1c>
    99fc:	2000      	movs	r0, #0
    99fe:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    9a00:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    9a02:	2f00      	cmp	r7, #0
    9a04:	d0fa      	beq.n	99fc <__sflush_r+0x18>
    9a06:	2300      	movs	r3, #0
    9a08:	682e      	ldr	r6, [r5, #0]
    9a0a:	602b      	str	r3, [r5, #0]
    9a0c:	2380      	movs	r3, #128	; 0x80
    9a0e:	015b      	lsls	r3, r3, #5
    9a10:	401a      	ands	r2, r3
    9a12:	d034      	beq.n	9a7e <__sflush_r+0x9a>
    9a14:	6d60      	ldr	r0, [r4, #84]	; 0x54
    9a16:	89a3      	ldrh	r3, [r4, #12]
    9a18:	075b      	lsls	r3, r3, #29
    9a1a:	d506      	bpl.n	9a2a <__sflush_r+0x46>
    9a1c:	6863      	ldr	r3, [r4, #4]
    9a1e:	1ac0      	subs	r0, r0, r3
    9a20:	6b63      	ldr	r3, [r4, #52]	; 0x34
    9a22:	2b00      	cmp	r3, #0
    9a24:	d001      	beq.n	9a2a <__sflush_r+0x46>
    9a26:	6c23      	ldr	r3, [r4, #64]	; 0x40
    9a28:	1ac0      	subs	r0, r0, r3
    9a2a:	0002      	movs	r2, r0
    9a2c:	6a21      	ldr	r1, [r4, #32]
    9a2e:	2300      	movs	r3, #0
    9a30:	0028      	movs	r0, r5
    9a32:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    9a34:	47b8      	blx	r7
    9a36:	89a1      	ldrh	r1, [r4, #12]
    9a38:	1c43      	adds	r3, r0, #1
    9a3a:	d106      	bne.n	9a4a <__sflush_r+0x66>
    9a3c:	682b      	ldr	r3, [r5, #0]
    9a3e:	2b1d      	cmp	r3, #29
    9a40:	d831      	bhi.n	9aa6 <__sflush_r+0xc2>
    9a42:	4a2c      	ldr	r2, [pc, #176]	; (9af4 <__sflush_r+0x110>)
    9a44:	40da      	lsrs	r2, r3
    9a46:	07d3      	lsls	r3, r2, #31
    9a48:	d52d      	bpl.n	9aa6 <__sflush_r+0xc2>
    9a4a:	2300      	movs	r3, #0
    9a4c:	6063      	str	r3, [r4, #4]
    9a4e:	6923      	ldr	r3, [r4, #16]
    9a50:	6023      	str	r3, [r4, #0]
    9a52:	04cb      	lsls	r3, r1, #19
    9a54:	d505      	bpl.n	9a62 <__sflush_r+0x7e>
    9a56:	1c43      	adds	r3, r0, #1
    9a58:	d102      	bne.n	9a60 <__sflush_r+0x7c>
    9a5a:	682b      	ldr	r3, [r5, #0]
    9a5c:	2b00      	cmp	r3, #0
    9a5e:	d100      	bne.n	9a62 <__sflush_r+0x7e>
    9a60:	6560      	str	r0, [r4, #84]	; 0x54
    9a62:	6b61      	ldr	r1, [r4, #52]	; 0x34
    9a64:	602e      	str	r6, [r5, #0]
    9a66:	2900      	cmp	r1, #0
    9a68:	d0c8      	beq.n	99fc <__sflush_r+0x18>
    9a6a:	0023      	movs	r3, r4
    9a6c:	3344      	adds	r3, #68	; 0x44
    9a6e:	4299      	cmp	r1, r3
    9a70:	d002      	beq.n	9a78 <__sflush_r+0x94>
    9a72:	0028      	movs	r0, r5
    9a74:	f000 f9ba 	bl	9dec <_free_r>
    9a78:	2000      	movs	r0, #0
    9a7a:	6360      	str	r0, [r4, #52]	; 0x34
    9a7c:	e7bf      	b.n	99fe <__sflush_r+0x1a>
    9a7e:	2301      	movs	r3, #1
    9a80:	6a21      	ldr	r1, [r4, #32]
    9a82:	0028      	movs	r0, r5
    9a84:	47b8      	blx	r7
    9a86:	1c43      	adds	r3, r0, #1
    9a88:	d1c5      	bne.n	9a16 <__sflush_r+0x32>
    9a8a:	682b      	ldr	r3, [r5, #0]
    9a8c:	2b00      	cmp	r3, #0
    9a8e:	d0c2      	beq.n	9a16 <__sflush_r+0x32>
    9a90:	2b1d      	cmp	r3, #29
    9a92:	d001      	beq.n	9a98 <__sflush_r+0xb4>
    9a94:	2b16      	cmp	r3, #22
    9a96:	d101      	bne.n	9a9c <__sflush_r+0xb8>
    9a98:	602e      	str	r6, [r5, #0]
    9a9a:	e7af      	b.n	99fc <__sflush_r+0x18>
    9a9c:	2340      	movs	r3, #64	; 0x40
    9a9e:	89a2      	ldrh	r2, [r4, #12]
    9aa0:	4313      	orrs	r3, r2
    9aa2:	81a3      	strh	r3, [r4, #12]
    9aa4:	e7ab      	b.n	99fe <__sflush_r+0x1a>
    9aa6:	2340      	movs	r3, #64	; 0x40
    9aa8:	430b      	orrs	r3, r1
    9aaa:	2001      	movs	r0, #1
    9aac:	81a3      	strh	r3, [r4, #12]
    9aae:	4240      	negs	r0, r0
    9ab0:	e7a5      	b.n	99fe <__sflush_r+0x1a>
    9ab2:	690f      	ldr	r7, [r1, #16]
    9ab4:	2f00      	cmp	r7, #0
    9ab6:	d0a1      	beq.n	99fc <__sflush_r+0x18>
    9ab8:	680b      	ldr	r3, [r1, #0]
    9aba:	600f      	str	r7, [r1, #0]
    9abc:	1bdb      	subs	r3, r3, r7
    9abe:	9301      	str	r3, [sp, #4]
    9ac0:	2300      	movs	r3, #0
    9ac2:	0792      	lsls	r2, r2, #30
    9ac4:	d100      	bne.n	9ac8 <__sflush_r+0xe4>
    9ac6:	694b      	ldr	r3, [r1, #20]
    9ac8:	60a3      	str	r3, [r4, #8]
    9aca:	9b01      	ldr	r3, [sp, #4]
    9acc:	2b00      	cmp	r3, #0
    9ace:	dc00      	bgt.n	9ad2 <__sflush_r+0xee>
    9ad0:	e794      	b.n	99fc <__sflush_r+0x18>
    9ad2:	9b01      	ldr	r3, [sp, #4]
    9ad4:	003a      	movs	r2, r7
    9ad6:	6a21      	ldr	r1, [r4, #32]
    9ad8:	0028      	movs	r0, r5
    9ada:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    9adc:	47b0      	blx	r6
    9ade:	2800      	cmp	r0, #0
    9ae0:	dc03      	bgt.n	9aea <__sflush_r+0x106>
    9ae2:	2340      	movs	r3, #64	; 0x40
    9ae4:	89a2      	ldrh	r2, [r4, #12]
    9ae6:	4313      	orrs	r3, r2
    9ae8:	e7df      	b.n	9aaa <__sflush_r+0xc6>
    9aea:	9b01      	ldr	r3, [sp, #4]
    9aec:	183f      	adds	r7, r7, r0
    9aee:	1a1b      	subs	r3, r3, r0
    9af0:	9301      	str	r3, [sp, #4]
    9af2:	e7ea      	b.n	9aca <__sflush_r+0xe6>
    9af4:	20400001 	.word	0x20400001

00009af8 <_fflush_r>:
    9af8:	690b      	ldr	r3, [r1, #16]
    9afa:	b570      	push	{r4, r5, r6, lr}
    9afc:	0005      	movs	r5, r0
    9afe:	000c      	movs	r4, r1
    9b00:	2b00      	cmp	r3, #0
    9b02:	d101      	bne.n	9b08 <_fflush_r+0x10>
    9b04:	2000      	movs	r0, #0
    9b06:	bd70      	pop	{r4, r5, r6, pc}
    9b08:	2800      	cmp	r0, #0
    9b0a:	d004      	beq.n	9b16 <_fflush_r+0x1e>
    9b0c:	6983      	ldr	r3, [r0, #24]
    9b0e:	2b00      	cmp	r3, #0
    9b10:	d101      	bne.n	9b16 <_fflush_r+0x1e>
    9b12:	f000 f85f 	bl	9bd4 <__sinit>
    9b16:	4b0b      	ldr	r3, [pc, #44]	; (9b44 <_fflush_r+0x4c>)
    9b18:	429c      	cmp	r4, r3
    9b1a:	d109      	bne.n	9b30 <_fflush_r+0x38>
    9b1c:	686c      	ldr	r4, [r5, #4]
    9b1e:	220c      	movs	r2, #12
    9b20:	5ea3      	ldrsh	r3, [r4, r2]
    9b22:	2b00      	cmp	r3, #0
    9b24:	d0ee      	beq.n	9b04 <_fflush_r+0xc>
    9b26:	0021      	movs	r1, r4
    9b28:	0028      	movs	r0, r5
    9b2a:	f7ff ff5b 	bl	99e4 <__sflush_r>
    9b2e:	e7ea      	b.n	9b06 <_fflush_r+0xe>
    9b30:	4b05      	ldr	r3, [pc, #20]	; (9b48 <_fflush_r+0x50>)
    9b32:	429c      	cmp	r4, r3
    9b34:	d101      	bne.n	9b3a <_fflush_r+0x42>
    9b36:	68ac      	ldr	r4, [r5, #8]
    9b38:	e7f1      	b.n	9b1e <_fflush_r+0x26>
    9b3a:	4b04      	ldr	r3, [pc, #16]	; (9b4c <_fflush_r+0x54>)
    9b3c:	429c      	cmp	r4, r3
    9b3e:	d1ee      	bne.n	9b1e <_fflush_r+0x26>
    9b40:	68ec      	ldr	r4, [r5, #12]
    9b42:	e7ec      	b.n	9b1e <_fflush_r+0x26>
    9b44:	0000ed7c 	.word	0x0000ed7c
    9b48:	0000ed9c 	.word	0x0000ed9c
    9b4c:	0000ed5c 	.word	0x0000ed5c

00009b50 <_cleanup_r>:
    9b50:	b510      	push	{r4, lr}
    9b52:	4902      	ldr	r1, [pc, #8]	; (9b5c <_cleanup_r+0xc>)
    9b54:	f000 f8b2 	bl	9cbc <_fwalk_reent>
    9b58:	bd10      	pop	{r4, pc}
    9b5a:	46c0      	nop			; (mov r8, r8)
    9b5c:	00009af9 	.word	0x00009af9

00009b60 <std.isra.0>:
    9b60:	2300      	movs	r3, #0
    9b62:	b510      	push	{r4, lr}
    9b64:	0004      	movs	r4, r0
    9b66:	6003      	str	r3, [r0, #0]
    9b68:	6043      	str	r3, [r0, #4]
    9b6a:	6083      	str	r3, [r0, #8]
    9b6c:	8181      	strh	r1, [r0, #12]
    9b6e:	6643      	str	r3, [r0, #100]	; 0x64
    9b70:	81c2      	strh	r2, [r0, #14]
    9b72:	6103      	str	r3, [r0, #16]
    9b74:	6143      	str	r3, [r0, #20]
    9b76:	6183      	str	r3, [r0, #24]
    9b78:	0019      	movs	r1, r3
    9b7a:	2208      	movs	r2, #8
    9b7c:	305c      	adds	r0, #92	; 0x5c
    9b7e:	f7ff fce9 	bl	9554 <memset>
    9b82:	4b05      	ldr	r3, [pc, #20]	; (9b98 <std.isra.0+0x38>)
    9b84:	6224      	str	r4, [r4, #32]
    9b86:	6263      	str	r3, [r4, #36]	; 0x24
    9b88:	4b04      	ldr	r3, [pc, #16]	; (9b9c <std.isra.0+0x3c>)
    9b8a:	62a3      	str	r3, [r4, #40]	; 0x28
    9b8c:	4b04      	ldr	r3, [pc, #16]	; (9ba0 <std.isra.0+0x40>)
    9b8e:	62e3      	str	r3, [r4, #44]	; 0x2c
    9b90:	4b04      	ldr	r3, [pc, #16]	; (9ba4 <std.isra.0+0x44>)
    9b92:	6323      	str	r3, [r4, #48]	; 0x30
    9b94:	bd10      	pop	{r4, pc}
    9b96:	46c0      	nop			; (mov r8, r8)
    9b98:	0000a7c5 	.word	0x0000a7c5
    9b9c:	0000a7ed 	.word	0x0000a7ed
    9ba0:	0000a825 	.word	0x0000a825
    9ba4:	0000a851 	.word	0x0000a851

00009ba8 <__sfmoreglue>:
    9ba8:	b570      	push	{r4, r5, r6, lr}
    9baa:	2568      	movs	r5, #104	; 0x68
    9bac:	1e4a      	subs	r2, r1, #1
    9bae:	4355      	muls	r5, r2
    9bb0:	000e      	movs	r6, r1
    9bb2:	0029      	movs	r1, r5
    9bb4:	3174      	adds	r1, #116	; 0x74
    9bb6:	f000 f963 	bl	9e80 <_malloc_r>
    9bba:	1e04      	subs	r4, r0, #0
    9bbc:	d008      	beq.n	9bd0 <__sfmoreglue+0x28>
    9bbe:	2100      	movs	r1, #0
    9bc0:	002a      	movs	r2, r5
    9bc2:	6001      	str	r1, [r0, #0]
    9bc4:	6046      	str	r6, [r0, #4]
    9bc6:	300c      	adds	r0, #12
    9bc8:	60a0      	str	r0, [r4, #8]
    9bca:	3268      	adds	r2, #104	; 0x68
    9bcc:	f7ff fcc2 	bl	9554 <memset>
    9bd0:	0020      	movs	r0, r4
    9bd2:	bd70      	pop	{r4, r5, r6, pc}

00009bd4 <__sinit>:
    9bd4:	6983      	ldr	r3, [r0, #24]
    9bd6:	b513      	push	{r0, r1, r4, lr}
    9bd8:	0004      	movs	r4, r0
    9bda:	2b00      	cmp	r3, #0
    9bdc:	d128      	bne.n	9c30 <__sinit+0x5c>
    9bde:	6483      	str	r3, [r0, #72]	; 0x48
    9be0:	64c3      	str	r3, [r0, #76]	; 0x4c
    9be2:	6503      	str	r3, [r0, #80]	; 0x50
    9be4:	4b13      	ldr	r3, [pc, #76]	; (9c34 <__sinit+0x60>)
    9be6:	4a14      	ldr	r2, [pc, #80]	; (9c38 <__sinit+0x64>)
    9be8:	681b      	ldr	r3, [r3, #0]
    9bea:	6282      	str	r2, [r0, #40]	; 0x28
    9bec:	9301      	str	r3, [sp, #4]
    9bee:	4298      	cmp	r0, r3
    9bf0:	d101      	bne.n	9bf6 <__sinit+0x22>
    9bf2:	2301      	movs	r3, #1
    9bf4:	6183      	str	r3, [r0, #24]
    9bf6:	0020      	movs	r0, r4
    9bf8:	f000 f820 	bl	9c3c <__sfp>
    9bfc:	6060      	str	r0, [r4, #4]
    9bfe:	0020      	movs	r0, r4
    9c00:	f000 f81c 	bl	9c3c <__sfp>
    9c04:	60a0      	str	r0, [r4, #8]
    9c06:	0020      	movs	r0, r4
    9c08:	f000 f818 	bl	9c3c <__sfp>
    9c0c:	2200      	movs	r2, #0
    9c0e:	60e0      	str	r0, [r4, #12]
    9c10:	2104      	movs	r1, #4
    9c12:	6860      	ldr	r0, [r4, #4]
    9c14:	f7ff ffa4 	bl	9b60 <std.isra.0>
    9c18:	2201      	movs	r2, #1
    9c1a:	2109      	movs	r1, #9
    9c1c:	68a0      	ldr	r0, [r4, #8]
    9c1e:	f7ff ff9f 	bl	9b60 <std.isra.0>
    9c22:	2202      	movs	r2, #2
    9c24:	2112      	movs	r1, #18
    9c26:	68e0      	ldr	r0, [r4, #12]
    9c28:	f7ff ff9a 	bl	9b60 <std.isra.0>
    9c2c:	2301      	movs	r3, #1
    9c2e:	61a3      	str	r3, [r4, #24]
    9c30:	bd13      	pop	{r0, r1, r4, pc}
    9c32:	46c0      	nop			; (mov r8, r8)
    9c34:	0000ed58 	.word	0x0000ed58
    9c38:	00009b51 	.word	0x00009b51

00009c3c <__sfp>:
    9c3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9c3e:	4b1e      	ldr	r3, [pc, #120]	; (9cb8 <__sfp+0x7c>)
    9c40:	0007      	movs	r7, r0
    9c42:	681e      	ldr	r6, [r3, #0]
    9c44:	69b3      	ldr	r3, [r6, #24]
    9c46:	2b00      	cmp	r3, #0
    9c48:	d102      	bne.n	9c50 <__sfp+0x14>
    9c4a:	0030      	movs	r0, r6
    9c4c:	f7ff ffc2 	bl	9bd4 <__sinit>
    9c50:	3648      	adds	r6, #72	; 0x48
    9c52:	68b4      	ldr	r4, [r6, #8]
    9c54:	6873      	ldr	r3, [r6, #4]
    9c56:	3b01      	subs	r3, #1
    9c58:	d504      	bpl.n	9c64 <__sfp+0x28>
    9c5a:	6833      	ldr	r3, [r6, #0]
    9c5c:	2b00      	cmp	r3, #0
    9c5e:	d007      	beq.n	9c70 <__sfp+0x34>
    9c60:	6836      	ldr	r6, [r6, #0]
    9c62:	e7f6      	b.n	9c52 <__sfp+0x16>
    9c64:	220c      	movs	r2, #12
    9c66:	5ea5      	ldrsh	r5, [r4, r2]
    9c68:	2d00      	cmp	r5, #0
    9c6a:	d00d      	beq.n	9c88 <__sfp+0x4c>
    9c6c:	3468      	adds	r4, #104	; 0x68
    9c6e:	e7f2      	b.n	9c56 <__sfp+0x1a>
    9c70:	2104      	movs	r1, #4
    9c72:	0038      	movs	r0, r7
    9c74:	f7ff ff98 	bl	9ba8 <__sfmoreglue>
    9c78:	6030      	str	r0, [r6, #0]
    9c7a:	2800      	cmp	r0, #0
    9c7c:	d1f0      	bne.n	9c60 <__sfp+0x24>
    9c7e:	230c      	movs	r3, #12
    9c80:	0004      	movs	r4, r0
    9c82:	603b      	str	r3, [r7, #0]
    9c84:	0020      	movs	r0, r4
    9c86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9c88:	2301      	movs	r3, #1
    9c8a:	0020      	movs	r0, r4
    9c8c:	425b      	negs	r3, r3
    9c8e:	81e3      	strh	r3, [r4, #14]
    9c90:	3302      	adds	r3, #2
    9c92:	81a3      	strh	r3, [r4, #12]
    9c94:	6665      	str	r5, [r4, #100]	; 0x64
    9c96:	6025      	str	r5, [r4, #0]
    9c98:	60a5      	str	r5, [r4, #8]
    9c9a:	6065      	str	r5, [r4, #4]
    9c9c:	6125      	str	r5, [r4, #16]
    9c9e:	6165      	str	r5, [r4, #20]
    9ca0:	61a5      	str	r5, [r4, #24]
    9ca2:	2208      	movs	r2, #8
    9ca4:	0029      	movs	r1, r5
    9ca6:	305c      	adds	r0, #92	; 0x5c
    9ca8:	f7ff fc54 	bl	9554 <memset>
    9cac:	6365      	str	r5, [r4, #52]	; 0x34
    9cae:	63a5      	str	r5, [r4, #56]	; 0x38
    9cb0:	64a5      	str	r5, [r4, #72]	; 0x48
    9cb2:	64e5      	str	r5, [r4, #76]	; 0x4c
    9cb4:	e7e6      	b.n	9c84 <__sfp+0x48>
    9cb6:	46c0      	nop			; (mov r8, r8)
    9cb8:	0000ed58 	.word	0x0000ed58

00009cbc <_fwalk_reent>:
    9cbc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    9cbe:	0004      	movs	r4, r0
    9cc0:	0007      	movs	r7, r0
    9cc2:	2600      	movs	r6, #0
    9cc4:	9101      	str	r1, [sp, #4]
    9cc6:	3448      	adds	r4, #72	; 0x48
    9cc8:	2c00      	cmp	r4, #0
    9cca:	d101      	bne.n	9cd0 <_fwalk_reent+0x14>
    9ccc:	0030      	movs	r0, r6
    9cce:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    9cd0:	6863      	ldr	r3, [r4, #4]
    9cd2:	68a5      	ldr	r5, [r4, #8]
    9cd4:	9300      	str	r3, [sp, #0]
    9cd6:	9b00      	ldr	r3, [sp, #0]
    9cd8:	3b01      	subs	r3, #1
    9cda:	9300      	str	r3, [sp, #0]
    9cdc:	d501      	bpl.n	9ce2 <_fwalk_reent+0x26>
    9cde:	6824      	ldr	r4, [r4, #0]
    9ce0:	e7f2      	b.n	9cc8 <_fwalk_reent+0xc>
    9ce2:	89ab      	ldrh	r3, [r5, #12]
    9ce4:	2b01      	cmp	r3, #1
    9ce6:	d908      	bls.n	9cfa <_fwalk_reent+0x3e>
    9ce8:	220e      	movs	r2, #14
    9cea:	5eab      	ldrsh	r3, [r5, r2]
    9cec:	3301      	adds	r3, #1
    9cee:	d004      	beq.n	9cfa <_fwalk_reent+0x3e>
    9cf0:	0029      	movs	r1, r5
    9cf2:	0038      	movs	r0, r7
    9cf4:	9b01      	ldr	r3, [sp, #4]
    9cf6:	4798      	blx	r3
    9cf8:	4306      	orrs	r6, r0
    9cfa:	3568      	adds	r5, #104	; 0x68
    9cfc:	e7eb      	b.n	9cd6 <_fwalk_reent+0x1a>
	...

00009d00 <__swhatbuf_r>:
    9d00:	b570      	push	{r4, r5, r6, lr}
    9d02:	000e      	movs	r6, r1
    9d04:	001d      	movs	r5, r3
    9d06:	230e      	movs	r3, #14
    9d08:	5ec9      	ldrsh	r1, [r1, r3]
    9d0a:	b090      	sub	sp, #64	; 0x40
    9d0c:	0014      	movs	r4, r2
    9d0e:	2900      	cmp	r1, #0
    9d10:	da07      	bge.n	9d22 <__swhatbuf_r+0x22>
    9d12:	2300      	movs	r3, #0
    9d14:	602b      	str	r3, [r5, #0]
    9d16:	89b3      	ldrh	r3, [r6, #12]
    9d18:	061b      	lsls	r3, r3, #24
    9d1a:	d411      	bmi.n	9d40 <__swhatbuf_r+0x40>
    9d1c:	2380      	movs	r3, #128	; 0x80
    9d1e:	00db      	lsls	r3, r3, #3
    9d20:	e00f      	b.n	9d42 <__swhatbuf_r+0x42>
    9d22:	aa01      	add	r2, sp, #4
    9d24:	f000 fdc0 	bl	a8a8 <_fstat_r>
    9d28:	2800      	cmp	r0, #0
    9d2a:	dbf2      	blt.n	9d12 <__swhatbuf_r+0x12>
    9d2c:	22f0      	movs	r2, #240	; 0xf0
    9d2e:	9b02      	ldr	r3, [sp, #8]
    9d30:	0212      	lsls	r2, r2, #8
    9d32:	4013      	ands	r3, r2
    9d34:	4a05      	ldr	r2, [pc, #20]	; (9d4c <__swhatbuf_r+0x4c>)
    9d36:	189b      	adds	r3, r3, r2
    9d38:	425a      	negs	r2, r3
    9d3a:	4153      	adcs	r3, r2
    9d3c:	602b      	str	r3, [r5, #0]
    9d3e:	e7ed      	b.n	9d1c <__swhatbuf_r+0x1c>
    9d40:	2340      	movs	r3, #64	; 0x40
    9d42:	2000      	movs	r0, #0
    9d44:	6023      	str	r3, [r4, #0]
    9d46:	b010      	add	sp, #64	; 0x40
    9d48:	bd70      	pop	{r4, r5, r6, pc}
    9d4a:	46c0      	nop			; (mov r8, r8)
    9d4c:	ffffe000 	.word	0xffffe000

00009d50 <__smakebuf_r>:
    9d50:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    9d52:	2602      	movs	r6, #2
    9d54:	898b      	ldrh	r3, [r1, #12]
    9d56:	0005      	movs	r5, r0
    9d58:	000c      	movs	r4, r1
    9d5a:	4233      	tst	r3, r6
    9d5c:	d006      	beq.n	9d6c <__smakebuf_r+0x1c>
    9d5e:	0023      	movs	r3, r4
    9d60:	3347      	adds	r3, #71	; 0x47
    9d62:	6023      	str	r3, [r4, #0]
    9d64:	6123      	str	r3, [r4, #16]
    9d66:	2301      	movs	r3, #1
    9d68:	6163      	str	r3, [r4, #20]
    9d6a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    9d6c:	ab01      	add	r3, sp, #4
    9d6e:	466a      	mov	r2, sp
    9d70:	f7ff ffc6 	bl	9d00 <__swhatbuf_r>
    9d74:	9900      	ldr	r1, [sp, #0]
    9d76:	0007      	movs	r7, r0
    9d78:	0028      	movs	r0, r5
    9d7a:	f000 f881 	bl	9e80 <_malloc_r>
    9d7e:	2800      	cmp	r0, #0
    9d80:	d108      	bne.n	9d94 <__smakebuf_r+0x44>
    9d82:	220c      	movs	r2, #12
    9d84:	5ea3      	ldrsh	r3, [r4, r2]
    9d86:	059a      	lsls	r2, r3, #22
    9d88:	d4ef      	bmi.n	9d6a <__smakebuf_r+0x1a>
    9d8a:	2203      	movs	r2, #3
    9d8c:	4393      	bics	r3, r2
    9d8e:	431e      	orrs	r6, r3
    9d90:	81a6      	strh	r6, [r4, #12]
    9d92:	e7e4      	b.n	9d5e <__smakebuf_r+0xe>
    9d94:	4b0f      	ldr	r3, [pc, #60]	; (9dd4 <__smakebuf_r+0x84>)
    9d96:	62ab      	str	r3, [r5, #40]	; 0x28
    9d98:	2380      	movs	r3, #128	; 0x80
    9d9a:	89a2      	ldrh	r2, [r4, #12]
    9d9c:	6020      	str	r0, [r4, #0]
    9d9e:	4313      	orrs	r3, r2
    9da0:	81a3      	strh	r3, [r4, #12]
    9da2:	9b00      	ldr	r3, [sp, #0]
    9da4:	6120      	str	r0, [r4, #16]
    9da6:	6163      	str	r3, [r4, #20]
    9da8:	9b01      	ldr	r3, [sp, #4]
    9daa:	2b00      	cmp	r3, #0
    9dac:	d00d      	beq.n	9dca <__smakebuf_r+0x7a>
    9dae:	230e      	movs	r3, #14
    9db0:	5ee1      	ldrsh	r1, [r4, r3]
    9db2:	0028      	movs	r0, r5
    9db4:	f000 fd8a 	bl	a8cc <_isatty_r>
    9db8:	2800      	cmp	r0, #0
    9dba:	d006      	beq.n	9dca <__smakebuf_r+0x7a>
    9dbc:	2203      	movs	r2, #3
    9dbe:	89a3      	ldrh	r3, [r4, #12]
    9dc0:	4393      	bics	r3, r2
    9dc2:	001a      	movs	r2, r3
    9dc4:	2301      	movs	r3, #1
    9dc6:	4313      	orrs	r3, r2
    9dc8:	81a3      	strh	r3, [r4, #12]
    9dca:	89a0      	ldrh	r0, [r4, #12]
    9dcc:	4338      	orrs	r0, r7
    9dce:	81a0      	strh	r0, [r4, #12]
    9dd0:	e7cb      	b.n	9d6a <__smakebuf_r+0x1a>
    9dd2:	46c0      	nop			; (mov r8, r8)
    9dd4:	00009b51 	.word	0x00009b51

00009dd8 <malloc>:
    9dd8:	b510      	push	{r4, lr}
    9dda:	4b03      	ldr	r3, [pc, #12]	; (9de8 <malloc+0x10>)
    9ddc:	0001      	movs	r1, r0
    9dde:	6818      	ldr	r0, [r3, #0]
    9de0:	f000 f84e 	bl	9e80 <_malloc_r>
    9de4:	bd10      	pop	{r4, pc}
    9de6:	46c0      	nop			; (mov r8, r8)
    9de8:	200000dc 	.word	0x200000dc

00009dec <_free_r>:
    9dec:	b570      	push	{r4, r5, r6, lr}
    9dee:	0005      	movs	r5, r0
    9df0:	2900      	cmp	r1, #0
    9df2:	d010      	beq.n	9e16 <_free_r+0x2a>
    9df4:	1f0c      	subs	r4, r1, #4
    9df6:	6823      	ldr	r3, [r4, #0]
    9df8:	2b00      	cmp	r3, #0
    9dfa:	da00      	bge.n	9dfe <_free_r+0x12>
    9dfc:	18e4      	adds	r4, r4, r3
    9dfe:	0028      	movs	r0, r5
    9e00:	f000 fda7 	bl	a952 <__malloc_lock>
    9e04:	4a1d      	ldr	r2, [pc, #116]	; (9e7c <_free_r+0x90>)
    9e06:	6813      	ldr	r3, [r2, #0]
    9e08:	2b00      	cmp	r3, #0
    9e0a:	d105      	bne.n	9e18 <_free_r+0x2c>
    9e0c:	6063      	str	r3, [r4, #4]
    9e0e:	6014      	str	r4, [r2, #0]
    9e10:	0028      	movs	r0, r5
    9e12:	f000 fd9f 	bl	a954 <__malloc_unlock>
    9e16:	bd70      	pop	{r4, r5, r6, pc}
    9e18:	42a3      	cmp	r3, r4
    9e1a:	d909      	bls.n	9e30 <_free_r+0x44>
    9e1c:	6821      	ldr	r1, [r4, #0]
    9e1e:	1860      	adds	r0, r4, r1
    9e20:	4283      	cmp	r3, r0
    9e22:	d1f3      	bne.n	9e0c <_free_r+0x20>
    9e24:	6818      	ldr	r0, [r3, #0]
    9e26:	685b      	ldr	r3, [r3, #4]
    9e28:	1841      	adds	r1, r0, r1
    9e2a:	6021      	str	r1, [r4, #0]
    9e2c:	e7ee      	b.n	9e0c <_free_r+0x20>
    9e2e:	0013      	movs	r3, r2
    9e30:	685a      	ldr	r2, [r3, #4]
    9e32:	2a00      	cmp	r2, #0
    9e34:	d001      	beq.n	9e3a <_free_r+0x4e>
    9e36:	42a2      	cmp	r2, r4
    9e38:	d9f9      	bls.n	9e2e <_free_r+0x42>
    9e3a:	6819      	ldr	r1, [r3, #0]
    9e3c:	1858      	adds	r0, r3, r1
    9e3e:	42a0      	cmp	r0, r4
    9e40:	d10b      	bne.n	9e5a <_free_r+0x6e>
    9e42:	6820      	ldr	r0, [r4, #0]
    9e44:	1809      	adds	r1, r1, r0
    9e46:	1858      	adds	r0, r3, r1
    9e48:	6019      	str	r1, [r3, #0]
    9e4a:	4282      	cmp	r2, r0
    9e4c:	d1e0      	bne.n	9e10 <_free_r+0x24>
    9e4e:	6810      	ldr	r0, [r2, #0]
    9e50:	6852      	ldr	r2, [r2, #4]
    9e52:	1841      	adds	r1, r0, r1
    9e54:	6019      	str	r1, [r3, #0]
    9e56:	605a      	str	r2, [r3, #4]
    9e58:	e7da      	b.n	9e10 <_free_r+0x24>
    9e5a:	42a0      	cmp	r0, r4
    9e5c:	d902      	bls.n	9e64 <_free_r+0x78>
    9e5e:	230c      	movs	r3, #12
    9e60:	602b      	str	r3, [r5, #0]
    9e62:	e7d5      	b.n	9e10 <_free_r+0x24>
    9e64:	6821      	ldr	r1, [r4, #0]
    9e66:	1860      	adds	r0, r4, r1
    9e68:	4282      	cmp	r2, r0
    9e6a:	d103      	bne.n	9e74 <_free_r+0x88>
    9e6c:	6810      	ldr	r0, [r2, #0]
    9e6e:	6852      	ldr	r2, [r2, #4]
    9e70:	1841      	adds	r1, r0, r1
    9e72:	6021      	str	r1, [r4, #0]
    9e74:	6062      	str	r2, [r4, #4]
    9e76:	605c      	str	r4, [r3, #4]
    9e78:	e7ca      	b.n	9e10 <_free_r+0x24>
    9e7a:	46c0      	nop			; (mov r8, r8)
    9e7c:	200008f8 	.word	0x200008f8

00009e80 <_malloc_r>:
    9e80:	2303      	movs	r3, #3
    9e82:	b570      	push	{r4, r5, r6, lr}
    9e84:	1ccd      	adds	r5, r1, #3
    9e86:	439d      	bics	r5, r3
    9e88:	3508      	adds	r5, #8
    9e8a:	0006      	movs	r6, r0
    9e8c:	2d0c      	cmp	r5, #12
    9e8e:	d21e      	bcs.n	9ece <_malloc_r+0x4e>
    9e90:	250c      	movs	r5, #12
    9e92:	42a9      	cmp	r1, r5
    9e94:	d81d      	bhi.n	9ed2 <_malloc_r+0x52>
    9e96:	0030      	movs	r0, r6
    9e98:	f000 fd5b 	bl	a952 <__malloc_lock>
    9e9c:	4a25      	ldr	r2, [pc, #148]	; (9f34 <_malloc_r+0xb4>)
    9e9e:	6814      	ldr	r4, [r2, #0]
    9ea0:	0021      	movs	r1, r4
    9ea2:	2900      	cmp	r1, #0
    9ea4:	d119      	bne.n	9eda <_malloc_r+0x5a>
    9ea6:	4c24      	ldr	r4, [pc, #144]	; (9f38 <_malloc_r+0xb8>)
    9ea8:	6823      	ldr	r3, [r4, #0]
    9eaa:	2b00      	cmp	r3, #0
    9eac:	d103      	bne.n	9eb6 <_malloc_r+0x36>
    9eae:	0030      	movs	r0, r6
    9eb0:	f000 fc76 	bl	a7a0 <_sbrk_r>
    9eb4:	6020      	str	r0, [r4, #0]
    9eb6:	0029      	movs	r1, r5
    9eb8:	0030      	movs	r0, r6
    9eba:	f000 fc71 	bl	a7a0 <_sbrk_r>
    9ebe:	1c43      	adds	r3, r0, #1
    9ec0:	d12c      	bne.n	9f1c <_malloc_r+0x9c>
    9ec2:	230c      	movs	r3, #12
    9ec4:	0030      	movs	r0, r6
    9ec6:	6033      	str	r3, [r6, #0]
    9ec8:	f000 fd44 	bl	a954 <__malloc_unlock>
    9ecc:	e003      	b.n	9ed6 <_malloc_r+0x56>
    9ece:	2d00      	cmp	r5, #0
    9ed0:	dadf      	bge.n	9e92 <_malloc_r+0x12>
    9ed2:	230c      	movs	r3, #12
    9ed4:	6033      	str	r3, [r6, #0]
    9ed6:	2000      	movs	r0, #0
    9ed8:	bd70      	pop	{r4, r5, r6, pc}
    9eda:	680b      	ldr	r3, [r1, #0]
    9edc:	1b5b      	subs	r3, r3, r5
    9ede:	d41a      	bmi.n	9f16 <_malloc_r+0x96>
    9ee0:	2b0b      	cmp	r3, #11
    9ee2:	d903      	bls.n	9eec <_malloc_r+0x6c>
    9ee4:	600b      	str	r3, [r1, #0]
    9ee6:	18cc      	adds	r4, r1, r3
    9ee8:	6025      	str	r5, [r4, #0]
    9eea:	e003      	b.n	9ef4 <_malloc_r+0x74>
    9eec:	428c      	cmp	r4, r1
    9eee:	d10e      	bne.n	9f0e <_malloc_r+0x8e>
    9ef0:	6863      	ldr	r3, [r4, #4]
    9ef2:	6013      	str	r3, [r2, #0]
    9ef4:	0030      	movs	r0, r6
    9ef6:	f000 fd2d 	bl	a954 <__malloc_unlock>
    9efa:	0020      	movs	r0, r4
    9efc:	2207      	movs	r2, #7
    9efe:	300b      	adds	r0, #11
    9f00:	1d23      	adds	r3, r4, #4
    9f02:	4390      	bics	r0, r2
    9f04:	1ac3      	subs	r3, r0, r3
    9f06:	d0e7      	beq.n	9ed8 <_malloc_r+0x58>
    9f08:	425a      	negs	r2, r3
    9f0a:	50e2      	str	r2, [r4, r3]
    9f0c:	e7e4      	b.n	9ed8 <_malloc_r+0x58>
    9f0e:	684b      	ldr	r3, [r1, #4]
    9f10:	6063      	str	r3, [r4, #4]
    9f12:	000c      	movs	r4, r1
    9f14:	e7ee      	b.n	9ef4 <_malloc_r+0x74>
    9f16:	000c      	movs	r4, r1
    9f18:	6849      	ldr	r1, [r1, #4]
    9f1a:	e7c2      	b.n	9ea2 <_malloc_r+0x22>
    9f1c:	2303      	movs	r3, #3
    9f1e:	1cc4      	adds	r4, r0, #3
    9f20:	439c      	bics	r4, r3
    9f22:	42a0      	cmp	r0, r4
    9f24:	d0e0      	beq.n	9ee8 <_malloc_r+0x68>
    9f26:	1a21      	subs	r1, r4, r0
    9f28:	0030      	movs	r0, r6
    9f2a:	f000 fc39 	bl	a7a0 <_sbrk_r>
    9f2e:	1c43      	adds	r3, r0, #1
    9f30:	d1da      	bne.n	9ee8 <_malloc_r+0x68>
    9f32:	e7c6      	b.n	9ec2 <_malloc_r+0x42>
    9f34:	200008f8 	.word	0x200008f8
    9f38:	200008fc 	.word	0x200008fc

00009f3c <__ssputs_r>:
    9f3c:	b5f0      	push	{r4, r5, r6, r7, lr}
    9f3e:	688e      	ldr	r6, [r1, #8]
    9f40:	b085      	sub	sp, #20
    9f42:	0007      	movs	r7, r0
    9f44:	000c      	movs	r4, r1
    9f46:	9203      	str	r2, [sp, #12]
    9f48:	9301      	str	r3, [sp, #4]
    9f4a:	429e      	cmp	r6, r3
    9f4c:	d839      	bhi.n	9fc2 <__ssputs_r+0x86>
    9f4e:	2390      	movs	r3, #144	; 0x90
    9f50:	898a      	ldrh	r2, [r1, #12]
    9f52:	00db      	lsls	r3, r3, #3
    9f54:	421a      	tst	r2, r3
    9f56:	d034      	beq.n	9fc2 <__ssputs_r+0x86>
    9f58:	2503      	movs	r5, #3
    9f5a:	6909      	ldr	r1, [r1, #16]
    9f5c:	6823      	ldr	r3, [r4, #0]
    9f5e:	1a5b      	subs	r3, r3, r1
    9f60:	9302      	str	r3, [sp, #8]
    9f62:	6963      	ldr	r3, [r4, #20]
    9f64:	9802      	ldr	r0, [sp, #8]
    9f66:	435d      	muls	r5, r3
    9f68:	0feb      	lsrs	r3, r5, #31
    9f6a:	195d      	adds	r5, r3, r5
    9f6c:	9b01      	ldr	r3, [sp, #4]
    9f6e:	106d      	asrs	r5, r5, #1
    9f70:	3301      	adds	r3, #1
    9f72:	181b      	adds	r3, r3, r0
    9f74:	42ab      	cmp	r3, r5
    9f76:	d900      	bls.n	9f7a <__ssputs_r+0x3e>
    9f78:	001d      	movs	r5, r3
    9f7a:	0553      	lsls	r3, r2, #21
    9f7c:	d532      	bpl.n	9fe4 <__ssputs_r+0xa8>
    9f7e:	0029      	movs	r1, r5
    9f80:	0038      	movs	r0, r7
    9f82:	f7ff ff7d 	bl	9e80 <_malloc_r>
    9f86:	1e06      	subs	r6, r0, #0
    9f88:	d109      	bne.n	9f9e <__ssputs_r+0x62>
    9f8a:	230c      	movs	r3, #12
    9f8c:	603b      	str	r3, [r7, #0]
    9f8e:	2340      	movs	r3, #64	; 0x40
    9f90:	2001      	movs	r0, #1
    9f92:	89a2      	ldrh	r2, [r4, #12]
    9f94:	4240      	negs	r0, r0
    9f96:	4313      	orrs	r3, r2
    9f98:	81a3      	strh	r3, [r4, #12]
    9f9a:	b005      	add	sp, #20
    9f9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9f9e:	9a02      	ldr	r2, [sp, #8]
    9fa0:	6921      	ldr	r1, [r4, #16]
    9fa2:	f7ff face 	bl	9542 <memcpy>
    9fa6:	89a3      	ldrh	r3, [r4, #12]
    9fa8:	4a14      	ldr	r2, [pc, #80]	; (9ffc <__ssputs_r+0xc0>)
    9faa:	401a      	ands	r2, r3
    9fac:	2380      	movs	r3, #128	; 0x80
    9fae:	4313      	orrs	r3, r2
    9fb0:	81a3      	strh	r3, [r4, #12]
    9fb2:	9b02      	ldr	r3, [sp, #8]
    9fb4:	6126      	str	r6, [r4, #16]
    9fb6:	18f6      	adds	r6, r6, r3
    9fb8:	6026      	str	r6, [r4, #0]
    9fba:	6165      	str	r5, [r4, #20]
    9fbc:	9e01      	ldr	r6, [sp, #4]
    9fbe:	1aed      	subs	r5, r5, r3
    9fc0:	60a5      	str	r5, [r4, #8]
    9fc2:	9b01      	ldr	r3, [sp, #4]
    9fc4:	42b3      	cmp	r3, r6
    9fc6:	d200      	bcs.n	9fca <__ssputs_r+0x8e>
    9fc8:	001e      	movs	r6, r3
    9fca:	0032      	movs	r2, r6
    9fcc:	9903      	ldr	r1, [sp, #12]
    9fce:	6820      	ldr	r0, [r4, #0]
    9fd0:	f000 fcad 	bl	a92e <memmove>
    9fd4:	68a3      	ldr	r3, [r4, #8]
    9fd6:	2000      	movs	r0, #0
    9fd8:	1b9b      	subs	r3, r3, r6
    9fda:	60a3      	str	r3, [r4, #8]
    9fdc:	6823      	ldr	r3, [r4, #0]
    9fde:	199e      	adds	r6, r3, r6
    9fe0:	6026      	str	r6, [r4, #0]
    9fe2:	e7da      	b.n	9f9a <__ssputs_r+0x5e>
    9fe4:	002a      	movs	r2, r5
    9fe6:	0038      	movs	r0, r7
    9fe8:	f000 fcb5 	bl	a956 <_realloc_r>
    9fec:	1e06      	subs	r6, r0, #0
    9fee:	d1e0      	bne.n	9fb2 <__ssputs_r+0x76>
    9ff0:	6921      	ldr	r1, [r4, #16]
    9ff2:	0038      	movs	r0, r7
    9ff4:	f7ff fefa 	bl	9dec <_free_r>
    9ff8:	e7c7      	b.n	9f8a <__ssputs_r+0x4e>
    9ffa:	46c0      	nop			; (mov r8, r8)
    9ffc:	fffffb7f 	.word	0xfffffb7f

0000a000 <_svfiprintf_r>:
    a000:	b5f0      	push	{r4, r5, r6, r7, lr}
    a002:	b09f      	sub	sp, #124	; 0x7c
    a004:	9002      	str	r0, [sp, #8]
    a006:	9305      	str	r3, [sp, #20]
    a008:	898b      	ldrh	r3, [r1, #12]
    a00a:	000f      	movs	r7, r1
    a00c:	0016      	movs	r6, r2
    a00e:	061b      	lsls	r3, r3, #24
    a010:	d511      	bpl.n	a036 <_svfiprintf_r+0x36>
    a012:	690b      	ldr	r3, [r1, #16]
    a014:	2b00      	cmp	r3, #0
    a016:	d10e      	bne.n	a036 <_svfiprintf_r+0x36>
    a018:	2140      	movs	r1, #64	; 0x40
    a01a:	f7ff ff31 	bl	9e80 <_malloc_r>
    a01e:	6038      	str	r0, [r7, #0]
    a020:	6138      	str	r0, [r7, #16]
    a022:	2800      	cmp	r0, #0
    a024:	d105      	bne.n	a032 <_svfiprintf_r+0x32>
    a026:	230c      	movs	r3, #12
    a028:	9a02      	ldr	r2, [sp, #8]
    a02a:	3801      	subs	r0, #1
    a02c:	6013      	str	r3, [r2, #0]
    a02e:	b01f      	add	sp, #124	; 0x7c
    a030:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a032:	2340      	movs	r3, #64	; 0x40
    a034:	617b      	str	r3, [r7, #20]
    a036:	2300      	movs	r3, #0
    a038:	ad06      	add	r5, sp, #24
    a03a:	616b      	str	r3, [r5, #20]
    a03c:	3320      	adds	r3, #32
    a03e:	766b      	strb	r3, [r5, #25]
    a040:	3310      	adds	r3, #16
    a042:	76ab      	strb	r3, [r5, #26]
    a044:	0034      	movs	r4, r6
    a046:	7823      	ldrb	r3, [r4, #0]
    a048:	2b00      	cmp	r3, #0
    a04a:	d147      	bne.n	a0dc <_svfiprintf_r+0xdc>
    a04c:	1ba3      	subs	r3, r4, r6
    a04e:	9304      	str	r3, [sp, #16]
    a050:	d00d      	beq.n	a06e <_svfiprintf_r+0x6e>
    a052:	1ba3      	subs	r3, r4, r6
    a054:	0032      	movs	r2, r6
    a056:	0039      	movs	r1, r7
    a058:	9802      	ldr	r0, [sp, #8]
    a05a:	f7ff ff6f 	bl	9f3c <__ssputs_r>
    a05e:	1c43      	adds	r3, r0, #1
    a060:	d100      	bne.n	a064 <_svfiprintf_r+0x64>
    a062:	e0b5      	b.n	a1d0 <_svfiprintf_r+0x1d0>
    a064:	696a      	ldr	r2, [r5, #20]
    a066:	9b04      	ldr	r3, [sp, #16]
    a068:	4694      	mov	ip, r2
    a06a:	4463      	add	r3, ip
    a06c:	616b      	str	r3, [r5, #20]
    a06e:	7823      	ldrb	r3, [r4, #0]
    a070:	2b00      	cmp	r3, #0
    a072:	d100      	bne.n	a076 <_svfiprintf_r+0x76>
    a074:	e0ac      	b.n	a1d0 <_svfiprintf_r+0x1d0>
    a076:	2201      	movs	r2, #1
    a078:	2300      	movs	r3, #0
    a07a:	4252      	negs	r2, r2
    a07c:	606a      	str	r2, [r5, #4]
    a07e:	a902      	add	r1, sp, #8
    a080:	3254      	adds	r2, #84	; 0x54
    a082:	1852      	adds	r2, r2, r1
    a084:	3401      	adds	r4, #1
    a086:	602b      	str	r3, [r5, #0]
    a088:	60eb      	str	r3, [r5, #12]
    a08a:	60ab      	str	r3, [r5, #8]
    a08c:	7013      	strb	r3, [r2, #0]
    a08e:	65ab      	str	r3, [r5, #88]	; 0x58
    a090:	4e58      	ldr	r6, [pc, #352]	; (a1f4 <_svfiprintf_r+0x1f4>)
    a092:	2205      	movs	r2, #5
    a094:	7821      	ldrb	r1, [r4, #0]
    a096:	0030      	movs	r0, r6
    a098:	f000 fc3e 	bl	a918 <memchr>
    a09c:	1c62      	adds	r2, r4, #1
    a09e:	2800      	cmp	r0, #0
    a0a0:	d120      	bne.n	a0e4 <_svfiprintf_r+0xe4>
    a0a2:	6829      	ldr	r1, [r5, #0]
    a0a4:	06cb      	lsls	r3, r1, #27
    a0a6:	d504      	bpl.n	a0b2 <_svfiprintf_r+0xb2>
    a0a8:	2353      	movs	r3, #83	; 0x53
    a0aa:	ae02      	add	r6, sp, #8
    a0ac:	3020      	adds	r0, #32
    a0ae:	199b      	adds	r3, r3, r6
    a0b0:	7018      	strb	r0, [r3, #0]
    a0b2:	070b      	lsls	r3, r1, #28
    a0b4:	d504      	bpl.n	a0c0 <_svfiprintf_r+0xc0>
    a0b6:	2353      	movs	r3, #83	; 0x53
    a0b8:	202b      	movs	r0, #43	; 0x2b
    a0ba:	ae02      	add	r6, sp, #8
    a0bc:	199b      	adds	r3, r3, r6
    a0be:	7018      	strb	r0, [r3, #0]
    a0c0:	7823      	ldrb	r3, [r4, #0]
    a0c2:	2b2a      	cmp	r3, #42	; 0x2a
    a0c4:	d016      	beq.n	a0f4 <_svfiprintf_r+0xf4>
    a0c6:	2000      	movs	r0, #0
    a0c8:	210a      	movs	r1, #10
    a0ca:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a0cc:	7822      	ldrb	r2, [r4, #0]
    a0ce:	3a30      	subs	r2, #48	; 0x30
    a0d0:	2a09      	cmp	r2, #9
    a0d2:	d955      	bls.n	a180 <_svfiprintf_r+0x180>
    a0d4:	2800      	cmp	r0, #0
    a0d6:	d015      	beq.n	a104 <_svfiprintf_r+0x104>
    a0d8:	9309      	str	r3, [sp, #36]	; 0x24
    a0da:	e013      	b.n	a104 <_svfiprintf_r+0x104>
    a0dc:	2b25      	cmp	r3, #37	; 0x25
    a0de:	d0b5      	beq.n	a04c <_svfiprintf_r+0x4c>
    a0e0:	3401      	adds	r4, #1
    a0e2:	e7b0      	b.n	a046 <_svfiprintf_r+0x46>
    a0e4:	2301      	movs	r3, #1
    a0e6:	1b80      	subs	r0, r0, r6
    a0e8:	4083      	lsls	r3, r0
    a0ea:	6829      	ldr	r1, [r5, #0]
    a0ec:	0014      	movs	r4, r2
    a0ee:	430b      	orrs	r3, r1
    a0f0:	602b      	str	r3, [r5, #0]
    a0f2:	e7cd      	b.n	a090 <_svfiprintf_r+0x90>
    a0f4:	9b05      	ldr	r3, [sp, #20]
    a0f6:	1d18      	adds	r0, r3, #4
    a0f8:	681b      	ldr	r3, [r3, #0]
    a0fa:	9005      	str	r0, [sp, #20]
    a0fc:	2b00      	cmp	r3, #0
    a0fe:	db39      	blt.n	a174 <_svfiprintf_r+0x174>
    a100:	9309      	str	r3, [sp, #36]	; 0x24
    a102:	0014      	movs	r4, r2
    a104:	7823      	ldrb	r3, [r4, #0]
    a106:	2b2e      	cmp	r3, #46	; 0x2e
    a108:	d10b      	bne.n	a122 <_svfiprintf_r+0x122>
    a10a:	7863      	ldrb	r3, [r4, #1]
    a10c:	1c62      	adds	r2, r4, #1
    a10e:	2b2a      	cmp	r3, #42	; 0x2a
    a110:	d13e      	bne.n	a190 <_svfiprintf_r+0x190>
    a112:	9b05      	ldr	r3, [sp, #20]
    a114:	3402      	adds	r4, #2
    a116:	1d1a      	adds	r2, r3, #4
    a118:	681b      	ldr	r3, [r3, #0]
    a11a:	9205      	str	r2, [sp, #20]
    a11c:	2b00      	cmp	r3, #0
    a11e:	db34      	blt.n	a18a <_svfiprintf_r+0x18a>
    a120:	9307      	str	r3, [sp, #28]
    a122:	4e35      	ldr	r6, [pc, #212]	; (a1f8 <_svfiprintf_r+0x1f8>)
    a124:	7821      	ldrb	r1, [r4, #0]
    a126:	2203      	movs	r2, #3
    a128:	0030      	movs	r0, r6
    a12a:	f000 fbf5 	bl	a918 <memchr>
    a12e:	2800      	cmp	r0, #0
    a130:	d006      	beq.n	a140 <_svfiprintf_r+0x140>
    a132:	2340      	movs	r3, #64	; 0x40
    a134:	1b80      	subs	r0, r0, r6
    a136:	4083      	lsls	r3, r0
    a138:	682a      	ldr	r2, [r5, #0]
    a13a:	3401      	adds	r4, #1
    a13c:	4313      	orrs	r3, r2
    a13e:	602b      	str	r3, [r5, #0]
    a140:	7821      	ldrb	r1, [r4, #0]
    a142:	2206      	movs	r2, #6
    a144:	482d      	ldr	r0, [pc, #180]	; (a1fc <_svfiprintf_r+0x1fc>)
    a146:	1c66      	adds	r6, r4, #1
    a148:	7629      	strb	r1, [r5, #24]
    a14a:	f000 fbe5 	bl	a918 <memchr>
    a14e:	2800      	cmp	r0, #0
    a150:	d046      	beq.n	a1e0 <_svfiprintf_r+0x1e0>
    a152:	4b2b      	ldr	r3, [pc, #172]	; (a200 <_svfiprintf_r+0x200>)
    a154:	2b00      	cmp	r3, #0
    a156:	d12f      	bne.n	a1b8 <_svfiprintf_r+0x1b8>
    a158:	6829      	ldr	r1, [r5, #0]
    a15a:	9b05      	ldr	r3, [sp, #20]
    a15c:	2207      	movs	r2, #7
    a15e:	05c9      	lsls	r1, r1, #23
    a160:	d528      	bpl.n	a1b4 <_svfiprintf_r+0x1b4>
    a162:	189b      	adds	r3, r3, r2
    a164:	4393      	bics	r3, r2
    a166:	3308      	adds	r3, #8
    a168:	9305      	str	r3, [sp, #20]
    a16a:	696b      	ldr	r3, [r5, #20]
    a16c:	9a03      	ldr	r2, [sp, #12]
    a16e:	189b      	adds	r3, r3, r2
    a170:	616b      	str	r3, [r5, #20]
    a172:	e767      	b.n	a044 <_svfiprintf_r+0x44>
    a174:	425b      	negs	r3, r3
    a176:	60eb      	str	r3, [r5, #12]
    a178:	2302      	movs	r3, #2
    a17a:	430b      	orrs	r3, r1
    a17c:	602b      	str	r3, [r5, #0]
    a17e:	e7c0      	b.n	a102 <_svfiprintf_r+0x102>
    a180:	434b      	muls	r3, r1
    a182:	3401      	adds	r4, #1
    a184:	189b      	adds	r3, r3, r2
    a186:	2001      	movs	r0, #1
    a188:	e7a0      	b.n	a0cc <_svfiprintf_r+0xcc>
    a18a:	2301      	movs	r3, #1
    a18c:	425b      	negs	r3, r3
    a18e:	e7c7      	b.n	a120 <_svfiprintf_r+0x120>
    a190:	2300      	movs	r3, #0
    a192:	0014      	movs	r4, r2
    a194:	200a      	movs	r0, #10
    a196:	001a      	movs	r2, r3
    a198:	606b      	str	r3, [r5, #4]
    a19a:	7821      	ldrb	r1, [r4, #0]
    a19c:	3930      	subs	r1, #48	; 0x30
    a19e:	2909      	cmp	r1, #9
    a1a0:	d903      	bls.n	a1aa <_svfiprintf_r+0x1aa>
    a1a2:	2b00      	cmp	r3, #0
    a1a4:	d0bd      	beq.n	a122 <_svfiprintf_r+0x122>
    a1a6:	9207      	str	r2, [sp, #28]
    a1a8:	e7bb      	b.n	a122 <_svfiprintf_r+0x122>
    a1aa:	4342      	muls	r2, r0
    a1ac:	3401      	adds	r4, #1
    a1ae:	1852      	adds	r2, r2, r1
    a1b0:	2301      	movs	r3, #1
    a1b2:	e7f2      	b.n	a19a <_svfiprintf_r+0x19a>
    a1b4:	3307      	adds	r3, #7
    a1b6:	e7d5      	b.n	a164 <_svfiprintf_r+0x164>
    a1b8:	ab05      	add	r3, sp, #20
    a1ba:	9300      	str	r3, [sp, #0]
    a1bc:	003a      	movs	r2, r7
    a1be:	4b11      	ldr	r3, [pc, #68]	; (a204 <_svfiprintf_r+0x204>)
    a1c0:	0029      	movs	r1, r5
    a1c2:	9802      	ldr	r0, [sp, #8]
    a1c4:	e000      	b.n	a1c8 <_svfiprintf_r+0x1c8>
    a1c6:	bf00      	nop
    a1c8:	9003      	str	r0, [sp, #12]
    a1ca:	9b03      	ldr	r3, [sp, #12]
    a1cc:	3301      	adds	r3, #1
    a1ce:	d1cc      	bne.n	a16a <_svfiprintf_r+0x16a>
    a1d0:	89bb      	ldrh	r3, [r7, #12]
    a1d2:	980b      	ldr	r0, [sp, #44]	; 0x2c
    a1d4:	065b      	lsls	r3, r3, #25
    a1d6:	d400      	bmi.n	a1da <_svfiprintf_r+0x1da>
    a1d8:	e729      	b.n	a02e <_svfiprintf_r+0x2e>
    a1da:	2001      	movs	r0, #1
    a1dc:	4240      	negs	r0, r0
    a1de:	e726      	b.n	a02e <_svfiprintf_r+0x2e>
    a1e0:	ab05      	add	r3, sp, #20
    a1e2:	9300      	str	r3, [sp, #0]
    a1e4:	003a      	movs	r2, r7
    a1e6:	4b07      	ldr	r3, [pc, #28]	; (a204 <_svfiprintf_r+0x204>)
    a1e8:	0029      	movs	r1, r5
    a1ea:	9802      	ldr	r0, [sp, #8]
    a1ec:	f000 f9be 	bl	a56c <_printf_i>
    a1f0:	e7ea      	b.n	a1c8 <_svfiprintf_r+0x1c8>
    a1f2:	46c0      	nop			; (mov r8, r8)
    a1f4:	0000edbc 	.word	0x0000edbc
    a1f8:	0000edc2 	.word	0x0000edc2
    a1fc:	0000edc6 	.word	0x0000edc6
    a200:	00000000 	.word	0x00000000
    a204:	00009f3d 	.word	0x00009f3d

0000a208 <__sfputc_r>:
    a208:	6893      	ldr	r3, [r2, #8]
    a20a:	b510      	push	{r4, lr}
    a20c:	3b01      	subs	r3, #1
    a20e:	6093      	str	r3, [r2, #8]
    a210:	2b00      	cmp	r3, #0
    a212:	da05      	bge.n	a220 <__sfputc_r+0x18>
    a214:	6994      	ldr	r4, [r2, #24]
    a216:	42a3      	cmp	r3, r4
    a218:	db08      	blt.n	a22c <__sfputc_r+0x24>
    a21a:	b2cb      	uxtb	r3, r1
    a21c:	2b0a      	cmp	r3, #10
    a21e:	d005      	beq.n	a22c <__sfputc_r+0x24>
    a220:	6813      	ldr	r3, [r2, #0]
    a222:	1c58      	adds	r0, r3, #1
    a224:	6010      	str	r0, [r2, #0]
    a226:	7019      	strb	r1, [r3, #0]
    a228:	b2c8      	uxtb	r0, r1
    a22a:	bd10      	pop	{r4, pc}
    a22c:	f7ff fb0e 	bl	984c <__swbuf_r>
    a230:	e7fb      	b.n	a22a <__sfputc_r+0x22>

0000a232 <__sfputs_r>:
    a232:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a234:	0006      	movs	r6, r0
    a236:	000f      	movs	r7, r1
    a238:	0014      	movs	r4, r2
    a23a:	18d5      	adds	r5, r2, r3
    a23c:	42ac      	cmp	r4, r5
    a23e:	d101      	bne.n	a244 <__sfputs_r+0x12>
    a240:	2000      	movs	r0, #0
    a242:	e007      	b.n	a254 <__sfputs_r+0x22>
    a244:	7821      	ldrb	r1, [r4, #0]
    a246:	003a      	movs	r2, r7
    a248:	0030      	movs	r0, r6
    a24a:	f7ff ffdd 	bl	a208 <__sfputc_r>
    a24e:	3401      	adds	r4, #1
    a250:	1c43      	adds	r3, r0, #1
    a252:	d1f3      	bne.n	a23c <__sfputs_r+0xa>
    a254:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0000a258 <_vfiprintf_r>:
    a258:	b5f0      	push	{r4, r5, r6, r7, lr}
    a25a:	b09f      	sub	sp, #124	; 0x7c
    a25c:	0006      	movs	r6, r0
    a25e:	000f      	movs	r7, r1
    a260:	0014      	movs	r4, r2
    a262:	9305      	str	r3, [sp, #20]
    a264:	2800      	cmp	r0, #0
    a266:	d004      	beq.n	a272 <_vfiprintf_r+0x1a>
    a268:	6983      	ldr	r3, [r0, #24]
    a26a:	2b00      	cmp	r3, #0
    a26c:	d101      	bne.n	a272 <_vfiprintf_r+0x1a>
    a26e:	f7ff fcb1 	bl	9bd4 <__sinit>
    a272:	4b7f      	ldr	r3, [pc, #508]	; (a470 <_vfiprintf_r+0x218>)
    a274:	429f      	cmp	r7, r3
    a276:	d15c      	bne.n	a332 <_vfiprintf_r+0xda>
    a278:	6877      	ldr	r7, [r6, #4]
    a27a:	89bb      	ldrh	r3, [r7, #12]
    a27c:	071b      	lsls	r3, r3, #28
    a27e:	d562      	bpl.n	a346 <_vfiprintf_r+0xee>
    a280:	693b      	ldr	r3, [r7, #16]
    a282:	2b00      	cmp	r3, #0
    a284:	d05f      	beq.n	a346 <_vfiprintf_r+0xee>
    a286:	2300      	movs	r3, #0
    a288:	ad06      	add	r5, sp, #24
    a28a:	616b      	str	r3, [r5, #20]
    a28c:	3320      	adds	r3, #32
    a28e:	766b      	strb	r3, [r5, #25]
    a290:	3310      	adds	r3, #16
    a292:	76ab      	strb	r3, [r5, #26]
    a294:	9402      	str	r4, [sp, #8]
    a296:	9c02      	ldr	r4, [sp, #8]
    a298:	7823      	ldrb	r3, [r4, #0]
    a29a:	2b00      	cmp	r3, #0
    a29c:	d15d      	bne.n	a35a <_vfiprintf_r+0x102>
    a29e:	9b02      	ldr	r3, [sp, #8]
    a2a0:	1ae3      	subs	r3, r4, r3
    a2a2:	9304      	str	r3, [sp, #16]
    a2a4:	d00d      	beq.n	a2c2 <_vfiprintf_r+0x6a>
    a2a6:	9b04      	ldr	r3, [sp, #16]
    a2a8:	9a02      	ldr	r2, [sp, #8]
    a2aa:	0039      	movs	r1, r7
    a2ac:	0030      	movs	r0, r6
    a2ae:	f7ff ffc0 	bl	a232 <__sfputs_r>
    a2b2:	1c43      	adds	r3, r0, #1
    a2b4:	d100      	bne.n	a2b8 <_vfiprintf_r+0x60>
    a2b6:	e0cc      	b.n	a452 <_vfiprintf_r+0x1fa>
    a2b8:	696a      	ldr	r2, [r5, #20]
    a2ba:	9b04      	ldr	r3, [sp, #16]
    a2bc:	4694      	mov	ip, r2
    a2be:	4463      	add	r3, ip
    a2c0:	616b      	str	r3, [r5, #20]
    a2c2:	7823      	ldrb	r3, [r4, #0]
    a2c4:	2b00      	cmp	r3, #0
    a2c6:	d100      	bne.n	a2ca <_vfiprintf_r+0x72>
    a2c8:	e0c3      	b.n	a452 <_vfiprintf_r+0x1fa>
    a2ca:	2201      	movs	r2, #1
    a2cc:	2300      	movs	r3, #0
    a2ce:	4252      	negs	r2, r2
    a2d0:	606a      	str	r2, [r5, #4]
    a2d2:	a902      	add	r1, sp, #8
    a2d4:	3254      	adds	r2, #84	; 0x54
    a2d6:	1852      	adds	r2, r2, r1
    a2d8:	3401      	adds	r4, #1
    a2da:	602b      	str	r3, [r5, #0]
    a2dc:	60eb      	str	r3, [r5, #12]
    a2de:	60ab      	str	r3, [r5, #8]
    a2e0:	7013      	strb	r3, [r2, #0]
    a2e2:	65ab      	str	r3, [r5, #88]	; 0x58
    a2e4:	7821      	ldrb	r1, [r4, #0]
    a2e6:	2205      	movs	r2, #5
    a2e8:	4862      	ldr	r0, [pc, #392]	; (a474 <_vfiprintf_r+0x21c>)
    a2ea:	f000 fb15 	bl	a918 <memchr>
    a2ee:	1c63      	adds	r3, r4, #1
    a2f0:	469c      	mov	ip, r3
    a2f2:	2800      	cmp	r0, #0
    a2f4:	d135      	bne.n	a362 <_vfiprintf_r+0x10a>
    a2f6:	6829      	ldr	r1, [r5, #0]
    a2f8:	06cb      	lsls	r3, r1, #27
    a2fa:	d504      	bpl.n	a306 <_vfiprintf_r+0xae>
    a2fc:	2353      	movs	r3, #83	; 0x53
    a2fe:	aa02      	add	r2, sp, #8
    a300:	3020      	adds	r0, #32
    a302:	189b      	adds	r3, r3, r2
    a304:	7018      	strb	r0, [r3, #0]
    a306:	070b      	lsls	r3, r1, #28
    a308:	d504      	bpl.n	a314 <_vfiprintf_r+0xbc>
    a30a:	2353      	movs	r3, #83	; 0x53
    a30c:	202b      	movs	r0, #43	; 0x2b
    a30e:	aa02      	add	r2, sp, #8
    a310:	189b      	adds	r3, r3, r2
    a312:	7018      	strb	r0, [r3, #0]
    a314:	7823      	ldrb	r3, [r4, #0]
    a316:	2b2a      	cmp	r3, #42	; 0x2a
    a318:	d02c      	beq.n	a374 <_vfiprintf_r+0x11c>
    a31a:	2000      	movs	r0, #0
    a31c:	210a      	movs	r1, #10
    a31e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a320:	7822      	ldrb	r2, [r4, #0]
    a322:	3a30      	subs	r2, #48	; 0x30
    a324:	2a09      	cmp	r2, #9
    a326:	d800      	bhi.n	a32a <_vfiprintf_r+0xd2>
    a328:	e06b      	b.n	a402 <_vfiprintf_r+0x1aa>
    a32a:	2800      	cmp	r0, #0
    a32c:	d02a      	beq.n	a384 <_vfiprintf_r+0x12c>
    a32e:	9309      	str	r3, [sp, #36]	; 0x24
    a330:	e028      	b.n	a384 <_vfiprintf_r+0x12c>
    a332:	4b51      	ldr	r3, [pc, #324]	; (a478 <_vfiprintf_r+0x220>)
    a334:	429f      	cmp	r7, r3
    a336:	d101      	bne.n	a33c <_vfiprintf_r+0xe4>
    a338:	68b7      	ldr	r7, [r6, #8]
    a33a:	e79e      	b.n	a27a <_vfiprintf_r+0x22>
    a33c:	4b4f      	ldr	r3, [pc, #316]	; (a47c <_vfiprintf_r+0x224>)
    a33e:	429f      	cmp	r7, r3
    a340:	d19b      	bne.n	a27a <_vfiprintf_r+0x22>
    a342:	68f7      	ldr	r7, [r6, #12]
    a344:	e799      	b.n	a27a <_vfiprintf_r+0x22>
    a346:	0039      	movs	r1, r7
    a348:	0030      	movs	r0, r6
    a34a:	f7ff fad5 	bl	98f8 <__swsetup_r>
    a34e:	2800      	cmp	r0, #0
    a350:	d099      	beq.n	a286 <_vfiprintf_r+0x2e>
    a352:	2001      	movs	r0, #1
    a354:	4240      	negs	r0, r0
    a356:	b01f      	add	sp, #124	; 0x7c
    a358:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a35a:	2b25      	cmp	r3, #37	; 0x25
    a35c:	d09f      	beq.n	a29e <_vfiprintf_r+0x46>
    a35e:	3401      	adds	r4, #1
    a360:	e79a      	b.n	a298 <_vfiprintf_r+0x40>
    a362:	4b44      	ldr	r3, [pc, #272]	; (a474 <_vfiprintf_r+0x21c>)
    a364:	6829      	ldr	r1, [r5, #0]
    a366:	1ac0      	subs	r0, r0, r3
    a368:	2301      	movs	r3, #1
    a36a:	4083      	lsls	r3, r0
    a36c:	430b      	orrs	r3, r1
    a36e:	602b      	str	r3, [r5, #0]
    a370:	4664      	mov	r4, ip
    a372:	e7b7      	b.n	a2e4 <_vfiprintf_r+0x8c>
    a374:	9b05      	ldr	r3, [sp, #20]
    a376:	1d18      	adds	r0, r3, #4
    a378:	681b      	ldr	r3, [r3, #0]
    a37a:	9005      	str	r0, [sp, #20]
    a37c:	2b00      	cmp	r3, #0
    a37e:	db3a      	blt.n	a3f6 <_vfiprintf_r+0x19e>
    a380:	9309      	str	r3, [sp, #36]	; 0x24
    a382:	4664      	mov	r4, ip
    a384:	7823      	ldrb	r3, [r4, #0]
    a386:	2b2e      	cmp	r3, #46	; 0x2e
    a388:	d10b      	bne.n	a3a2 <_vfiprintf_r+0x14a>
    a38a:	7863      	ldrb	r3, [r4, #1]
    a38c:	1c62      	adds	r2, r4, #1
    a38e:	2b2a      	cmp	r3, #42	; 0x2a
    a390:	d13f      	bne.n	a412 <_vfiprintf_r+0x1ba>
    a392:	9b05      	ldr	r3, [sp, #20]
    a394:	3402      	adds	r4, #2
    a396:	1d1a      	adds	r2, r3, #4
    a398:	681b      	ldr	r3, [r3, #0]
    a39a:	9205      	str	r2, [sp, #20]
    a39c:	2b00      	cmp	r3, #0
    a39e:	db35      	blt.n	a40c <_vfiprintf_r+0x1b4>
    a3a0:	9307      	str	r3, [sp, #28]
    a3a2:	7821      	ldrb	r1, [r4, #0]
    a3a4:	2203      	movs	r2, #3
    a3a6:	4836      	ldr	r0, [pc, #216]	; (a480 <_vfiprintf_r+0x228>)
    a3a8:	f000 fab6 	bl	a918 <memchr>
    a3ac:	2800      	cmp	r0, #0
    a3ae:	d007      	beq.n	a3c0 <_vfiprintf_r+0x168>
    a3b0:	4b33      	ldr	r3, [pc, #204]	; (a480 <_vfiprintf_r+0x228>)
    a3b2:	682a      	ldr	r2, [r5, #0]
    a3b4:	1ac0      	subs	r0, r0, r3
    a3b6:	2340      	movs	r3, #64	; 0x40
    a3b8:	4083      	lsls	r3, r0
    a3ba:	4313      	orrs	r3, r2
    a3bc:	602b      	str	r3, [r5, #0]
    a3be:	3401      	adds	r4, #1
    a3c0:	7821      	ldrb	r1, [r4, #0]
    a3c2:	1c63      	adds	r3, r4, #1
    a3c4:	2206      	movs	r2, #6
    a3c6:	482f      	ldr	r0, [pc, #188]	; (a484 <_vfiprintf_r+0x22c>)
    a3c8:	9302      	str	r3, [sp, #8]
    a3ca:	7629      	strb	r1, [r5, #24]
    a3cc:	f000 faa4 	bl	a918 <memchr>
    a3d0:	2800      	cmp	r0, #0
    a3d2:	d044      	beq.n	a45e <_vfiprintf_r+0x206>
    a3d4:	4b2c      	ldr	r3, [pc, #176]	; (a488 <_vfiprintf_r+0x230>)
    a3d6:	2b00      	cmp	r3, #0
    a3d8:	d12f      	bne.n	a43a <_vfiprintf_r+0x1e2>
    a3da:	6829      	ldr	r1, [r5, #0]
    a3dc:	9b05      	ldr	r3, [sp, #20]
    a3de:	2207      	movs	r2, #7
    a3e0:	05c9      	lsls	r1, r1, #23
    a3e2:	d528      	bpl.n	a436 <_vfiprintf_r+0x1de>
    a3e4:	189b      	adds	r3, r3, r2
    a3e6:	4393      	bics	r3, r2
    a3e8:	3308      	adds	r3, #8
    a3ea:	9305      	str	r3, [sp, #20]
    a3ec:	696b      	ldr	r3, [r5, #20]
    a3ee:	9a03      	ldr	r2, [sp, #12]
    a3f0:	189b      	adds	r3, r3, r2
    a3f2:	616b      	str	r3, [r5, #20]
    a3f4:	e74f      	b.n	a296 <_vfiprintf_r+0x3e>
    a3f6:	425b      	negs	r3, r3
    a3f8:	60eb      	str	r3, [r5, #12]
    a3fa:	2302      	movs	r3, #2
    a3fc:	430b      	orrs	r3, r1
    a3fe:	602b      	str	r3, [r5, #0]
    a400:	e7bf      	b.n	a382 <_vfiprintf_r+0x12a>
    a402:	434b      	muls	r3, r1
    a404:	3401      	adds	r4, #1
    a406:	189b      	adds	r3, r3, r2
    a408:	2001      	movs	r0, #1
    a40a:	e789      	b.n	a320 <_vfiprintf_r+0xc8>
    a40c:	2301      	movs	r3, #1
    a40e:	425b      	negs	r3, r3
    a410:	e7c6      	b.n	a3a0 <_vfiprintf_r+0x148>
    a412:	2300      	movs	r3, #0
    a414:	0014      	movs	r4, r2
    a416:	200a      	movs	r0, #10
    a418:	001a      	movs	r2, r3
    a41a:	606b      	str	r3, [r5, #4]
    a41c:	7821      	ldrb	r1, [r4, #0]
    a41e:	3930      	subs	r1, #48	; 0x30
    a420:	2909      	cmp	r1, #9
    a422:	d903      	bls.n	a42c <_vfiprintf_r+0x1d4>
    a424:	2b00      	cmp	r3, #0
    a426:	d0bc      	beq.n	a3a2 <_vfiprintf_r+0x14a>
    a428:	9207      	str	r2, [sp, #28]
    a42a:	e7ba      	b.n	a3a2 <_vfiprintf_r+0x14a>
    a42c:	4342      	muls	r2, r0
    a42e:	3401      	adds	r4, #1
    a430:	1852      	adds	r2, r2, r1
    a432:	2301      	movs	r3, #1
    a434:	e7f2      	b.n	a41c <_vfiprintf_r+0x1c4>
    a436:	3307      	adds	r3, #7
    a438:	e7d5      	b.n	a3e6 <_vfiprintf_r+0x18e>
    a43a:	ab05      	add	r3, sp, #20
    a43c:	9300      	str	r3, [sp, #0]
    a43e:	003a      	movs	r2, r7
    a440:	4b12      	ldr	r3, [pc, #72]	; (a48c <_vfiprintf_r+0x234>)
    a442:	0029      	movs	r1, r5
    a444:	0030      	movs	r0, r6
    a446:	e000      	b.n	a44a <_vfiprintf_r+0x1f2>
    a448:	bf00      	nop
    a44a:	9003      	str	r0, [sp, #12]
    a44c:	9b03      	ldr	r3, [sp, #12]
    a44e:	3301      	adds	r3, #1
    a450:	d1cc      	bne.n	a3ec <_vfiprintf_r+0x194>
    a452:	89bb      	ldrh	r3, [r7, #12]
    a454:	065b      	lsls	r3, r3, #25
    a456:	d500      	bpl.n	a45a <_vfiprintf_r+0x202>
    a458:	e77b      	b.n	a352 <_vfiprintf_r+0xfa>
    a45a:	980b      	ldr	r0, [sp, #44]	; 0x2c
    a45c:	e77b      	b.n	a356 <_vfiprintf_r+0xfe>
    a45e:	ab05      	add	r3, sp, #20
    a460:	9300      	str	r3, [sp, #0]
    a462:	003a      	movs	r2, r7
    a464:	4b09      	ldr	r3, [pc, #36]	; (a48c <_vfiprintf_r+0x234>)
    a466:	0029      	movs	r1, r5
    a468:	0030      	movs	r0, r6
    a46a:	f000 f87f 	bl	a56c <_printf_i>
    a46e:	e7ec      	b.n	a44a <_vfiprintf_r+0x1f2>
    a470:	0000ed7c 	.word	0x0000ed7c
    a474:	0000edbc 	.word	0x0000edbc
    a478:	0000ed9c 	.word	0x0000ed9c
    a47c:	0000ed5c 	.word	0x0000ed5c
    a480:	0000edc2 	.word	0x0000edc2
    a484:	0000edc6 	.word	0x0000edc6
    a488:	00000000 	.word	0x00000000
    a48c:	0000a233 	.word	0x0000a233

0000a490 <_printf_common>:
    a490:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    a492:	0015      	movs	r5, r2
    a494:	9301      	str	r3, [sp, #4]
    a496:	688a      	ldr	r2, [r1, #8]
    a498:	690b      	ldr	r3, [r1, #16]
    a49a:	9000      	str	r0, [sp, #0]
    a49c:	000c      	movs	r4, r1
    a49e:	4293      	cmp	r3, r2
    a4a0:	da00      	bge.n	a4a4 <_printf_common+0x14>
    a4a2:	0013      	movs	r3, r2
    a4a4:	0022      	movs	r2, r4
    a4a6:	602b      	str	r3, [r5, #0]
    a4a8:	3243      	adds	r2, #67	; 0x43
    a4aa:	7812      	ldrb	r2, [r2, #0]
    a4ac:	2a00      	cmp	r2, #0
    a4ae:	d001      	beq.n	a4b4 <_printf_common+0x24>
    a4b0:	3301      	adds	r3, #1
    a4b2:	602b      	str	r3, [r5, #0]
    a4b4:	6823      	ldr	r3, [r4, #0]
    a4b6:	069b      	lsls	r3, r3, #26
    a4b8:	d502      	bpl.n	a4c0 <_printf_common+0x30>
    a4ba:	682b      	ldr	r3, [r5, #0]
    a4bc:	3302      	adds	r3, #2
    a4be:	602b      	str	r3, [r5, #0]
    a4c0:	2706      	movs	r7, #6
    a4c2:	6823      	ldr	r3, [r4, #0]
    a4c4:	401f      	ands	r7, r3
    a4c6:	d027      	beq.n	a518 <_printf_common+0x88>
    a4c8:	0023      	movs	r3, r4
    a4ca:	3343      	adds	r3, #67	; 0x43
    a4cc:	781b      	ldrb	r3, [r3, #0]
    a4ce:	1e5a      	subs	r2, r3, #1
    a4d0:	4193      	sbcs	r3, r2
    a4d2:	6822      	ldr	r2, [r4, #0]
    a4d4:	0692      	lsls	r2, r2, #26
    a4d6:	d430      	bmi.n	a53a <_printf_common+0xaa>
    a4d8:	0022      	movs	r2, r4
    a4da:	9901      	ldr	r1, [sp, #4]
    a4dc:	3243      	adds	r2, #67	; 0x43
    a4de:	9800      	ldr	r0, [sp, #0]
    a4e0:	9e08      	ldr	r6, [sp, #32]
    a4e2:	47b0      	blx	r6
    a4e4:	1c43      	adds	r3, r0, #1
    a4e6:	d025      	beq.n	a534 <_printf_common+0xa4>
    a4e8:	2306      	movs	r3, #6
    a4ea:	6820      	ldr	r0, [r4, #0]
    a4ec:	682a      	ldr	r2, [r5, #0]
    a4ee:	68e1      	ldr	r1, [r4, #12]
    a4f0:	4003      	ands	r3, r0
    a4f2:	2500      	movs	r5, #0
    a4f4:	2b04      	cmp	r3, #4
    a4f6:	d103      	bne.n	a500 <_printf_common+0x70>
    a4f8:	1a8d      	subs	r5, r1, r2
    a4fa:	43eb      	mvns	r3, r5
    a4fc:	17db      	asrs	r3, r3, #31
    a4fe:	401d      	ands	r5, r3
    a500:	68a3      	ldr	r3, [r4, #8]
    a502:	6922      	ldr	r2, [r4, #16]
    a504:	4293      	cmp	r3, r2
    a506:	dd01      	ble.n	a50c <_printf_common+0x7c>
    a508:	1a9b      	subs	r3, r3, r2
    a50a:	18ed      	adds	r5, r5, r3
    a50c:	2700      	movs	r7, #0
    a50e:	42bd      	cmp	r5, r7
    a510:	d120      	bne.n	a554 <_printf_common+0xc4>
    a512:	2000      	movs	r0, #0
    a514:	e010      	b.n	a538 <_printf_common+0xa8>
    a516:	3701      	adds	r7, #1
    a518:	68e3      	ldr	r3, [r4, #12]
    a51a:	682a      	ldr	r2, [r5, #0]
    a51c:	1a9b      	subs	r3, r3, r2
    a51e:	429f      	cmp	r7, r3
    a520:	dad2      	bge.n	a4c8 <_printf_common+0x38>
    a522:	0022      	movs	r2, r4
    a524:	2301      	movs	r3, #1
    a526:	3219      	adds	r2, #25
    a528:	9901      	ldr	r1, [sp, #4]
    a52a:	9800      	ldr	r0, [sp, #0]
    a52c:	9e08      	ldr	r6, [sp, #32]
    a52e:	47b0      	blx	r6
    a530:	1c43      	adds	r3, r0, #1
    a532:	d1f0      	bne.n	a516 <_printf_common+0x86>
    a534:	2001      	movs	r0, #1
    a536:	4240      	negs	r0, r0
    a538:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    a53a:	2030      	movs	r0, #48	; 0x30
    a53c:	18e1      	adds	r1, r4, r3
    a53e:	3143      	adds	r1, #67	; 0x43
    a540:	7008      	strb	r0, [r1, #0]
    a542:	0021      	movs	r1, r4
    a544:	1c5a      	adds	r2, r3, #1
    a546:	3145      	adds	r1, #69	; 0x45
    a548:	7809      	ldrb	r1, [r1, #0]
    a54a:	18a2      	adds	r2, r4, r2
    a54c:	3243      	adds	r2, #67	; 0x43
    a54e:	3302      	adds	r3, #2
    a550:	7011      	strb	r1, [r2, #0]
    a552:	e7c1      	b.n	a4d8 <_printf_common+0x48>
    a554:	0022      	movs	r2, r4
    a556:	2301      	movs	r3, #1
    a558:	321a      	adds	r2, #26
    a55a:	9901      	ldr	r1, [sp, #4]
    a55c:	9800      	ldr	r0, [sp, #0]
    a55e:	9e08      	ldr	r6, [sp, #32]
    a560:	47b0      	blx	r6
    a562:	1c43      	adds	r3, r0, #1
    a564:	d0e6      	beq.n	a534 <_printf_common+0xa4>
    a566:	3701      	adds	r7, #1
    a568:	e7d1      	b.n	a50e <_printf_common+0x7e>
	...

0000a56c <_printf_i>:
    a56c:	b5f0      	push	{r4, r5, r6, r7, lr}
    a56e:	b08b      	sub	sp, #44	; 0x2c
    a570:	9206      	str	r2, [sp, #24]
    a572:	000a      	movs	r2, r1
    a574:	3243      	adds	r2, #67	; 0x43
    a576:	9307      	str	r3, [sp, #28]
    a578:	9005      	str	r0, [sp, #20]
    a57a:	9204      	str	r2, [sp, #16]
    a57c:	7e0a      	ldrb	r2, [r1, #24]
    a57e:	000c      	movs	r4, r1
    a580:	9b10      	ldr	r3, [sp, #64]	; 0x40
    a582:	2a6e      	cmp	r2, #110	; 0x6e
    a584:	d100      	bne.n	a588 <_printf_i+0x1c>
    a586:	e08f      	b.n	a6a8 <_printf_i+0x13c>
    a588:	d817      	bhi.n	a5ba <_printf_i+0x4e>
    a58a:	2a63      	cmp	r2, #99	; 0x63
    a58c:	d02c      	beq.n	a5e8 <_printf_i+0x7c>
    a58e:	d808      	bhi.n	a5a2 <_printf_i+0x36>
    a590:	2a00      	cmp	r2, #0
    a592:	d100      	bne.n	a596 <_printf_i+0x2a>
    a594:	e099      	b.n	a6ca <_printf_i+0x15e>
    a596:	2a58      	cmp	r2, #88	; 0x58
    a598:	d054      	beq.n	a644 <_printf_i+0xd8>
    a59a:	0026      	movs	r6, r4
    a59c:	3642      	adds	r6, #66	; 0x42
    a59e:	7032      	strb	r2, [r6, #0]
    a5a0:	e029      	b.n	a5f6 <_printf_i+0x8a>
    a5a2:	2a64      	cmp	r2, #100	; 0x64
    a5a4:	d001      	beq.n	a5aa <_printf_i+0x3e>
    a5a6:	2a69      	cmp	r2, #105	; 0x69
    a5a8:	d1f7      	bne.n	a59a <_printf_i+0x2e>
    a5aa:	6821      	ldr	r1, [r4, #0]
    a5ac:	681a      	ldr	r2, [r3, #0]
    a5ae:	0608      	lsls	r0, r1, #24
    a5b0:	d523      	bpl.n	a5fa <_printf_i+0x8e>
    a5b2:	1d11      	adds	r1, r2, #4
    a5b4:	6019      	str	r1, [r3, #0]
    a5b6:	6815      	ldr	r5, [r2, #0]
    a5b8:	e025      	b.n	a606 <_printf_i+0x9a>
    a5ba:	2a73      	cmp	r2, #115	; 0x73
    a5bc:	d100      	bne.n	a5c0 <_printf_i+0x54>
    a5be:	e088      	b.n	a6d2 <_printf_i+0x166>
    a5c0:	d808      	bhi.n	a5d4 <_printf_i+0x68>
    a5c2:	2a6f      	cmp	r2, #111	; 0x6f
    a5c4:	d029      	beq.n	a61a <_printf_i+0xae>
    a5c6:	2a70      	cmp	r2, #112	; 0x70
    a5c8:	d1e7      	bne.n	a59a <_printf_i+0x2e>
    a5ca:	2220      	movs	r2, #32
    a5cc:	6809      	ldr	r1, [r1, #0]
    a5ce:	430a      	orrs	r2, r1
    a5d0:	6022      	str	r2, [r4, #0]
    a5d2:	e003      	b.n	a5dc <_printf_i+0x70>
    a5d4:	2a75      	cmp	r2, #117	; 0x75
    a5d6:	d020      	beq.n	a61a <_printf_i+0xae>
    a5d8:	2a78      	cmp	r2, #120	; 0x78
    a5da:	d1de      	bne.n	a59a <_printf_i+0x2e>
    a5dc:	0022      	movs	r2, r4
    a5de:	2178      	movs	r1, #120	; 0x78
    a5e0:	3245      	adds	r2, #69	; 0x45
    a5e2:	7011      	strb	r1, [r2, #0]
    a5e4:	4a6c      	ldr	r2, [pc, #432]	; (a798 <_printf_i+0x22c>)
    a5e6:	e030      	b.n	a64a <_printf_i+0xde>
    a5e8:	000e      	movs	r6, r1
    a5ea:	681a      	ldr	r2, [r3, #0]
    a5ec:	3642      	adds	r6, #66	; 0x42
    a5ee:	1d11      	adds	r1, r2, #4
    a5f0:	6019      	str	r1, [r3, #0]
    a5f2:	6813      	ldr	r3, [r2, #0]
    a5f4:	7033      	strb	r3, [r6, #0]
    a5f6:	2301      	movs	r3, #1
    a5f8:	e079      	b.n	a6ee <_printf_i+0x182>
    a5fa:	0649      	lsls	r1, r1, #25
    a5fc:	d5d9      	bpl.n	a5b2 <_printf_i+0x46>
    a5fe:	1d11      	adds	r1, r2, #4
    a600:	6019      	str	r1, [r3, #0]
    a602:	2300      	movs	r3, #0
    a604:	5ed5      	ldrsh	r5, [r2, r3]
    a606:	2d00      	cmp	r5, #0
    a608:	da03      	bge.n	a612 <_printf_i+0xa6>
    a60a:	232d      	movs	r3, #45	; 0x2d
    a60c:	9a04      	ldr	r2, [sp, #16]
    a60e:	426d      	negs	r5, r5
    a610:	7013      	strb	r3, [r2, #0]
    a612:	4b62      	ldr	r3, [pc, #392]	; (a79c <_printf_i+0x230>)
    a614:	270a      	movs	r7, #10
    a616:	9303      	str	r3, [sp, #12]
    a618:	e02f      	b.n	a67a <_printf_i+0x10e>
    a61a:	6820      	ldr	r0, [r4, #0]
    a61c:	6819      	ldr	r1, [r3, #0]
    a61e:	0605      	lsls	r5, r0, #24
    a620:	d503      	bpl.n	a62a <_printf_i+0xbe>
    a622:	1d08      	adds	r0, r1, #4
    a624:	6018      	str	r0, [r3, #0]
    a626:	680d      	ldr	r5, [r1, #0]
    a628:	e005      	b.n	a636 <_printf_i+0xca>
    a62a:	0640      	lsls	r0, r0, #25
    a62c:	d5f9      	bpl.n	a622 <_printf_i+0xb6>
    a62e:	680d      	ldr	r5, [r1, #0]
    a630:	1d08      	adds	r0, r1, #4
    a632:	6018      	str	r0, [r3, #0]
    a634:	b2ad      	uxth	r5, r5
    a636:	4b59      	ldr	r3, [pc, #356]	; (a79c <_printf_i+0x230>)
    a638:	2708      	movs	r7, #8
    a63a:	9303      	str	r3, [sp, #12]
    a63c:	2a6f      	cmp	r2, #111	; 0x6f
    a63e:	d018      	beq.n	a672 <_printf_i+0x106>
    a640:	270a      	movs	r7, #10
    a642:	e016      	b.n	a672 <_printf_i+0x106>
    a644:	3145      	adds	r1, #69	; 0x45
    a646:	700a      	strb	r2, [r1, #0]
    a648:	4a54      	ldr	r2, [pc, #336]	; (a79c <_printf_i+0x230>)
    a64a:	9203      	str	r2, [sp, #12]
    a64c:	681a      	ldr	r2, [r3, #0]
    a64e:	6821      	ldr	r1, [r4, #0]
    a650:	1d10      	adds	r0, r2, #4
    a652:	6018      	str	r0, [r3, #0]
    a654:	6815      	ldr	r5, [r2, #0]
    a656:	0608      	lsls	r0, r1, #24
    a658:	d522      	bpl.n	a6a0 <_printf_i+0x134>
    a65a:	07cb      	lsls	r3, r1, #31
    a65c:	d502      	bpl.n	a664 <_printf_i+0xf8>
    a65e:	2320      	movs	r3, #32
    a660:	4319      	orrs	r1, r3
    a662:	6021      	str	r1, [r4, #0]
    a664:	2710      	movs	r7, #16
    a666:	2d00      	cmp	r5, #0
    a668:	d103      	bne.n	a672 <_printf_i+0x106>
    a66a:	2320      	movs	r3, #32
    a66c:	6822      	ldr	r2, [r4, #0]
    a66e:	439a      	bics	r2, r3
    a670:	6022      	str	r2, [r4, #0]
    a672:	0023      	movs	r3, r4
    a674:	2200      	movs	r2, #0
    a676:	3343      	adds	r3, #67	; 0x43
    a678:	701a      	strb	r2, [r3, #0]
    a67a:	6863      	ldr	r3, [r4, #4]
    a67c:	60a3      	str	r3, [r4, #8]
    a67e:	2b00      	cmp	r3, #0
    a680:	db5c      	blt.n	a73c <_printf_i+0x1d0>
    a682:	2204      	movs	r2, #4
    a684:	6821      	ldr	r1, [r4, #0]
    a686:	4391      	bics	r1, r2
    a688:	6021      	str	r1, [r4, #0]
    a68a:	2d00      	cmp	r5, #0
    a68c:	d158      	bne.n	a740 <_printf_i+0x1d4>
    a68e:	9e04      	ldr	r6, [sp, #16]
    a690:	2b00      	cmp	r3, #0
    a692:	d064      	beq.n	a75e <_printf_i+0x1f2>
    a694:	0026      	movs	r6, r4
    a696:	9b03      	ldr	r3, [sp, #12]
    a698:	3642      	adds	r6, #66	; 0x42
    a69a:	781b      	ldrb	r3, [r3, #0]
    a69c:	7033      	strb	r3, [r6, #0]
    a69e:	e05e      	b.n	a75e <_printf_i+0x1f2>
    a6a0:	0648      	lsls	r0, r1, #25
    a6a2:	d5da      	bpl.n	a65a <_printf_i+0xee>
    a6a4:	b2ad      	uxth	r5, r5
    a6a6:	e7d8      	b.n	a65a <_printf_i+0xee>
    a6a8:	6809      	ldr	r1, [r1, #0]
    a6aa:	681a      	ldr	r2, [r3, #0]
    a6ac:	0608      	lsls	r0, r1, #24
    a6ae:	d505      	bpl.n	a6bc <_printf_i+0x150>
    a6b0:	1d11      	adds	r1, r2, #4
    a6b2:	6019      	str	r1, [r3, #0]
    a6b4:	6813      	ldr	r3, [r2, #0]
    a6b6:	6962      	ldr	r2, [r4, #20]
    a6b8:	601a      	str	r2, [r3, #0]
    a6ba:	e006      	b.n	a6ca <_printf_i+0x15e>
    a6bc:	0649      	lsls	r1, r1, #25
    a6be:	d5f7      	bpl.n	a6b0 <_printf_i+0x144>
    a6c0:	1d11      	adds	r1, r2, #4
    a6c2:	6019      	str	r1, [r3, #0]
    a6c4:	6813      	ldr	r3, [r2, #0]
    a6c6:	8aa2      	ldrh	r2, [r4, #20]
    a6c8:	801a      	strh	r2, [r3, #0]
    a6ca:	2300      	movs	r3, #0
    a6cc:	9e04      	ldr	r6, [sp, #16]
    a6ce:	6123      	str	r3, [r4, #16]
    a6d0:	e054      	b.n	a77c <_printf_i+0x210>
    a6d2:	681a      	ldr	r2, [r3, #0]
    a6d4:	1d11      	adds	r1, r2, #4
    a6d6:	6019      	str	r1, [r3, #0]
    a6d8:	6816      	ldr	r6, [r2, #0]
    a6da:	2100      	movs	r1, #0
    a6dc:	6862      	ldr	r2, [r4, #4]
    a6de:	0030      	movs	r0, r6
    a6e0:	f000 f91a 	bl	a918 <memchr>
    a6e4:	2800      	cmp	r0, #0
    a6e6:	d001      	beq.n	a6ec <_printf_i+0x180>
    a6e8:	1b80      	subs	r0, r0, r6
    a6ea:	6060      	str	r0, [r4, #4]
    a6ec:	6863      	ldr	r3, [r4, #4]
    a6ee:	6123      	str	r3, [r4, #16]
    a6f0:	2300      	movs	r3, #0
    a6f2:	9a04      	ldr	r2, [sp, #16]
    a6f4:	7013      	strb	r3, [r2, #0]
    a6f6:	e041      	b.n	a77c <_printf_i+0x210>
    a6f8:	6923      	ldr	r3, [r4, #16]
    a6fa:	0032      	movs	r2, r6
    a6fc:	9906      	ldr	r1, [sp, #24]
    a6fe:	9805      	ldr	r0, [sp, #20]
    a700:	9d07      	ldr	r5, [sp, #28]
    a702:	47a8      	blx	r5
    a704:	1c43      	adds	r3, r0, #1
    a706:	d043      	beq.n	a790 <_printf_i+0x224>
    a708:	6823      	ldr	r3, [r4, #0]
    a70a:	2500      	movs	r5, #0
    a70c:	079b      	lsls	r3, r3, #30
    a70e:	d40f      	bmi.n	a730 <_printf_i+0x1c4>
    a710:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a712:	68e0      	ldr	r0, [r4, #12]
    a714:	4298      	cmp	r0, r3
    a716:	da3d      	bge.n	a794 <_printf_i+0x228>
    a718:	0018      	movs	r0, r3
    a71a:	e03b      	b.n	a794 <_printf_i+0x228>
    a71c:	0022      	movs	r2, r4
    a71e:	2301      	movs	r3, #1
    a720:	3219      	adds	r2, #25
    a722:	9906      	ldr	r1, [sp, #24]
    a724:	9805      	ldr	r0, [sp, #20]
    a726:	9e07      	ldr	r6, [sp, #28]
    a728:	47b0      	blx	r6
    a72a:	1c43      	adds	r3, r0, #1
    a72c:	d030      	beq.n	a790 <_printf_i+0x224>
    a72e:	3501      	adds	r5, #1
    a730:	68e3      	ldr	r3, [r4, #12]
    a732:	9a09      	ldr	r2, [sp, #36]	; 0x24
    a734:	1a9b      	subs	r3, r3, r2
    a736:	429d      	cmp	r5, r3
    a738:	dbf0      	blt.n	a71c <_printf_i+0x1b0>
    a73a:	e7e9      	b.n	a710 <_printf_i+0x1a4>
    a73c:	2d00      	cmp	r5, #0
    a73e:	d0a9      	beq.n	a694 <_printf_i+0x128>
    a740:	9e04      	ldr	r6, [sp, #16]
    a742:	0028      	movs	r0, r5
    a744:	0039      	movs	r1, r7
    a746:	f7fe fdaf 	bl	92a8 <__aeabi_uidivmod>
    a74a:	9b03      	ldr	r3, [sp, #12]
    a74c:	3e01      	subs	r6, #1
    a74e:	5c5b      	ldrb	r3, [r3, r1]
    a750:	0028      	movs	r0, r5
    a752:	7033      	strb	r3, [r6, #0]
    a754:	0039      	movs	r1, r7
    a756:	f7fe fd21 	bl	919c <__udivsi3>
    a75a:	1e05      	subs	r5, r0, #0
    a75c:	d1f1      	bne.n	a742 <_printf_i+0x1d6>
    a75e:	2f08      	cmp	r7, #8
    a760:	d109      	bne.n	a776 <_printf_i+0x20a>
    a762:	6823      	ldr	r3, [r4, #0]
    a764:	07db      	lsls	r3, r3, #31
    a766:	d506      	bpl.n	a776 <_printf_i+0x20a>
    a768:	6863      	ldr	r3, [r4, #4]
    a76a:	6922      	ldr	r2, [r4, #16]
    a76c:	4293      	cmp	r3, r2
    a76e:	dc02      	bgt.n	a776 <_printf_i+0x20a>
    a770:	2330      	movs	r3, #48	; 0x30
    a772:	3e01      	subs	r6, #1
    a774:	7033      	strb	r3, [r6, #0]
    a776:	9b04      	ldr	r3, [sp, #16]
    a778:	1b9b      	subs	r3, r3, r6
    a77a:	6123      	str	r3, [r4, #16]
    a77c:	9b07      	ldr	r3, [sp, #28]
    a77e:	aa09      	add	r2, sp, #36	; 0x24
    a780:	9300      	str	r3, [sp, #0]
    a782:	0021      	movs	r1, r4
    a784:	9b06      	ldr	r3, [sp, #24]
    a786:	9805      	ldr	r0, [sp, #20]
    a788:	f7ff fe82 	bl	a490 <_printf_common>
    a78c:	1c43      	adds	r3, r0, #1
    a78e:	d1b3      	bne.n	a6f8 <_printf_i+0x18c>
    a790:	2001      	movs	r0, #1
    a792:	4240      	negs	r0, r0
    a794:	b00b      	add	sp, #44	; 0x2c
    a796:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a798:	0000edde 	.word	0x0000edde
    a79c:	0000edcd 	.word	0x0000edcd

0000a7a0 <_sbrk_r>:
    a7a0:	2300      	movs	r3, #0
    a7a2:	b570      	push	{r4, r5, r6, lr}
    a7a4:	4c06      	ldr	r4, [pc, #24]	; (a7c0 <_sbrk_r+0x20>)
    a7a6:	0005      	movs	r5, r0
    a7a8:	0008      	movs	r0, r1
    a7aa:	6023      	str	r3, [r4, #0]
    a7ac:	f7f8 f85a 	bl	2864 <_sbrk>
    a7b0:	1c43      	adds	r3, r0, #1
    a7b2:	d103      	bne.n	a7bc <_sbrk_r+0x1c>
    a7b4:	6823      	ldr	r3, [r4, #0]
    a7b6:	2b00      	cmp	r3, #0
    a7b8:	d000      	beq.n	a7bc <_sbrk_r+0x1c>
    a7ba:	602b      	str	r3, [r5, #0]
    a7bc:	bd70      	pop	{r4, r5, r6, pc}
    a7be:	46c0      	nop			; (mov r8, r8)
    a7c0:	20000ac8 	.word	0x20000ac8

0000a7c4 <__sread>:
    a7c4:	b570      	push	{r4, r5, r6, lr}
    a7c6:	000c      	movs	r4, r1
    a7c8:	250e      	movs	r5, #14
    a7ca:	5f49      	ldrsh	r1, [r1, r5]
    a7cc:	f000 f8ea 	bl	a9a4 <_read_r>
    a7d0:	2800      	cmp	r0, #0
    a7d2:	db03      	blt.n	a7dc <__sread+0x18>
    a7d4:	6d63      	ldr	r3, [r4, #84]	; 0x54
    a7d6:	181b      	adds	r3, r3, r0
    a7d8:	6563      	str	r3, [r4, #84]	; 0x54
    a7da:	bd70      	pop	{r4, r5, r6, pc}
    a7dc:	89a3      	ldrh	r3, [r4, #12]
    a7de:	4a02      	ldr	r2, [pc, #8]	; (a7e8 <__sread+0x24>)
    a7e0:	4013      	ands	r3, r2
    a7e2:	81a3      	strh	r3, [r4, #12]
    a7e4:	e7f9      	b.n	a7da <__sread+0x16>
    a7e6:	46c0      	nop			; (mov r8, r8)
    a7e8:	ffffefff 	.word	0xffffefff

0000a7ec <__swrite>:
    a7ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a7ee:	001f      	movs	r7, r3
    a7f0:	898b      	ldrh	r3, [r1, #12]
    a7f2:	0005      	movs	r5, r0
    a7f4:	000c      	movs	r4, r1
    a7f6:	0016      	movs	r6, r2
    a7f8:	05db      	lsls	r3, r3, #23
    a7fa:	d505      	bpl.n	a808 <__swrite+0x1c>
    a7fc:	230e      	movs	r3, #14
    a7fe:	5ec9      	ldrsh	r1, [r1, r3]
    a800:	2200      	movs	r2, #0
    a802:	2302      	movs	r3, #2
    a804:	f000 f874 	bl	a8f0 <_lseek_r>
    a808:	89a3      	ldrh	r3, [r4, #12]
    a80a:	4a05      	ldr	r2, [pc, #20]	; (a820 <__swrite+0x34>)
    a80c:	0028      	movs	r0, r5
    a80e:	4013      	ands	r3, r2
    a810:	81a3      	strh	r3, [r4, #12]
    a812:	0032      	movs	r2, r6
    a814:	230e      	movs	r3, #14
    a816:	5ee1      	ldrsh	r1, [r4, r3]
    a818:	003b      	movs	r3, r7
    a81a:	f000 f81f 	bl	a85c <_write_r>
    a81e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a820:	ffffefff 	.word	0xffffefff

0000a824 <__sseek>:
    a824:	b570      	push	{r4, r5, r6, lr}
    a826:	000c      	movs	r4, r1
    a828:	250e      	movs	r5, #14
    a82a:	5f49      	ldrsh	r1, [r1, r5]
    a82c:	f000 f860 	bl	a8f0 <_lseek_r>
    a830:	89a3      	ldrh	r3, [r4, #12]
    a832:	1c42      	adds	r2, r0, #1
    a834:	d103      	bne.n	a83e <__sseek+0x1a>
    a836:	4a05      	ldr	r2, [pc, #20]	; (a84c <__sseek+0x28>)
    a838:	4013      	ands	r3, r2
    a83a:	81a3      	strh	r3, [r4, #12]
    a83c:	bd70      	pop	{r4, r5, r6, pc}
    a83e:	2280      	movs	r2, #128	; 0x80
    a840:	0152      	lsls	r2, r2, #5
    a842:	4313      	orrs	r3, r2
    a844:	81a3      	strh	r3, [r4, #12]
    a846:	6560      	str	r0, [r4, #84]	; 0x54
    a848:	e7f8      	b.n	a83c <__sseek+0x18>
    a84a:	46c0      	nop			; (mov r8, r8)
    a84c:	ffffefff 	.word	0xffffefff

0000a850 <__sclose>:
    a850:	b510      	push	{r4, lr}
    a852:	230e      	movs	r3, #14
    a854:	5ec9      	ldrsh	r1, [r1, r3]
    a856:	f000 f815 	bl	a884 <_close_r>
    a85a:	bd10      	pop	{r4, pc}

0000a85c <_write_r>:
    a85c:	b570      	push	{r4, r5, r6, lr}
    a85e:	0005      	movs	r5, r0
    a860:	0008      	movs	r0, r1
    a862:	0011      	movs	r1, r2
    a864:	2200      	movs	r2, #0
    a866:	4c06      	ldr	r4, [pc, #24]	; (a880 <_write_r+0x24>)
    a868:	6022      	str	r2, [r4, #0]
    a86a:	001a      	movs	r2, r3
    a86c:	f7fd f816 	bl	789c <_write>
    a870:	1c43      	adds	r3, r0, #1
    a872:	d103      	bne.n	a87c <_write_r+0x20>
    a874:	6823      	ldr	r3, [r4, #0]
    a876:	2b00      	cmp	r3, #0
    a878:	d000      	beq.n	a87c <_write_r+0x20>
    a87a:	602b      	str	r3, [r5, #0]
    a87c:	bd70      	pop	{r4, r5, r6, pc}
    a87e:	46c0      	nop			; (mov r8, r8)
    a880:	20000ac8 	.word	0x20000ac8

0000a884 <_close_r>:
    a884:	2300      	movs	r3, #0
    a886:	b570      	push	{r4, r5, r6, lr}
    a888:	4c06      	ldr	r4, [pc, #24]	; (a8a4 <_close_r+0x20>)
    a88a:	0005      	movs	r5, r0
    a88c:	0008      	movs	r0, r1
    a88e:	6023      	str	r3, [r4, #0]
    a890:	f7f7 fffa 	bl	2888 <_close>
    a894:	1c43      	adds	r3, r0, #1
    a896:	d103      	bne.n	a8a0 <_close_r+0x1c>
    a898:	6823      	ldr	r3, [r4, #0]
    a89a:	2b00      	cmp	r3, #0
    a89c:	d000      	beq.n	a8a0 <_close_r+0x1c>
    a89e:	602b      	str	r3, [r5, #0]
    a8a0:	bd70      	pop	{r4, r5, r6, pc}
    a8a2:	46c0      	nop			; (mov r8, r8)
    a8a4:	20000ac8 	.word	0x20000ac8

0000a8a8 <_fstat_r>:
    a8a8:	2300      	movs	r3, #0
    a8aa:	b570      	push	{r4, r5, r6, lr}
    a8ac:	4c06      	ldr	r4, [pc, #24]	; (a8c8 <_fstat_r+0x20>)
    a8ae:	0005      	movs	r5, r0
    a8b0:	0008      	movs	r0, r1
    a8b2:	0011      	movs	r1, r2
    a8b4:	6023      	str	r3, [r4, #0]
    a8b6:	f7f7 ffea 	bl	288e <_fstat>
    a8ba:	1c43      	adds	r3, r0, #1
    a8bc:	d103      	bne.n	a8c6 <_fstat_r+0x1e>
    a8be:	6823      	ldr	r3, [r4, #0]
    a8c0:	2b00      	cmp	r3, #0
    a8c2:	d000      	beq.n	a8c6 <_fstat_r+0x1e>
    a8c4:	602b      	str	r3, [r5, #0]
    a8c6:	bd70      	pop	{r4, r5, r6, pc}
    a8c8:	20000ac8 	.word	0x20000ac8

0000a8cc <_isatty_r>:
    a8cc:	2300      	movs	r3, #0
    a8ce:	b570      	push	{r4, r5, r6, lr}
    a8d0:	4c06      	ldr	r4, [pc, #24]	; (a8ec <_isatty_r+0x20>)
    a8d2:	0005      	movs	r5, r0
    a8d4:	0008      	movs	r0, r1
    a8d6:	6023      	str	r3, [r4, #0]
    a8d8:	f7f7 ffde 	bl	2898 <_isatty>
    a8dc:	1c43      	adds	r3, r0, #1
    a8de:	d103      	bne.n	a8e8 <_isatty_r+0x1c>
    a8e0:	6823      	ldr	r3, [r4, #0]
    a8e2:	2b00      	cmp	r3, #0
    a8e4:	d000      	beq.n	a8e8 <_isatty_r+0x1c>
    a8e6:	602b      	str	r3, [r5, #0]
    a8e8:	bd70      	pop	{r4, r5, r6, pc}
    a8ea:	46c0      	nop			; (mov r8, r8)
    a8ec:	20000ac8 	.word	0x20000ac8

0000a8f0 <_lseek_r>:
    a8f0:	b570      	push	{r4, r5, r6, lr}
    a8f2:	0005      	movs	r5, r0
    a8f4:	0008      	movs	r0, r1
    a8f6:	0011      	movs	r1, r2
    a8f8:	2200      	movs	r2, #0
    a8fa:	4c06      	ldr	r4, [pc, #24]	; (a914 <_lseek_r+0x24>)
    a8fc:	6022      	str	r2, [r4, #0]
    a8fe:	001a      	movs	r2, r3
    a900:	f7f7 ffcc 	bl	289c <_lseek>
    a904:	1c43      	adds	r3, r0, #1
    a906:	d103      	bne.n	a910 <_lseek_r+0x20>
    a908:	6823      	ldr	r3, [r4, #0]
    a90a:	2b00      	cmp	r3, #0
    a90c:	d000      	beq.n	a910 <_lseek_r+0x20>
    a90e:	602b      	str	r3, [r5, #0]
    a910:	bd70      	pop	{r4, r5, r6, pc}
    a912:	46c0      	nop			; (mov r8, r8)
    a914:	20000ac8 	.word	0x20000ac8

0000a918 <memchr>:
    a918:	b2c9      	uxtb	r1, r1
    a91a:	1882      	adds	r2, r0, r2
    a91c:	4290      	cmp	r0, r2
    a91e:	d101      	bne.n	a924 <memchr+0xc>
    a920:	2000      	movs	r0, #0
    a922:	4770      	bx	lr
    a924:	7803      	ldrb	r3, [r0, #0]
    a926:	428b      	cmp	r3, r1
    a928:	d0fb      	beq.n	a922 <memchr+0xa>
    a92a:	3001      	adds	r0, #1
    a92c:	e7f6      	b.n	a91c <memchr+0x4>

0000a92e <memmove>:
    a92e:	b510      	push	{r4, lr}
    a930:	4288      	cmp	r0, r1
    a932:	d902      	bls.n	a93a <memmove+0xc>
    a934:	188b      	adds	r3, r1, r2
    a936:	4298      	cmp	r0, r3
    a938:	d308      	bcc.n	a94c <memmove+0x1e>
    a93a:	2300      	movs	r3, #0
    a93c:	429a      	cmp	r2, r3
    a93e:	d007      	beq.n	a950 <memmove+0x22>
    a940:	5ccc      	ldrb	r4, [r1, r3]
    a942:	54c4      	strb	r4, [r0, r3]
    a944:	3301      	adds	r3, #1
    a946:	e7f9      	b.n	a93c <memmove+0xe>
    a948:	5c8b      	ldrb	r3, [r1, r2]
    a94a:	5483      	strb	r3, [r0, r2]
    a94c:	3a01      	subs	r2, #1
    a94e:	d2fb      	bcs.n	a948 <memmove+0x1a>
    a950:	bd10      	pop	{r4, pc}

0000a952 <__malloc_lock>:
    a952:	4770      	bx	lr

0000a954 <__malloc_unlock>:
    a954:	4770      	bx	lr

0000a956 <_realloc_r>:
    a956:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a958:	0007      	movs	r7, r0
    a95a:	000d      	movs	r5, r1
    a95c:	0016      	movs	r6, r2
    a95e:	2900      	cmp	r1, #0
    a960:	d105      	bne.n	a96e <_realloc_r+0x18>
    a962:	0011      	movs	r1, r2
    a964:	f7ff fa8c 	bl	9e80 <_malloc_r>
    a968:	0004      	movs	r4, r0
    a96a:	0020      	movs	r0, r4
    a96c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a96e:	2a00      	cmp	r2, #0
    a970:	d103      	bne.n	a97a <_realloc_r+0x24>
    a972:	f7ff fa3b 	bl	9dec <_free_r>
    a976:	0034      	movs	r4, r6
    a978:	e7f7      	b.n	a96a <_realloc_r+0x14>
    a97a:	f000 f827 	bl	a9cc <_malloc_usable_size_r>
    a97e:	002c      	movs	r4, r5
    a980:	4286      	cmp	r6, r0
    a982:	d9f2      	bls.n	a96a <_realloc_r+0x14>
    a984:	0031      	movs	r1, r6
    a986:	0038      	movs	r0, r7
    a988:	f7ff fa7a 	bl	9e80 <_malloc_r>
    a98c:	1e04      	subs	r4, r0, #0
    a98e:	d0ec      	beq.n	a96a <_realloc_r+0x14>
    a990:	0029      	movs	r1, r5
    a992:	0032      	movs	r2, r6
    a994:	f7fe fdd5 	bl	9542 <memcpy>
    a998:	0029      	movs	r1, r5
    a99a:	0038      	movs	r0, r7
    a99c:	f7ff fa26 	bl	9dec <_free_r>
    a9a0:	e7e3      	b.n	a96a <_realloc_r+0x14>
	...

0000a9a4 <_read_r>:
    a9a4:	b570      	push	{r4, r5, r6, lr}
    a9a6:	0005      	movs	r5, r0
    a9a8:	0008      	movs	r0, r1
    a9aa:	0011      	movs	r1, r2
    a9ac:	2200      	movs	r2, #0
    a9ae:	4c06      	ldr	r4, [pc, #24]	; (a9c8 <_read_r+0x24>)
    a9b0:	6022      	str	r2, [r4, #0]
    a9b2:	001a      	movs	r2, r3
    a9b4:	f7fc ff5e 	bl	7874 <_read>
    a9b8:	1c43      	adds	r3, r0, #1
    a9ba:	d103      	bne.n	a9c4 <_read_r+0x20>
    a9bc:	6823      	ldr	r3, [r4, #0]
    a9be:	2b00      	cmp	r3, #0
    a9c0:	d000      	beq.n	a9c4 <_read_r+0x20>
    a9c2:	602b      	str	r3, [r5, #0]
    a9c4:	bd70      	pop	{r4, r5, r6, pc}
    a9c6:	46c0      	nop			; (mov r8, r8)
    a9c8:	20000ac8 	.word	0x20000ac8

0000a9cc <_malloc_usable_size_r>:
    a9cc:	1f0b      	subs	r3, r1, #4
    a9ce:	681b      	ldr	r3, [r3, #0]
    a9d0:	1f18      	subs	r0, r3, #4
    a9d2:	2b00      	cmp	r3, #0
    a9d4:	da01      	bge.n	a9da <_malloc_usable_size_r+0xe>
    a9d6:	580b      	ldr	r3, [r1, r0]
    a9d8:	18c0      	adds	r0, r0, r3
    a9da:	4770      	bx	lr
    a9dc:	65620a0d 	.word	0x65620a0d
    a9e0:	65726f66 	.word	0x65726f66
    a9e4:	6d6f6320 	.word	0x6d6f6320
    a9e8:	69736f70 	.word	0x69736f70
    a9ec:	64206574 	.word	0x64206574
    a9f0:	63697665 	.word	0x63697665
    a9f4:	74732065 	.word	0x74732065
    a9f8:	0d747261 	.word	0x0d747261
    a9fc:	00000000 	.word	0x00000000
    aa00:	682f2e2e 	.word	0x682f2e2e
    aa04:	732f6c61 	.word	0x732f6c61
    aa08:	682f6372 	.word	0x682f6372
    aa0c:	615f6c61 	.word	0x615f6c61
    aa10:	615f6364 	.word	0x615f6364
    aa14:	636e7973 	.word	0x636e7973
    aa18:	0000632e 	.word	0x0000632e
    aa1c:	682f2e2e 	.word	0x682f2e2e
    aa20:	732f6c61 	.word	0x732f6c61
    aa24:	682f6372 	.word	0x682f6372
    aa28:	645f6c61 	.word	0x645f6c61
    aa2c:	615f6361 	.word	0x615f6361
    aa30:	636e7973 	.word	0x636e7973
    aa34:	0000632e 	.word	0x0000632e
    aa38:	682f2e2e 	.word	0x682f2e2e
    aa3c:	732f6c61 	.word	0x732f6c61
    aa40:	682f6372 	.word	0x682f6372
    aa44:	665f6c61 	.word	0x665f6c61
    aa48:	6873616c 	.word	0x6873616c
    aa4c:	0000632e 	.word	0x0000632e
    aa50:	682f2e2e 	.word	0x682f2e2e
    aa54:	732f6c61 	.word	0x732f6c61
    aa58:	682f6372 	.word	0x682f6372
    aa5c:	695f6c61 	.word	0x695f6c61
    aa60:	6d5f6332 	.word	0x6d5f6332
    aa64:	6e79735f 	.word	0x6e79735f
    aa68:	00632e63 	.word	0x00632e63
    aa6c:	682f2e2e 	.word	0x682f2e2e
    aa70:	732f6c61 	.word	0x732f6c61
    aa74:	682f6372 	.word	0x682f6372
    aa78:	695f6c61 	.word	0x695f6c61
    aa7c:	00632e6f 	.word	0x00632e6f
    aa80:	682f2e2e 	.word	0x682f2e2e
    aa84:	732f6c61 	.word	0x732f6c61
    aa88:	682f6372 	.word	0x682f6372
    aa8c:	735f6c61 	.word	0x735f6c61
    aa90:	6d5f6970 	.word	0x6d5f6970
    aa94:	6e79735f 	.word	0x6e79735f
    aa98:	00632e63 	.word	0x00632e63
    aa9c:	682f2e2e 	.word	0x682f2e2e
    aaa0:	732f6c61 	.word	0x732f6c61
    aaa4:	682f6372 	.word	0x682f6372
    aaa8:	745f6c61 	.word	0x745f6c61
    aaac:	72656d69 	.word	0x72656d69
    aab0:	0000632e 	.word	0x0000632e
    aab4:	682f2e2e 	.word	0x682f2e2e
    aab8:	732f6c61 	.word	0x732f6c61
    aabc:	682f6372 	.word	0x682f6372
    aac0:	755f6c61 	.word	0x755f6c61
    aac4:	74726173 	.word	0x74726173
    aac8:	7973615f 	.word	0x7973615f
    aacc:	632e636e 	.word	0x632e636e
    aad0:	00000000 	.word	0x00000000
    aad4:	682f2e2e 	.word	0x682f2e2e
    aad8:	732f6c61 	.word	0x732f6c61
    aadc:	682f6372 	.word	0x682f6372
    aae0:	755f6c61 	.word	0x755f6c61
    aae4:	74726173 	.word	0x74726173
    aae8:	6e79735f 	.word	0x6e79735f
    aaec:	00632e63 	.word	0x00632e63
    aaf0:	682f2e2e 	.word	0x682f2e2e
    aaf4:	752f6c61 	.word	0x752f6c61
    aaf8:	736c6974 	.word	0x736c6974
    aafc:	6372732f 	.word	0x6372732f
    ab00:	6974752f 	.word	0x6974752f
    ab04:	6c5f736c 	.word	0x6c5f736c
    ab08:	2e747369 	.word	0x2e747369
    ab0c:	00000063 	.word	0x00000063
    ab10:	682f2e2e 	.word	0x682f2e2e
    ab14:	752f6c61 	.word	0x752f6c61
    ab18:	736c6974 	.word	0x736c6974
    ab1c:	6372732f 	.word	0x6372732f
    ab20:	6974752f 	.word	0x6974752f
    ab24:	725f736c 	.word	0x725f736c
    ab28:	62676e69 	.word	0x62676e69
    ab2c:	65666675 	.word	0x65666675
    ab30:	00632e72 	.word	0x00632e72

0000ab34 <_adcs>:
    ab34:	03000200 00000000 00000000 00001801     ................
	...
    ab50:	682f2e2e 612f6c70 682f6364 615f6c70     ../hpl/adc/hpl_a
    ab60:	632e6364 00000000 682f2e2e 642f6c70     dc.c....../hpl/d
    ab70:	682f6361 645f6c70 632e6361 00000000     ac/hpl_dac.c....

0000ab80 <_map>:
    ab80:	00000000 00000020 00000001 00000021     .... .......!...
    ab90:	00000002 00000022 00000003 00000023     ....".......#...
    aba0:	00000004 00000004 00000005 00000005     ................
    abb0:	00000006 00000006 00000007 00000007     ................
    abc0:	00000008 00000028 00000009 00000029     ....(.......)...
    abd0:	0000000a 0000002a 0000000b 0000002b     ....*.......+...
    abe0:	0000000c 0000002c 0000000d 0000002d     ....,.......-...
    abf0:	0000000e 0000002e 0000000f 0000002f     ............/...
    ac00:	682f2e2e 652f6c70 682f6369 655f6c70     ../hpl/eic/hpl_e
    ac10:	632e6369 00000000 682f2e2e 6e2f6c70     ic.c....../hpl/n
    ac20:	74636d76 682f6c72 6e5f6c70 74636d76     vmctrl/hpl_nvmct
    ac30:	632e6c72 00000000 682f2e2e 722f6c70     rl.c....../hpl/r
    ac40:	682f6374 725f6c70 632e6374 00000000     tc/hpl_rtc.c....

0000ac50 <_usarts>:
    ac50:	00000001 40100004 00030000 0000c504     .......@........
    ac60:	00000000 00000005 40310004 00030000     ..........1@....
    ac70:	0000c504 00000000                       ........

0000ac78 <_i2cms>:
    ac78:	00000003 00200014 00000100 00000022     ...... ....."...
    ac88:	00d70000 007a1200                       ......z.

0000ac90 <_i2css>:
	...

0000aca0 <sercomspi_regs>:
    aca0:	0030000c 00020000 00000000 01ff004f     ..0.........O...
    acb0:	00000000 682f2e2e 732f6c70 6f637265     ....../hpl/serco
    acc0:	70682f6d 65735f6c 6d6f6372 0000632e     m/hpl_sercom.c..
    acd0:	00004a25 00000804                       %J......

0000acd8 <_usb_ep_cfgs>:
    acd8:	20000700 00000000 00000040 00000000     ... ....@.......
	...
    acf0:	200006f8 00000000 00000008 200006b8     ... ........... 
    ad00:	00000000 00000040 00000000 00000000     ....@...........
	...
    ad20:	00005d48 00005d60 00005d78 00005d90     H]..`]..x]...]..
    ad30:	00005da8 00005e56 00005eb0 00005ec8     .]..V^...^...^..
    ad40:	00005e98 00005d5e 00005ee0 00005efc     .^..^]...^...^..
    ad50:	000069da 000069e0 000069ee 00006b6e     .i...i...i..nk..
    ad60:	000069f4 00006a18 00006a3c 00006a60     .i...j..<j..`j..
    ad70:	00006a84 00006b98 00006b74 00006bbc     .j...k..tk...k..
    ad80:	00006c64 00006c88 00006c8e 00006d36     dl...l...l..6m..
    ad90:	00006d04 00006cf6 00006cc2 00006e28     .m...l...l..(n..
    ada0:	00006e36 00006e68 00006de0 00006dac     6n..hn...m...m..
    adb0:	00006d78 00006d44 00006e76 00006ea6     xm..Dm..vn...n..
    adc0:	00006ea0 00006ec8 00006ed6 00006eba     .n...n...n...n..
    add0:	00006eac 00006f08 000071a2 0000716e     .n...o...q..nq..
    ade0:	0000716e 0000716e 000071ac 0000716e     nq..nq...q..nq..
    adf0:	0000716e 0000716e 000071d0 000071b6     nq..nq...q...q..
    ae00:	00007166 0000714c                       fq..Lq..

0000ae08 <set_error_text_PS_low>:
    ae08:	00121101 00000200                       ........

0000ae10 <set_error_text_PS_high>:
    ae10:	00121101 00000301                       ........

0000ae18 <set_error_text_USB_error>:
    ae18:	00121101 00000002                       ........

0000ae20 <simulation_trigger_LED_off>:
    ae20:	00001301 00001200                       ........

0000ae28 <man_trig_trigger_LED_off>:
    ae28:	00011301 00001300                       ........

0000ae30 <man_trig_trigger_LED_on>:
    ae30:	00011301 00001201                       ........

0000ae38 <simulation_trigger_LED_on>:
    ae38:	00001301 00001301                       ........

0000ae40 <set_trigg_slice_txt>:
    ae40:	000a1101 00001802                       ........

0000ae48 <set_trigg_volume_txt>:
    ae48:	000a1101 00001903                       ........

0000ae50 <set_no_of_slices_txt>:
    ae50:	000a1101 00001a00                       ........

0000ae58 <set_no_of_volumes_txt>:
    ae58:	000a1101 00001b01                       ........

0000ae60 <set_pulse_length_txt>:
    ae60:	000a1101 00001e04                       ........

0000ae68 <set_tr_time_txt>:
    ae68:	000a1101 00001f05                       ........

0000ae70 <ad>:
    ae70:	0003e000                                ....

0000ae74 <error_beep_sound_data>:
    ae74:	02a9022d 030b02bb 027d02ca 02a6028e     -.........}.....
    ae84:	031d02c7 031c0306 02e9031a 03700331     ............1.p.
    ae94:	03f103d0 036003ce 02ad02c5 037802e4     ......`.......x.
    aea4:	03c803ea 02d30379 0214023f 02e00258     ....y...?...X...
    aeb4:	02cd0318 02340237 029402a5 01d9022e     ....7.4.........
    aec4:	026901d8 022e02d9 015c013c 02360207     ..i.....<.\...6.
    aed4:	018901ef 01a2014e 016301e2 010000ef     ....N.....c.....
    aee4:	01e4017c 016401d7 004900b0 005d001d     |.....d...I...].
    aef4:	014c0100 00e00155 002b0052 0098003b     ..L.U...R.+.;...
    af04:	012000de 00f60120 010a0124 01770140     .. . ...$...@.w.
    af14:	019e0183 0142017e 01a3016a 025001c1     ....~.B.j.....P.
    af24:	02a20260 027602b8 02810262 02ce028d     `.....v.b.......
    af34:	02df02f4 02d7030a 032e02e9 03cf0379     ............y...
    af44:	039703ce 02a10300 031702bb 03d903b8     ................
    af54:	032a039f 021c027a 029a0225 02ff0307     ..*.z...%.......
    af64:	0218027d 02ae026f 01ff0261 021101c7     }...o...a.......
    af74:	02a502b7 012a01a2 023301b7 01be021a     ......*...3.....
    af84:	016a0161 01b501da 00ec011d 01be0139     a.j.........9...
    af94:	01ad01ec 0076010e 002c0036 013500b4     ......v.6.,...5.
    afa4:	012f015b 003a0090 0067002d 00ff00c4     [./...:.-.g.....
    afb4:	01010133 011f010f 016a0115 01960179     3.........j.y...
    afc4:	015f0196 01970144 020b01a2 02730265     .._.D.......e.s.
    afd4:	029502c1 026d0264 02a00289 02de02f2     ....d.m.........
    afe4:	02f802f6 030d02cd 03a9034a 03ba03d5     ........J.......
    aff4:	02bc0353 02db02a6 03dd0368 037103be     S.......h.....q.
    b004:	023d02cf 02550213 031302db 023502ca     ..=...U.......5.
    b014:	02a20232 022d0292 01d701d9 02d60267     2.....-.....g...
    b024:	013e022f 0208015e 01ef0236 0151018c     /.>.^...6.....Q.
    b034:	01e501a4 00f30167 017e0105 01d901e5     ....g.....~.....
    b044:	00b70168 00240051 01040060 0157014f     h...Q.$.`...O.W.
    b054:	005600e4 003d0030 00e1009b 01230122     ..V.0.=.....".#.
    b064:	012600f7 0140010c 01830179 018001a0     ..&...@.y.......
    b074:	016a0143 01c001a5 02600250 02b802a0     C.j.....P.`.....
    b084:	02610275 028c027f 02f402cb 030902db     u.a.............
    b094:	02e602d6 0375032c 03cc03cc 03000396     ....,.u.........
    b0a4:	02ba029f 03b60314 039d03d8 0279032a     ............*.y.
    b0b4:	0224021b 03070299 027d02ff 026e0216     ..$.......}...n.
    b0c4:	026102af 01c701fe 02b70210 01a302a8     ..a.............
    b0d4:	01b70127 021b0235 016101bf 01da0169     '...5.....a.i...
    b0e4:	011d01b7 013900ec 01ed01bf 010f01ae     ......9.........
    b0f4:	00370077 00b3002c 015c0137 00910131     w.7.,...7.\.1...
    b104:	002e003a 00c50066 013500ff 010d0102     :...f.....5.....
    b114:	01140121 017a016b 01980196 0143015f     !...k.z....._.C.
    b124:	01a30197 02670209 02c20270 02630295     ......g.p.....c.
    b134:	0289026d 02f2029f 02f402df 02cb02f9     m...............
    b144:	0349030d 03d603a8 035503b9 02a402ba     ..I.......U.....
    b154:	036602da 03bd03de 02d00371 0212023b     ..f.....q...;...
    b164:	02db0253 02cb0314 022f0235 029302a3     S.......5./.....
    b174:	01d9022d 026501d6 023202d8 015b013c     -.....e...2.<.[.
    b184:	02380209 018c01f0 01a20150 016801e7     ..8.....P.....h.
    b194:	010400f2 01e7017d 016a01da 005100b7     ....}.....j...Q.
    b1a4:	005e0025 01500105 00e70158 00300055     %.^...P.X...U.0.
    b1b4:	009b003d 012100e2 00f50126 010d0127     =.....!.&...'...
    b1c4:	017c013e 01a10182 01430180 01a80168     >.|.......C.h...
    b1d4:	025101bd 029e0261 027402bb 027f0260     ..Q.a.....t.`...
    b1e4:	02c9028d 02da02f6 02d70309 032d02e3     ..............-.
    b1f4:	03cd0374 039603cc 029c0301 031202ba     t...............
    b204:	03da03b6 032c039d 021a0279 02970223     ......,.y...#...
    b214:	03010308 0213027f 02b1026c 01fe0262     ........l...b...
    b224:	020d01c6 02ac02b7 012301a4 023601b5     ..........#...6.
    b234:	01bf021c 01660161 01bb01db 00ea011d     ....a.f.........
    b244:	01bf0137 01af01ef 00760111 002b0037     7.........v.7.+.
    b254:	013900b1 0133015c 00390092 0064002e     ..9.\.3...9...d.
    b264:	00fe00c6 01040135 0124010b 016b0112     ....5.....$...k.
    b274:	0195017b 01600199 01960141 020501a5     {.....`.A.......
    b284:	026e026b 029702c3 026c0262 029e028a     k.n.....b.l.....
    b294:	02e102f2 02fc02f1 030c02c8 03a70349     ............I...
    b2a4:	03b903d7 02ba0357 02da02a2 03e00364     ....W.......d...
    b2b4:	037203be 023a02d2 02510211 031602db     ..r...:...Q.....
    b2c4:	023502cd 02a4022b 022d0296 01d401d9     ..5.+.....-.....
    b2d4:	02db0263 013a0238 02090156 01f1023a     c...8.:.V...:...
    b2e4:	014f018d 01ea019f 00f0016b 017c0102     ..O.....k.....|.
    b2f4:	01db01e8 00b8016c 0026004f 0104005b     ....l...O.&.[...
    b304:	01590152 005400ea 003c002f 00e30099     R.Y...T./.<.....
    b314:	01290120 012600f4 013a010f 0181017e      .)...&...:.~...
    b324:	018201a1 01650143 01bb01aa 02640250     ....C.e.....P.d.
    b334:	02bf029a 025f0273 028d027e 02f902c6     ....s._.~.......
    b344:	030902d8 02e002d9 0372032e 03cd03cd     ..........r.....
    b354:	03030397 02b9029a 03b40310 039c03de     ................
    b364:	0279032f 02220218 03090295 02810303     /.y...".........
    b374:	02690211 026302b5 01c501fe 02b6020a     ..i...c.........
    b384:	01a702b2 01b2011d 021e0239 016201c0     ........9.....b.
    b394:	01da0163 011d01c0 013500e8 01f101be     c.........5.....
    b3a4:	011401b1 00370075 00ad002a 015c013b     ....u.7.*...;.\.
    b3b4:	00940136 002e0036 00c70062 013600fe     6...6...b.....6.
    b3c4:	01070106 01100127 017d016a 019b0193     ....'...j.}.....
    b3d4:	01400161 01a80194 026f01ff 02c2026c     a.@.......o.l...
    b3e4:	025f029b 028a026b 02f0029d 02ed02e4     .._.k...........
    b3f4:	02c70300 034a0309 03d903a4 035a03b9     ......J.......Z.
    b404:	029f02ba 036002da 03c003e2 02d60372     ......`.....r...
    b414:	02100238 02da024e 02cf0318 02250236     8...N.......6.%.
    b424:	029a02a3 01d9022d 025f01d1 023f02de     ....-....._...?.
    b434:	014f0138 023e0209 018e01f2 019b014d     8.O...>.....M...
    b444:	017001ee 010000ee 01ea017a 016f01de     ..p.....z.....o.
    b454:	004e00bb 00570027 01540103 00ef0159     ..N.'.W...T.Y...
    b464:	002e0053 0097003c 011e00e5 00f3012c     S...<.......,...
    b474:	01130124 01810135 01a10181 01430184     $...5.........C.
    b484:	01ac0161 024c01ba 0294026a 027402c3     a.....L.j.....t.
    b494:	027e025d 02c3028e 02d802fb 02de0307     ].~.............
    b4a4:	032e02da 03cd0370 039703d0 02960307     ....p...........
    b4b4:	030e02b7 03e203b1 0331039c 0216027c     ..........1.|...
    b4c4:	02910220 0305030a 020f0284 02b80263      ...........c...
    b4d4:	01fe0266 020501c5 02ba02b4 011601ad     f...............
    b4e4:	023c01ad 01c10221 01600162 01c701d8     ..<.!...b.`.....
    b4f4:	00e4011e 01bd0133 01b401f4 00750118     ....3.........u.
    b504:	002a0036 013e00a8 0139015d 00330099     6.*...>.].9...3.
    b514:	0060002f 00ff00c6 010b0135 01290102     /.`.....5.....).
    b524:	01660110 01900182 0163019d 0191013e     ..f.......c.>...
    b534:	01f801ac 026c0272 02a102be 026a025d     ....r.l.....].j.
    b544:	029c028a 02e902ed 030302e9 030402c7     ................
    b554:	03a1034c 03bb03dc 02bc035c 02d9029a     L.......\.......
    b564:	03e3035b 037103c4 023802da 024c020d     [.....q...8...L.
    b574:	031b02d7 023802d3 02a1021f 022e02a0     ......8.........
    b584:	01cf01d9 02e10259 0138024a 02080145     ....Y...J.8.E...
    b594:	01f40243 014d018f 01f00196 00eb0177     C.....M.....w...
    b5a4:	017700fd 01e201ea 00be0172 0027004c     ..w.....r...L.'.
    b5b4:	00ff0053 01590159 005400f5 003c002b     S...Y.Y...T.+.<.
    b5c4:	00e60093 012e011d 012000f4 01300118     .......... ...0.
    b5d4:	01820182 0188019f 015c0144 01ba01ad     ........D.\.....
    b5e4:	02710245 02c6028e 02590278 028f027d     E.q.....x.Y.}...
    b5f4:	02fd02c0 030202da 02d502e3 0370032c     ............,.p.
    b604:	03d303ca 030c0398 02b30294 03ad030d     ................
    b614:	039e03e7 02800333 021e0212 030a028d     ....3...........
    b624:	0289030a 025b020d 026c02bc 01c401fd     ......[...l.....
    b634:	02b00200 01b702c3 01a3010e 02260240     ............@.&.
    b644:	016301c2 01d4015c 012301d0 013000df     ..c.\.....#...0.
    b654:	01f801bb 011d01b7 00340076 00a1002a     ........v.4.*...
    b664:	0161013e 009f013a 002e0030 00c4005e     >.a.:...0...^...
    b674:	01340101 00fe0110 0112012a 0186015f     ..4.....*..._...
    b684:	019e018e 013c0166 01b0018c 027201f1     ....f.<.......r.
    b694:	02b70270 025c02a9 028b0266 02e9029c     p.....\.f.......
    b6a4:	02e502ee 02cb0303 034d02fd 03dc039e     ..........M.....
    b6b4:	035f03be 029302c0 035702d7 03cb03e3     .._.......W.....
    b6c4:	02df0371 02090239 02d30248 02d8031e     q...9...H.......
    b6d4:	0218023c 02a9029c 01d70231 025101cd     <.......1.....Q.
    b6e4:	025902e2 0137013b 024a0204 018f01f8     ..Y.;.7...J.....
    b6f4:	018f014c 018201f2 00f600e9 01eb0174     L...........t...
    b704:	017601e7 004a00c2 004f0027 015e00f9     ..v...J.'.O...^.
    b714:	00fa015b 00260057 0090003c 011d00e7     [...W.&.<.......
    b724:	00f70130 011e011a 0180012c 019c0186     0.......,.......
    b734:	0146018b 01ac0156 023c01bd 028b0278     ..F.V.....<.x...
    b744:	027f02c5 027a0255 02bc0291 02de02fc     ....U.z.........
    b754:	02e902fc 032702d2 03c70371 039b03d7     ......'.q.......
    b764:	02930311 030b02ac 03ec03a7 033503a2     ..............5.
    b774:	020f0286 02880219 030f0309 020c028e     ................
    b784:	02be0250 01fd0275 01fa01c3 02cd02a9     P...u...........
    b794:	010701c6 02440195 01c3022f 01580164     ......D./...d.X.
    b7a4:	01d901cd 00d8012b 01b9012a 01bd01fb     ....+...*.......
    b7b4:	00780122 00290031 013d0099 013d0167     ".x.1.)...=.g.=.
    b7c4:	002e00a7 005d002a 010200c1 01150133     ....*.].....3...
    b7d4:	012800fc 01580117 018f018a 016b019d     ..(...X.......k.
    b7e4:	0185013b 01ed01b5 0277026e 02ae02b0     ;.......n.w.....
    b7f4:	0260025f 029d028b 02f302e4 030102e4     _.`.............
    b804:	02f502d0 039c034b 03c203dc 02c40363     ....K.......c...
    b814:	02d2028d 03e00353 037303d3 023c02e4     ....S.....s...<.
    b824:	02430204 032102ce 024002e0 02940210     ..C...!...@.....
    b834:	023802b2 01c901d5 02e10249 0143026b     ..8.....I...k.C.
    b844:	01fb0125 01fe0254 014c0190 01f10188     %...T.....L.....
    b854:	00eb0190 016e00ec 01ed01eb 00c8017c     ......n.....|...
    b864:	00250048 00f0004c 015f0161 005d0100     H.%.L...a._...].
    b874:	003a0021 00e7008d 0132011e 011300fc     !.:.......2.....
    b884:	012b0121 018b017b 018e019a 0151014a     !.+.{.......J.Q.
    b894:	01c101a9 027b0232 02c1028c 02530287     ....2.{.......S.
    b8a4:	02930275 02fa02b9 02f702e4 02d202ec     u...............
    b8b4:	0370031f 03da03c4 0317039f 02a30293     ..p.............
    b8c4:	03a20307 03aa03f0 028c0336 0212020e     ........6.......
    b8d4:	03070282 02970316 0243020c 028202bc     ..........C.....
    b8e4:	01bf01ff 02a101f4 01db02d5 017f0102     ................
    b8f4:	023c0244 016301c7 01c50154 013801e1     D.<...c.T.....8.
    b904:	011f00d2 020001b5 012901c4 002e007c     ..........).|...
    b914:	00920028 016e0138 00af0142 0025002e     (...8.n.B.....%.
    b924:	00be005b 01330104 00fc011a 011b0123     [.....3.....#...
    b934:	018a0152 019c0192 013c0170 01b7017c     R.......p.<.|...
    b944:	026601ec 02ac027e 026502b1 0287025a     ..f.~.....e.Z...
    b954:	02df029f 02e502f5 02d502fd 034602ef     ..............F.
    b964:	03d9039b 036203c2 028402c6 034202c4     ......b.......B.
    b974:	03c703ca 02dc0366 01fe023d 02ba0237     ....f...=...7...
    b984:	02d6030c 02080241 02a60279 01d8023c     ....A...y...<...
    b994:	023701ca 026e02c1 0134016b 025001ec     ..7...n.k.4...P.
    b9a4:	01a2020a 01960168 01b101f1 01180125     ....h.......%...
    b9b4:	01f00183 019f01f7 00aa0111 00af008e     ................
    b9c4:	01890129 0145018d 009b00ce 00ef00b0     ).....E.........
    b9d4:	015e0134 014c016e 01650156 01a0016d     4.^.n.L.V.e.m...
    b9e4:	01bb01b3 018a01b4 01c20188 021b01da     ................
    b9f4:	025b024f 02590277 02430234 0270025a     O.[.w.Y.4.C.Z.p.
    ba04:	028b0294 028b0290 02a0027b 02ff02d1     ........{.......
    ba14:	02ea030c 0251029e 02890253 030702db     ......Q.S.......
    ba24:	02a302e4 0207024b 023c0205 028b0280     ....K.....<.....
    ba34:	0207024e 02550219 02030243 01f601e0     N.....U.C.......
    ba44:	02600242 019401fb 021801bd 01ec0220     B.`......... ...
    ba54:	01b901c0 01f601e5 018d01ba 01e201a6     ................
    ba64:	01ee0201 017a01b7 015f015f 01bc0183     ......z._._.....
    ba74:	01c601d2 01710199 0181016d 01b701a0     ......q.m.......
    ba84:	01c101c6 01c301b9 01d201c5 01e501e1     ................
    ba94:	01de01e7 01df01d3 01fb01ef 021b0214     ................
    baa4:	02230222 02100214 021c0217 02290225     ".#.........%.).
    bab4:	02270225 02220220 0237022d 023a023e     %.'. .".-.7.>.:.
    bac4:	0218022c 0214020e 022d0221 0221022c     ,.......!.-.,.!.
    bad4:	02050213 020201ff 020f020c 0203020c     ................
    bae4:	02030200 02010206 01fd0200 01fe0201     ................
    baf4:	0262020c 029b0269 029a02d1 0265027a     ..b.i.......z.e.
    bb04:	02970281 02f5029f 02e902fb 03030312     ................
    bb14:	02f102e5 03670331 03ee03b2 03c203e6     ....1.g.........
    bb24:	02dc0362 02c102ad 037f02fc 03ec03e6     b...............
    bb34:	036a03bd 025a02e5 021e0220 02e0026d     ..j...Z. ...m...
    bb44:	030c0318 0232029e 028d022e 027e02b2     ......2.......~.
    bb54:	01e30226 020d01c7 02d6029c 01780261     &...........a.x.
    bb64:	017c0128 02390209 01c80211 014c0172     (.|...9.....r.L.
    bb74:	01db0183 014801be 00ed00e7 01a70132     ......H.....2...
    bb84:	01d801e6 00fc0190 00350080 0029000f     ..........5...).
    bb94:	0117009d 01510146 0087010f 00190035     ....F.Q.....5...
    bba4:	0065001e 00e000aa 011a0119 00f700fa     ..e.............
    bbb4:	0104011e 016d011b 0189016a 0182019a     ......m.j.......
    bbc4:	0132015c 019b0174 020c01a7 02670262     \.2.t.......b.g.
    bbd4:	02cd029a 02770297 027f0264 029c0296     ......w.d.......
    bbe4:	02f602f3 030e02e5 02e102ff 032d02ee     ..............-.
    bbf4:	03ac0362 03e103e9 035d03be 02ab02d8     b.........].....
    bc04:	02fc02c0 03e3037e 03ba03e9 02e10366     ....~.......f...
    bc14:	02200257 026e021f 031702e0 029b030a     W. ...n.........
    bc24:	022e0230 02b1028e 0224027c 01c701e2     0.......|.$.....
    bc34:	029d020f 025d02d5 01290175 020b017e     ......].u.).~...
    bc44:	02100239 017201c7 0185014c 01be01dd     9.....r.L.......
    bc54:	00e70147 013400ef 01e701aa 018f01d8     G.....4.........
    bc64:	008000fb 00110036 00a0002b 01470119     ....6...+.....G.
    bc74:	010f0152 00350085 001f001a 00ac0067     R.....5.....g...
    bc84:	011b00e1 00fa011b 011f00f7 011c0104     ................
    bc94:	016a016f 019a0189 015c0182 01760132     o.j.......\.2.v.
    bca4:	01a8019c 0263020d 029b0267 029602ce     ......c.g.......
    bcb4:	02640277 0296027f 02f3029c 02e402f6     w.d.............
    bcc4:	02fe030e 02ee02e0 0362032d 03e903ad     ........-.b.....
    bcd4:	03bc03e0 02d6035b 02c002aa 038002fc     ....[...........
    bce4:	03e803e4 036403b8 025502de 021f021f     ......d...U.....
    bcf4:	02e2026f 03090318 022e0299 0290022e     o...............
    bd04:	027b02b2 01e10223 021001c7 02d5029f     ..{.#...........
    bd14:	0172025b 01800128 023a020d 01c6020f     [.r.(.....:.....
    bd24:	014c0170 01de0186 014501bd 00f000e6     p.L.......E.....
    bd34:	01ac0136 01d701e8 00f9018d 0035007e     6...........~.5.
    bd44:	002c0011 011b00a3 01520148 0083010e     ..,.....H.R.....
    bd54:	001a0034 00680020 00e200ad 011b011c     4... .h.........
    bd64:	00f700fa 0104011f 0170011d 018a016a     ..........p.j...
    bd74:	0182019b 0132015b 019c0177 020f01a8     ....[.2.w.......
    bd84:	02670264 02ce029c 02760295 027f0263     d.g.......v.c...
    bd94:	029c0296 02f602f5 030f02e4 02e002fe     ................
    bda4:	032e02ee 03ae0363 03e003e9 035903bb     ....c.........Y.
    bdb4:	02aa02d4 02fd02c0 03e50382 03b703e8     ................
    bdc4:	02dc0363 021e0253 0271021f 031802e4     c...S.....q.....
    bdd4:	02970309 022e022d 02b20291 0222027a     ....-.......z.".
    bde4:	01c701e0 02a20211 025902d6 0127016e     ..........Y.n.'.
    bdf4:	020f0182 020e023a 016f01c5 0187014c     ....:.....o.L...
    be04:	01bc01df 00e50143 013700f0 01e901ad     ....C.....7.....
    be14:	018c01d7 007d00f7 00110034 00a5002d     ......}.4...-...
    be24:	0148011d 010d0152 00330081 0020001a     ..H.R.....3... .
    be34:	00ae0069 011d00e3 00f9011b 012000f7     i............. .
    be44:	011d0104 016a0171 019b018a 015b0181     ....q.j.......[.
    be54:	01780131 01a8019d 02660211 029c0267     1.x.......f.g...
    be64:	029402cf 02630275 0297027f 02f6029c     ....u.c.........
    be74:	02e302f6 02fd030f 02ee02df 0364032f     ............/.d.
    be84:	03ea03ae 03bb03e0 02d20358 02c102a9     ........X.......
    be94:	038302fe 03e803e7 036103b6 025102da     ..........a...Q.
    bea4:	021f021d 02e60271 03090319 022b0296     ....q.........+.
    beb4:	0292022e 027902b3 01df0221 021201c6     ......y.!.......
    bec4:	02d602a4 016b0257 01830126 023b0211     ....W.k.&.....;.
    bed4:	01c4020d 014c016e 01e10187 014101bc     ....n.L.......A.
    bee4:	00f000e4 01af0138 01d601ea 00f5018b     ....8...........
    bef4:	0034007b 002d0010 011f00a6 01520149     {.4...-.....I.R.
    bf04:	0080010c 001a0032 006a0020 00e400b0     ....2... .j.....
    bf14:	011b011d 00f700f9 01040120 0173011d     ........ .....s.
    bf24:	018a016a 0180019c 0131015b 019f0178     j.......[.1.x...
    bf34:	021201a8 02670267 02d0029c 02740293     ....g.g.......t.
    bf44:	027f0264 029c0298 02f702f6 031002e2     d...............
    bf54:	02df02fd 033002ef 03af0365 03df03eb     ......0.e.......
    bf64:	035703ba 02a802d0 02ff02c1 03e80385     ..W.............
    bf74:	03b603e8 02d90360 021c024f 02720220     ....`...O... .r.
    bf84:	031a02e7 02950308 022e022a 02b40293     ........*.......
    bf94:	02200278 01c601de 02a60213 025602d7     x. ...........V.
    bfa4:	01240168 02120185 020c023d 016d01c3     h.$.....=.....m.
    bfb4:	0188014b 01bc01e2 00e20140 013900f0     K.......@.....9.
    bfc4:	01eb01b0 018b01d6 007900f3 00100033     ..........y.3...
    bfd4:	00a7002d 014a0121 010c0151 0030007e     -...!.J.Q...~.0.
    bfe4:	0020001a 00b1006b 011e00e4 00f8011b     .. .k...........
    bff4:	012000f7 011c0104 016b0174 019d0189     .. .....t.k.....
    c004:	015a0180 01780130 01a701a0 02690213     ..Z.0.x.......i.
    c014:	029c0267 029302d2 02640273 0299027f     g.......s.d.....
    c024:	02f7029c 02e102f8 02fe0310 02ef02de     ................
    c034:	03660330 03ec03af 03b903df 02ce0356     0.f.........V...
    c044:	02c202a7 038602ff 03e803ea 035f03b5     .............._.
    c054:	024d02d7 0220021b 02e90272 0308031a     ..M... .r.......
    c064:	02280294 0294022e 027702b5 01dd021f     ..(.......w.....
    c074:	021301c6 02d802a7 01660256 01860122     ........V.f."...
    c084:	023e0214 01c2020c 014a016c 01e30188     ..>.....l.J.....
    c094:	013e01bd 00f000e1 01b1013a 01d501ed     ..>.....:.......
    c0a4:	00f2018a 00320077 002e0010 012300a8     ....w.2.......#.
    c0b4:	0151014b 007d010c 001a002f 006b0020     K.Q...}./... .k.
    c0c4:	00e500b2 011c011f 00f700f8 01050121     ............!...
    c0d4:	0175011b 0188016c 017f019e 0130015a     ..u.l.......Z.0.
    c0e4:	01a20178 021301a7 0268026a 02d3029b     x.......j.h.....
    c0f4:	02720293 027e0264 029c0299 02fa02f6     ..r.d.~.........
    c104:	031102e0 02dd02ff 033102ee 03af0367     ..........1.g...
    c114:	03e003ed 035503b8 02a502cd 030002c2     ......U.........
    c124:	03ec0386 03b403e8 02d6035e 021a024b     ........^...K...
    c134:	02720220 031b02ea 02930308 022d0226      .r.........&.-.
    c144:	02b60295 021e0277 01c601dc 02a90212     ....w...........
    c154:	025502da 011f0164 02150187 020b0240     ..U.d.......@...
    c164:	016b01c2 0188014a 01be01e4 00e0013d     ..k.J.......=...
    c174:	013b00ef 01ef01b1 018a01d5 007500f1     ..;...........u.
    c184:	000f0031 00a9002d 014c0125 010c0151     1...-...%.L.Q...
    c194:	002d007c 0020001a 00b4006b 011f00e5     |.-... .k.......
    c1a4:	00f8011d 012100f6 01190107 016e0176     ......!.....v.n.
    c1b4:	019f0187 015a017f 01760130 01a701a4     ......Z.0.v.....
    c1c4:	026c0212 029a0269 029402d4 02650270     ..l.i.......p.e.
    c1d4:	029a027d 02f5029c 02df02fd 03000310     }...............
    c1e4:	02ee02dc 03680331 03ee03af 03b703e0     ....1.h.........
    c1f4:	02cb0355 02c302a3 03870300 03e903ed     U...............
    c204:	035e03b3 024a02d5 02200218 02eb0272     ..^...J... .r...
    c214:	0308031d 02240294 0295022c 027702b8     ......$.,.....w.
    c224:	01db021d 021201c6 02dc02a9 01630256     ............V.c.
    c234:	0187011b 02420216 01c1020b 0149016b     ......B.....k.I.
    c244:	01e50187 013c01bf 00ee00de 01b2013c     ......<.....<...
    c254:	01d601f0 00f10189 00310073 002d000f     ........s.1...-.
    c264:	012600a9 0151014e 007c010d 001a002b     ..&.N.Q...|.+...
    c274:	006b0020 00e600b5 011e011f 00f600f7      .k.............
    c284:	01080120 01760118 01850170 018001a1      .....v.p.......
    c294:	01300159 01a60175 021101a7 026a026e     Y.0.u.......n.j.
    c2a4:	02d50298 026e0296 027d0265 029d029b     ......n.e.}.....
    c2b4:	02ff02f4 030f02de 02db0302 033102ed     ..............1.
    c2c4:	03af0369 03e103ef 035503b6 02a102cb     i.........U.....
    c2d4:	030002c3 03ef0386 03b303ea 02d5035d     ............]...
    c2e4:	02160249 02710221 031e02ec 02940308     I...!.q.........
    c2f4:	022a0223 02ba0294 021c0277 01c501da     #.*.....w.......
    c304:	02aa0211 025702de 01170162 02180186     ......W.b.......
    c314:	020c0244 016b01c0 01860148 01c201e5     D.....k.H.......
    c324:	00dd013c 013d00ed 01f201b2 018901d7     <.....=.........
    c334:	007100f2 000f0030 00a8002d 01500128     ..q.0...-...(.P.
    c344:	010e0150 0029007c 00210019 00b7006a     P...|.)...!.j...
    c354:	011f00e7 00f8011f 012000f5 0117010a     .......... .....
    c364:	01730175 01a10183 01580181 01720131     u.s.......X.1.r.
    c374:	01a901a8 0270020f 0296026c 029802d5     ......p.l.......
    c384:	0265026c 029b027d 02f2029e 02de0302     l.e.}...........
    c394:	0304030c 02ec02db 036a0331 03ef03af     ........1.j.....
    c3a4:	03b603e3 02cb0356 02c2029e 03850301     ....V...........
    c3b4:	03ec03f1 035c03b2 024802d5 02200214     ......\...H... .
    c3c4:	02ec0271 03080320 02220295 02940227     q... .....".'...
    c3d4:	027802bd 01d9021b 021001c5 02e102a9     ..x.............
    c3e4:	01620259 01850112 02460219 01bf020d     Y.b.......F.....
    c3f4:	0147016b 01e60185 013d01c5 00eb00db     k.G.......=.....
    c404:	01b2013d 01d801f4 00f30189 002e0070     =...........p...
    c414:	002c000f 012900a7 01500152 007d010f     ..,...).R.P...}.
    c424:	00190026 00690022 00e800b7 0121011e     &...".i.......!.
    c434:	00f400f8 010d011f 01730115 01820177     ..........s.w...
    c444:	018301a1 01310157 01a90170 020c01aa     ....W.1.p.......
    c454:	026f0271 02d50294 026a029c 027c0264     q.o.......j.d.|.
    c464:	029f029b 030402ef 030902df 02db0306     ................
    c474:	033002ea 03ae036b 03e403ef 035603b5     ..0.k.........V.
    c484:	029b02cb 030202c1 03f20383 03b203ee     ................
    c494:	02d6035c 02110247 02700220 032302eb     \...G... .p...#.
    c4a4:	02960309 02240221 02bf0292 021a027a     ....!.$.....z...
    c4b4:	01c401d8 02a8020e 025d02e4 010d0163     ..........].c...
    c4c4:	021a0181 020e0249 016b01be 01830146     ....I.....k.F...
    c4d4:	01c801e5 00d9013e 013d00e8 01f501b2     ....>.....=.....
    c4e4:	018901da 006f00f4 0010002d 00a5002b     ......o.-...+...
    c4f4:	0155012a 010f0150 0024007f 00220017     *.U.P.....$...".
    c504:	00b80068 011e00e9 00f90122 011e00f3     h.......".......
    c514:	0115010f 017b0171 019f0182 01570185     ....q.{.......W.
    c524:	016d0131 01ad01aa 02710208 02920273     1.m.......q.s...
    c534:	02a002d3 02620269 029b027c 02ec02a0     ....i.b.|.......
    c544:	02e10306 03080306 02e802dd 036c032f     ............/.l.
    c554:	03ee03ae 03b503e6 02cc0356 02bf0298     ........V.......
    c564:	03820302 03f103f2 035b03b2 024702d6     ..........[...G.
    c574:	021f020e 02ea026f 030b0325 02210298     ....o...%.....!.
    c584:	028f0221 027d02c2 01d7021a 020c01c4     !.....}.........
    c594:	02e602a6 01660262 017c0107 024d021b     ....b.f...|...M.
    c5a4:	01be0210 0145016b 01e40181 014101cd     ....k.E.......A.
    c5b4:	00e500d7 01b2013c 01dd01f7 00f60189     ....<...........
    c5c4:	002b006f 002b000f 012a00a3 01510158     o.+...+...*.X.Q.
    c5d4:	00820110 00150022 00660023 00eb00b8     ...."...#.f.....
    c5e4:	0125011e 00f600fe 01180121 0172011c     ..%.....!.....r.
    c5f4:	01880183 018e01a2 013e0162 01b10175     ........b.>.u...
    c604:	020501b6 026c0266 02bb0283 025d0292     ....f.l.......].
    c614:	026c0254 028b0287 02e102c9 02da02c2     T.l.............
    c624:	02ba02de 02f802bf 035e032b 038a0390     ........+.^.....
    c634:	0311035f 027502a3 02c90292 037d0328     _.....u.....(.}.
    c644:	034a037e 02a10305 02080235 02500215     ~.J.....5.....P.
    c654:	02d402a8 026d02c0 02140217 02870261     ......m.....a...
    c664:	02110258 01d701e3 026b0206 02430298     X.........k...C.
    c674:	015d019f 021101a8 020c0233 01a501d7     ..].....3.......
    c684:	01b2018e 01e401ee 01530193 0190015b     ..........S.[...
    c694:	01fb01d4 01bf01ee 01280170 00f90105     ........p.(.....
    c6a4:	014a010a 01ac0192 018901a9 01160145     ..J.........E...
    c6b4:	011c0111 0166013e 01980180 018c019c     ....>.f.........
    c6c4:	019b0188 019c019a 01cb01c0 01d701cd     ................
    c6d4:	01bd01d0 01c401ae 01e301df 02280201     ..............(.
    c6e4:	0234022d 023a0248 021f0224 02320228     -.4.H.:.$...(.2.
    c6f4:	02490234 02470252 024e024d 02410242     4.I.R.G.M.N.B.A.
    c704:	02650253 02830275 02710280 02330256     S.e.u.....q.V.3.
    c714:	022b0223 0256023b 026d026e 0247025d     #.+.;.V.n.m.].G.
    c724:	020e022b 02040201 02280213 022d0233     +.........(.3.-.
    c734:	02050219 02130203 0212021c 01fa0203     ................
    c744:	020001f8 02190211 01f2020b 01f301e8     ................
    c754:	02060202 01fb0201 01f501f6 01fe01f9     ................
    c764:	01f901fe 01f801f6 01fe01fb 01ff01ff     ................
    c774:	020001ff                                ....

0000c778 <click_sound_data>:
    c778:	01fd01ff 01fe01fe 020001ff 02020201     ................
    c788:	02020203 01fc01ff 01fb01f9 02070200     ................
    c798:	01fe0207 01f801f5 020e0206 01e401fe     ................
    c7a8:	020c0210 01f601f2 01eb021a 020f0201     ................
    c7b8:	021601e8 020c01ee 020201f8 01ff01fe     ................
    c7c8:	01fc0201 01fb0203 01fc0200 01fe0200     ................
    c7d8:	01fc0201 01f80206 02120200 020101f8     ................
    c7e8:	02060208 01fb01fb 02040208 01fe01fe     ................
    c7f8:	02060200 020601f8 020d01fb 020801f2     ................
    c808:	020401fc 01f30204 01eb0212 01ea0215     ................
    c818:	01d40221 01db022d 02150210 022e01d1     !...-...........
    c828:	020b01df 01e40214 022301fc 01f801e4     ..........#.....
    c838:	020c0210 01f201ee 02080209 01fb0204     ................
    c848:	01f901f8 020301fe 02030206 01f90201     ................
    c858:	01f801f3 02060200 02030207 01f701fd     ................
    c868:	01f701f8 01fa01fd 01f701fe 020101ff     ................
    c878:	0207020a 021401f0 020301ea 01f201fc     ................
    c888:	01f80204 01eb020b 01fc0216 020d0206     ................
    c898:	021a01f2 01ea0212 020301f4 01ef01e2     ................
    c8a8:	020001dd 01e101ee 01f201f7 01f60202     ................
    c8b8:	02120204 022a021d 02440232 024f0252     ......*.2.D.R.O.
    c8c8:	02200243 01ca0200 01670193 01890162     C. .......g.b...
    c8d8:	023f01cb 02c9028d 023b0272 0110005e     ..?.....r.;.^...
    c8e8:	03a602ec 0000026b 036f01f1 003f0304     ....k.....o...?.
    c8f8:	02e201c8 01d401fa 024c01c9 025201b4     ..........L...R.
    c908:	022401c6 021701d9 020501f8 01f80200     ..$.............
    c918:	01ef0209 01f3020f 01f5020c 01fa0205     ................
    c928:	01ff0201 01ff0201 01fe01ff 020001ff     ................
    c938:	020001ff 01ff01fe 020201fd 020101ff     ................
    c948:	020101fc 020d01f8 01f701fc 01f4020a     ................
    c958:	01f4020b 01fe0207 021001fa 01ff01e9     ................
    c968:	02060210 020001ea 01f80211 01fd01f8     ................
    c978:	01f5020d 01fe020d 01fe01f0 020f01ff     ................
    c988:	01fb01fc 01fc0204 01ff0201 020b01fe     ................
    c998:	020001ff 01fc01fc 02040201 01fb0203     ................
    c9a8:	020001fe 020001fe 02020204 02000200     ................
    c9b8:	02010201 02010201 02030203 02020201     ................
    c9c8:	02010202 02030201 02020203 02010202     ................
    c9d8:	02030204 02000201 02010202 02000201     ................
    c9e8:	02010201 02000200 01ff0200 01fd01fe     ................
    c9f8:	01fb01fc 01fa01fa 01f801f7 01f801f7     ................
    ca08:	01f601f7 01f901f9 01fd01fa 01fe01fd     ................
    ca18:	01fe01ff 02020201 02050204 01fe0203     ................
    ca28:	020a0205 02020200 02010205 01ff0205     ................
    ca38:	020301fe 02010202 020801f8 020501fa     ................
    ca48:	01fa01fd 01fc0209 01fd0201 01fe0206     ................
    ca58:	020001ff 020201ff 01f90200 02000204     ................

0000ca68 <beep_sound_data>:
    ca68:	01fb0200 01a301f0 017f0159 01d501ad     ........Y.......
    ca78:	022b0233 01fb0232 018d0195 01b20178     3.+.2.......x...
    ca88:	01f601af 027e025c 01c90254 018e01c4     ....\.~.T.......
    ca98:	0132014b 01f3016a 022e0203 02720263     K.2.j.......c.r.
    caa8:	01d10247 01aa01cc 01510150 024601a2     G.......P.Q...F.
    cab8:	02b4026f 029e0301 0155022a 00c5011f     o.......*.U.....
    cac8:	00ef0077 025e0167 02f90274 02d2032a     w...g.^.t...*...
    cad8:	015f025f 00d7015b 010d00de 02ab01b1     _._.[...........
    cae8:	033902ac 02e90316 00fd022d 004400cf     ..9.....-.....D.
    caf8:	00c70091 02e001b7 036902dd 0308031f     ..........i.....
    cb08:	013301ec 00940157 011c0106 02ff0244     ..3.W.......D...
    cb18:	038c02f1 02eb030f 00e4018b 003c00e5     ..............<.
    cb28:	00c900a3 028501f9 038502d1 02ff0311     ................
    cb38:	014c01d6 006c00f9 00f500e8 025d022b     ..L...l.....+.].
    cb48:	02f90276 0258027f 00e7011c 001e0099     v.....X.........
    cb58:	00cd009a 021a0204 03100293 026f02aa     ..............o.
    cb68:	01200124 003a00b6 00e10093 0213022d     $. ...:.....-...
    cb78:	031702a2 0251029b 01120107 0011006d     ......Q.....m...
    cb88:	00c2006e 01e501f8 02fe02be 023602b4     n.............6.
    cb98:	01620123 005a0076 01370084 021f0247     #.b.v.Z...7.G...
    cba8:	02ff031d 021d02d1 0151012e 0092004c     ..........Q.L...
    cbb8:	017700bd 0246026e 02f50350 021902df     ..w.n.F.P.......
    cbc8:	01790154 00c1005f 018700b7 025e0245     T.y._.......E.^.
    cbd8:	02c5034a 01df02d1 014e015f 00dd0056     J......._.N.V...
    cbe8:	01c000d2 027c024d 02e7035d 01e702ef     ....M.|.].......
    cbf8:	010f0167 00d80053 01f300c5 029d023c     g...S.......<...
    cc08:	02d30356 01a302d1 01100190 00f80070     V...........p...
    cc18:	022200f5 02b10237 02a6032a 01670294     ..".7...*.....g.
    cc28:	00c6016a 00da0064 0253010b 02e20216     j...d.....S.....
    cc38:	02a7031c 0141027b 00a6016d 00fd0097     ....{.A.m.......
    cc48:	0277014a 03230245 02a0030a 0116023e     J.w.E.#.....>...
    cc58:	00590156 00ce007a 02670142 0313023b     V.Y.z...B.g.;...
    cc68:	029802cd 00fe01f5 004b0146 00c60090     ........F.K.....
    cc78:	0235016d 03070200 02610288 00d7019b     m.5.......a.....
    cc88:	000100fa 00a30091 02340190 033b0235     ..........4.5.;.
    cc98:	02a902a5 012f01b5 002d0120 00e700db     ....../. .-.....
    cca8:	027101ec 037402a9 029a02b1 01120169     ..q...t.....i...
    ccb8:	003000e9 010100e4 02730248 037102c1     ..0.....H.s...q.
    ccc8:	02a602bd 0154017c 004500d6 012400ec     ....|.T...E...$.
    ccd8:	026c026c 035602e7 029802b0 014b015a     l.l...V.....Z.K.
    cce8:	006a00b7 01340108 026d0278 034b0318     ..j...4.x.m...K.
    ccf8:	028902b6 014b0133 006f0093 014f00f0     ....3.K...o...O.
    cd08:	02440295 02fd0312 020f027a 013000fc     ..D.....z.....0.
    cd18:	0065003c 015800cc 02410276 02e40330     <.e...X.v.A.0...
    cd28:	01de028a 011b00d0 00930027 017f00cf     ........'.......
    cd38:	02460260 02ce034a 01d4029c 010700f9     `.F.J...........
    cd48:	00a7001f 01ac00d1 0263026a 02af034a     ........j.c.J...
    cd58:	01a6029a 00ed010c 00a80000 01d100c7     ................
    cd68:	027a0245 02940348 016c029a 00ef011f     E.z.H.....l.....
    cd78:	00db0023 022f00f1 02c1026d 02a00355     #...../.m...U...
    cd88:	015d02a6 00c40135 00e8003a 025e0110     ..].5...:.....^.
    cd98:	02d30243 02980344 011f028b 00950135     C...D.......5...
    cda8:	00cd0035 024c00f5 02f10237 0293030d     5.....L.7.......
    cdb8:	0118024e 007c0142 00d8006c 02640140     N...B.|.l...@.d.
    cdc8:	031d0245 02b80302 011c0236 00560155     E.......6...U.V.
    cdd8:	00fa0096 02950189 0368026d 02cd030e     ........m.h.....
    cde8:	01260220 0073016e 011400cb 02ad01d2      .&.n.s.........
    cdf8:	0387029e 02c902fe 013a01f7 00590141     ..........:.A.Y.
    ce08:	011600f4 029d01ff 03820299 02be02d2     ................
    ce18:	013501b1 002d010d 00ee00dd 024e0208     ..5...-.......N.
    ce28:	033e0298 028f0295 012b0168 003b00d9     ..>.....h.+...;.
    ce38:	00f300da 022e0227 031c028f 02720275     ....'.......u.r.
    ce48:	01240128 002400a2 00d200cb 02200222     (.$...$.....". .
    ce58:	031c02c6 0259027c 01380112 0044007f     ....|.Y...8...D.
    ce68:	011b00ce 024c0257 0320030b 025502b4     ....W.L... ...U.
    ce78:	01500138 0085007f 015b00e2 02670289     8.P.......[...g.
    ce88:	031d0344 024802c7 0164013b 009f0061     D.....H.;.d.a...
    ce98:	018c00e7 02740297 02f60363 021b02cf     ......t.c.......
    cea8:	01640143 00d0005c 01e80109 0290029c     C.d.\...........
    ceb8:	0314038f 020702eb 015f015c 00fc0071     ........\._.q...
    cec8:	021d011c 02e002c8 032003bc 01ee0303     .......... .....
    ced8:	0155017d 011c0087 025f0121 02df02bf     }.U.....!._.....
    cee8:	02fd0394 01b202e5 0102015b 00fd005e     ........[...^...
    cef8:	025f011f 02e90269 02d40381 017302b7     .._.i.........s.
    cf08:	00e0016c 0106007e 02880145 02ff0264     l...~...E...d...
    cf18:	02ba034b 014d028b 00af0164 00f60077     K.....M.d...w...
    cf28:	0273013b 03180254 02a30318 012b0262     ;.s.T.......b.+.
    cf38:	008a015d 00dc0083 0277015c 033b023d     ].......\.w.=.;.
    cf48:	02b90312 013d0247 00700159 00f700b2     ....G.=.Y.p.....
    cf58:	027c019d 03660265 02d20304 0146020b     ..|.e.f.......F.
    cf68:	00600154 00e300cf 027301bd 037b0279     T.`.......s.y.{.
    cf78:	02d902e9 014a01e8 004f0140 00f000e1     ......J.@.O.....
    cf88:	0288020c 0378029d 02ca02de 014701a4     ......x.......G.
    cf98:	005d0126 01110107 028f0233 038f02e1     &.].....3.......
    cfa8:	02c702d4 0172019e 00610107 013e010a     ......r...a...>.
    cfb8:	0282026d 036502fc 02bf02db 017c0180     m.....e.......|.
    cfc8:	008700f6 01560116 027e0291 037f032f     ......V...~./...
    cfd8:	02b202e3 018f017f 00bc00e8 01790139     ............9.y.
    cfe8:	02730292 03450349 027602d8 01840143     ..s.I.E...v.C...
    cff8:	00c000bc 0199011d 026c02a0 0326034f     ..........l.O.&.
    d008:	023a02cc 0177012d 00b4006e 019300fc     ..:.-.w.n.......
    d018:	02540281 02f3035c 01f902ce 015b0135     ..T.\.......5.[.
    d028:	00c80058 01d000f9 02760277 02f00377     X.......w.v.w...
    d038:	01e702da 012a0131 00e40050 01ef00e7     ....1.*.P.......
    d048:	027f0262 02c3035d 019202b5 01160140     b...].......@...
    d058:	00f30040 022600f9 02b80270 02b50360     @.....&.p...`...
    d068:	017702ad 00f00149 00f80055 024b010b     ..w.I...U.....K.
    d078:	02e90260 02b8035a 017302b6 00c90168     `...Z.....s.h...
    d088:	00f80070 0274012b 03130264 02d70356     p...+.t.d...V...
    d098:	01610297 00bb016f 011700a7 027a0155     ..a.o.......U.z.
    d0a8:	034c0273 02e40348 01450288 00ac018b     s.L.H.....E.....
    d0b8:	013a00cb 02cc01bb 038f0290 030a034a     ..:.........J...
    d0c8:	016e027d 009b0197 013600f7 02dd01e5     }.n.......6.....
    d0d8:	03890298 02e30316 014f022b 0065015e     ........+.O.^.e.
    d0e8:	010800f4 02a301e6 037b0285 02d002da     ..........{.....
    d0f8:	012e01c8 00340121 00dc00d4 024901e2     ....!.4.......I.
    d108:	03380278 028c02a1 012e0177 002600e8     x.8.....w.....&.
    d118:	00cd00c3 023001f3 031e0283 02820288     ......0.........
    d128:	013d0150 004300c4 00e900d6 02470229     P.=...C.....).G.
    d138:	031602bf 0275028d 01310137 0047008f     ......u.7.1...G.
    d148:	010100d6 02240248 032e02f2 026402a8     ....H.$.......d.
    d158:	015c012e 007f008f 014000f4 025f0271     ..\.......@.q._.
    d168:	0327033f 026802c9 01580136 00a1007d     ?.'...h.6.X.}...
    d178:	017e0100 02530283 02f0033c 020302a5     ..~...S.<.......
    d188:	01480107 009f004b 018d00d2 024a026d     ..H.K.......m.J.
    d198:	02c50335 01d90299 0118011c 00c0003b     5...........;...
    d1a8:	01dd00f7 02870273 02d4036c 01dc02cb     ....s...l.......
    d1b8:	013f0137 00de005b 021a00fe 02ae0280     7.?.[...........
    d1c8:	02c7037c 01a302c5 01140152 00fa0054     |.......R...T...
    d1d8:	024b0113 02b5025e 02b10359 016002a9     ..K.^...Y.....`.
    d1e8:	00c60149 00e20046 024d0108 02de0231     I...F.....M.1...
    d1f8:	02b70350 01540299 00b3015b 00f9006c     P.....T.[...l...
    d208:	0265012b 02fb0254 02970317 010e0258     +.e.T.......X...
    d218:	005e012d 00c30045 0258011a 030b022a     -.^.E.....X.*...
    d228:	029c02eb 00f90229 003c0144 00c80078     ....)...D.<.x...
    d238:	02600164 03120215 029602cc 00ef01e4     d.`.............
    d248:	00250114 00c00090 025a0196 03510235     ..%.......Z.5.Q.
    d258:	02b802d2 012e01de 002b012d 00d300bc     ........-.+.....
    d268:	025401d1 03430264 02960294 0114018f     ..T.d.C.........
    d278:	002500ff 00d300be 026001f5 034e029d     ..%.......`...N.
    d288:	02b002b2 01330183 004700e1 00ed00e2     ......3...G.....
    d298:	0259022b 035802cb 02b102b7 01740175     +.Y...X.....u.t.
    d2a8:	006900de 011d0107 02700274 03570307     ..i.....t.p...W.
    d2b8:	02a802c2 0186016f 008700d0 01470105     ....o.........G.
    d2c8:	025c0274 03280317 026a02c1 01520136     t.\...(...j.6.R.
    d2d8:	00870092 014700e7 0234024f 02d5030a     ......G.O.4.....
    d2e8:	01db026e 012400d7 00a5005f 01b3010e     n.....$._.......
    d2f8:	02460286 02c10329 01550223 00c80088     ..F.)...#.U.....
    d308:	00c8003e 019d00f8 01ff024b 01e9028d     >.......K.......
    d318:	017501d3 011400ef 01450084 01a1013d     ..u.......E.=...
    d328:	01eb01f6 01e0029d 016001f7 00fa0122     ..........`."...
    d338:	01500093 01b30124 01d601a1 01b9021e     ..P.$...........
    d348:	01cd0229 01f20215 01f201bb 01e80197     )...............
    d358:	01530171 019001a6                       q.S.....

0000d360 <sync_beep_sound_data>:
    d360:	01f60200 01e601e6 021401f5 0230022a     ............*.0.
    d370:	01fb0224 018801c7 01fa0193 02c9028b     $...............
    d380:	0188026d 013100ca 03f402af 01290333     m.....1.....3.).
    d390:	007a000d 02fd01ab 035f03b2 00fa0248     ..z......._.H...
    d3a0:	008c004b 028e0171 0336034d 014c0266     K...q...M.6.f.L.
    d3b0:	00bf009c 02840181 03460343 018a0293     ........C.F.....
    d3c0:	00d700d0 026c017d 0345032d 01b002ab     ....}.l.-.E.....
    d3d0:	00dd00ed 024e016e 033b030f 01cc02b8     ....n.N...;.....
    d3e0:	00df0103 022f015d 032e02f1 01e302c0     ....]./.........
    d3f0:	00e10116 0212014e 031f02d2 020002cb     ....N...........
    d400:	00df012f 01ef0134 031b02b7 021802db     /...4...........
    d410:	00db013d 01da0124 031202a5 022302dd     =...$.........#.
    d420:	00e8014e 01cb0125 02fb0287 023d02df     N...%.........=.
    d430:	00f4016c 01b8011c 02ef0273 024e02e1     l.......s.....N.
    d440:	01070184 01a5011f 02d2024f 027b02ea     ........O.....{.
    d450:	011701b4 0181010b 02d30237 028e02f9     ........7.......
    d460:	012301c8 0178010b 02c60229 029a02f6     ..#...x.).......
    d470:	013401de 0169010b 02b20212 02a702f0     ..4...i.........
    d480:	014701f6 015b010c 029f01fc 02b202eb     ..G...[.........
    d490:	015c020d 01510113 028801e6 02bd02e1     ..\...Q.........
    d4a0:	01730228 01400114 027901d0 02c502de     (.s...@...y.....
    d4b0:	01850237 013e0120 025701ba 02d102cb     7... .>...W.....
    d4c0:	01a8025c 012b0129 0245019f 02d702c5     \...).+...E.....
    d4d0:	01bf026d 01290139 022b018c 02e002b6     m...9.)...+.....
    d4e0:	01da028b 01090136 022b0170 02ef02c8     ....6...p.+.....
    d4f0:	01db0290 01100139 0219016d 02eb02b6     ....9...m.......
    d500:	01f4029e 01170150 02000160 02e902a2     ....P...`.......
    d510:	020702ab 0115015b 01f20156 02de0293     ....[...V.......
    d520:	021602ab 01250173 01da0151 02d30278     ....s.%.Q...x...
    d530:	022d02b5 012b0188 01c90147 02ca0267     ..-...+.G...g...
    d540:	024102bb 0133019e 01b4013f 02c00252     ..A...3.?...R...
    d550:	025502c0 013f01b4 01a3013a 02b1023d     ..U...?.:...=...
    d560:	026802c3 014d01cd 01900136 02a50226     ..h...M.6...&...
    d570:	027802c5 015e01e4 01810135 029b0215     ..x...^.5.......
    d580:	028102c6 016c01f3 017a013b 02870202     ......l.;.z.....
    d590:	028d02bf 017c020a 01650137 027f01ed     ......|.7.e.....
    d5a0:	029702c3 01880218 015f013c 026d01dd     ........<._...m.
    d5b0:	029f02bc 019c0228 0165014b 025501d3     ....(...K.e...U.
    d5c0:	029802a3 01b9023a 0160015f 023d01bc     ....:..._.`...=.
    d5d0:	029d0298 01cb024b 01570165 022e01ac     ....K...e.W.....
    d5e0:	029e0290 01dd0256 015a0174 0219019e     ....V...t.Z.....
    d5f0:	02a10282 01f00267 0155017e 020d0191     ....g...~.U.....
    d600:	02a1027c 01fc026d 015e018b 01fd018e     |...m.....^.....
    d610:	02980269 02120275 016501a2 01e80182     i...u.....e.....
    d620:	02950259 0220027d 016b01af 01d9017d     Y...}. ...k.}...
    d630:	028d0249 02300282 017301c1 01c80176     I.....0...s.v...
    d640:	02880239 02390288 017a01ca 01c00177     9.....9...z.w...
    d650:	02750228 024b0284 018901e5 01ab0170     (.u...K.....p...
    d660:	026e0214 02580289 019301f3 01a30172     ..n...X.....r...
    d670:	02640207 02630288 019d0205 0196016e     ..d...c.....n...
    d680:	025f01fb 0268028a 01a6020b 01970175     .._...h.....u...
    d690:	024d01f1 0268027c 01b90219 01910180     ..M.|.h.........
    d6a0:	023e01e1 026c0275 01c80227 018b0186     ..>.u.l.'.......
    d6b0:	023201d3 02760274 01d20234 0188018a     ..2.t.v.4.......
    d6c0:	022301c7 0279026a 01e60246 01810193     ..#.j.y.F.......
    d6d0:	021601b9 02780264 01f3024b 018501a1     ....d.x.K.......
    d6e0:	020201ac 027f025a 0201025b 018001a6     ....Z...[.......
    d6f0:	01f801a3 027a024f 02130262 018501b8     ....O.z.b.......
    d700:	01e40198 027b0242 021e026e 018101b9     ....B.{.n.......
    d710:	01e20196 0271023b 021f0265 019101c8     ....;.q.e.......
    d720:	01dc019b 0264022e 02280261 019e01d8     ......d.a.(.....
    d730:	01d6019f 02570220 0230025e 01ab01e5     .... .W.^.0.....
    d740:	01cc01a3 0246020e 023a0259 01b801f8     ......F.Y.:.....
    d750:	01bf01a2 023f01fd 0247025f 01bb0202     ......?._.G.....
    d760:	01ba019e 023e01fb 0246025d 01c40206     ......>.].F.....
    d770:	01bd01a7 023301f5 02480255 01cc020f     ......3.U.H.....
    d780:	01bb01a9 022f01f3 0240024f 01db0211     ....../.O.@.....
    d790:	01ba01b7 022001e4 0248024b 01da0217     ...... .K.H.....
    d7a0:	01c601b9 021901ed 02390238 01f1021c     ........8.9.....
    d7b0:	01c301cd 020201d6 024c0235 01fe0235     ........5.L.5...
    d7c0:	01b001c8 01f901c3 02540235 02080242     ........5.T.B...
    d7d0:	01ad01c9 01f801c1 024e0232 0205023a     ........2.N.:...
    d7e0:	01b501ce 01fd01c9 02450231 01fe0230     ........1.E.0...
    d7f0:	01bc01cd 020701d8 022b0226 020a021d     ........&.+.....
    d800:	01d301ee 01ed01d1 02290211 0212022a     ..........).*...
    d810:	01d601f1 01ee01d4 022a0213 020f0225     ..........*.%...
    d820:	01db01f1 01ee01d9 0224020d 02160227     ..........$.'...
    d830:	01d701f7 01e701ce 0223020d 02140224     ..........#.$...
    d840:	01e401fc 01e401d8 021501fe 021b0220     ............ ...
    d850:	01ea0206 01e501db 021001fc 02120218     ................
    d860:	01f40204 01ee01eb 020301f8 0218020f     ................
    d870:	01fd0212 01e501e7 020f01f9 02140219     ................
    d880:	01f50204 01f601f0 020601ff 020b020b     ................
    d890:	01ff0208 01f001f2 020401fa 020b0209     ................
    d8a0:	02010209 01f001f4 020301f9 02050205     ................
    d8b0:	02040205 01f601fd 01f801f5 020601fd     ................
    d8c0:	0208020f 01ee01f6 020501f7 02070209     ................
    d8d0:	01ff0205 01f201f3 020c01ff 0204020c     ................
    d8e0:	01ff01ff 01f801fc 01fe01f8 02080204     ................
    d8f0:	02050209 01ef01fa 01fd01f1 020a0207     ................
    d900:	02040209 01ec01f8 020201f0 02150213     ................
    d910:	01f60208 01eb01eb 020e01fa 02100217     ................
    d920:	01f40200 01e801ec 020d01f4 0212021b     ................
    d930:	01ea01fa 01f101e9 02110201 02040211     ................
    d940:	01f801f9 01f701fa 020101f8 020f020c     ................
    d950:	01fc0209 01ee01f2 020901f6 02160218     ................
    d960:	01f50205 01f001ef 020801f8 02160217     ................
    d970:	01f30205 01ed01eb 020a01f8 02160219     ................
    d980:	01f00203 01eb01e9 020801f3 0220021d     .............. .
    d990:	01ec020a 01e701de 021101fd 02120219     ................
    d9a0:	01f00200 01f501ee 020301fc 0210020b     ................
    d9b0:	0202020d 01ec01f6 01f701e9 021b020f     ................
    d9c0:	02010215 01e901ee 01fb01ed 0219020e     ................
    d9d0:	02000213 01e801ee 01fc01ee 0217020d     ................
    d9e0:	02000212 01eb01ef 01fb01f1 02120209     ................
    d9f0:	02050211 01eb01f6 01f301e9 02160207     ................
    da00:	02070215 01ed01f8 01ec01e7 02170200     ................
    da10:	020f021e 01e801f7 01f301e8 02120204     ................
    da20:	020a0213 01f301fc 01f201f1 020a01fb     ................
    da30:	02110214 01f60203 01f101f1 020801f9     ................
    da40:	02140214 01f50207 01ee01ec 020a01fa     ................
    da50:	02120215 01f10202 01f601ee 02090200     ................
    da60:	020c020f 01f20200 01f601ef 020d0202     ................
    da70:	0206020e 01f101f9 01fc01f2 020c0207     ................
    da80:	02000208 01f701fa 01ff01f9 02060203     ................
    da90:	02060207 01f401ff 01fc01f3 020b0206     ................
    daa0:	0202020a 01f401fa 01fe01f5 02070205     ................
    dab0:	02010206 01f501fa 020501f9 0205020b     ................
    dac0:	01f401fa 020301fa 02010205 01fe01fd     ................
    dad0:	02000200 01fd01fe 01ff01fd 01fc01fe     ................
    dae0:	020101fd 02040206 01f401fa 020401fa     ................
    daf0:	02070208 01ff0204 01f801f8 020301fd     ................
    db00:	02070207 02000204 01fd01fe              ............

0000db0c <switch_to_default_form>:
    db0c:	00000a01 00000b00                       ........

0000db14 <switch_to_session_running_form>:
    db14:	00010a01 00000a00                       ........

0000db1c <switch_to_manual_trigger_form>:
    db1c:	00020a01 00000900                       ........

0000db24 <switch_to_simulation_running_form>:
    db24:	00030a01 00000800                       ........

0000db2c <switch_to_settings_1_form>:
    db2c:	00040a01 00000f00                       ........

0000db34 <set_response_sound_on>:
    db34:	00031101 00001201                       ........

0000db3c <set_response_sound_switch_on>:
    db3c:	00011e01 00001f01                       ........

0000db44 <set_response_sound_off>:
    db44:	00031101 00001300                       ........

0000db4c <set_response_sound_switch_off>:
    db4c:	00011e01 00001e00                       ........

0000db54 <set_trigger_sound_on>:
    db54:	00021101 00001301                       ........

0000db5c <set_trigger_sound_switch_on>:
    db5c:	00001e01 00001e01                       ........

0000db64 <set_trigger_sound_off>:
    db64:	00021101 00001200                       ........

0000db6c <set_trigger_sound_switch_off>:
    db6c:	00001e01 00001f00                       ........

0000db74 <switch_to_settings_2_form>:
    db74:	00050a01 00000e00                       ........

0000db7c <switch_to_settings_3_form>:
    db7c:	00080a01 00000300                       ........

0000db84 <switch_to_keyboard_form>:
    db84:	00060a01 00000d00                       ........

0000db8c <switch_to_menu_form>:
    db8c:	00070a01 00000c00                       ........

0000db94 <switch_to_about_form>:
    db94:	000a0a01 00000100                       ........

0000db9c <switch_to_error_form>:
    db9c:	000b0a01 00000000 74747562 70206e6f     ........button p
    dbac:	73736572 000d6465 73616c66 72772068     ressed..flash wr
    dbbc:	20657469 6f206f6e 6c732066 73656369     ite no of slices
    dbcc:	7525202c 00000a0d 73616c66 72772068     , %u....flash wr
    dbdc:	65747469 6f6e206e 20666f20 63696c73     itten no of slic
    dbec:	202c7365 202c7525 0a0d7525 00000000     es, %u, %u......
    dbfc:	73616c66 72772068 20657469 6f206f6e     flash write no o
    dc0c:	6f762066 656d756c 25202c73 000a0d75     f volumes, %u...
    dc1c:	73616c66 72772068 65747469 6f6e206e     flash written no
    dc2c:	20666f20 756c6f76 2c73656d 2c752520      of volumes, %u,
    dc3c:	0d752520 0000000a 73616c66 72772068      %u.....flash wr
    dc4c:	20657469 67697274 6e6f2067 696c7320     ite trigg on sli
    dc5c:	202c6563 0a0d7525 00000000 73616c66     ce, %u......flas
    dc6c:	72772068 65747469 7274206e 20676769     h written trigg 
    dc7c:	73206e6f 6563696c 7525202c 7525202c     on slice, %u, %u
    dc8c:	00000a0d 73616c66 72772068 20657469     ....flash write 
    dc9c:	67697274 6e6f2067 6c6f7620 2c656d75     trigg on volume,
    dcac:	0d752520 0000000a 73616c66 72772068      %u.....flash wr
    dcbc:	65747469 7274206e 20676769 76206e6f     itten trigg on v
    dccc:	6d756c6f 25202c65 25202c75 000a0d75     olume, %u, %u...
    dcdc:	73616c66 72772068 20657469 736c7570     flash write puls
    dcec:	656c2065 6874676e 7525202c 00000a0d     e length, %u....
    dcfc:	73616c66 72772068 65747469 7570206e     flash written pu
    dd0c:	2065736c 676e656c 202c7468 202c7525     lse lenght, %u, 
    dd1c:	0a0d7525 00000000 73616c66 72772068     %u......flash wr
    dd2c:	20657469 74205254 2c656d69 756c2520     ite TR time, %lu
    dd3c:	00000a0d 73616c66 72772068 65747469     ....flash writte
    dd4c:	5254206e 6d697420 25202c65 25202c75     n TR time, %u, %
    dd5c:	25202c75 25202c75 000a0d75 73616c66     u, %u, %u...flas
    dd6c:	72772068 20657469 67697274 20726567     h write trigger 
    dd7c:	6572202f 6e6f7073 73206573 646e756f     / response sound
    dd8c:	7525202c 00000a0d 73616c66 72772068     , %u....flash wr
    dd9c:	65747469 7274206e 65676769 202f2072     itten trigger / 
    ddac:	70736572 65736e6f 756f7320 202c646e     response sound, 
    ddbc:	202c7525 0a0d7525 00000000 73616c66     %u, %u......flas
    ddcc:	72772068 20657469 6e756f73 6f762064     h write sound vo
    dddc:	656d756c 7525202c 00000a0d 73616c66     lume, %u....flas
    ddec:	72772068 65747469 6f73206e 20646e75     h written sound 
    ddfc:	756c6f76 202c656d 202c7525 0a0d7525     volume, %u, %u..
    de0c:	00000000 64616572 73657320 6e6f6973     ....read session
    de1c:	74616420 72662061 66206d6f 6873616c      data from flash
    de2c:	0000000d 6f5f6f6e 6c735f66 73656369     ....no_of_slices
    de3c:	61657220 72662064 66206d6f 6873616c      read from flash
    de4c:	7525203a 00000a0d 6f5f6f6e 6f765f66     : %u....no_of_vo
    de5c:	656d756c 65722073 66206461 206d6f72     lumes read from 
    de6c:	73616c66 25203a68 000a0d75 67697274     flash: %u...trig
    de7c:	5f6e6f5f 63696c73 65722065 66206461     _on_slice read f
    de8c:	206d6f72 73616c66 25203a68 000a0d75     rom flash: %u...
    de9c:	67697274 5f6e6f5f 756c6f76 7220656d     trig_on_volume r
    deac:	20646165 6d6f7266 616c6620 203a6873     ead from flash: 
    debc:	0a0d7525 00000000 736c7570 656c5f65     %u......pulse_le
    decc:	6874676e 61657220 72662064 66206d6f     ngth read from f
    dedc:	6873616c 7525203a 00000a0d 745f5254     lash: %u....TR_t
    deec:	20656d69 64616572 6f726620 6c66206d     ime read from fl
    defc:	3a687361 756c2520 00000a0d 67697274     ash: %lu....trig
    df0c:	20726567 6572202f 6e6f7073 73206573     ger / response s
    df1c:	646e756f 7525203a 7525202c 00000a0d     ound: %u, %u....
    df2c:	6e756f73 6f762064 656d756c 61657220     sound volume rea
    df3c:	72662064 66206d6f 6873616c 7525203a     d from flash: %u
    df4c:	00000a0d 41206f6e 72204b43 69656365     ....no ACK recei
    df5c:	2c646576 73657220 00636e79 72617473     ved, resync.star
    df6c:	69742074 756f656d 00000d74 65636572     t timeout...rece
    df7c:	64657669 206e6120 204b4341 616e6966     ived an ACK fina
    df8c:	2e796c6c 000d2e2e 656d6974 2074756f     lly.....timeout 
    df9c:	6e756f63 3a726574 756c2520 00000a0d     counter: %lu....
    dfac:	646e6573 6d6f6320 646e616d 0000000d     send command....
    dfbc:	255f5f5f 0000756c 626d756e 203a7265     ___%lu..number: 
    dfcc:	0d756c25 0000000a 2e302e31 00000036     %lu.....1.0.6...
    dfdc:	765f5f5f 69737265 203a6e6f 00007325     ___version: %s..
    dfec:	73726576 3a6e6f69 0d732520 0000000a     version: %s.....
    dffc:	74207773 6564206f 6c756166 6f662074     sw to default fo
    e00c:	000d6d72 74207773 6573206f 75722073     rm..sw to ses ru
    e01c:	6e696e6e 6f662067 000d6d72 74207773     nning form..sw t
    e02c:	616d206f 7274206e 66206769 0d6d726f     o man trig form.
    e03c:	00000000 74207773 6973206f 7572206d     ....sw to sim ru
    e04c:	6e696e6e 6f662067 000d6d72 74697773     nning form..swit
    e05c:	74206863 6573206f 6e697474 31207367     ch to settings 1
    e06c:	726f6620 00000d6d 74746573 20676e69      form...setting 
    e07c:	70736572 65736e6f 756f7320 7320646e     response sound s
    e08c:	63746977 6e612068 65742064 6f207478     witch and text o
    e09c:	00000d6e 74746573 20676e69 70736572     n...setting resp
    e0ac:	65736e6f 756f7320 7320646e 63746977     onse sound switc
    e0bc:	6e612068 65742064 6f207478 000d6666     h and text off..
    e0cc:	74746573 20676e69 67697274 20726567     setting trigger 
    e0dc:	6e756f73 77732064 68637469 646e6120     sound switch and
    e0ec:	78657420 6e6f2074 0000000d 74746573      text on....sett
    e0fc:	20676e69 67697274 20726567 6e756f73     ing trigger soun
    e10c:	77732064 68637469 646e6120 78657420     d switch and tex
    e11c:	666f2074 00000d66 74746573 20676e69     t off...setting 
    e12c:	67697274 206e6f20 63696c73 74732065     trig on slice st
    e13c:	676e6972 0000000d 74746573 20676e69     ring....setting 
    e14c:	67697274 206e6f20 756c6f76 7320656d     trig on volume s
    e15c:	6e697274 00000d67 74207773 6573206f     tring...sw to se
    e16c:	6e697474 32207367 726f6620 00000d6d     ttings 2 form...
    e17c:	74746573 20676e69 6f206f6e 6f762066     setting no of vo
    e18c:	656d756c 74732073 676e6972 0000000d     lumes string....
    e19c:	74746573 20676e69 6f206f6e 6c732066     setting no of sl
    e1ac:	73656369 72747320 0d676e69 00000000     ices string.....
    e1bc:	74746573 20676e69 736c7570 656c2065     setting pulse le
    e1cc:	6874676e 72747320 0d676e69 00000000     ngth string.....
    e1dc:	74746573 20676e69 74205254 20656d69     setting TR time 
    e1ec:	69727473 000d676e 74207773 6573206f     string..sw to se
    e1fc:	6e697474 33207367 726f6620 00000d6d     ttings 3 form...
    e20c:	74207773 656b206f 616f6279 66206472     sw to keyboard f
    e21c:	0d6d726f 00000000 74207773 656d206f     orm.....sw to me
    e22c:	6620756e 0d6d726f 00000000 74207773     nu form.....sw t
    e23c:	6261206f 2074756f 6d726f66 0000000d     o about form....
    e24c:	74207773 7265206f 20726f72 6d726f66     sw to error form
    e25c:	0000000d 255f5f5f 202f2075 20207525     ....___%u / %u  
    e26c:	00002020 72727563 20746e65 63696c73       ..current slic
    e27c:	25203a65 000a0d75 2a2a2a2a 2a2a2a2a     e: %u...********
    e28c:	75632a2a 6e657272 6f762074 656d756c     **current volume
    e29c:	7525203a 00000a0d 21212121 21212121     : %u....!!!!!!!!
    e2ac:	21212121 21212121 00212121 76207370     !!!!!!!!!!!.ps v
    e2bc:	61746c6f 74206567 6c206f6f 0000776f     oltage too low..
    e2cc:	76207370 61746c6f 74206567 68206f6f     ps voltage too h
    e2dc:	00686769 70757370 6c6f7620 65676174     igh.psup voltage
    e2ec:	20736920 0a0d6425 00000000 21212121      is %d......!!!!
    e2fc:	21212121 21212121 21212121 0d212121     !!!!!!!!!!!!!!!.
    e30c:	00000000 20425355 6f727265 00000d72     ....USB error...
    e31c:	20425355 6e6e6f63 69746365 6f206e6f     USB connection o
    e32c:	00000d6b 72617473 676e6974 6d697320     k...starting sim
    e33c:	74616c75 0d6e6f69 00000000 74746573     ulation.....sett
    e34c:	20676e69 72727563 20746e65 63696c73     ing current slic
    e35c:	74732065 676e6972 0000000d 74746573     e string....sett
    e36c:	20676e69 72727563 20746e65 756c6f76     ing current volu
    e37c:	7320656d 6e697274 00000d67 79616c70     me string...play
    e38c:	20676e69 72617473 6f732074 0d646e75     ing start sound.
    e39c:	00000000 706f7473 676e6970 6d697320     ....stopping sim
    e3ac:	74616c75 0d6e6f69 00000000 72617473     ulation.....star
    e3bc:	676e6974 6e616d20 206c6175 67697274     ting manual trig
    e3cc:	0d726567 00000000 706f7473 676e6970     ger.....stopping
    e3dc:	6e616d20 206c6175 67697274 0d726567      manual trigger.
    e3ec:	00000000 72617473 676e6974 73657320     ....starting ses
    e3fc:	6e6f6973 0000000d 62616e65 5220656c     sion....enable R
    e40c:	77702058 00000d72 65776f70 676e6972     X pwr...powering
    e41c:	20707520 63205854 31202e68 0000000d      up TX ch. 1....
    e42c:	65776f70 676e6972 20707520 63205854     powering up TX c
    e43c:	32202e68 0000000d 706f7473 676e6970     h. 2....stopping
    e44c:	73657320 6e6f6973 0000000d 65776f70      session....powe
    e45c:	676e6972 776f6420 5854206e 2e686320     ring down TX ch.
    e46c:	000d3120 65776f70 676e6972 776f6420      1..powering dow
    e47c:	5854206e 2e686320 000d3220 61736964     n TX ch. 2..disa
    e48c:	20656c62 70205852 000d7277 4c460a0d     ble RX pwr....FL
    e49c:	20485341 65676170 7a697320 25203a65     ASH page size: %
    e4ac:	000a0d64 65730a0d 6f697373 6164206e     d.....session da
    e4bc:	73206174 3a657a69 0d642520 0000000a     ta size: %d.....
    e4cc:	6f730a0d 20646e75 756c6f76 7320656d     ..sound volume s
    e4dc:	3a657a69 0d642520 0000000a 65720a0d     ize: %d.......re
    e4ec:	6e6f7073 73206573 646e756f 7a697320     sponse sound siz
    e4fc:	25203a65 000a0d64 75630a0d 6e657272     e: %d.....curren
    e50c:	6f662074 73206d72 3a657a69 0d642520     t form size: %d.
    e51c:	0000000a 64616572 20676e69 74746573     ....reading sett
    e52c:	73676e69 6f726620 4c46206d 20485341     ings from FLASH 
    e53c:	6f6d656d 00007972 62616e65 676e696c     memory..enabling
    e54c:	43414420 0000000d 69676572 72657473      DAC....register
    e55c:	74786520 71726920 6e797320 72742063      ext irq sync tr
    e56c:	65676769 00000d72 69676572 72657473     igger...register
    e57c:	74786520 71726920 74756220 0d6e6f74      ext irq button.
    e58c:	00000000 65736572 434c2074 00000d44     ....reset LCD...
    e59c:	20746573 204b4341 65746661 69642072     set ACK after di
    e5ac:	616c7073 65722079 0d746573 00000000     splay reset.....
    e5bc:	62616e65 676e696c 64756120 61206f69     enabling audio a
    e5cc:	000d706d 2a2a2a2a 2a2a2a2a 2a2a2a2a     mp..************
    e5dc:	2a2a2a2a 2a2a2a2a 2a2a2a2a 2a2a2a2a     ****************
    e5ec:	2a2a2a2a 2a2a2a2a 0d2a2a2a 00000000     ***********.....
    e5fc:	74696e69 696c6169 6974617a 64206e6f     initialization d
    e60c:	2c656e6f 61747320 6e697472 616d2067     one, starting ma
    e61c:	6c206e69 0d706f6f 00000000 64207370     in loop.....ps d
    e62c:	202c7069 746c6f76 3a656761 2c642520     ip, voltage: %d,
    e63c:	756f6320 7265746e 7525203a 00000a0d      counter: %u....
    e64c:	20425355 63736964 656e6e6f 64657463     USB disconnected
    e65c:	00000d21 756d6973 6574616c 0d532064     !...simulated S.
    e66c:	00000000 74697773 74206863 67676972     ....switch trigg
    e67c:	4c207265 6f204445 00000d6e 206e616d     er LED on...man 
    e68c:	67697274 69777320 20686374 67697274     trig switch trig
    e69c:	20726567 2044454c 0d66666f 00000000     ger LED off.....
    e6ac:	756d6973 6974616c 73206e6f 63746977     simulation switc
    e6bc:	72742068 65676769 454c2072 6e6f2044     h trigger LED on
    e6cc:	0000000d 756d6973 6974616c 73206e6f     ....simulation s
    e6dc:	63746977 72742068 65676769 454c2072     witch trigger LE
    e6ec:	666f2044 00000d66 706f7473 73657320     D off...stop ses
    e6fc:	6e6f6973 20796220 68737570 74747562     sion by pushbutt
    e70c:	000d6e6f 72617473 65732074 6f697373     on..start sessio
    e71c:	7962206e 73757020 74756268 0d6e6f74     n by pushbutton.
    e72c:	00000000 69770a0d 7475626e 206e6f74     ......winbutton 
    e73c:	73657270 2c646573 646e6920 203a7865     pressed, index: 
    e74c:	0a0d7525 00000000 74697773 6e696863     %u......switchin
    e75c:	6f742067 726f6620 0d37206d 00000000     g to form 7.....
    e76c:	756d6973 6574616c 0d412064 00000000     simulated A.....
    e77c:	756d6973 6574616c 0d422064 00000000     simulated B.....
    e78c:	756d6973 6574616c 0d432064 00000000     simulated C.....
    e79c:	756d6973 6574616c 0d442064 00000000     simulated D.....
    e7ac:	72617473 79732074 7320636e 646e756f     start sync sound
    e7bc:	0000000d 20746573 63696c73 72742065     ....set slice tr
    e7cc:	20676769 202c6f6e 74697773 74206863     igg no, switch t
    e7dc:	6f66206f 36206d72 0000000d 20746573     o form 6....set 
    e7ec:	756c6f76 7420656d 67676972 2c6f6e20     volume trigg no,
    e7fc:	69777320 20686374 66206f74 206d726f      switch to form 
    e80c:	00000d36 6d726f66 6f6d2034 202c6572     6...form4 more, 
    e81c:	74697773 74206863 6f66206f 35206d72     switch to form 5
    e82c:	0000000d 6d726f66 63612034 74706563     ....form4 accept
    e83c:	7773202c 68637469 206f7420 6d726f66     , switch to form
    e84c:	000d3720 53414c46 72772048 65747469      7..FLASH writte
    e85c:	00000d6e 6d726f66 61632034 6c65636e     n...form4 cancel
    e86c:	7773202c 68637469 206f7420 6d726f66     , switch to form
    e87c:	000d3720 20746573 63696c73 6e207365      7..set slices n
    e88c:	73202c6f 63746977 6f742068 726f6620     o, switch to for
    e89c:	0d36206d 00000000 20746573 756c6f76     m 6.....set volu
    e8ac:	2073656d 202c6f6e 74697773 74206863     mes no, switch t
    e8bc:	6f66206f 36206d72 0000000d 20746573     o form 6....set 
    e8cc:	736c7570 656c2065 6874676e 7773202c     pulse length, sw
    e8dc:	68637469 206f7420 6d726f66 000d3620     itch to form 6..
    e8ec:	20746573 74205254 2c656d69 69777320     set TR time, swi
    e8fc:	74686374 6f66206f 36206d72 0000000d     tchto form 6....
    e90c:	6d726f66 6f6d2038 202c6572 74697773     form8 more, swit
    e91c:	74206863 6f66206f 38206d72 0000000d     ch to form 8....
    e92c:	6d726f66 63612035 74706563 7773202c     form5 accept, sw
    e93c:	68637469 206f7420 6d726f66 000d3720     itch to form 7..
    e94c:	6d726f66 61632035 6c65636e 7773202c     form5 cancel, sw
    e95c:	68637469 206f7420 6d726f66 000d3720     itch to form 7..
    e96c:	74746573 73676e69 7773202c 68637469     settings, switch
    e97c:	206f7420 6d726f66 000d3420 756e656d      to form 4..menu
    e98c:	63616220 73202c6b 63746977 6f742068      back, switch to
    e99c:	726f6620 0d30206d 00000000 756f6261      form 0.....abou
    e9ac:	73202c74 63746977 6f742068 726f6620     t, switch to for
    e9bc:	0d30206d 00000000 6d726f66 6f6d2034     m 0.....form4 mo
    e9cc:	202c6572 74697773 74206863 6f66206f     re, switch to fo
    e9dc:	34206d72 000d2020 6d726f66 62203031     rm 4  ..form10 b
    e9ec:	2c6b6361 69777320 20686374 6d206f74     ack, switch to m
    e9fc:	20756e65 6d726f66 000d2020 75626434     enu form  ..4dbu
    ea0c:	6e6f7474 65727020 64657373 6e69202c     tton pressed, in
    ea1c:	3a786564 2c752520 6c617620 203a6575     dex: %u, value: 
    ea2c:	0a0d7525 00000000 67697274 20726567     %u......trigger 
    ea3c:	20646e73 74697773 69206863 6e6f2073     snd switch is on
    ea4c:	0000000d 67697274 20726567 20646e73     ....trigger snd 
    ea5c:	74697773 69206863 666f2073 00000d66     switch is off...
    ea6c:	70736572 65736e6f 646e7320 69777320     response snd swi
    ea7c:	20686374 6f207369 00000d6e 70736572     tch is on...resp
    ea8c:	65736e6f 646e7320 69777320 20686374     onse snd switch 
    ea9c:	6f207369 000d6666 6279656b 6472616f     is off..keyboard
    eaac:	0d6b6f20 00000000 7220626b 72757465      ok.....kb retur
    eabc:	6176206e 3a65756c 756c2520 00000a0d     n value: %lu....
    eacc:	6279656b 6472616f 2c6b6f20 69777320     keyboard ok, swi
    eadc:	20686374 6b636162 206f7420 6d726f66     tch back to form
    eaec:	0d752520 0000000a 636e6163 000d6c65      %u.....cancel..
    eafc:	6279656b 6472616f 6e616320 2c6c6563     keyboard cancel,
    eb0c:	69777320 20686374 6b636162 206f7420      switch back to 
    eb1c:	6d726f66 0d752520 0000000a 0a0d6925     form %u.....%i..
    eb2c:	00000000 7620626b 65756c61 6c25203a     ....kb value: %l
    eb3c:	70202c75 20766572 7620626b 65756c61     u, prev kb value
    eb4c:	6c25203a 000a0d75 6e657645 65722074     : %lu...Event re
    eb5c:	76696563 66206465 206d6f72 202c7525     ceived from %u, 
    eb6c:	65646e69 25203a78 000a0d75 702f2e2e     index: %u...../p
    eb7c:	69737265 6e657473 74735f74 6761726f     ersistent_storag
    eb8c:	766e2f65 746e695f 616e7265 6c665f6c     e/nv_internal_fl
    eb9c:	5f687361 72746c75 00632e61 524f5453     ash_ultra.c.STOR
    ebac:	00454741 702f2e2e 69737265 6e657473     AGE.../persisten
    ebbc:	74735f74 6761726f 766e2f65 6f74735f     t_storage/nv_sto
    ebcc:	65676172 0000632e 00007998 000079cc     rage.c...y...y..
    ebdc:	000079e6 00007a00 00007a1a 00007a34     .y...z...z..4z..
    ebec:	69676572 72657473 20787220 6c6c6163     register rx call
    ebfc:	6b636162 0000000d 69676572 72657473     back....register
    ec0c:	20787420 6c6c6163 6b636162 0000000d      tx callback....
    ec1c:	62616e45 7520656c 31747261 0000000d     Enable uart1....

0000ec2c <keyboard_report_desc>:
    ec2c:	06090105 070501a1 e729e019 01250015     ..........)...%.
    ec3c:	08950175 01810281 65290019 65250015     u.........)e..%e
    ec4c:	06950875 08050081 05290119 01250015     u.........)...%.
    ec5c:	05950175 03950291 00c00191              u...........

0000ec68 <mouse_report_desc>:
    ec68:	02090105 010901a1 090500a1 03290119     ..............).
    ec78:	01250015 03950175 05750281 01810195     ..%.u.....u.....
    ec88:	30090105 38093109 7f258115 03950875     ...0.1.8..%.u...
    ec98:	c0c00681 000087ee 000087ca 000087ee     ................
    eca8:	000087d0 000087ee 0000879a 000087ee     ................
    ecb8:	000087ee 000087ee 000087ac 000087ee     ................
    ecc8:	000087d6 752f2e2e 642f6273 63697665     ....../usb/devic
    ecd8:	73752f65 2e636462 00000063 73750a0d     e/usbdc.c.....us
    ece8:	20636462 74696e69 0000000d 64630a0d     bdc init......cd
    ecf8:	615f6663 69206d63 0d74696e 00000000     cf_acm init.....
    ed08:	656b0a0d 616f6279 69206472 0d74696e     ..keyboard init.
    ed18:	00000000 73750a0d 20636462 72617473     ......usbdc star
    ed28:	00000d74 73750a0d 20636462 61747461     t.....usbdc atta
    ed38:	000d6863 6f630a0d 736f706d 20657469     ch....composite 
    ed48:	69766564 69206563 0d74696e 00000000     device init.....

0000ed58 <_global_impure_ptr>:
    ed58:	200000e0                                ... 

0000ed5c <__sf_fake_stderr>:
	...

0000ed7c <__sf_fake_stdin>:
	...

0000ed9c <__sf_fake_stdout>:
	...
    edbc:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
    edcc:	32313000 36353433 41393837 45444342     .0123456789ABCDE
    eddc:	31300046 35343332 39383736 64636261     F.0123456789abcd
    edec:	00006665                                ef..

0000edf0 <_init>:
    edf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    edf2:	46c0      	nop			; (mov r8, r8)
    edf4:	bcf8      	pop	{r3, r4, r5, r6, r7}
    edf6:	bc08      	pop	{r3}
    edf8:	469e      	mov	lr, r3
    edfa:	4770      	bx	lr

0000edfc <__init_array_start>:
    edfc:	000000dd 	.word	0x000000dd

0000ee00 <_fini>:
    ee00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ee02:	46c0      	nop			; (mov r8, r8)
    ee04:	bcf8      	pop	{r3, r4, r5, r6, r7}
    ee06:	bc08      	pop	{r3}
    ee08:	469e      	mov	lr, r3
    ee0a:	4770      	bx	lr

0000ee0c <__fini_array_start>:
    ee0c:	000000b5 	.word	0x000000b5
