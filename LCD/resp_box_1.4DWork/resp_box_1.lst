file D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS

file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\Gen4-uLCD-32PT.fnc

000001  000001  #platform "Gen4-uLCD-32PT"
000002  000001  #platform "Gen4-uLCD-32PT"
000003  000008  */
000004  000009      #constant Gen4_ULCD_32PT
000005  000009      #constant Gen4_ULCD_32PT
000006  000010        
000007  000011      #IFNOT EXISTS PICASO_FUNCTIONS
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\PicasoFunctions.fnc

000008  000012          #inherit "PicasoFunctions.fnc"          // inherit the generic functions
000009  000012          #inherit "PicasoFunctions.fnc"          // inherit the generic functions
000010  000001        
000011  000002  // Common inheritance for PicasoGFX2 platforms
000012  000003        
000013  000004  #constant PICASO_FUNCTIONS
000014  000004  #constant PICASO_FUNCTIONS
000015  000005        
000016  000006        
000017  000007  #CONST
000018  000017  #END
000019  000018        
000020  000019  #CONST
000021  000025  #END
000022  000026        
000023  000027        
000024  000028  #CONST
000025  000040  #END
000026  000041        
000027  000042        
000028  000043  #CONST
000029  000208  #END
000030  000209        
000031  000210        
000032  000211  // baud divisor rates for setbaud(n);
000033  000212  #CONST
000034  000234  #END
000035  000235        
000036  000236        
000037  000237        
000038  000238        
000039  000243  */
000040  000244        
000041  000245        
000042  000246  //==============================================//
000043  000247  // EVE bios functions                           //
000044  000248  //==============================================//
000045  000249                                                  //
000046  000250  func serin(), 1;                // read a byte from COM0
000047  000251  // Syntax: serin();
000048  000252  // Usage : char := serin();
000049  000253  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
000050  000254  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000051  000255  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000052  000256  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000053  000257  //     : Returns: -1 if no character is available
000054  000258  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
000055  000259  //     : Returns: positive value 0 to 255 for a valid character received
000056  000260        
000057  000261  func putch("char"), 0;                // write single char to current output device
000058  000262  // Syntax: putch("char");
000059  000263  // Usage : putch("A");
000060  000264  // Notes : Transmits a single byte from the Serial Port COM0. The transmission format is:
000061  000265  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000062  000266  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000063  000267  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000064  000268  //     : The arguments can be a variable, array element, expression or constant
000065  000269        
000066  000270  func serout("char"), 0;                // write a byte to COM0
000067  000271  // Syntax: serout1("char");
000068  000272  // Usage : serout1(ch);
000069  000273  // Notes : send character to COM1
000070  000274        
000071  000275  func setbaud("baudnum"), 0;            // set baud rate of COM0
000072  000276  // Syntax: setbaud(baud_number);
000073  000277  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
000074  000278  // *Notes : argument specifies the baud rate using pre-defined constant.
000075  000279  //       : The pre-defined constant is a value of 0-19 , and internally
000076  000280  //       : this is used as a table pointer to get the baud rate divisor
000077  000281  //       : value for one of the 20 selected baud rates, control is then
000078  000282  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
000079  000283  //       : The pre-defined constants equate to a value of 0-19.
000080  000284  //       : If a value other than 0-19 is used, a run time error (eror 25)
000081  000285  //       : will occur.
000082  000286        
000083  000287  func to("device"), 1;                // output device redirection
000084  000288  // Syntax: to(outstream);
000085  000289  // Usage : to(APPEND); putstr("TWO ");
000086  000290  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000087  000291  //     :
000088  000292  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000089  000293  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000090  000294  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000091  000295  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000092  000296  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000093  000297  //     : completed its action. The APPEND argument is used to send the printed output to the same
000094  000298  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000095  000299  //     : sequential data to a media stream.
000096  000300  //     :
000097  000301  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000098  000302  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000099  000303  //     :                            appended to user memory if previous redirection was to an array.
000100  000304  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000101  000305  //     : TEXT           0xFF08      Output is directed to the screen (default).
000102  000306  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000103  000307  //     : I2C            0xF820      Output is directed to the I2C port.
000104  000308  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000105  000309        
000106  000310        
000107  000311  func pause("milliseconds"), 0;            // blocking delay
000108  000312  // Syntax: pause(milliseconds);
000109  000313  // Usage : pause(1000);                //pause for 1 second
000110  000314  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000111  000315        
000112  000316  func putnum("arg1","arg2"), 1;            // print number to current output device
000113  000317  // Syntax: putnum(format, value);
000114  000318  // Usage : var := putnum(HEX, val);
000115  000319  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000116  000320  //     : Format: A constant that specifies the number format
000117  000321  //     : Value : The number to be printed
000118  000322  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000119  000323  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000120  000324  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000121  000325  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000122  000326  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000123  000327  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000124  000328  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000125  000329  //     :                                     BIN6     BIN6Z     BIN6ZB
000126  000330  //     :                                     BIN7     BIN7Z     BIN7ZB
000127  000331  //     :                                     BIN8     BIN8Z     BIN8ZB
000128  000332  //     :                                     BIN9     BIN9Z     BIN9ZB
000129  000333  //     :                                     BIN10     BIN10Z     BIN10ZB
000130  000334  //     :                                     BIN11     BIN11Z     BIN11ZB
000131  000335  //     :                                     BIN12     BIN12Z     BIN12ZB
000132  000336  //     :                                     BIN13     BIN13Z     BIN13ZB
000133  000337  //     :                                     BIN14     BIN14Z     BIN14ZB
000134  000338  //     :                                     BIN15     BIN15Z     BIN15ZB
000135  000339  //     :                                     BIN16     BIN16Z     BIN16ZB
000136  000340  //     :
000137  000341  //     : bit 15 Leading spaces (1=space before signed number, 0=No space)
000138  000342  //     : bit 14 sign bit (0=signed, 1=unsigned)
000139  000343  //     : bit 13 Blanking (1=Leading zero blanking, 0=Show Zeros)
000140  000344  //     : bit 12 Leading zeros (1=Zeros included, 0=Zeros suppressed)
000141  000345  //     : bits 11-8 Displayed digit quantity
000142  000346  //     : bits 7-5 Reserved
000143  000347  //     : bits 4-0 Number base (usually 2,10 or 16)
000144  000348        
000145  000349        
000146  000350  func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only, not usable)
000147  000351        
000148  000352  func putstr("string"), 1;                       // print string to current output device
000149  000353  // Syntax: putstr(pointer);
000150  000354  // Usage : putstr("HELLO\n");
000151  000355  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000152  000356  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000153  000357  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000154  000358  //       : The output of putstr can be redirected to the communications port, the media, or memory
000155  000359  //       : using the to(...); function.
000156  000360  //       : A string constant is automatically terminated with a zero.
000157  000361  //       : A string in a data statement is not automatically terminated with a zero.
000158  000362  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000159  000363  //       : element packs 1 or 2 characters.
000160  000364        
000161  000365        
000162  000366  func strlen("varAddress"), 1;                   // return length of a var packed string in character units
000163  000367  // Syntax: strlen("varAddress);
000164  000368  // Usage : strlen("HELLO\n");
000165  000369  // Notes : gives the length of a string that is packed into regular var array
000166  000370  //       : Use str_Length(ptr)  for string pointer mode
000167  000371        
000168  000372        
000169  000373  //==============================================//
000170  000374  // Memory Access Function Prototypes            //
000171  000375  //==============================================//
000172  000376                                                  //
000173  000377  func peekW("address"), 1;                       // read a word from system memory
000174  000378  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000175  000379  // refer to address map of internal variables   //
000176  000380  //==============================================//
000177  000381  // Math Functions                               //
000178  000382  //==============================================//
000179  000383                                                  //
000180  000384  func ABS("value"), 1;                           // return a positive number
000181  000385  // Syntax: ABS(value);
000182  000386  // Usage : var := ABS(arg);
000183  000387  // Notes : Returns the absolute value of an argument
000184  000388        
000185  000389  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000186  000390  // Syntax: MIN(value1, value2);
000187  000391  // Usage : var := MIN(arg1, arg2);
000188  000392  // Notes : Returns the minimum of 2 arguments
000189  000393        
000190  000394  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000191  000395  // Syntax: MAX(value1, value2);
000192  000396  // Usage : var := MAX(arg1, arg2);
000193  000397  // Notes : Returns the maximum of 2 arguments
000194  000398        
000195  000399  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000196  000400  // Syntax: SWAP(&var1, &var2);
000197  000401  // Usage : SWAP(&var1, &var2);
000198  000402  // Notes : Swaps the contents of 2 variables or memory locations
000199  000403        
000200  000404  func SIN("angle"), 1;                           // return SIN of angle
000201  000405  // Syntax: SIN(angle);
000202  000406  // Usage : var := SIN(arg);
000203  000407  // Notes : Returns the sine in radians of an argument in degrees
000204  000408  //       : the returned value range is from 127 to -127. The real
000205  000409  //       : cosine values vary from 1.0 to -1.0 so appropriate
000206  000410  //       : scaling must be done in user code.
000207  000411        
000208  000412  func COS("angle"), 1;                           // return COS of angle
000209  000413  // Syntax: COS(angle);
000210  000414  // Usage : var := COS(arg);
000211  000415  // Notes : Returns the cosine in radians of an argument in degrees
000212  000416  //       : the returned value range is from 127 to -127. The real
000213  000417  //       : cosine values vary from 1.0 to -1.0 so appropriate
000214  000418  //       : scaling must be done in user code.
000215  000419        
000216  000420  func RAND(), 1;                                 // return a pseudo random number
000217  000421  // Syntax: RAND();
000218  000422  // Usage : var := RAND();
000219  000423  // Notes : Returns a random number between 0 and 0xFFFF.
000220  000424  //       : The random number generator must first be seeded
000221  000425  //       : by using the SEED(number) function.
000222  000426        
000223  000427  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000224  000428  // Syntax: SEED(number);
000225  000429  // Usage : SEED(arg);
000226  000430  // Notes : Seeds the random number generator.
000227  000431        
000228  000432  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000229  000433  // Syntax: OVF();
000230  000434  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000231  000435  //       : hiWord := OVF();
000232  000436  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000233  000437        
000234  000438  func SQRT("number"), 1;                         // return square root of a number
000235  000439  // Syntax: SQRT(number);
000236  000440  // Usage : SQRT(arg);
000237  000441  // Notes : Returns the integer square root of a number.
000238  000442  //------------------------------------------------------------------//
000239  000443  //          Text Related Function Prototypes
000240  000444  //------------------------------------------------------------------//
000241  000445        
000242  000446  func txt_MoveCursor("line", "column"), 0;
000243  000447  // Syntax: txt_SetCursor(line, column);
000244  000448  // Usage : txt_SetCursor(arg1, arg2);
000245  000449  // Notes : Moves the text Cursor to a new screen position set by
000246  000450  //       : line,column parameters.
000247  000451        
000248  000452  func txt_Set("mode", "value"), 0;
000249  000453  // Syntax: txt_Set(mode, value);
000250  000454  // Usage : txt_Set(arg1, arg2);
000251  000455  // Returns : Original value before the change
000252  000456  // Notes : Sets various text related parameters used by other functions
000253  000457  //       : This allows the features to be set programatically with a
000254  000458  //       : single function call.It is strongly recommended to use the
000255  000459  //       : pre-defined constants rather than the mode numbers.
000256  000460  //       : NB:- Although it is often required to be able to set text
000257  000461  //       : functions with a single function call for graphics engine
000258  000462  //       : related functions, there is a complete set of single parameter
000259  000463  //       : shortcut functions that have exactly the same function as
000260  000464  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000261  000465  //       :
000262  000466  //       : mode = TEXT_COLOUR (mode 0)
000263  000467  //       : txt_Set(TEXT_COLOUR, value);
000264  000468  //       : value = 0 to 0xFFFF, Black to White
000265  000469  //       : Sets the Text colour for the display
000266  000470  //       : Default = LIME.
000267  000471  //       :
000268  000472  //       : mode = TEXT_HIGHLIGHT (mode 1)
000269  000473  //       : txt_Set(TEXT_HIGHLIGHT, value);
000270  000474  //       : value = 0 to 0xFFFF, Black to White
000271  000475  //       : Sets the Text background colour for the display. Effective
000272  000476  //       : when text mode is Opaque.
000273  000477  //       : Default = BLACK.
000274  000478  //       :
000275  000479  //       : mode = FONT_ID (mode 2)
000276  000480  //       : txt_Set(FONT_ID, value);
000277  000481  //       : value = FONT1, FONT2 or FONT3 for internal fonts
000278  000482  //       : else this value is the name of a font included
000279  000483  //       : in a users program in a data statement.
000280  000484  //       : Default = FONT SIZE 3.
000281  000485  //       :
000282  000486  //       : mode = TEXT_WIDTH  (mode 3)
000283  000487  //       : txt_Set(TEXT_WIDTH, value);
000284  000488  //       : value = 1 to 16
000285  000489  //       : Sets the Text Width multiplier
000286  000490  //       : text will be printed magnified horizontally
000287  000491  //       : by this factor, Default = 1.
000288  000492  //       :
000289  000493  //       : mode = TEXT_HEIGHT  (mode 4)
000290  000494  //       : txt_Set(TEXT_HEIGHT, value);
000291  000495  //       : value = 1 to 16
000292  000496  //       : Sets the Text Height multiplier
000293  000497  //       : text will be printed magnified vertically
000294  000498  //       : by this factor, Default = 1.
000295  000499  //       :
000296  000500  //       : mode = TEXT_XGAP  (mode 5)
000297  000501  //       : txt_Set(TEXT_XGAP, value);
000298  000502  //       : value = 1 to 32
000299  000503  //       : Sets the horizontal gap between characters
000300  000504  //       : The gap is in pixel units, Default = 0
000301  000505  //       :
000302  000506  //       : mode = TEXT_YGAP  (mode 6)
000303  000507  //       : txt_Set(TEXT_YGAP, value);
000304  000508  //       : value = 1 to 32
000305  000509  //       : Sets the vertical gap below characters
000306  000510  //       : The gap is in pixel units, Default = 0
000307  000511  //       :
000308  000512  //       : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
000309  000513  //       : txt_Set(TEXT_PRINTDELAY, value);
000310  000514  //       : value = 0 to 255
000311  000515  //       : Sets the delay time (in ms) during character
000312  000516  //       : printing to give a 'teletype' like effect.
000313  000517  //       : Often used to attract attention to a string
000314  000518  //       : being printed which can often be missed if
000315  000519  //       : just suddenly appearing or changing.
000316  000520  //       : Default = 0 ms.
000317  000521  //       :
000318  000522  //       : mode = TEXT_OPACITY (mode 8)
000319  000523  //       : txt_Set(TEXT_OPACITY, value);
000320  000524  //       : value = TRANSPARENT (0) = Text Trasparent
000321  000525  //       : value = OPAQUE (1) = Text Opaque
000322  000526  //       : Sets the Opacity/Transparency of the text
000323  000527  //       : Default = 0 or TRANSPARENT
000324  000528  //       :
000325  000529  //       : mode = TEXT_BOLD (mode 9)
000326  000530  //       : txt_Set(TEXT_BOLD, value);
000327  000531  //       : value = dont care
000328  000532  //       : Sets Bold Text mode for the next string or char
000329  000533  //       : The feature automatically resets after printing
000330  000534  //       : using putstr or print has completed
000331  000535  //       :
000332  000536  //       : mode = TEXT_ITALIC (mode 10)
000333  000537  //       : txt_Set(TEXT_ITALIC, value);
000334  000538  //       : value = dont care
000335  000539  //       : Sets Italic Text mode for the next string or char
000336  000540  //       : The feature automatically resets after printing
000337  000541  //       : using putstr or print has completed
000338  000542        
000339  000543  //       : mode = TEXT_INVERSE (mode 11)
000340  000544  //       : txt_Set(TEXT_INVERSE, value);
000341  000545  //       : value = dont care
000342  000546  //       : Sets Inverse Text mode for the next string or char
000343  000547  //       : The feature automatically resets after printing
000344  000548  //       : using putstr or print has completed
000345  000549  //       :
000346  000550  //       : mode = TEXT_UNDERLINED (mode 12)
000347  000551  //       : txt_Set(TEXT_UNDERLINED, value);
000348  000552  //       : value = dont care
000349  000553  //       : Sets Underlined Text mode for the next string or char
000350  000554  //       : The feature automatically resets after printing
000351  000555  //       : using putstr or print has completed
000352  000556  //       :
000353  000557  //       : mode = TEXT_ATTRIBUTES (mode 13)
000354  000558  //       : txt_Set(TEXT_ATTRIBUTES, value);
000355  000559  //       : value = bits are defined as:
000356  000560  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000357  000561  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000358  000562  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000359  000563  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000360  000564  //       : Allows a combination of text attributes to be defined together
000361  000565  //       : by 'or'ing the bits together.
000362  000566  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000363  000567  //       : The feature automatically resets after printing
000364  000568  //       : using putstr or print has completed.
000365  000569  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000366  000570  //       :
000367  000571  //       : mode = TEXT_WRAP (mode 14)
000368  000572  //       : txt_Set(TEXT_WRAP , value);
000369  000573  //       : Sets the position where text wrap will occur
000370  000574  //       : The feature automatically resets when screen
000371  000575  //       : mode is changed. If the value is set to 0,
000372  000576  //       : text wrap is turned off.
000373  000577  //       : of the current screen. Default value is 0
000374  000578  // Notes : The value is in pixel units.
000375  000579  //       :
000376  000580        
000377  000581  //       : txt_Set mode 15 reserved for future use
000378  000582  //       :
000379  000583        
000380  000584        
000381  000585        
000382  000586  //=====================================================//
000383  000587  // Single parameter short-cuts                         //
000384  000588  // for the txt_Set functions                           //
000385  000589  // These functions return the existing value before    //
000386  000590  // the change is made.                                 //
000387  000591  //=====================================================//
000388  000592  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000389  000593  func txt_BGcolour("colour"), 1;             // 1  text background colour
000390  000594  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000391  000595  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000392  000596  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000393  000597  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000394  000598  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000395  000599  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000396  000600  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000397  000601  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000398  000602  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000399  000603  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000400  000604  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000401  000605  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000402  000606  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000403  000607  func _1F(), 0;                              // 15 text (reserved DO NOT REMOVE)
000404  000608        
000405  000609        
000406  000610  //------------------------------------------------------------------//
000407  000611  //                 Hardware Function Prototypes
000408  000612  //------------------------------------------------------------------//
000409  000613        
000410  000614  // I/O Pin reference:-
000411  000615  //
000412  000616  //    IO1_PIN           is pin 2 of J1
000413  000617  //    IO2_PIN           is pin 1 of J1
000414  000618  //    IO3_PIN           is pin 3 of J1
000415  000619  //    IO4_PIN           is pin 5 of J1 (also used for BUS_RD)
000416  000620  //    IO5_PIN           is pin 9 of J2 (also used for BUS_WR)
000417  000621  //    BUS_RD_PIN        is pin 5 of J1 (alias IO4_PIN)
000418  000622  //    BUS_WR_PIN        is pin 9 of J2 (alias IO5_PIN)
000419  000623  //    BUS_0             is pin 27 of J1
000420  000624  //    BUS_1             is pin 25 of J1
000421  000625  //    BUS_2             is pin 23 of J1
000422  000626  //    BUS_3             is pin 21 of J1
000423  000627  //    BUS_4             is pin 19 of J1
000424  000628  //    BUS_5             is pin 17 of J1
000425  000629  //    BUS_6             is pin 13 of J2
000426  000630  //    BUS_7             is pin 11 of J2
000427  000631  //    BACKLITE          is backlite control pin
000428  000632  //    AUDIO_ENABLE      is amplifier chip control pin
000429  000633        
000430  000634  func pin_Set("mode", "pin"), 1;            // set pin to required mode
000431  000635  // Syntax: pin_Set(mode, pin);
000432  000636  // Usage : pin_Set(arg1, arg2);
000433  000637  // Notes : Sets the appropriate pins to Inputs or Outputs
000434  000638  //       : returns true if the pin number is legal (usually ignored)
000435  000639  //       :
000436  000640  //       : mode = 0 : Set Pin to Output
000437  000641  //       : pin_Set(0, pin);
000438  000642  //       : pin_Set(OUTPUT, pin);
000439  000643  //       : pin = 1  : set IO1_PIN to output (pin 2 J1)
000440  000644  //       : pin = 2  : set IO2_PIN to output (pin 1 J1)
000441  000645  //       : pin = 3  : set IO3_PIN to output (pin 3 J1)
000442  000646  //       : pin = 4  : set IO4_PIN to output (pin 5 J1, also used for BUS_RD)
000443  000647  //       : pin = 5  : set IO5_PIN to output (pin 9 J2, also used for BUS_WR)
000444  000648  //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
000445  000649  //       : pin = 8  : set BUS_0   to output (pin 27 of J1)
000446  000650  //       : pin = 9  : set BUS_1   to output (pin 25 of J1)
000447  000651  //       : pin = 10 : set BUS_2   to output (pin 23 of J1)
000448  000652  //       : pin = 11 : set BUS_3   to output (pin 21 of J1)
000449  000653  //       : pin = 12 : set BUS_4   to output (pin 19 of J1)
000450  000654  //       : pin = 13 : set BUS_5   to output (pin 17 of J1)
000451  000655  //       : pin = 14 : set BUS_6   to output (pin 13 of J2)
000452  000656  //       : pin = 15 : set BUS_7   to output (pin 11 of J2)
000453  000657  //       : Sets the desired pin to be used as an Output.
000454  000658  //       :
000455  000659  //       : mode = 1 : Set Pin to Input
000456  000660  //       : pin_Set(1, pin);
000457  000661  //       : pin_Set(INPUT, pin);
000458  000662  //       : pin = 1  : set IO1_PIN to input (pin 2 J1)
000459  000663  //       : pin = 2  : set IO2_PIN to input (pin 1 J1)
000460  000664  //       : pin = 3  : set IO3_PIN to input (pin 3 J1)
000461  000665  //       : pin = 4  : set IO4_PIN to input (pin 5 J1, also used for BUS_RD)
000462  000666  //       : pin = 5  : set IO5_PIN to input (pin 9 J2, also used for BUS_WR)
000463  000667  //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
000464  000668  //       : pin = 8  : set BUS_0   to input (pin 27 of J1)
000465  000669  //       : pin = 9  : set BUS_1   to input (pin 25 of J1)
000466  000670  //       : pin = 10 : set BUS_2   to input (pin 23 of J1)
000467  000671  //       : pin = 11 : set BUS_3   to input (pin 21 of J1)
000468  000672  //       : pin = 12 : set BUS_4   to input (pin 19 of J1)
000469  000673  //       : pin = 13 : set BUS_5   to input (pin 17 of J1)
000470  000674  //       : pin = 14 : set BUS_6   to input (pin 13 of J2)
000471  000675  //       : pin = 15 : set BUS_7   to input (pin 11 of J2)
000472  000676  //       : Sets the desired pin to be used as an Input.
000473  000677        
000474  000678  func pin_HI("pin"), 1;                    // set pin to logic '1'
000475  000679  // Syntax: pin_HI(pin);
000476  000680  // Usage : pin_HI(arg);
000477  000681  // Notes : Outputs a logic "High" (3.3V) on the appropriate
000478  000682  //       : pin that was previously selected as an Output.
000479  000683  //       : returns true if the pin number is legal (usually ignored)
000480  000684  //       :
000481  000685  //       : pin = 1  : set IO1_PIN to "High" level (pin 2 of J1)
000482  000686  //       : pin = 2  : set IO2_PIN to "High" level (pin 1 of J1)
000483  000687  //       : pin = 3  : set IO3_PIN to "High" level (pin 3 of J1)
000484  000688  //       : pin = 4  : set IO4_PIN to "High" level (pin 5 of J1, also used for BUS_RD)
000485  000689  //       : pin = 5  : set IO5_PIN to "High" level (pin 9 of J2, also used for BUS_WR)
000486  000690  //       : pin = 6  : set DCENB pin to "High" level (BACKLITE ON)
000487  000691  //       : pin = 7  : set AUDIO_ENABL pin to "High" level (AMP OFF)
000488  000692  //       : pin = 8  : set BUS_0   to "High" level (pin 27 of J1)
000489  000693  //       : pin = 9  : set BUS_1   to "High" level (pin 25 of J1)
000490  000694  //       : pin = 10 : set BUS_2   to "High" level (pin 23 of J1)
000491  000695  //       : pin = 11 : set BUS_3   to "High" level (pin 21 of J1)
000492  000696  //       : pin = 12 : set BUS_4   to "High" level (pin 19 of J1)
000493  000697  //       : pin = 13 : set BUS_5   to "High" level (pin 17 of J1)
000494  000698  //       : pin = 14 : set BUS_6   to "High" level (pin 13 of J2)
000495  000699  //       : pin = 15 : set BUS_7   to "High" level (pin 11 of J2)
000496  000700        
000497  000701  func pin_LO("pin"), 1;                    // set pin to logic '0'
000498  000702  // Syntax: pin_LO(pin);
000499  000703  // Usage : pin_LO(arg);
000500  000704  // Notes : Outputs a logic "Low" (0V) on the appropriate
000501  000705  //       : pin that was previously selected as an Output.
000502  000706  //       : returns true if the pin number is legal (usually ignored)
000503  000707  //       :
000504  000708  //       : pin = 1 : set IO1_PIN to "Low" level (pin 2 of J1)
000505  000709  //       : pin = 2 : set IO2_PIN to "Low" level (pin 1 of J1)
000506  000710  //       : pin = 3 : set IO3_PIN to "Low" level (pin 3 of J1)
000507  000711  //       : pin = 4 : set IO4_PIN to "Low" level (pin 5 of J1, also used for BUS_RD)
000508  000712  //       : pin = 5 : set IO5_PIN to "Low" level (pin 9 of J2, also used for BUS_WR)
000509  000713  //       : pin = 6 : set DCENB pin to "Low" level (BACKLITE)
000510  000714  //       : pin = 7 : set AUDIO_ENABL pin to "Low" level (AMP ON)
000511  000715  //       : pin = 8  : set BUS_0  to "Low" level (pin 27 of J1)
000512  000716  //       : pin = 9  : set BUS_1  to "Low" level (pin 25 of J1)
000513  000717  //       : pin = 10 : set BUS_2  to "Low" level (pin 23 of J1)
000514  000718  //       : pin = 11 : set BUS_3  to "Low" level (pin 21 of J1)
000515  000719  //       : pin = 12 : set BUS_4  to "Low" level (pin 19 of J1)
000516  000720  //       : pin = 13 : set BUS_5  to "Low" level (pin 17 of J1)
000517  000721  //       : pin = 14 : set BUS_6  to "Low" level (pin 13 of J2)
000518  000722  //       : pin = 15 : set BUS_7  to "Low" level (pin 11 of J2)
000519  000723        
000520  000724  func pin_Read("pin"), 1;                // read pin, logic or analogue
000521  000725  // Syntax: pin_Read(pin);
000522  000726  // Usage : arg1 := pin_Read(arg2);
000523  000727  // Notes : Reads the logic state of the appropriate
000524  000728  //       : pin that was previously selected as an Input.
000525  000729  //       :
000526  000730  //       : pin = 1  : Read the state of IO1_PIN (pin 2 of J1)
000527  000731  //       : pin = 2  : Read the state of IO2_PIN (pin 1 of J1)
000528  000732  //       : pin = 3  : Read the state of IO3_PIN (pin 3 of J1)
000529  000733  //       : pin = 4  : Read the state of IO4_PIN (pin 5 of J1, also used for BUS_RD)
000530  000734  //       : pin = 5  : Read the state of IO5_PIN (pin 9 of J2, also used for BUS_WR)
000531  000735  //       : pin = 6  : Read the state of DCENB pin to "Low" level (BACKLITE)
000532  000736  //       : pin = 7  : Read the state of AUDIO_ENABL pin to "Low" level (AMP ON)
000533  000737  //       : pin = 8  : Read the state of BUS_0   (pin 27 of J1)
000534  000738  //       : pin = 9  : Read the state of BUS_1   (pin 25 of J1)
000535  000739  //       : pin = 10 : Read the state of BUS_2   (pin 23 of J1)
000536  000740  //       : pin = 11 : Read the state of BUS_3   (pin 21 of J1)
000537  000741  //       : pin = 12 : Read the state of BUS_4   (pin 19 of J1)
000538  000742  //       : pin = 13 : Read the state of BUS_5   (pin 17 of J1)
000539  000743  //       : pin = 14 : Read the state of BUS_6   (pin 13 of J2)
000540  000744  //       : pin = 15 : Read the state of BUS_7   (pin 11 of J2)
000541  000745  //       : Returns a 0 (logic low) or 1 (logic high).
000542  000746        
000543  000747        
000544  000748  //------------------------------------------------------------------//
000545  000749  //                 P1 module BUS I/O control
000546  000750  //------------------------------------------------------------------//
000547  000751        
000548  000752  func bus_In(), 1;
000549  000753  // Syntax: bus_In();
000550  000754  // Usage : arg1 := bus_In();
000551  000755  // Notes : Read the 8bit wide bus into the lower 8 bits of arg1.
000552  000756  //       : The upper 8 bits of arg1 are set to 0.
000553  000757  //       : the BUS_RD and BUS_WR pins are not affected.
000554  000758  //       :
000555  000759  //       : BUS_0 is pin 27 of J1
000556  000760  //       : BUS_1 is pin 25 of J1
000557  000761  //       : BUS_2 is pin 23 of J1
000558  000762  //       : BUS_3 is pin 21 of J1
000559  000763  //       : BUS_4 is pin 19 of J1
000560  000764  //       : BUS_5 is pin 17 of J1
000561  000765  //       : BUS_6 is pin 13 of J2
000562  000766  //       : BUS_7 is pin 11 of J2
000563  000767        
000564  000768  func bus_Out("var"), 0;
000565  000769  // Syntax: bus_Out(var);
000566  000770  // Usage : bus_Out(arg1);
000567  000771  // Notes : The lower 8 bits of arg1 are placed on the 8bit wide bus.
000568  000772  //       : The upper 8 bits of arg1 are ignored.
000569  000773  //       : the BUS_RD and BUS_WR pins are not affected.
000570  000774  //       : NB:- any BUS pins that are set to inputs are not affected.
000571  000775  //       :
000572  000776  //       : BUS_0 is pin 27 of J1
000573  000777  //       : BUS_1 is pin 25 of J1
000574  000778  //       : BUS_2 is pin 23 of J1
000575  000779  //       : BUS_3 is pin 21 of J1
000576  000780  //       : BUS_4 is pin 19 of J1
000577  000781  //       : BUS_5 is pin 17 of J1
000578  000782  //       : BUS_6 is pin 13 of J2
000579  000783  //       : BUS_7 is pin 11 of J2
000580  000784        
000581  000785  func bus_Set("var"), 0;
000582  000786  // Syntax: bus_Set(var);
000583  000787  // Usage : bus_Set(arg1);
000584  000788  // Notes : The lower 8 bits of arg1 are placed in the BUS direction register.
000585  000789  //       : a '1' sets a pin to be an input, a '0' sets a pin to be output.
000586  000790  //       : The upper 8 bits of arg1 are ignored.
000587  000791  //       : the BUS_RD and BUS_WR pins are not affected.
000588  000792  //       :
000589  000793  //       : BUS_0 is pin 27 of J1
000590  000794  //       : BUS_1 is pin 25 of J1
000591  000795  //       : BUS_2 is pin 23 of J1
000592  000796  //       : BUS_3 is pin 21 of J1
000593  000797  //       : BUS_4 is pin 19 of J1
000594  000798  //       : BUS_5 is pin 17 of J1
000595  000799  //       : BUS_6 is pin 13 of J2
000596  000800  //       : BUS_7 is pin 11 of J2
000597  000801        
000598  000802  func bus_Write("var"), 0;
000599  000803  // Syntax: bus_Write(var);
000600  000804  // Usage : bus_Write(arg1);
000601  000805  // Notes : The lower 8 bits of arg1 are placed on the BUS, then, after
000602  000806  //       : a settling delay of approx 50nsec, the BUS_WR pin is strobed
000603  000807  //       : LO for approx 50nsec then set back HI.
000604  000808  //       : The upper 8 bits of arg1 are ignored.
000605  000809  //       : NB:- the BUS_WR pin is automatically pre-set to an output to
000606  000810  //       : ensure BUS write integrity.
000607  000811  //       :
000608  000812  //       : BUS_0 is pin 27 of J1
000609  000813  //       : BUS_1 is pin 25 of J1
000610  000814  //       : BUS_2 is pin 23 of J1
000611  000815  //       : BUS_3 is pin 21 of J1
000612  000816  //       : BUS_4 is pin 19 of J1
000613  000817  //       : BUS_5 is pin 17 of J1
000614  000818  //       : BUS_6 is pin 13 of J2
000615  000819  //       : BUS_7 is pin 11 of J2
000616  000820        
000617  000821  func bus_Read(), 1;
000618  000822  // Syntax: bus_Read();
000619  000823  // Usage : arg1 := bus_Read();
000620  000824  // Notes : The BUS_RD pin set to LO, then, after a settling delay
000621  000825  //       : of approx 50nsec, the BUS is read into the lower 8 bits of arg
000622  000826  //       : (the upper 8 bits being set to 0)
000623  000827  //       : the BUS_RD pin is then set back to a HI level.
000624  000828  //       : NB:- the BUS_RD pin is automatically pre-set to an output to
000625  000829  //       : ensure BUS write integrity.
000626  000830  //       :
000627  000831  //       : BUS_0 is pin 27 of J1
000628  000832  //       : BUS_1 is pin 25 of J1
000629  000833  //       : BUS_2 is pin 23 of J1
000630  000834  //       : BUS_3 is pin 21 of J1
000631  000835  //       : BUS_4 is pin 19 of J1
000632  000836  //       : BUS_5 is pin 17 of J1
000633  000837  //       : BUS_6 is pin 13 of J2
000634  000838  //       : BUS_7 is pin 11 of J2
000635  000839        
000636  000840        
000637  000841  //------------------------------------------------------------------//
000638  000842  //   Graphics Functions
000639  000843  //------------------------------------------------------------------//
000640  000844  func gfx_Set("mode", "value"), 0;            // set various graphics functions
000641  000845  // Syntax: gfx_Set(mode, value);
000642  000846  // Usage : gfx_Set(arg1, arg2);
000643  000847  // Notes : Sets various graphics parameters used by other functions
000644  000848  //       : This allows the features to be set programatically with a
000645  000849  //       : single function call.It is strongly recommended to use the
000646  000850  //       : pre-defined constants rather than the mode numbers.
000647  000851  //       : NB:- Although it is often required to be able to set graphics
000648  000852  //       : functions with a single function call for graphics engine
000649  000853  //       : related functions, there is a complete set of single parameter
000650  000854  //       : shortcut functions that have exactly the same function as
000651  000855  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
000652  000856  //       :
000653  000857  //       : mode = PEN_SIZE (mode 16)
000654  000858  //       : gfx_Set(PEN_SIZE, value);
000655  000859  //       : value = SOLID (value 0) rectangle and circle objects are solid
000656  000860  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
000657  000861  //       : Sets the mode of the Pen used by most graphics objects
000658  000862  //       :
000659  000863  //       : mode = BACKGROUND_COLOUR (mode 17)
000660  000864  //       : gfx_Set(BACKGROUND_COLOUR, value);
000661  000865  //       : value = 0 to 0xFFFF, Black to White
000662  000866  //       : Sets the Background colour of the screen
000663  000867  //       :
000664  000868  //       : mode = OBJECT_COLOUR (mode 18)
000665  000869  //       : gfx_Set(OBJECT_COLOUR, value);
000666  000870  //       : value = 0 to 0xFFFF, Black to White
000667  000871  //       : Sets the Object colour used in various functions
000668  000872  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
000669  000873  //       :
000670  000874  //       : mode = CLIPPING (mode 19)
000671  000875  //       : gfx_Set(CLIPPING, value);
000672  000876  //       : value = OFF (value 0) Clipping disabled
000673  000877  //       : value = ON (value 1) Clipping enabled
000674  000878  //       : Enables/Disables the Clipping feature
000675  000879  //       :
000676  000880  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
000677  000881  //       : gfx_Set(TRANSPARENT_COLOUR, value);
000678  000882  //       : value = 0 to 0xFFFF Black to White
000679  000883  //       : Sets Bitmap, Image or Animation Transparency Colour.
000680  000884  //       : NB not implemented
000681  000885  //       :
000682  000886  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
000683  000887  //       : gfx_Set(5, value);
000684  000888  //       : value = OFF (value 0) Transparency disabled
000685  000889  //       : value = ON (value 1) Transparency enabled
000686  000890  //       : Enables/Disables the Transparency feature
000687  000891  //       : NB not implemented
000688  000892  //       :
000689  000893  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
000690  000894  //       : gfx_Set(FRAME_DELAY, value);
000691  000895  //       : value = 0 to 65535 ms
000692  000896  //       : Sets the Video/Animation clip inter-frame delay. This setting will
000693  000897  //       : over-ride the embedded frame delay of the clip. After the event,
000694  000898  //       : the setting will auto disable and if further inter-frame delays need
000695  000899  //       : overriding the setting must be re-issued.
000696  000900  //       :
000697  000901  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
000698  000902  //       : gfx_Set(SCREEN_MODE, value);
000699  000903  //       : value = LANDSCAPE   (value 0)
000700  000904  //       : value = LANDSCAPE_R (value 1)
000701  000905  //       : value = PORTRAIT    (value 2)
000702  000906  //       : value = PORTRAIT_R  (value 3)
000703  000907  //       :
000704  000908  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
000705  000909  //       : gfx_Set(OUTLINE_COLOUR, value);
000706  000910  //       : value = 1 to 0xFFFF, if 0, featre is OFF
000707  000911  //       : Sets the filled Rectangle or Circle objects outline colour
000708  000912  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
000709  000913  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
000710  000914  //       :
000711  000915  //       : Only supports variable contrast for uOLED Modules
000712  000916  //       : mode = CONTRAST (mode 25) : Contrast
000713  000917  //       : gfx_Set(CONTRAST, value);
000714  000918  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
000715  000919  //       : when contrast=0, display is placed in low power mode.
000716  000920  //       : This function should be called with contrast=0 when
000717  000921  //       : powering down the module.
000718  000922  //       :
000719  000923  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
000720  000924  //       : gfx_Set(LINE_PATTERN, value);
000721  000925  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
000722  000926  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
000723  000927  //       : a value of 0 turns the feature off
000724  000928  //       :
000725  000929  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
000726  000930  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
000727  000931  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
000728  000932  //       : NB not implemented, default is COLOUR16
000729  000933  //       :
000730  000934  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
000731  000935  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
000732  000936  //       : sets the button and slider objects bevel width
000733  000937  //       :
000734  000938  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
000735  000939  //       : gfx_Set(BEVEL_SHADOW , 5);
000736  000940  //       : sets the button and slider objects darken and lighten depth for the bevel colour
000737  000941  //       :
000738  000942  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
000739  000943  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
000740  000944  //       : sets the origin of drawn objects to a position other than 0,0
000741  000945  //       :
000742  000946  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
000743  000947  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
000744  000948  //       : sets the origin of drawn objects to a position other than 0,0
000745  000949        
000746  000950        
000747  000951  func gfx_Cls(), 0;                    // clear the screen
000748  000952  // Syntax: gfx_Cls();
000749  000953  // Usage : gfx_Cls();
000750  000954  // Notes : Clears the screen with current background colour
000751  000955        
000752  000956  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
000753  000957  // Syntax: gfx_MoveTo(x, y);
000754  000958  // Usage : gfx_MoveTo(arg1, arg2);
000755  000959  // Notes : Moves the origin to a new x,y position
000756  000960        
000757  000961  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
000758  000962  // Syntax: gfx_MoveRel(x, y);
000759  000963  // Usage : gfx_MoveRel(arg1, arg2);
000760  000964  // Notes : Moves the origin to a new x,y position
000761  000965  //       : relative to the current origing
000762  000966        
000763  000967  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
000764  000968  // Syntax: gfx_LineTo(x1, y1);
000765  000969  // Usage : gfx_LineTo(arg1, arg2);
000766  000970  // Notes : Draws a Line from the origin x,y to x1,y1.
000767  000971  //       : The new origin is then set to x1, y1. Line colour needs
000768  000972  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000769  000973        
000770  000974  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
000771  000975  // Syntax: gfx_LineRel(x1, y1);
000772  000976  // Usage : gfx_LineRel(arg1, arg2);
000773  000977  // Notes : Draws a Line from the origin x,y to x1,y1.
000774  000978  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
000775  000979  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
000776  000980        
000777  000981  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
000778  000982  // Syntax: gfx_Line(x1, x2, y2, colr);
000779  000983  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
000780  000984  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
000781  000985        
000782  000986  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
000783  000987  // Syntax: gfx_Line(x1, x2, y, colr);
000784  000988  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000785  000989  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
000786  000990        
000787  000991  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
000788  000992  // Syntax: gfx_Line(y1, y2, x, colr);
000789  000993  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000790  000994  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
000791  000995        
000792  000996  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
000793  000997  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
000794  000998  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000795  000999  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
000796  001000  //       : bottom corner (x2,y2) on the screen.
000797  001001        
000798  001002  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
000799  001003  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
000800  001004  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000801  001005  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
000802  001006  //       : bottom corner (x2,y2) on the screen.
000803  001007        
000804  001008  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
000805  001009  // Syntax: gfx_Circle(x, y, rad, colr);
000806  001010  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000807  001011  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
000808  001012        
000809  001013  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
000810  001014  // Syntax: gfx_Circle(x, y, rad, colr);
000811  001015  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000812  001016  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
000813  001017        
000814  001018  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
000815  001019  // Syntax: gfx_PutPixel(x, y, colr);
000816  001020  // Usage : gfx_PutPixel(arg1, arg2, arg3);
000817  001021  // Notes : Plots a coloured pixel on the screen at x,y location
000818  001022        
000819  001023  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
000820  001024  // Syntax: gfx_GetPixel(x, y);
000821  001025  // Usage : var := gfx_GetPixel(arg1, arg2);
000822  001026  // Notes : Reads and returns the colour value of a pixel at location x,y
000823  001027        
000824  001028  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
000825  001029  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
000826  001030  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000827  001031  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000828  001032  //       : Vertices must be specified in an anti-clockwise fashion
000829  001033        
000830  001034  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
000831  001035  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
000832  001036  // Usage : gfx_OrbitInit(&arg1, &arg2);
000833  001037  // Notes : Sets up the Orbit function parameters.
000834  001038  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
000835  001039  //       : variables that get updated after calling gfx_Orbit(,,) function.
000836  001040  //       : The coordiantaes are calculated relative to the origin
000837  001041  //       : obtained by using the gfx_MoveTo(x, y) function.
000838  001042        
000839  001043  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
000840  001044  // Syntax: gfx_Orbit(angle, distance);
000841  001045  // Usage : gfx_Orbit(arg1, arg2);
000842  001046  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
000843  001047  //       : only known parameters are the angle and the distance from the current origin.
000844  001048        
000845  001049  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
000846  001050  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
000847  001051  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
000848  001052  // Notes : This function is very similar to the Ploygon function
000849  001053  //       : with the exception of the 1st and the last vertices not joined.
000850  001054        
000851  001055  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
000852  001056  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
000853  001057  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
000854  001058  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000855  001059  //       : Vertices must be minimum of 3 and can be specified in any fashion
000856  001060        
000857  001061  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
000858  001062  // Syntax: gfx_Dot();
000859  001063  // Usage : gfx_Dot();
000860  001064  // Notes : Places a coloured dot at the origin
000861  001065        
000862  001066        
000863  001067  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
000864  001068  // Syntax: gfx_Bullet();
000865  001069  // Usage : gfx_Bullet();
000866  001070  // Notes : Places a coloured circle at the origin
000867  001071  //       : filled or unfilled state is controlled by PenSize
000868  001072        
000869  001073  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
000870  001074  // Syntax: gfx_IncX();
000871  001075  // Usage : var := gfx_IncX();
000872  001076  // Notes : Increments the x coordinate of the origin
000873  001077        
000874  001078  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
000875  001079  // Syntax: gfx_IncY();
000876  001080  // Usage : var := gfx_IncY();
000877  001081  // Notes : Increments the y coordinate of the origin
000878  001082        
000879  001083  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
000880  001084  // Syntax: gfx_BoxTo(x1, y1);
000881  001085  // Usage : gfx_BoxTo(arg1, arg2);
000882  001086  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
000883  001087  //       : The new origin is then set to x1,y1. Rectangle colour needs
000884  001088  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000885  001089  //       : and the PenSize setting determines if Box is solid or outline.
000886  001090        
000887  001091  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
000888  001092  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
000889  001093  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
000890  001094  // Notes : Specifies a clipping window region on the screen such that any objects
000891  001095  //       : and text placed onto the screen will be clipped and displayed only
000892  001096  //       : within that region. For the clipping window to take effect, "Clipping"
000893  001097  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
000894  001098        
000895  001099        
000896  001100  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
000897  001101  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
000898  001102  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
000899  001103  // *Notes:
000900  001104        
000901  001105  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
000902  001106  // Syntax: gfx_SetClipRegion();
000903  001107  // Usage : var := gfx_SetClipRegion();
000904  001108  // *Notes:
000905  001109        
000906  001110  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
000907  001111  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
000908  001112  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
000909  001113  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000910  001114  //       : with xradius = xrad and yradius = yrad.
000911  001115  //       : if PenSize = 0 Ellipse is Solid
000912  001116  //       : if PenSize = 1 Ellipse is Outline
000913  001117        
000914  001118        
000915  001119  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
000916  001120  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
000917  001121  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
000918  001122  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000919  001123  //       : with xradius = xrad and yradius = yrad.
000920  001124        
000921  001125  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 0;
000922  001126  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
000923  001127  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
000924  001128  // Notes : Draws a 3 dimensional Text Button at screen location defined by
000925  001129  //       : x,y arguments (top left corner). The size of the button depends on
000926  001130  //       : the font, width, height and length of the text.
000927  001131  //       : The button appearance will depend on the state parameter setting:
000928  001132  //       :         state = 0 : Button Pressed
000929  001133  //       :         state = 1 : Button Raised
000930  001134        
000931  001135  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
000932  001136  // Syntax: gfx_Panel("style", "x", "y", "width", "height", "colour"), 0;
000933  001137  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
000934  001138  // Notes : Draws a panel (groupbox) at screen location defined by
000935  001139  //       : x, y, width and height with colour "colour".
000936  001140  //       :         state = 0 : recessed
000937  001141  //       :         state = 1 : raised
000938  001142        
000939  001143  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
000940  001144  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
000941  001145  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
000942  001146  // Notes : Draws a 3 dimensional Slider Bar on the screen.
000943  001147  //       : Slider parameters are as follows:
000944  001148  //       :         mode = 0 : Slider recessed
000945  001149  //       :         mode = 1 : Slider raised
000946  001150  //       :         x1, y1 = top left corner
000947  001151  //       :         x2, y2 = bottom right corner
000948  001152  //       :         scale = n : sets the full scale range from 0 to n
000949  001153  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
000950  001154  //       : returns:-
000951  001155        
000952  001156        
000953  001157  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
000954  001158  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
000955  001159  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
000956  001160  // Notes : Copies an area of a screen from xs,ys of size given by width and height
000957  001161  //       : and pastes it to another location determined by xd, yd.
000958  001162        
000959  001163  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
000960  001164  // Syntax: gfx_RGBto565(red, green, blue);
000961  001165  // Usage : gfx_RGBto565(arg1, arg2, arg3);
000962  001166  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
000963  001167        
000964  001168  func gfx_332to565("COLOUR8BIT"), 1;
000965  001169  // Syntax: gfx_332to565(colour);
000966  001170  // Usage : gfx_332to565(arg);
000967  001171  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
000968  001172        
000969  001173  func gfx_Selection("index", "backcolor", "textcolor"), 0;
000970  001174  // Syntax: gfx_Selection("index", "backcolor", "textcolor"), 0;
000971  001175  // Usage : gfx_Selection(1, RED, YELLOW);
000972  001176  // Notes : Called prior to drawing a button, this function
000973  001177  //       : hilites the required text line on a multiline button.
000974  001178        
000975  001179  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
000976  001180  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
000977  001181  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000978  001182  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000979  001183  //       : Vertices must be specified in an anti-clockwise fashion
000980  001184        
000981  001185        
000982  001186  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
000983  001187  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
000984  001188  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
000985  001189  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000986  001190  //       : Vertices must be minimum of 3 and can be specified in any fashion
000987  001191        
000988  001192        
000989  001193  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
000990  001194  // Syntax: gfx_Offset(x, y);
000991  001195  // Usage : gfx_Offset(arg1, arg2);
000992  001196  // Notes : Set the screen offset
000993  001197        
000994  001198        
000995  001199        
000996  001200  func gfx_Get("mode"), 1;
000997  001201  // Syntax: gfx_Get(mode);
000998  001202  // Usage : arg1 := gfx_Get(arg);
000999  001203  // Notes : Returns various parameters to caller
001000  001204  //       :
001001  001205  //       : mode = X_MAX (mode 0) : current orientations maximum X value
001002  001206  //       : var := gfx_Get(X_MAX);
001003  001207  //       : Returns the maximum horizontal value of the display
001004  001208  //       :
001005  001209  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
001006  001210  //       : var := gfx_Get(Y_MAX);
001007  001211  //       : Returns the maximum vertical value of the display
001008  001212  //       :
001009  001213  //       : mode = LEFT_POS (mode 2) : Left location of last Object
001010  001214  //       : var := gfx_Get(LEFT_POS);
001011  001215  //       : Returns the left location of the last drawn object
001012  001216  //       : such as a slider or button or an image/video
001013  001217  //       :
001014  001218  //       : mode = TOP_POS (mode 3) : Top location of Object
001015  001219  //       : var := gfx_Get(TOP_POS);
001016  001220  //       : Returns the top location of the last drawn object
001017  001221  //       : such as a slider or button or an image/video
001018  001222  //       :
001019  001223  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
001020  001224  //       : var := gfx_Get(RIGHT_POS);
001021  001225  //       : Returns the right location of the last drawn object
001022  001226  //       : such as a slider or button or an image/video
001023  001227  //       :
001024  001228  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
001025  001229  //       : var := gfx_Get(BOTTOM_POS );
001026  001230  //       : Returns the bottom location of the last drawn object
001027  001231  //       : such as a slider or button or an image/video
001028  001232  //       :
001029  001233        
001030  001234        
001031  001235  //==================================================//
001032  001236  // Single parameter short-cuts                      //
001033  001237  // for the gfx_Set functions                        //
001034  001238  // These functions return the existing value before //
001035  001239  // the change is made.                              //
001036  001240  //==================================================//
001037  001241  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
001038  001242  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
001039  001243  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
001040  001244  func gfx_Clipping("mode"), 0;                       // 3  graphics clipping ON/OFF
001041  001245  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
001042  001246  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
001043  001247  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
001044  001248  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
001045  001249  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
001046  001250  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
001047  001251  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
001048  001252  func gfx_ColourMode("mode"), 1;                     // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
001049  001253  func gfx_BevelWidth("mode"), 1;                     // 12 graphics button bevel width
001050  001254  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
001051  001255  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
001052  001256  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
001053  001257        
001054  001258        
001055  001259  //==================================================//
001056  001260  // uSD/FLASH Function Prototypes                    //
001057  001261  //==================================================//
001058  001262  func media_Video("x", "y"), 0;                      // display movie at position x y
001059  001263  // Syntax: media_Video(x, y);
001060  001264  // Usage : media_Video(arg1, arg2);
001061  001265  // Notes : Play a Video/Animation clip from the uSD card at screen location
001062  001266  //       : specified by x,y (top left corner). The location of the clip in the
001063  001267  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
001064  001268        
001065  001269  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
001066  001270  // Syntax: media_VideoFrame(Frame_number);
001067  001271  // Usage : arg1 := media_VideoFrame();
001068  001272  // Notes : After a pointer to a valid video has been set with media_SetSector,
001069  001273  //       : calling this function shows each fram sequentially, returning
001070  001274  //       : the number of frames remaining. The position of the image is
001071  001275  //     : at the current origin as set with gfx_MoveTo(...);
001072  001276        
001073  001277  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
001074  001278  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
001075  001279  // Usage : media_SetAdd(arg1, arg2);
001076  001280  // Notes : Set uSD internal Address pointer for bytewise access
001077  001281        
001078  001282  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
001079  001283  // Syntax: media_SetSector(SectHiWord, SectLoWord);
001080  001284  // Usage : media_SetSector(arg1, arg2);
001081  001285  // Notes : Set uSD internal Sector pointer for sector block access
001082  001286        
001083  001287  func media_RdSector("*destination"), 1;
001084  001288  // Syntax: media_RdSector(*destination);
001085  001289  // Usage : media_RdSector(rdblock);
001086  001290  // Notes : Reads and Returns 512 bytes (256 words) into a destination
001087  001291  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
001088  001292  //       : After the read the Sector pointer is automatically incremented by 1.
001089  001293  //       : Returns TRUE if uSD response was TRUE
001090  001294        
001091  001295  func media_WrSector("*source"), 1;
001092  001296  // Syntax: media_WrSector(*source);
001093  001297  // Usage : media_WrSector(wrblock);
001094  001298  // Notes : Writes 512 bytes (256 words) from a source memory block
001095  001299  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
001096  001300  //       : pointer is automatically incremented by 1.
001097  001301  //       : Returns TRUE if uSD response was TRUE
001098  001302        
001099  001303  func media_ReadByte(), 1;                // read a byte at the current stream position
001100  001304  // Syntax: media_RdByte();
001101  001305  // Usage : var := media_RdByte();
001102  001306  // Notes : Reads and Returns a single byte of data from the
001103  001307  //       : uSD card pointed to by the internal Address pointer.
001104  001308  //       : After the read the Address pointer is automatically
001105  001309  //       : incremented by 1.
001106  001310        
001107  001311  func media_ReadWord(), 1;                // read a word at the current stream position
001108  001312  // Syntax: media_ReadWord();
001109  001313  // Usage : var := media_ReadWord();
001110  001314  // *Notes : Reads and Returns a single word of data from the
001111  001315  //       : uSD card pointed to by the internal Address pointer.
001112  001316  //       : After the read the Address pointer is automatically
001113  001317  //       : incremented by 2.
001114  001318        
001115  001319  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
001116  001320  // Syntax: media_WriteByte(arg1);
001117  001321  // Usage : var := media_WriteByte(arg1);
001118  001322  // *Notes : Writes and Returns xxxxx
001119  001323  //       : After the write the Address pointer is automatically
001120  001324  //       : incremented by 1.
001121  001325        
001122  001326  func media_WriteWord("word"), 1;            // write a word to the current stream position
001123  001327  // Syntax: media_WriteWord(arg1);
001124  001328  // Usage : var := media_WriteWord(arg1);
001125  001329  // *Notes : Writes and Returns xxxxx
001126  001330  //       : After the write the Address pointer is automatically
001127  001331  //       : incremented by 2.
001128  001332        
001129  001333  func media_Image("x", "y"), 0;            // display image at position x y
001130  001334  // Syntax: media_Image(x, y);
001131  001335  // Usage : media_Image(arg1, arg2);
001132  001336  // Notes : Display an image from the uSD card at screen location
001133  001337  //       : specified by x,y (top left corner). The location of the
001134  001338  //       : Image in the uSD card must be specified by
001135  001339  //       : media_setSector(Image_Sector_Add) function.
001136  001340        
001137  001341  func media_Flush(), 1;                    // after writing to media, flush the sector and write
001138  001342  // Syntax: media_Flush();
001139  001343  // Usage : var := media_Flush();
001140  001344  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
001141  001345  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
001142  001346        
001143  001347  func media_Init(), 1;                    // initialize uSD card
001144  001348  // Usage : media_Init();
001145  001349  // Notes : Initialise uSD CARD
001146  001350  //       : Response: 0 = No Card
001147  001351  //       :           1 = Card Initialised
001148  001352        
001149  001353        
001150  001354  //==============================================//
001151  001355  // Communications Function Prototypes           //
001152  001356  //==============================================//
001153  001357  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
001154  001358  // Syntax: com_Init(buffer, bufsize, qualifier);
001155  001359  // Usage1: com_Init(mybuf, 20, 0);
001156  001360  // Usage2: com_Init(mybuf, 20, ':');
001157  001361  // Notes : initialize a serial capture buffer for the comms input
001158  001362  //       : The program must declare a var array as a circular buffer.
001159  001363  //       : Usage1 declares a circular buffer which will continually
001160  001364  //       : buffer characters.
001161  001365  //       : Usage2 must receive ':' before any characters will
001162  001366  //       : accumulate in the buffer.
001163  001367        
001164  001368  func com_Reset(), 0;                 // reset the comms receiver
001165  001369  // Syntax: com_Reset();
001166  001370  // Usage : com_Reset();
001167  001371  // Notes : reset comms to default polled mode
001168  001372        
001169  001373  func com_Count(), 1;                // return count of characters in receive buffer
001170  001374  // Syntax: com_Count();
001171  001375  // Usage : arg := com_Count();
001172  001376  // Notes : return count of buffered characters in buffer attachment
001173  001377        
001174  001378  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
001175  001379  // Syntax: com_Full();
001176  001380  // Usage : if (com_Full() ,,,, go read buffer;
001177  001381  // Notes : return true if buffer full (not necessarily an error if
001178  001382  //       : buffer is sized to a packet size)
001179  001383        
001180  001384  func com_Error(), 1;                // return comms errors comms error occurred
001181  001385  // Syntax: com_Error();
001182  001386  // Usage : if (com_Error() ) ...... take recovery action;
001183  001387  // Notes : return non zero if any errors low level comms errors occured
001184  001388  // returns :
001185  001389  // bit0 = Receiver Overflow Error
001186  001390  // bit1 = Receiver Framing Error
001187  001391  // bit2 = Transmit Buffer Overflow
001188  001392        
001189  001393  func com_Sync(), 1;                // returns TRUE if qualifier has been received
001190  001394  // Syntax: com_Sync();
001191  001395  // Usage : com_Sync();
001192  001396  // return true if sync character has been received in com_Init("...") mode
001193  001397        
001194  001398        
001195  001399  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001196  001400  // Syntax: com_TXbuffer("buf", "bufsize", "pin");
001197  001401  // Usage : com_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001198  001402  // Usage : com_TXbuffer(0, 0, 0);              // revert to non buffered service
001199  001403  // Notes : initialize a serial buffer for the COM0 output.
001200  001404  //       : The program must declare a var array as a circular buffer.
001201  001405  //       : When a TX buffer is declared for comms, the transmission
001202  001406  //       : of characters becomes non blocking. The only time
001203  001407  //       : blocking will occur is if the buffer has insufficient space
001204  001408  //       : to accept the next character, in which case the function
001205  001409  //       : will wait for buffer space to become available. If the
001206  001410  //       : TX buffer is no longer required, just set the buffer pointer
001207  001411  //       : to zero, the size in this case doesnt matter and is ignored.
001208  001412  //       : The function can resize or reallocated to another buffer at
001209  001413  //       : any time. The buffer is flushed before any changes are made.
001210  001414  //       : "pin" designates an IO pin to control a bi-directional 
001211  001415  //       : control device for half duplex mode. "pin" will go HI at the
001212  001416  //       : start of a transmission, and will return low after the final
001213  001417  //       : byte is transmitted. If not required, just set "pin" to zero.
001214  001418        
001215  001419        
001216  001420  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
001217  001421  // Syntax: com_TXcount();
001218  001422  // Usage : arg := com_Count();
001219  001423  // Notes : return count of characters remaining in COM0 transmit buffer
001220  001424  //       : that was previously allocated with com_TXbuffer(...);
001221  001425        
001222  001426        
001223  001427  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
001224  001428  // Syntax: com_TXemptyEvent(function);
001225  001429  // Usage : arg := com_TXemptyEvent();
001226  001430  // Notes : If a comms TX buffer that was previously allocated with
001227  001431  //       : com_TXbuffer(...);, this function can be used to set up
001228  001432  //       : a function to be called when the COM0 TX buffer is empty.
001229  001433  //       : This is useful for either reloading the TX buffer, setting
001230  001434  //       : or clearing a pin to change the direction of eg a RS485
001231  001435  //       : line driver, or any other form of traffic control.
001232  001436  //       : The event function must not have any parameters.
001233  001437  //       : To disable the event, simply call com_TXemptyEvent(0).
001234  001438  //       : com_TXbuffer(...); also resets any active event.
001235  001439  //       : com_TXemptyEvent returns any previous event function
001236  001440  //       : address, or zero if there was no previous function.
001237  001441        
001238  001442        
001239  001443  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
001240  001444  // Usage : arg := com_TXbufferHold(ON);  // hold the buffer while we fill it
001241  001445  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
001242  001446  // Notes : Expecting that a comms TX buffer that was previously allocated with
001243  001447  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
001244  001448  //       : the buffer being sent wile it is being loaded. Mormally, when
001245  001449  //       : using buffered comms, the transmit process will begin
001246  001450  //       : immediately. This is often undesirable for 2 reasons,
001247  001451  //       : 1] you may wish to build a packet then send it later
001248  001452  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001249  001453  //       : as the FIFO buffer is constantly trying to empty while
001250  001454  //       : you are busy tring to fill it.
001251  001455  // return -1 if function is called illegally when TX comms is not buffered.
001252  001456  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
001253  001457  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
001254  001458        
001255  001459        
001256  001460  //=============================================================//
001257  001461  // Auxilliary Communications Function Prototypes
001258  001462  //=============================================================//
001259  001463  func com1_Init("buffer", "bufsize", "qualifier"), 0;
001260  001464  // Syntax: com_Init(buffer, bufsize, qualifier);
001261  001465  // Usage1: com_Init(mybuf, 20, 0);
001262  001466  // Usage2: com_Init(mybuf, 20, ':');
001263  001467  // Notes : initialize a serial capture buffer for the comms input
001264  001468  //       : The program must declare a var array as a circular buffer.
001265  001469  //       : Usage1 declares a circular buffer which will continually
001266  001470  //       : buffer characters.
001267  001471  //       : Usage2 must receive ':' before any characters will
001268  001472  //       : accumulate in the buffer.
001269  001473        
001270  001474  func com1_Reset(), 0;
001271  001475  // Syntax: com_Reset();
001272  001476  // Usage : com_Reset();
001273  001477  // Notes : reset comms receiver to default polled mode
001274  001478        
001275  001479  func com1_Count(), 1;
001276  001480  // Syntax: com_Count();
001277  001481  // Usage : arg := com_Count();
001278  001482  // Notes : return count of characters in receive buffer
001279  001483        
001280  001484  func com1_Full(), 1;
001281  001485  // Syntax: com_Full();
001282  001486  // Usage : if (com_Full() ,,,, go read buffer;
001283  001487  // Notes : return true if receive buffer full
001284  001488        
001285  001489  func com1_Error(), 1;
001286  001490  // Syntax: com_Error();
001287  001491  // Usage : if (com_Error() ) ...... take recovery action;
001288  001492  // Notes : return non zero if any level comms errors occured
001289  001493  // returns :
001290  001494  // bit0 = Receiver Overflow Error
001291  001495  // bit1 = Receiver Framing Error
001292  001496  // bit2 = Transmit Buffer Overflow
001293  001497        
001294  001498  func com1_Sync(), 1;
001295  001499  // Syntax: com_Sync();
001296  001500  // Usage : com_Sync();
001297  001501  // Notes : return true if sync character has been received in com_Init("...") mode
001298  001502        
001299  001503        
001300  001504  func com1_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001301  001505  // Syntax: com1_TXbuffer("buf", "bufsize", "pin");
001302  001506  // Usage : com1_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001303  001507  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
001304  001508  // Notes : initialize a serial buffer for the COM1 output.
001305  001509  //       : The program must declare a var array as a circular buffer.
001306  001510  //       : When a TX buffer is declared for comms, the transmission
001307  001511  //       : of characters becomes non blocking. The only time
001308  001512  //       : blocking will occur is if the buffer has insufficient space
001309  001513  //       : to accept the next character, in which case the function
001310  001514  //       : will wait for buffer space to become available. If the
001311  001515  //       : TX buffer is no longer required, just set the buffer pointer
001312  001516  //       : to zero, the size in this case doesnt matter and is ignored.
001313  001517  //       : The function can resize or reallocated to another buffer at
001314  001518  //       : any time. The buffer is flushed before any changes are made.
001315  001519  //       : "pin" designates an IO pin to control a bi-directional 
001316  001520  //       : control device for half duplex mode. "pin" will go HI at the
001317  001521  //       : start of a transmission, and will return low after the final
001318  001522  //       : byte is transmitted. If not required, just set "pin" to zero.
001319  001523        
001320  001524        
001321  001525  func com1_TXcount(), 1;                // return count of characters in COM1 TX buffer
001322  001526  // Syntax: com1_TXcount();
001323  001527  // Usage : arg := com1_Count();
001324  001528  // Notes : return count of characters remaining in COM1 transmit buffer
001325  001529  //       : that was previously allocated with com1_TXbuffer(...);
001326  001530        
001327  001531        
001328  001532  func com1_TXemptyEvent("function"), 1;  // sets a function to be called when COM1 TX buffer empty
001329  001533  // Syntax: com1_TXemptyEvent(function);
001330  001534  // Usage : arg := com1_TXemptyEvent();
001331  001535  // Notes : If a comms TX buffer that was previously allocated with
001332  001536  //       : com1_TXbuffer(...);, this function can be used to set up
001333  001537  //       : a function to be called when the COM1 TX buffer is empty.
001334  001538  //       : This is useful for either reloading the TX buffer, setting
001335  001539  //       : or clearing a pin to change the direction of eg a RS485
001336  001540  //       : line driver, or any other form of traffic control.
001337  001541  //       : The event function must not have any parameters.
001338  001542  //       : To disable the event, simply call com1_TXemptyEvent(0).
001339  001543  //       : com1_TXbuffer(...); also resets any active event.
001340  001544  //       : com1_TXemptyEvent returns any previous event function
001341  001545  //       : address, or zero if there was no previous function.
001342  001546        
001343  001547        
001344  001548  func com1_TXbufferHold("state"), 1; // hold or release a com1_TXbuffer
001345  001549  // Usage : arg := com1_TXbufferHold(ON);  // hold the buffer while we fill it
001346  001550  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
001347  001551  // Notes : Expecting that a comms TX buffer that was previously allocated with
001348  001552  //       : com1_TXbuffer(...);, com1_TXbufferHold(ON) can be used to stop
001349  001553  //       : the buffer being sent wile it is being loaded. Mormally, when
001350  001554  //       : using buffered comms, the transmit process will begin
001351  001555  //       : immediately. This is often undesirable for 2 reasons,
001352  001556  //       : 1] you may wish to build a packet then send it later
001353  001557  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001354  001558  //       : as the FIFO buffer is constantly trying to empty while
001355  001559  //       : you are busy tring to fill it.
001356  001560  // return -1 if function is called illegally when TX comms is not buffered.
001357  001561  // return buffer count when called with argument of 1, eg com1_TXbufferHold(ON)
001358  001562  // return 0 when argument is zero, eg com1_TXbufferHold(OFF)
001359  001563        
001360  001564  func serin1(), 1;
001361  001565  // Syntax: serin1();
001362  001566  // Usage : char := serin1();
001363  001567  // Notes : return the next available character from COM1
001364  001568        
001365  001569  func serout1("char"), 0;
001366  001570  // Syntax: serout1("char");
001367  001571  // Usage : serout1(ch);
001368  001572  // Notes : send character to COM1
001369  001573        
001370  001574  func com_SetBaud("comport","baudrate/10"), 1;
001371  001575  // Syntax: com_SetBaud("comport","baudrate/10");
001372  001576  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
001373  001577  // Notes : sets to any viable baud rate from 160 to 655350
001374  001578  // return true if baud rate was acceptable
001375  001579        
001376  001580        
001377  001581        
001378  001582  //==============================================//
001379  001583  // Display Access                               //
001380  001584  //==============================================//
001381  001585  func disp_Init(), 0;                            // initialize display with required tables
001382  001586  // Syntax: disp_Init();
001383  001587  // Usage : disp_Init();
001384  001588  // Notes : Initialises or reinitialises the display.
001385  001589  //       : Normally used after restoration of peripheral power
001386  001590  //       : and after DeepSleep.
001387  001591        
001388  001592  func disp_SetReg("register", "data"), 0;
001389  001593  // Syntax: display_SetReg(register, data);
001390  001594  // Usage : display_SetReg(arg1, arg2);
001391  001595  // Notes : Sets uLCD specific display driver registers. Refer
001392  001596  //       : to appropriate display driver data sheet.
001393  001597        
001394  001598  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
001395  001599  // Syntax: disp_setGRAM(x1, y1, x2, y2);
001396  001600  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
001397  001601  // Notes : Prepares the GRAM area for user access.
001398  001602  //       : Data can now be written with disp_GRAM.
001399  001603  //       : GRAM will be set accordingly for the correct screen mode.
001400  001604  //       : the LO word of the 32 bit pixel count is returned. This is
001401  001605  //       : usually all that is needed unlse GRAM area exceeds 256^2
001402  001606  //       : A copy of the 32bit value can be found in
001403  001607  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
001404  001608        
001405  001609  func disp_WrGRAM("colour"), 0;
001406  001610  // Syntax: display_WrGRAM(colour);
001407  001611  // Usage : display_WrGRAM(arg);
001408  001612  // Notes : Data can be written to the GRAM consecutively using
001409  001613  //       : this function once the GRAM access window has been setup.
001410  001614        
001411  001615  func disp_WriteControl("value"), 0;             // write a control byte to the display
001412  001616  func disp_WriteWord("value"), 0;                // write a word to the display
001413  001617        
001414  001618        
001415  001619  func disp_ReadWord(), 1;                        // read a word from the display
001416  001620  // Syntax: disp_ReadWord();
001417  001621  // Usage : x:=disp_ReadWord();
001418  001622  // Notes : Read a word from the controller
001419  001623  // Eg:   : disp_WriteControl(0);         // select Ilitek ID register
001420  001624  //       : print(disp_ReadWord());        // print ID
001421  001625  //       : (Many displays are write only)
001422  001626        
001423  001627                                                  //
001424  001628  //==============================================//
001425  001629  // unadorned SPI functions                      //
001426  001630  //==============================================//
001427  001631  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
001428  001632  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
001429  001633  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
001430  001634  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
001431  001635                                                  //
001432  001636  //==============================================//
001433  001637  // flash device specific functions              //
001434  001638  //==============================================//
001435  001639  func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
001436  001640  func flash_ID(), 1;                             // read ID code from FLASH device
001437  001641  func flash_BulkErase(), 0;                      // erase the entire FLASH device
001438  001642  func flash_BlockErase("block"), 1;              // erase the required 64k flash block
001439  001643                                                  //
001440  001644                                                  //
001441  001645  //==============================================//
001442  001646  // string and character size function           //
001443  001647  //==============================================//
001444  001648  func charwidth("char"), 1;                      // return width of a character in pixel units
001445  001649  func charheight("char"), 1;                     // return height of a character in pixel units
001446  001650  func strwidth("pointer"), 1;                    // return width of a string in pixel units
001447  001651  func strheight(), 1;                            // return height of a string in pixel units
001448  001652        
001449  001653        
001450  001654  //------------------------------------------------------------------//
001451  001655  //        I2C Function Prototypes
001452  001656  //------------------------------------------------------------------//
001453  001657  func I2C_Open("speed"), 0;
001454  001658  // Syntax: I2C_Open(speed),
001455  001659  // Usage : I2C_Open(I2C_MED);
001456  001660  // Notes : configures the I2C module
001457  001661  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
001458  001662        
001459  001663  func I2C_Close(), 0;
001460  001664  // Syntax: I2C_Close();
001461  001665  // Usage : I2C_Close();
001462  001666  // Notes : disables the I2C1 module.
001463  001667        
001464  001668  func I2C_Start(), 1;
001465  001669  // Syntax: I2C_Start();
001466  001670  // Usage : I2C_Start();
001467  001671  // Notes : generates a Start condition.
001468  001672  //       : returns true if successful (usually ignored)
001469  001673        
001470  001674  func I2C_Stop(), 1;
001471  001675  // Syntax: I2C_Stop();
001472  001676  // Usage : I2C_Stop();
001473  001677  // Notes : generates a Stop condition.
001474  001678  //       : returns true if successful (usually ignored)
001475  001679        
001476  001680  func I2C_Restart(), 1;
001477  001681  // Syntax: I2C_Restart();
001478  001682  // Usage : I2C_Restart();
001479  001683  // Notes : generates a Restart condition.
001480  001684  //       : returns true if successful (usually ignored)
001481  001685        
001482  001686  func I2C_Read(), 1;
001483  001687  // Syntax: I2C_Read();
001484  001688  // Usage : ch := I2C_Read();
001485  001689  // Notes : reads a single byte from the I2C Bus.
001486  001690        
001487  001691  func I2C_Write("byte"), 1;
001488  001692  // Syntax: I2C_Write(byte);
001489  001693  // Usage : r := I2C_Write(ch);
001490  001694  // Notes : is used to write a byte to the I2C bus.
001491  001695  //       : Returns 0 if failed, 1 if no ack, 2 if ack
001492  001696        
001493  001697  func I2C_Ack(), 0;
001494  001698  // Syntax: I2C_Ack();
001495  001699  // Usage : I2C_Ack();
001496  001700  // Notes : generates the acknowledge condition.
001497  001701        
001498  001702  func I2C_Nack(), 0;
001499  001703  // Syntax: I2C_Nack();
001500  001704  // Usage : I2C_Nack();
001501  001705  // Notes : generates the negative acknowledge condition.
001502  001706        
001503  001707  func I2C_AckStatus(), 0;
001504  001708  // Syntax: I2C_AckStatus();
001505  001709  // Usage : r := I2C_AckStatus();
001506  001710  // Notes : returns the ACK status from the device.
001507  001711        
001508  001712  func I2C_AckPoll("control"), 1;
001509  001713  // Syntax: I2C_AckPoll();
001510  001714  // Usage : r := I2C_AckPoll(0xA0);
001511  001715  // Notes : waits for a device to return from ACK polling.
001512  001716        
001513  001717  func I2C_Idle(), 0;
001514  001718  // Syntax: I2C_Idle();
001515  001719  // Usage : I2C_Idle();
001516  001720  // Notes : waits until the I2C Bus is Inactive.
001517  001721        
001518  001722  func I2C_Gets("buffer", "size"), 1;
001519  001723  // Syntax: I2C_Gets("buffer", "size");
001520  001724  // Usage : r := I2C_Gets(mybuf, 16);
001521  001725  // Notes : only reads up to "size" characters into "buffer"
001522  001726  //       : Reads up to asciiz terminator including terminator
001523  001727        
001524  001728  func I2C_Getn("buffer", "size"), 1;
001525  001729  // Syntax: I2C_Gets("buffer", "size");
001526  001730  // Usage : r := I2C_Gets(mybuf, 16);
001527  001731  // Notes : reads "size" bytes into "buffer"
001528  001732  //       :
001529  001733        
001530  001734  func I2C_Puts("buffer"), 1;
001531  001735  // Syntax: I2C_Puts("buffer");
001532  001736  // Usage : r := I2C_Puts(mybuf);
001533  001737  // Notes : writes an asciiz string to the I2C device
001534  001738  //       : returns count of characters written
001535  001739        
001536  001740  func I2C_Putn("buffer", "count"), 1;
001537  001741  // Syntax: I2C_Putn("buffer","count");
001538  001742  // Usage : r := I2C_Puts(mybuf,10);
001539  001743  // Notes : writes up to "size" bytes to the I2C device
001540  001744  //       : returns number of bytes written
001541  001745        
001542  001746        
001543  001747  //------------------------------------------------------------------//
001544  001748  //        Image Control Function Prototypes
001545  001749  //------------------------------------------------------------------//
001546  001750  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
001547  001751  // Syntax: img_SetPosition(handle, index, xpos, ypos);
001548  001752  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
001549  001753  // Notes : set the position where the image will be displayed
001550  001754  //       : returns true if index was ok and function was successful.
001551  001755  //       : you may turn off an image so when img_Refresh is called,
001552  001756  //       : the image will not be shown
001553  001757        
001554  001758  func img_Enable("handle", "index"), 1;
001555  001759  // Syntax: img_Enable(handle, index);
001556  001760  // Usage : r := img_Enable(hImageList, imagenum);
001557  001761  // Notes : enable image in a image list
001558  001762  //       : returns true if index was ok and function was successful.
001559  001763  //       : this is the default state so when img_Refresh is called,
001560  001764  //       : all the images in the list will be shown
001561  001765  //       : if index is set to -1, all of the images are enabled
001562  001766        
001563  001767  func img_Disable("handle", "index"), 1;
001564  001768  // Syntax: img_Disable(handle, index);
001565  001769  // Usage : r := img_Disable(hImageList, imagenum);
001566  001770  // Notes : disable image in a image list
001567  001771  //       : returns true if index was ok and function was successful.
001568  001772  //       : you must turn off an image so when img_Refresh is called,
001569  001773  //       : the image will not be shown.
001570  001774  //       : if index is set to -1, all of the images are disabled
001571  001775        
001572  001776        
001573  001777  func img_Darken("handle", "index"), 1;
001574  001778  // Syntax: img_Darken(handle, index);
001575  001779  // Usage : r := img_Darken(hImageList, imagenum);
001576  001780  // Notes : darken image in a image list
001577  001781  //       : returns true if index was ok and function was successful.
001578  001782  //       : if index is set to -1, all of the images are darkened
001579  001783  //       : NB:- this feature will only work for the next refresh, then
001580  001784  //       : the image reverts back to normal when displayed again.
001581  001785        
001582  001786        
001583  001787  func img_Lighten("handle", "index"), 1;
001584  001788  // Syntax: img_Lighten(handle, index);
001585  001789  // Usage : r := img_Lighten(hImageList, imagenum);
001586  001790  // Notes : lighten image in a image list
001587  001791  //       : returns true if index was ok and function was successful.
001588  001792  //       : if index is set to -1, all of the images are lightened
001589  001793  //       : NB:- this feature will only work for the next refresh, then
001590  001794  //       : the image reverts back to normal when displayed again.
001591  001795        
001592  001796  func img_SetWord("handle", "index", "offset", "word"), 1;
001593  001797  // Syntax: img_SetWord(handle, index, offset, word);
001594  001798  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
001595  001799  // Notes : set specified word (0-7) in a image entry
001596  001800  //       : returns TRUE if successful, return value usually ignored.
001597  001801        
001598  001802  func img_GetWord("handle", "index", "offset"), 1;
001599  001803  // Syntax: myvar := img_GetWord("handle", "index", "offset");
001600  001804  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
001601  001805  // Notes : returns specified word (0-14) from an image entry
001602  001806  //       : refer to image control entry offsets.
001603  001807        
001604  001808  func img_Show("handle", "index"), 1;
001605  001809  // Syntax: img_Show(handle, index);
001606  001810  // Usage : display image entry (regardless of enable/disable)
001607  001811  //       : returns TRUE if successful, return value usually ignored.
001608  001812        
001609  001813  func img_SetAttributes("handle", "index","value"), 1;
001610  001814  // Syntax: img_SetAttributes("handle", "index","offset");
001611  001815  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
001612  001816  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
001613  001817  //       : of an image control entry. "value" refers to various bits in
001614  001818  //       : the image control entry (see image attribute flags).
001615  001819  //       : A '1' bit in the "value" field SETS the respective bit
001616  001820  //       : in the IMAGE_FLAGS field of the image control entry.
001617  001821  //       : returns TRUE if successful, return value usually ignored.
001618  001822        
001619  001823  func img_ClearAttributes("handle", "index","value"), 1;
001620  001824  // Syntax: img_ClearAttributes("handle", "index","offset");
001621  001825  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
001622  001826  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
001623  001827  //       : of an image control entry. "value" refers to various bits in
001624  001828  //       : the image control entry (see image attribute flags)
001625  001829  //       : a '1' bit in the "value" field CLEARS the respective bit
001626  001830  //       : in the IMAGE_FLAGS field of the image control entry.
001627  001831  //       : returns TRUE if successful, return value usually ignored.
001628  001832        
001629  001833  func img_Touched("handle", "index"), 1;
001630  001834  // Syntax: r := img_Touched(handle, index);
001631  001835  // Usage : img_Touched(hndl, 17);
001632  001836  //       : returns -1 if image not touched, or returns index
001633  001837  // Notes : if index is passed as -1, function tests all images,
001634  001838  //       : and returns -1 if image not touched, or returns index.
001635  001839        
001636  001840        
001637  001841        
001638  001842        
001639  001843  //------------------------------------------------------------------//
001640  001844  //        Timer Function Prototypes
001641  001845  //------------------------------------------------------------------//
001642  001846  func sys_T(), 1;
001643  001847  // Syntax: sys_T();
001644  001848  // Usage : t := sys_T();
001645  001849  // Notes : return the current value of the rolling system timer (1msec) LO word
001646  001850        
001647  001851  func sys_T_HI(), 1;
001648  001852  // Syntax: sys_T_HI();
001649  001853  // Usage : t := sys_T_HI();
001650  001854  // Notes : return the current value of the rolling system timer (1msec) HI word
001651  001855        
001652  001856  func sys_SetTimer("timernum","value"), 0;
001653  001857  // Syntax: sys_SetTimer("timernum", "value");
001654  001858  // Usage : sys_SetTimer(TIMER5, 10000);
001655  001859  // Notes : set a countdown on the selected timer, or 'top up' if required.
001656  001860  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001657  001861  //       : Maximum timeout period is 65.535 seconds
001658  001862  //       : A timer can be read with the sys_GetTimer("timernum") function
001659  001863        
001660  001864  func sys_GetTimer("timernum"), 1;
001661  001865  // Syntax: t := sys_GetTimer("timernum");
001662  001866  // Usage : t := sys_GetTimer(TIMER3);
001663  001867  // Notes : returns 0 if timer has expired, or the current countdown value.
001664  001868  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001665  001869  //       : Maximum timeout period is 65.535 seconds
001666  001870  //       : A timer must be set with the sys_SetTimer("timernum","value") function
001667  001871        
001668  001872  func sys_SetTimerEvent("timernum","function"), 1;
001669  001873  // Syntax: sys_SetTimerFunction("timernum", "function");
001670  001874  // Usage : sys_SetTimer(TIMER5, myfunc);
001671  001875  // Notes : set a function to be called for selected timer.
001672  001876  //       : When the timer reaches zero, the function is called.
001673  001877  //       : The called function must not have any parameters
001674  001878  //       : sys_SetTimerEvent returns any previous event function
001675  001879  //       : address, or zero if there was no previous function.
001676  001880        
001677  001881  func sys_EventQueue(), 1;
001678  001882  // Syntax: sys_EventQueue();
001679  001883  // Usage : tasks := sys_EventQueue();
001680  001884  // Notes : returns the max number of events that were pending
001681  001885  //       : in the timer queue since the last call to this function.
001682  001886  //       : This can be used to assess timer event overhead burden,
001683  001887  //       : especially after or during a sys_EventsPostpone action.
001684  001888        
001685  001889  func sys_EventsPostpone(), 0;
001686  001890  // Syntax: sys_EventPostpone();
001687  001891  // Usage : sys_EventPostpone();   // postpone the event queue
001688  001892  // Notes : postpone any events until the sys_EventResume function is executed
001689  001893  //       : The timer event queue will continue to queue events, but no action
001690  001894  //       : will take place untill a sys_EventResume function is encountered.
001691  001895  //       : The queue will continue to receive up to 32 events before discarding
001692  001896  //       : any further events. This function is required to allow a sequence of
001693  001897  //       : instructions or functions to occur that would otherwise be corrupted
001694  001898  //       : by an event occuring during the sequence of instructions or functions.
001695  001899  //       : A good example of this is when you set a position to print, if there
001696  001900  //       : was no way of locking the current sequence, an event may occur which
001697  001901  //       : does a similar thing, and a contention would occur - printing to
001698  001902  //       : the wrong position. This function should be used wisely, if any action
001699  001903  //       : that is required would take considerable time, it is better to disable
001700  001904  //       : any conflicting event functions with a bypass flag, then restart the
001701  001905  //       : conflicting event by re-issuing a timer value.
001702  001906        
001703  001907  func sys_EventsResume(), 0;
001704  001908  // Syntax: sys_EventsResume();
001705  001909  // Usage : sys_EventsResume();   // resume the event queue
001706  001910  // Notes : resume any postponed events. The queue will try to execute any timer
001707  001911  //       : events that were incurred during the postponed period.
001708  001912        
001709  001913        
001710  001914  func sys_Sleep("units"), 1;
001711  001915  // Syntax: t := sys_Sleep("units");
001712  001916  // Usage : t := sys_Sleep(10);
001713  001917  // Notes : sets the display into low power mode for a period of time.
001714  001918  //       : Touching the touch screen will also wake from sleep.
001715  001919  //       : Returns remaining sleep units.
001716  001920        
001717  001921  func iterator("offset"), 0;
001718  001922  // Syntax: t :=  iterator("offset");
001719  001923  // Usage : t :=  iterator(10);
001720  001924  // Notes : set the iterator size for ++/--
001721  001925  //       : The next postinc,postdec,preinc of predec will alter
001722  001926  //       : by the specified value.
001723  001927  //       : The offset will return to 1 after the next operation.
001724  001928        
001725  001929        
001726  001930        
001727  001931        
001728  001932  //------------------------------------------------------------------//
001729  001933  //         Touch Screen Function Prototypes
001730  001934  //------------------------------------------------------------------//
001731  001935        
001732  001936  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
001733  001937  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
001734  001938  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
001735  001939  // Notes : Specifies a new touch detect region on the screen
001736  001940  //       : such that only touch activity in that region will
001737  001941  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
001738  001942        
001739  001943  func touch_Set("mode"), 0;
001740  001944  // Syntax: touch_Set(mode);
001741  001945  // Usage : touch_Set(arg);
001742  001946  // Notes : Sets various Touch Screen related parameters
001743  001947  //       :
001744  001948  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
001745  001949  //       : touch_Set(TOUCH_ENABLE);
001746  001950  //       : Enables and initialises Touch Screen hardware
001747  001951  //       :
001748  001952  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
001749  001953  //       : touch_Set(TOUCH_DISABLE );
001750  001954  //       : Disables the Touch Screen
001751  001955  //       : Note: Touch Screen runs in the background and disabling
001752  001956  //       : it when not in use will free up extra resources
001753  001957  //       : such as 4DVM CPU cycles.
001754  001958  //       :
001755  001959  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
001756  001960  //       : touch_Set(TOUCH_REGIONDEFAULT);
001757  001961  //       : This will reset the current active region to default
001758  001962  //       : to the full screen without the application having to
001759  001963  //       : set a new active region for the full screen.
001760  001964  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
001761  001965  //       : that requre to be interfaced with an external pointing
001762  001966  //       : device, values that are poked into TOUCH_DRIVE will be
001763  001967  //       : read with the touch_Get() function)
001764  001968        
001765  001969        
001766  001970  func touch_Get("mode"), 1;
001767  001971  // Syntax: touch_Get(mode);
001768  001972  // Usage : arg1 := touch_Get(arg);
001769  001973  // Notes : Returns various Touch Screen parameters to caller
001770  001974  //       :
001771  001975  //       : mode = TOUCH_STATUS  (mode 0)
001772  001976  //       : var := touch_Get(TOUCH_STATUS);
001773  001977  //       : Returns the various states of the touch screen
001774  001978  //       : 0 = NOTOUCH
001775  001979  //       : 1 = TOUCH_PRESSED
001776  001980  //       : 2 = TOUCH_RELEASED
001777  001981  //       : 3 = TOUCH_MOVING
001778  001982  //       :
001779  001983  //       : mode = TOUCH_GETX   (mode 1)
001780  001984  //       : var := touch_Get(TOUCH_GETX);
001781  001985  //       : Returns the X coordinates of the touch
001782  001986  //       :
001783  001987  //       : mode = TOUCH_GETY   (mode 2)
001784  001988  //       : var := touch_Get(TOUCH_GETY);
001785  001989  //       : Returns the Y coordinates of the touch
001786  001990        
001787  001991  //------------------------------------------------------------------//
001788  001992  //        CTYPE Function Prototypes
001789  001993  //------------------------------------------------------------------//
001790  001994        
001791  001995  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
001792  001996  // Syntax: isdigit("char");
001793  001997  // Usage : Var := isdigit(ch);
001794  001998  // Notes : char specifies the ascii character for the test
001795  001999  //     : 0 : char is not an ascii digit.
001796  002000  //     : 1 : char is an ascii digit..
001797  002001  //     : Valid range is "0123456789"
001798  002002        
001799  002003  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
001800  002004  // Syntax: isxdigit("char");
001801  002005  // Usage : Var := isxdigit(ch);
001802  002006  // Notes : char specifies the ascii character for the test
001803  002007  //     : 0 : char is not an ascii hexadecimal digit.
001804  002008  //     : 1 : char is an ascii hexadecimal digit..
001805  002009  //     : Valid range is "0123456789ABCDEF"
001806  002010        
001807  002011  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
001808  002012  // Syntax: isupper("char");
001809  002013  // Usage : Var := isupper(ch);
001810  002014  // Notes : char specifies the ascii character for the test
001811  002015  //     : 0 : char is not an ascii upper-case letter.
001812  002016  //     : 1 : char is an ascii upper-case letter.
001813  002017  //     : Valid range is "ABCD....WXYZ"
001814  002018        
001815  002019  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
001816  002020  // Syntax: islower("char");
001817  002021  // Usage : Var := islower(ch);
001818  002022  // Notes : char specifies the ascii character for the test
001819  002023  //     : 0 : char is not an ascii lower-case letter.
001820  002024  //     : 1 : char is an ascii lower-case letter.
001821  002025  //     : Valid range is "abcd....wxyz"
001822  002026        
001823  002027  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
001824  002028  // Syntax: isalpha("char");
001825  002029  // Usage : Var := isalpha(ch);
001826  002030  // Notes : char specifies the ascii character for the test
001827  002031  //     : 0 : char is not an ascii lower or upper case letter.
001828  002032  //     : 1 : char is an ascii lower or upper case letter.
001829  002033  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
001830  002034        
001831  002035  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
001832  002036  // Syntax: isalnum("char");
001833  002037  // Usage : Var := isalnum(ch);
001834  002038  // Notes : char specifies the ascii character for the test
001835  002039  //     : 0 : char is not an ascii alphanumeric character.
001836  002040  //     : 1 : char is an ascii alphanumeric character.
001837  002041  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
001838  002042        
001839  002043  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
001840  002044  // Syntax: isprint("char");
001841  002045  // Usage : Var := isprint(ch);
001842  002046  // Notes : char specifies the ascii character for the test
001843  002047  //     : 0 : char is not a printable ascii character.
001844  002048  //     : 1 : char is a printable ascii character.
001845  002049  //     : Valid range is "0x20...0x7F"
001846  002050        
001847  002051  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
001848  002052  // Syntax: isspace("char");
001849  002053  // Usage : Var := isspace(ch);
001850  002054  // Notes : char specifies the ascii character for the test
001851  002055  //     : 0 : char is not a space type character.
001852  002056  //     : 1 : char is a space type character.
001853  002057  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
001854  002058        
001855  002059  //unformatted
001856  002060  func iswhite("char"), 1;    //
001857  002061  // Syntax: iswhite("char");
001858  002062  // Usage : Var := iswhite(ch);
001859  002063  // Notes : char specifies the ascii character for the test
001860  002064  //     : 0 : char is not a space or tab character.
001861  002065  //     : 1 : char is not a space or tab character.
001862  002066  //     : Valid range is space or tab
001863  002067        
001864  002068  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
001865  002069  // Syntax: toupper("char");
001866  002070  // Usage : Var := toupper(ch);
001867  002071  // Notes : char specifies the ascii character for the test
001868  002072  //     : "ABCD....XYZ" : if character is a lower case letter.
001869  002073  //     : char : if character is not a lower case letter.
001870  002074  //     : Valid range is "abcd....wxyz"
001871  002075        
001872  002076  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
001873  002077  // Syntax: tolower("char");
001874  002078  // Usage : Var := tolower(ch);
001875  002079  // Notes : char specifies the ascii character for the test
001876  002080  //     : "abcd....xyz" : if character is an upper case letter.
001877  002081  //     : char : if character is not an upper case letter.
001878  002082  //     : Valid range is "ABCD....WXYZ"
001879  002083        
001880  002084  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
001881  002085  // Syntax: LObyte(var);
001882  002086  // Usage : myVar := LObyte(myvar2);
001883  002087  // Notes : var specifies the user variable
001884  002088  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
001885  002089        
001886  002090  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
001887  002091  // Syntax: HIbyte(var);
001888  002092  // Usage : myVar := HIbyte(myvar2);
001889  002093  // Notes : var specifies the user variable
001890  002094  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
001891  002095        
001892  002096        
001893  002097  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
001894  002098  // Syntax: ByteSwap(var);
001895  002099  // Usage : myVar := ByteSwap(myvar2);
001896  002100  // Notes : var specifies the user variable
001897  002101  //     : Returns the endian swapped value of a 16 bit variable
001898  002102        
001899  002103        
001900  002104  //------------------------------------------------------------------//
001901  002105  //        Memory Allocation Function Prototypes
001902  002106  //------------------------------------------------------------------//
001903  002107        
001904  002108  func mem_Alloc("size"), 1;
001905  002109  // Syntax: mem_Alloc(bytesize);
001906  002110  // Usage : myvar := mem_Alloc(100);
001907  002111  // Notes : Allocate a block of memory to pointer myvar
001908  002112  //       : The allocated memory contains garbage but is a fast allocation.
001909  002113  //       : The block must later be released with mem_Free();
001910  002114  //       : returns 0 if function fails
001911  002115        
001912  002116  func mem_AllocV("size"), 1;
001913  002117  // Syntax: mem_AllocV(bytesize);
001914  002118  // Usage : myvar := mem_AllocV(100);
001915  002119  // Notes : Allocate a block of memory to pointer myvar
001916  002120  //       : The block of memory is filled with signature values
001917  002121  //       : the block starts with A5,5A then fills with incrementing
001918  002122  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
001919  002123  //       : This can be helpful when debugging
001920  002124  //       : The block must later be released with mem_Free();
001921  002125  //       : returns 0 if function fails
001922  002126        
001923  002127  func mem_AllocZ("size"), 1;
001924  002128  // Syntax: mem_AllocZ(bytesize);
001925  002129  // Usage : myvar := mem_AllocC(100);
001926  002130  // Notes : Allocate a zeroed block of memory to pointer myvar
001927  002131  //       : The block of memory is filled with zeroes
001928  002132  //       : The block must later be released with mem_Free();
001929  002133  //       : returns 0 if function fails
001930  002134        
001931  002135  func mem_Realloc("ptr", "size"), 1;
001932  002136  // Syntax: myvar := mem_Realloc("ptr", "size");
001933  002137  // Usage : myvar := mem_Realloc(ptr, size);
001934  002138  // Notes : The function may move the memory block to a new location,
001935  002139  //       : in which case the new location is returned.
001936  002140  //       : The content of the memory block is preserved up to the lesser
001937  002141  //       : of the new and old sizes, even if the block is moved.
001938  002142  //       : If the new size is larger, the value of the newly allocated
001939  002143  //       : portion is indeterminate. In case that ptr is NULL,
001940  002144  //       : the function behaves exactly as mem_Alloc, assigning a new block
001941  002145  //       : of size bytes and returning a pointer to the beginning of it.
001942  002146  //       : In case that the size is 0, the memory previously allocated in
001943  002147  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
001944  002148  //       : pointer is returned.
001945  002149        
001946  002150  func mem_Free("allocation"), 1;
001947  002151  // Syntax: myvar := mem_Free(allocation);
001948  002152  // Usage : myvar := mem_Free(myvar);
001949  002153  // Notes : De-allocate a block of memory previously created with
001950  002154  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
001951  002155  //       : returns 0 if function fails
001952  002156        
001953  002157  func mem_Heap(), 1;
001954  002158  // Syntax: myvar := mem_Heap();
001955  002159  // Usage : myvar := mem_Heap();
001956  002160  // Notes : returns bytecount available in heap
001957  002161  //       :
001958  002162        
001959  002163  func mem_Set("ptr","char","size"), 1;
001960  002164  // Syntax: mem_Set(ptr,char,bytesize);
001961  002165  // Usage : mem_Set(p, 'A', 100);
001962  002166  // Notes : fill a block of memory with a byte value
001963  002167  //       : returns ptr
001964  002168        
001965  002169  func mem_Copy("src", "dest", "bytecount"), 1;
001966  002170  // Syntax: myvar := mem_Copy(src, dest, bytesize);
001967  002171  // Usage : myvar := mem_Copy(p1, p2, 100);
001968  002172  // Notes : copy a word aligned block of memory from src to dest
001969  002173  //       : Note that count is a byte count, this facilitates
001970  002174  //       : copying word aligned byte arrays when using word
001971  002175  //       : aliggned packed strings.
001972  002176  //       : returns src
001973  002177        
001974  002178  func mem_Compare("ptr1","ptr2","count"), 1;
001975  002179  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
001976  002180  // Usage : myvar := mem_Compare(p1, p2, 100);
001977  002181  // Notes : compare blocks of memory at src, dest
001978  002182  //       : returns 0 if we have a match
001979  002183        
001980  002184  //------------------------------------------------------------------//
001981  002185  //        FAT16 Function Prototypes
001982  002186  //------------------------------------------------------------------//
001983  002187        
001984  002188  func file_Error(), 1;
001985  002189  // Syntax: myvar := file_Error();
001986  002190  // Usage : e := file_Error();
001987  002191  // Notes : return the most recent file error.
001988  002192  //       :
001989  002193        
001990  002194  func file_Count("filename"), 1;
001991  002195  // Syntax: count := file_Count("filename");
001992  002196  // Usage : count := file_Count("*.4dg");
001993  002197  // Notes : returns number of files found that match the criteria
001994  002198        
001995  002199  func file_Dir("filename"), 1;
001996  002200  // Syntax: count := file_Dir("filename");
001997  002201  // Usage : count := file_Dir("*.4dg");
001998  002202  // Notes : streams a string of filenames that agree with the search key
001999  002203  //       : returns number of files found that match the criteria
002000  002204        
002001  002205  func file_FindFirst("fname"), 1;
002002  002206  // Syntax: res := file_FindFirst("fname");
002003  002207  // Usage : if (file_FindFirst("*.4xe") ....
002004  002208  // Notes : returns true if at least 1 file exists
002005  002209  //       : that satisfies the file argument.
002006  002210  //       : Wildcards are usually used so if
002007  002211  //       : file_FindFirst returns true, further
002008  002212  //       : tests can be made using file_FindNext();
002009  002213  //       : to find all the files that match the
002010  002214  //       : wildcard class. Note that the stream behaviour
002011  002215  //       : is the same as file_Dir.
002012  002216  //       :
002013  002217        
002014  002218  func file_FindNext(), 1;
002015  002219  // Syntax: res := file_FindNext();
002016  002220  // Usage : while ((file_FindNext()) ....
002017  002221  // Notes : returns true if more file exists
002018  002222  //       : that satisfies the file argument
002019  002223  //       : that was given for  file_FindFirst.
002020  002224  //       : Wildcards must be used for
002021  002225  //       : file_FindFirst, else this function will
002022  002226  //       : always return zero as the only occurence
002023  002227  //       : will have already been found.
002024  002228  //       : Note that the stream behaviour
002025  002229  //       : is the same as file_Dir.
002026  002230  //       :
002027  002231        
002028  002232  func file_Exists("fname"), 1;
002029  002233  // Syntax: res := file_Exists("fname"),
002030  002234  // Usage : if(file_Exists("myfile") ....
002031  002235  // Notes : returns true if file exists
002032  002236  //       :
002033  002237        
002034  002238  func file_Open("fname", "mode"), 1;
002035  002239  // Syntax: handle := file_Open("fname","mode"),
002036  002240  // Usage : handle := file_Open("myfile.txt", 'r');
002037  002241  // Notes : returns handle if file exists
002038  002242  //       :
002039  002243        
002040  002244  func file_Close("handle"), 1;
002041  002245  // Syntax: res := file_Close("handle");
002042  002246  // Usage : res := file_Close(hnd1);
002043  002247  // Notes : returns true if file closed ok
002044  002248  //       :
002045  002249        
002046  002250  func file_Read("*dest", "size", "handle"), 1;
002047  002251  // Syntax: res := file_Read("*dest", "size", "handle"),
002048  002252  // Usage : res := file_Read(memblock,20,hnd1);
002049  002253  // Notes : returns number of characters read
002050  002254  //       : if "dest" is zero, data is read direct to GRAM window
002051  002255  //       :
002052  002256        
002053  002257        
002054  002258  func file_Seek("handle", "HiWord", "LoWord"), 1;
002055  002259  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
002056  002260  // Usage : res := file_Seek(hSource, 0, 0x1234);
002057  002261  // Notes : set file position to 0x00001234 (byte position 4660)
002058  002262  //       : for the file handle so subsequent data may be read
002059  002263  //       : from that position onwards with file_GetC(...),
002060  002264  //       : file_GetW(...) or file_GetS(...), or an image
002061  002265  //       : can be displayed with file_Image(...)
002062  002266  // Notes : returns true if ok, usually ignored
002063  002267        
002064  002268  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
002065  002269  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
002066  002270  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
002067  002271  // Notes : set file seek position to 123000
002068  002272  //       : for the file handle so subsequent data may be read
002069  002273  //       : from that record position onwards with file_GetC(...),
002070  002274  //       : file_GetW(...) or file_GetS(...), or an image
002071  002275  //       : can be displayed with file_Image(...)
002072  002276  // Notes : returns true if ok, usually ignored
002073  002277        
002074  002278  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
002075  002279  // Syntax: file_Tell("handle", &HiWord, &LoWord);
002076  002280  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
002077  002281  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
002078  002282  //       : returns true if function succeeded
002079  002283        
002080  002284  func file_Write("*source", "size", "handle"), 1;
002081  002285  // Syntax: res := fwrite("*source", "size", "handle"),
002082  002286  // Usage : res := fwrite(memblock, 20, hnd1);
002083  002287  // Notes : returns number of bytes written
002084  002288  //       :
002085  002289        
002086  002290  func file_Size("handle", "&HiWord", "&LoWord"), 1;
002087  002291  // Syntax: file_Size("handle", &HiWord, &LoWord);
002088  002292  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
002089  002293  // Notes : Reads the 32 bit file size and stores it into 2 variables.
002090  002294  //       : returns true if function succeeded
002091  002295        
002092  002296  func file_Image("x", "y", "handle"), 1;
002093  002297  // Syntax: file_Image(x, y, handle);
002094  002298  // Usage : file_Image(10, 10, hnd1);
002095  002299  // Notes : Display an image from a file at the current file position.
002096  002300  //       : The image is displayed at x,y (with respect to top left corner).
002097  002301  //       : If there is more than 1 image in the file, it can be
002098  002302  //       : accessed with file_Seek(...)
002099  002303        
002100  002304  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
002101  002305  // Syntax: file_ScreenCapture(x, y, w, h, handle);
002102  002306  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
002103  002307  // Notes : Save a image from screen to file at the current file position.
002104  002308  //       : The image can later be displayed with file_Image(...);
002105  002309  //       : The file may be opened in append mode to accumulate multiple
002106  002310  //       : images. Later, the images can be accessed with file_Seek(...);
002107  002311  //       : Note that the image will be sector aligned.
002108  002312  //       : All image headers must start on a sector boundary.
002109  002313  //       : The image is saved from x, y (with respect to top left corner)
002110  002314  //       : and the capture area is determined by "width" and "height".
002111  002315  //       : returns 0 if function succeeded
002112  002316        
002113  002317  func file_PutC("char","handle"), 1;
002114  002318  // Syntax: file_PutC("char", "handle");
002115  002319  // Usage : file_PutC('x', hndl);
002116  002320  // Notes : returns true if function succeeded
002117  002321        
002118  002322  func file_GetC("handle"), 1;
002119  002323  // Syntax: file_GetC("handle");
002120  002324  // Usage : mychar := fgetC("handle");
002121  002325  // Notes : returns next char from file
002122  002326        
002123  002327  func file_PutW("word","handle"), 1;
002124  002328  // Syntax: file_PutW("word","handle");
002125  002329  // Usage : file_PutW(0x1234, hndl);
002126  002330  // Notes : returns true if function succeeded
002127  002331        
002128  002332  func file_GetW("handle"), 1;
002129  002333  // Syntax: file_GetW("handle");
002130  002334  // Usage : myword := fgetW("handle");
002131  002335  // Notes : returns next word in file
002132  002336        
002133  002337  func file_PutS("*source", "handle"), 1;
002134  002338  // Syntax: res := file_Puts("*source", "handle"),
002135  002339  // Usage : res := file_Puts(mystring, hnd1);
002136  002340  // Notes : returns number of characters written
002137  002341  //       :
002138  002342        
002139  002343  func file_GetS("*string", "size", "handle"), 1;
002140  002344  // Syntax: res := file_Gets("*string", "size", "handle");
002141  002345  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
002142  002346  // Notes : get a string from a file
002143  002347  //       : returns pointer to string or null if failed.
002144  002348  //       : file_GetS(...) automatically appends a null-terminator to the data read.
002145  002349  //       : NB:- only reads up to "size-1" characters into "string"
002146  002350  //       : file_GetS(...) will stop reading when any of the following conditions are true:
002147  002351  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
002148  002352  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
002149  002353  //       : C] It reaches the end of file
002150  002354  //       : D] A read error occurs.
002151  002355        
002152  002356        
002153  002357  func file_Erase("fname"), 1;
002154  002358  // Syntax: res := file_Erase("fname");
002155  002359  // Usage : res := file_Erase("myfile.txt");
002156  002360  // Notes : returns true if successful
002157  002361  //       :
002158  002362        
002159  002363  func file_Rewind("handle"), 1;
002160  002364  // Syntax: res := file_Rewind("handle");
002161  002365  // Usage : res := file_Rewind(hnd1);
002162  002366  // Notes : returns true if file rewound ok (usually ignored)
002163  002367  //       : resets the file pointer the the beginning of the open file.
002164  002368        
002165  002369  func file_LoadFunction("fname.4xe"), 1;
002166  002370  // Syntax: res := file_LoadFunction("fname.4fn");
002167  002371  // Usage : myfunc := file_LoadFunction(myfuncname);
002168  002372  // Notes : Load a function or program from disk and
002169  002373  //       : return a function pointer to the allocation.
002170  002374  //       : The function can then be invoked just like any other
002171  002375  //       : function would be called via a function pointer.
002172  002376  //       : Parameters may be passed to it in a conventional way.
002173  002377  //       : The function may be discarded at any time when no
002174  002378  //       : longer required, thus freeing its memory resources.
002175  002379  //       : The loaded function can be discarded with mem_Free(..)
002176  002380  //       : eg:
002177  002381  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
002178  002382  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
002179  002383  //       : then elsewhere in your program:-
002180  002384  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
002181  002385  //       : if(res == QUIT_APPLICATION) goto exitApp;
002182  002386  //       : Later in your program, when popupWindow is no longer
002183  002387  //       : required for the application:-
002184  002388  //       : res := mem_Free(popupWindow);
002185  002389  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
002186  002390  //       : The callers stack is shared by the loaded function,
002187  002391  //       : however any global variables in the loaded function
002188  002392  //       : are private to that function.
002189  002393  //
002190  002394        
002191  002395  func file_Run("fname.4xe", "arglistptr"), 1;
002192  002396  // Syntax: res := file_Run("fname.4xe","arglistptr");
002193  002397  // Usage : res := file_Run(fname, argptr);
002194  002398  // Notes : current program releases any allocated memory but
002195  002399  //       : retains the stack and global memory.
002196  002400  //       : If arglistptr is 0, no arguments are passed, else
002197  002401  //       : arglist points to an array, the first element being
002198  002402  //       : the number of elements in the array.
002199  002403  //       : func 'main' in the called program accepts
002200  002404  //       : the arguments, if any. THe arguments can only
002201  002405  //       : be passed by value, no pointers or references can be
002202  002406  //       : used as all memory is cleared before the file
002203  002407  //       : is loaded. Refer to file_Exec and file_LoadFunction
002204  002408  //       : for functions that can pass by reference.
002205  002409        
002206  002410  func file_Exec("fname.4xe", "arglistptr"), 1;
002207  002411  // Syntax: res := file_Exec("fname.4xe","arglistptr");
002208  002412  // Usage : res := file_Exec("fname.4xe","arglistptr");
002209  002413  // Notes : returns like a function, current program
002210  002414  //       : calling program is kept active and control returns to it.
002211  002415  //       : If arglistptr is 0, no arguments are passed, else
002212  002416  //       : arglist points to an array, the first element being
002213  002417  //       : the number of elements in the array.
002214  002418  //       : func 'main' in the called program accepts the arguments.
002215  002419  //       : This function is similar to file_LoadFunction(...), however,
002216  002420  //       : the function argument list is passed by pointer, and
002217  002421  //       : the memory consumed by the function is released as
002218  002422  //       : soon as the function completes.
002219  002423        
002220  002424  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
002221  002425  // Syntax: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
002222  002426  // Usage : hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
002223  002427  // Notes : Reads a control file to create an image list.
002224  002428  //       : Returns NULL if function fails.
002225  002429  //       : Returns a handle (pointer to the memory allocation) to the
002226  002430  //       : image control list that has been created.
002227  002431  //       : "fname1" is the control list filename "*.dat"
002228  002432  //       : "fname2" is the image filename "*.gci"
002229  002433        
002230  002434  // Notes : This function Calculates the size of a chunk of memory required for
002231  002435  //       : a image list and populates it from the image control file ("*.dat")
002232  002436  //       : therefore, when imagelist is no longer required, you must de-allocate
002233  002437  //       : the image list memory by using eg:- mem_Free(hImagelist);
002234  002438  //       : to restore the heap.
002235  002439  //       :
002236  002440  //       : mode 0:- it is assumed that there is a graphics file with the
002237  002441  //       : file extension "fname2.gci". In this case, the images have been stored
002238  002442  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
002239  002443  //       : "fname1.dat" file are saved in the image control so that the image control
002240  002444  //       : can open the file (*.gci) and us file_Seek to get to the position of the
002241  002445  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
002242  002446  //       : mode 0 builds the image control quickly as it only scans the *.dat file
002243  002447  //       : for the file offsets and save them in the relevant entries in the image control.
002244  002448  //       : The penalty is that images take longer to find when displayed due to file_Seek
002245  002449  //       : overheads.
002246  002450  //
002247  002451  //       : mode 1:- it is assumed that there is a graphics file with the
002248  002452  //       : file extension "fname2.gci". In this case, the images have been stored
002249  002453  //       : in a FAT16 file concurrently, and the offset of the images are saved
002250  002454  //       : in the image control so that image file (*.gci) can be mapped to directly.
002251  002455  //       : The absolute cluster/sector is mapped so file seek does not need to be called
002252  002456  //       : internally. This means that there is no seek time penalty, however, the
002253  002457  //       : image list takes a lot longer to build, as all the seeking is done at control
002254  002458  //       : build time.
002255  002459        
002256  002460  //       : mode 2:- the graphics file with the is placed in a partitioned area
002257  002461  //       : In this case, the images have been stored in a in a known raw area of the FAT16
002258  002462  //       : disk, and the absolute address of the images are saved in the DAT file
002259  002463  //       : This is the fastest operation of the image control as there is no seeking
002260  002464  //       : or other disk activity taking place.
002261  002465        
002262  002466  func file_Mount(), 1;
002263  002467  // Syntax: r := file_Mount();
002264  002468  // Usage : r := file_Mount();
002265  002469  // Notes : Create a control block for FAT16 and mount the File System
002266  002470        
002267  002471  func file_Unmount(), 0;
002268  002472  // Syntax: file_Unmount();
002269  002473  // Usage : file_Unmount();
002270  002474  // Notes : release any control block and buffers for FAT16
002271  002475  //       : and unmount the File System
002272  002476        
002273  002477  func file_PlayWAV("fname1"), 1;
002274  002478  // Syntax: file_PlayWAV("fname1");
002275  002479  // Usage : file_PlayWAV("ding.wav");
002276  002480  // Notes : Play a wave file with filename "fname1"
002277  002481  //       : This function automatically grabs a chunk
002278  002482  //       : of memory for a file buffer, and a wave
002279  002483  //       : buffer. The minimum memory requirement is
002280  002484  //       : about 580 bytes for the disk io service and
002281  002485  //       : a minimum wave buffer size of 1024. The siz
002282  002486  //       : of the wave buffer allocation
002283  002487  //       : can be increased by the snd_BufSize function.
002284  002488  //       : The default size 1024 bytes.
002285  002489  //       : NB the memory is only required during the
002286  002490  //       : duration of play, and is automatically
002287  002491  //       : released while not in use.
002288  002492  //       : See the Sound Class services for other associated controls.
002289  002493  //       : If there are no errors, returns number of blocks to play (1 to 32767)
002290  002494  //       : If errors occured, the folling is returned
002291  002495  //       : -7  : Insufficient memory available for WAV buffer and file
002292  002496  //       : -6  : cant play this rate
002293  002497  //       : -5  : no data chunk found in first rsector
002294  002498  //       : -4  : no format data
002295  002499  //       : -3  : no wave chunk signature
002296  002500  //       : -2  : bad wave file format
002297  002501  //       : -1  : file not found
002298  002502        
002299  002503        
002300  002504        
002301  002505  //------------------------------------------------------------------//
002302  002506  //        Sound Class Services
002303  002507  //------------------------------------------------------------------//
002304  002508        
002305  002509  func snd_Volume("var"), 0;
002306  002510  // Syntax: snd_Volume("var");
002307  002511  // Usage : snd_Volume(30);
002308  002512  // Notes : set sound playback volume.  Var must
002309  002513  //       : be in the range from 8 (min volume)
002310  002514  //       : to 127 (max volume). If var is less
002311  002515  //       : than 8 volume is set to 8, and if
002312  002516  //       : var > 127 it is set to 127.
002313  002517        
002314  002518  func snd_Pitch("pitch"), 1;
002315  002519  // func snd_Pitch("freq"), 1;
002316  002520  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
002317  002521  // Notes : sets the samples playback rate to a different frequency
002318  002522  //       : The minimum value is 4khz
002319  002523  //       : Setting the pitch to zero restores the original sample rate
002320  002524  //       : Return value is the samples original sample rate.
002321  002525        
002322  002526  func snd_BufSize("var"), 0;
002323  002527  // Syntax: snd_BufSize("var");
002324  002528  // Usage : snd_BufSize(2);
002325  002529  // Notes : specify the a memory chunk size for the wavefile buffer.
002326  002530  //       : default size 1024 bytes.
002327  002531  //       : 0 = 1024 bytes (default)
002328  002532  //       : 1 = 2048 bytes
002329  002533  //       : 2 = 4096 bytes
002330  002534  //       : 3 = 8192 bytes
002331  002535        
002332  002536  func snd_Stop(), 0;
002333  002537  // Syntax: snd_Stop();
002334  002538  // Usage : snd_Stop();
002335  002539  // Notes : stop any sound that is playing, releasing
002336  002540  //       : buffers and closes any open wav file.
002337  002541        
002338  002542  func snd_Pause(), 0;
002339  002543  // Syntax: snd_Pause();
002340  002544  // Usage : snd_Pause();
002341  002545  // Notes : pauses any sound that is playing, does nothing
002342  002546  //       : until sound is resumed with snd_Continue().
002343  002547  //       : The sample cam be terminated with snd_Stop.
002344  002548  //       : buffers and closes any open wav file.
002345  002549        
002346  002550  func snd_Continue(), 0;
002347  002551  // Syntax: snd_Continue();
002348  002552  // Usage : snd_Continue();
002349  002553  // Notes : resume any sound that is paused by snd_Pause.
002350  002554        
002351  002555  func snd_Playing(), 1;
002352  002556  // Syntax: snd_Playing();
002353  002557  // Usage : r := snd_Playing();
002354  002558  // Notes : returns 0 if sound has finished playing,
002355  002559  //       : else return number of 512 byte blocks to go.
002356  002560        
002357  002561        
002358  002562        
002359  002563  //------------------------------------------------------------------//
002360  002564  //        String Class Services
002361  002565  //------------------------------------------------------------------//
002362  002566        
002363  002567  func str_Ptr("&var"), 1;
002364  002568  // Syntax: str_Ptr(&var);
002365  002569  // Usage : p := str_Ptr(&var);
002366  002570  // Notes : return a byte pointer to a word region
002367  002571        
002368  002572  func str_GetD("&ptr", "&var"), 1;
002369  002573  // Syntax: str_GetD(&ptr, &var);
002370  002574  // Usage : ok := str_GetD(&ptr, &var);
002371  002575  // Notes : convert number in a string to DWORD ( myvar[2] )
002372  002576  //       : returns true if function succeeds, advancing ptr
002373  002577        
002374  002578  func str_GetW("&ptr", "&var"), 1;
002375  002579  // Syntax: str_GetW(&ptr, &var);
002376  002580  // Usage : ok := str_GetW(&ptr, &var);
002377  002581  // Notes : convert number in a string to WORD ( myvar )
002378  002582  //       : returns true if function succeeds, advancing ptr
002379  002583        
002380  002584  func str_GetHexW("&ptr", "&var"), 1;
002381  002585  // Syntax: str_GetHexW(&ptr, &var);
002382  002586  // Usage : ok := str_GetHexW(&ptr, &var);
002383  002587  // Notes : convert HEX number in a string to WORD ( myvar )
002384  002588  //       : returns true if function succeeds, advancing ptr
002385  002589        
002386  002590  func str_GetC("&ptr", "&var"), 1;
002387  002591  // Syntax: str_GetC(&ptr, &var);
002388  002592  // Usage : ok := str_GetC(&ptr, &var);
002389  002593  // Notes : get a valid ascii char in a string to WORD ( myvar )
002390  002594  //       : returns true if function succeeds, advancing ptr
002391  002595        
002392  002596  func str_GetByte("ptr"), 1;
002393  002597  // Syntax: str_GetByte(ptr);
002394  002598  // Usage : myvar := str_GetByte(ptr);
002395  002599  // Notes : get a byte to myvar
002396  002600  //       : returns value
002397  002601        
002398  002602  func str_GetWord("ptr"), 1;
002399  002603  // Syntax: GetWord(ptr);
002400  002604  // Usage : GetWord(ptr);
002401  002605  // Notes : get a word to myvar
002402  002606  //       : returns value
002403  002607        
002404  002608  func str_PutByte("ptr","val"), 0;
002405  002609  // Syntax: str_PutByte(ptr);
002406  002610  // Usage : myvar := str_PutByte(ptr);
002407  002611  // Notes : put a byte at ptr
002408  002612  //       : returns value
002409  002613        
002410  002614  func str_PutWord("ptr","val"), 0;
002411  002615  // Syntax: str_PutWord("ptr","val");
002412  002616  // Usage : str_PutWord(p,100);
002413  002617  // Notes : put word 100 at current pointer location
002414  002618  //       : returns value
002415  002619        
002416  002620  func str_Match("&ptr", "*str"), 1;
002417  002621  // Syntax: str_Match(&ptr, *str);
002418  002622  // Usage : r := str_Match(&p, "hello");
002419  002623  // Notes : Case sensitive match
002420  002624  //       : returns true if function succeded, andvancing pointer to position past
002421  002625  //       : the matched item. Note that any whitespace characters are skipped
002422  002626  //       : in the source string prior to the test.
002423  002627        
002424  002628  func str_MatchI("&ptr", "*str"), 1;
002425  002629  // Syntax: str_MatchI(&ptr, *str);
002426  002630  // Usage : r := str_MatchI(&p, "hello");
002427  002631  // Notes : Case insensitive match
002428  002632  //       : returns true if function succeded, andvancing pointer to position past
002429  002633  //       : the matched item. Note that any whitespace characters are skipped
002430  002634  //       : in the source string prior to the test.
002431  002635        
002432  002636  func str_Find("&ptr", "*str"), 1;
002433  002637  // Syntax: str_Find(&ptr, *str);
002434  002638  // Usage : n := str_Find(&p, "hello");
002435  002639  // Notes : given the address of a pointer to a source string as the
002436  002640  //       : first argument, and a pointer to a test string as the second
002437  002641  //       : argument, attempt to find the position of the matching string
002438  002642  //       : in the source string. The test is performed with case sensitivity.
002439  002643  //       : return 0 if not found, else returns the address of the first
002440  002644  //       : character of the match. NB:- The source pointer is not altered.
002441  002645        
002442  002646  func str_FindI("&ptr", "*str"), 1;
002443  002647  // Syntax: str_Find(&ptr, *str);
002444  002648  // Usage : n := str_Find(&p, "hello");
002445  002649  // Notes : given the address of a pointer to a source string as the
002446  002650  //       : first argument, and a pointer to a test string as the second
002447  002651  //       : argument, attempt to find the position of the matching string
002448  002652  //       : in the source string. The test is performed with no case
002449  002653  //       : sensitivity, eg upper and lower case chars are accepted.
002450  002654  //       : return 0 if not found, else returns the address of the first
002451  002655  //       : character of the match. NB:- The source pointer is not altered.
002452  002656        
002453  002657  func str_Length("ptr"), 1;
002454  002658  // Syntax: str_Length(ptr);
002455  002659  // Usage : len := str_Ptr(mystring);
002456  002660  // Notes : return the length of a byte aligned string excluding terminator
002457  002661        
002458  002662  func str_Printf("&ptr", "*format"), 1;
002459  002663  // Syntax: str_Printf("&ptr", "*format");
002460  002664  // Usage : r := str_Printf(&p, "%8s");
002461  002665  // Notes : refer to documentation
002462  002666  //       :
002463  002667        
002464  002668  func str_Cat("dest","src"), 1;
002465  002669  // Syntax: str_Append("&dest","&src");
002466  002670  // Usage : str_Append(&buf,"Hello");
002467  002671  // Notes : Appends a copy of the source string to the destination string.
002468  002672  //       : The terminating null character in destination is overwritten by
002469  002673  //       : the first character of source, and a new null-character is appended
002470  002674  //       : at the end of the new string formed by the concatenation of both in destination.
002471  002675  //       : returns destination.
002472  002676        
002473  002677  func str_CatN("dest","src","count"), 1;
002474  002678  // Syntax: str_Append("&dest","&src","count");
002475  002679  // Usage : str_Append(&buf,"Monday",3);
002476  002680  // Notes : Appends a copy of the source string to the destination string.
002477  002681  //       : The number of characters copied is limited by "count".
002478  002682  //       : The terminating null character in destination is overwritten by
002479  002683  //       : the first character of source, and a new null-character is appended
002480  002684  //       : at the end of the new string formed by the concatenation of both in destination.
002481  002685  //       : returns destination.
002482  002686        
002483  002687        
002484  002688  func sys_StoreTouchCalibration(), 1;
002485  002689  // Syntax: sys_StoreTouchCalibration();
002486  002690  // Usage : r := sys_StoreTouchCalibration();
002487  002691  // Notes : Store the touch calibration values in non-volatile memory.
002488  002692  //       : Returns true if the values have been accepted and stored,
002489  002693  //       : else returns false if write could not be performed, or
002490  002694  //       : touch calibration values are improbable.
002491  002695  //       : The values that are stored are obtained from:-
002492  002696  //     : TOUCH_XMINCAL             78  // touch calibration value
002493  002697  //     : TOUCH_YMINCAL             79  // touch calibration value
002494  002698  //       : TOUCH_XMAXCAL             80  // touch calibration value
002495  002699  //       : TOUCH_YMAXCAL             81  // touch calibration value
002496  002700  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
002497  002701  //       : This function is not supported on uVGA, Capicitive touch
002498  002702  //       : and 4.3" resistive touch modules.
002499  002703        
002500  002704        
002501  002705  func unicode_page("charbeg","charend","charoffset"), 1;
002502  002706  // Syntax: unicode_page("charbeg","charend","charoffset");
002503  002707  // Usage : eg:  F_Traditional_0x20_0xFF
002504  002708  // Notes : After selecting a unicode image control with txt_FontID,
002505  002709  //       : this function is called to set the required font within the
002506  002710  //       : unicode set. The file "Unicode.inc" contains wrappers for
002507  002711  //       : this function, and it is not normally called directly.
002508  002712  //       : Returns count of characters in the set.
002509  002713  //       : Refer to "Unicode.inc" for further information.
002510  002714        
002511  002715        
002512  002716  func EVE_SP(), 1;
002513  002717  // Syntax: EVE_SP();
002514  002718  // Usage : eg:  print(EVE_SP());
002515  002719  // Notes : Used for debugging to assess the current stack level,
002516  002720  //       : mainly for checking stack leaks
002517  002721        
002518  002722  func EVE_SSIZE(), 1;
002519  002723  // Syntax: EVE_SSIZE();
002520  002724  // Usage : eg:  print(EVE_SSIZE());
002521  002725  // Notes : Used to get the stack size,
002522  002726  //       : mainly for debugging purposes
002523  002727        
002524  002728        
002525  002729  // uVGAII extended functions
002526  002730  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
002527  002731  // Syntax: disp_Sync(line);
002528  002732  // Usage : disp_Sync(480);
002529  002733  // Notes : Waits till the hardware gets to a certain line.
002530  002734  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
002531  002735  //       : Some experimentation may be needed to find an optimum line for disp_Sync
002532  002736  //       : depending on the graphics operation. The higher the value, the slower
002533  002737  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
002534  002738  //       : within the vertical retrace period) where it will just 'hang up' stopping the
002535  002739  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
002536  002740  //       : be slowest (as its actually right at the end of the blanking period) and 508
002537  002741  //       : will cause a hangup situation as it is above the highes scanline value.
002538  002742  //       : Currently, this function is only supported on displays with SSD1963 driver.
002539  002743        
002540  002744        
002541  002745  // New functions added to PmmC v2.8
002542  002746  //================================================================
002543  002747  func CY(), 1;
002544  002748  // Syntax: CY();
002545  002749  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
002546  002750  //       : print(myvar," "CY(),"\n");           // carry = 1
002547  002751  // Notes : This function returns the carry status of an
002548  002752  // unsigned overflow from any 16 or 32bit additions or sutractions.
002549  002753  //================================================================
002550  002754        
002551  002755        
002552  002756  //================================================================
002553  002757  func str_ByteMove("src", "dest", "count"), 1;
002554  002758  // func str_ByteMove("src", "dest", "count"), 1;
002555  002759  // Syntax   : str_ByteMove(src, dest, bytecount);
002556  002760  // Input    : STR *source points to byte aligned source.
002557  002761  //          : STR *dest   points to byte aligned destination.
002558  002762  //          : VAR count   number of bytes to transfer.
002559  002763  // Usage    : nextpos := str_ByteMove(s, d, 100);
002560  002764  // Notes    : copy bytes from "src" to "dest", stopping only
002561  002765  //          : when "count" is exhausted.
002562  002766  //          : No terminator is appended, it is purely a
002563  002767  //          : byte copy, and any zeroes encountered will
002564  002768  //          : also be copied.
002565  002769  // Returns  : returns a pointer to the end of the destination
002566  002770  //          : (which is "dest" + "count")
002567  002771  //================================================================
002568  002772        
002569  002773        
002570  002774  //================================================================
002571  002775  func str_Copy("dest", "src"), 1;
002572  002776  // Syntax   : str_Copy(dest, src);
002573  002777  // Input    : STR *dest   points to byte aligned destination.
002574  002778  //          : STR *source points to byte aligned source.
002575  002779  // Usage    : nextplace := str_Copy(d, s);
002576  002780  // Notes    : copy a string from "src" to "dest", stopping only
002577  002781  //          : when the end of source string "src" is encountered
002578  002782  //          : (0x00 terminator).
002579  002783  //          : The terminator is always appended, even if "src" is
002580  002784  //          : an empty string.
002581  002785  // Returns  : returns a pointer to the 0x00 string terminator at
002582  002786  //          : end of "dest" (which is "dest" + str_Length(src); )
002583  002787  //================================================================
002584  002788        
002585  002789  //================================================================
002586  002790  func str_CopyN("dest", "src", "count"), 1;
002587  002791  // Syntax   : str_CopyN(dest, src, bytecount);
002588  002792  // Input    : STR *dest   points to byte aligned destination.
002589  002793  //          : STR *source points to byte aligned source.
002590  002794  //          : VAR count   max number of chars to copy.
002591  002795  // Usage    : nextplace := str_CopyN(d, s, 100);
002592  002796  // Notes    : copy a string from "src" to "dest", stopping only
002593  002797  //          : when "count" is exhausted, or end of source
002594  002798  //          : string "str" is encountered (0x00 string terminator).
002595  002799  //          : The terminator is always appended, even if
002596  002800  //          : "count" is zero, or "src" is a null string.
002597  002801  // Returns  : returns a pointer to the 0x00 string terminator
002598  002802  //          : (which is "dest" + whatever was copied)
002599  002803  //================================================================
002600  002804        
002601  002805  //================================================================
002602  002806  func umul_1616("&res32", "val1", "val2"), 1;
002603  002807  // Syntax   : umul_1616(&res32, varA, varB);
002604  002808  // Input    : DWORD *result   points to 32bit result register.
002605  002809  //          : VAR   val1  16bit register or constant
002606  002810  //          : VAR   val2  16bit register or constant
002607  002811  // Usage    : var res32[2];
002608  002812  //          : umul_1616(&res32, myvar, 50000);
002609  002813  // Notes    : performs an unsigned multiply of 2 x 16bit values
002610  002814  //          : placing the 32bit result in a 2 word array.
002611  002815  // Returns  : the pointer to the 32bit result.
002612  002816  //          : carry and overflow are not affected.
002613  002817  //================================================================
002614  002818        
002615  002819  //================================================================
002616  002820  func uadd_3232("&res32", "&val1", "&val2"), 1;
002617  002821  // Syntax   : cmp_3232(&res32, &varA, &varB);
002618  002822  // Input    : DWORD *res32 points to optional result (or zero for compare)
002619  002823  //          : DWORD *val1 points to 32bit augend
002620  002824  //          : DWORD *val2 points to 32bit addend
002621  002825  // Usage    : var res32[2];
002622  002826  //          : res := cmp_3232(res32, val1, val2);
002623  002827  // Notes    : performs an unsigned addition of 2 x 32bit values
002624  002828  //          : placing the 32bit result in a 2 word array.
002625  002829  // Returns  : returns 1 on 32bit unsigned overflow (carry).
002626  002830  //          ; carry flag is also set on 32bit unsigned overflow
002627  002831  //          ; and can be read with the CY() function.
002628  002832  //================================================================
002629  002833        
002630  002834  //================================================================
002631  002835  func usub_3232("&res32", "&val1", "&val2"), 1;
002632  002836  // Syntax   : cmp_3232(&res32, &varA, &varB);
002633  002837  // Input    : DWORD *res32 points to optional result (or zero for compare)
002634  002838  //          : DWORD *val1 points to first 32bit minuend
002635  002839  //          : DWORD *val2 points to 32bit subtrahend
002636  002840  // Usage    : var res32[2];
002637  002841  //          : res := cmp_3232(res32, val1, val2);
002638  002842  // Notes    : performs an unsigned subtraction of 2 x 32bit values
002639  002843  //          : placing the 32bit result in a 2 word array.
002640  002844  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
002641  002845  //          ; carry flag is also set on 32bit unsigned underflow
002642  002846  //          ; and can be read with the CY() function.
002643  002847  //================================================================
002644  002848        
002645  002849  //================================================================
002646  002850  func ucmp_3232("&val1", "&val2"), 1;
002647  002851  // Syntax   : cmp_3232(&varA, &varB);
002648  002852  // Input    : DWORD *val1 points to 32bit minuend
002649  002853  //          : DWORD *val2 points to 32bit sutrahend
002650  002854  // Usage    : res := cmp_3232(val1, val2);
002651  002855  // Notes    : performs an unsigned comparison of 2 x 32bit values.
002652  002856  //          : The result of the subtraction is returned.
002653  002857  // Returns  : 0  if equal
002654  002858  //          : 1  if val1 > val2
002655  002859  //          : -1 if val1 < val2
002656  002860  //          : This function does not affect the carry flag.
002657  002861  //================================================================
002658  002862        
002659  002863  func disp_Disconnect(), 0;                     // Disconnect display to ensure reduced power after disabling peripheral power. New in v3.8
002660  002864  // Syntax: disp_Disconnect();                  New in v3.8
002661  002865  // Usage : disp_Disconnect();
002662  002866  // Notes : Disconnects the display driver pins and/or reconfigures it to achieve
002663  002867  //       : its lowest possible power consumption. Use after disabling peripheral power
002664  002868  //       : to ensure the minimal power usage by the display.
002665  002869  //       : disp_Init() should be used to reinitialise the display.
002666  002870        
002667  002871  func reserved(), 0;                            
002668  002872        
002669  002873  func sys_DeepSleep("units"), 1;
002670  002874  // Syntax: t := sys_DeepSleep("units");       New in v3.8
002671  002875  // Usage : t := sys_DeepSleep(10);
002672  002876  // Notes : sets the display and processor into lowest power mode for a period of time.
002673  002877  //       : When returning from DeepSleep the display should be reinitialised
002674  002878  //       : with disp_Init().
002675  002879  //       : Touching the touch screen will also wake from sleep.
002676  002880  //       : Returns remaining sleep units.
002677  002881        
002678  002882  //------------------------------------------------------------------//
002679  002883  // CONSTANTS
002680  002884  //------------------------------------------------------------------//
002681  002885        
002682  002886  // generic constants
002683  002887  #CONST
002684  002896  #END
002685  002897        
002686  002898  //------------------------------------------------------------------------------
002687  002899  // Pin related constants
002688  002900  //------------------------------------------------------------------------------
002689  002901  #CONST
002690  002919  #END
002691  002920        
002692  002921  //------------------------------------------------------------------------------
002693  002922  //gfx_Set() related constants
002694  002923  //------------------------------------------------------------------------------
002695  002924  #CONST
002696  002941  #END
002697  002942        
002698  002943        
002699  002944  //gfx_Get() related constants
002700  002945  #CONST
002701  002954  #END
002702  002955        
002703  002956        
002704  002957        
002705  002958        
002706  002959  #CONST
002707  002972  #END
002708  002973        
002709  002974        
002710  002975  #CONST
002711  002998  #END
002712  002999        
002713  003000  //------------------------------------------------------------------------------
002714  003001  //txt_Set() related constants
002715  003002  //------------------------------------------------------------------------------
002716  003003  #CONST
002717  003022  #END
002718  003023        
002719  003024        
002720  003025        
002721  003026  //------------------------------------------------------------------------------
002722  003027  //txt_Set() related arguments
002723  003028  // NB:- FONT4 must be inherited if required,
002724  003029  // eg #inherit "FONT4.fnt"
002725  003030  //------------------------------------------------------------------------------
002726  003031  #CONST
002727  003043  #END
002728  003044        
002729  003045        
002730  003046        
002731  003047  //touch_Set() related constants
002732  003048  #CONST
002733  003052  #END
002734  003053        
002735  003054  //touch_Get() related constants
002736  003055  #CONST
002737  003063  #END
002738  003064        
002739  003065  // image control offset related constants
002740  003066  #CONST
002741  003073  #END
002742  003074        
002743  003075  // image attribute flags
002744  003076  // for img_SetAttributes(...) and img_ClearAttributes(...)
002745  003077  #CONST
002746  003091  #END
002747  003092        
002748  003093        
002749  003094  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
002750  003094  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
002751  003095        
002752  003096  // image control entry offsets
002753  003097  #CONST
002754  003112  #END
002755  003113        
002756  003114  #CONST
002757  003132  #END
002758  003133        
002759  003134        
002760  003135        
002761  003136        
002762  003137  #CONST
002763  003157  #END
002764  003158        
002765  003159        
002766  003160        
002767  003161  // timer control  related constants
002768  003162  #CONST
002769  003171  #END
002770  003172        
002771  003173  // I2C timing related constants
002772  003174  #CONST
002773  003178  #END
002774  003179        
002775  003180        
002776  003181  // spi_Init(...)  mode arguments
002777  003182  #CONST
002778  003192  #END
002779  003193        
002780  003194  //------------------------------------------------------------------------------
002781  003195  // system WORD variables accesible with peekW and pokeW or pointer access
002782  003196  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
002783  003197  // can also be accessed with peekW and pokeW
002784  003198  //------------------------------------------------------------------------------
002785  003199        
002786  003200  #CONST
002787  003294  #END
002788  003295        
002789  003296  //------------------------------------------------------------------------------
002790  003297  // FILEIO Error Code Constants
002791  003298  //------------------------------------------------------------------------------
002792  003299  #CONST
002793  003325  #END
002794  003326        
002795  003327  //==================================================================================================
002796  003328        
002797  003329        
002798  003330        
002799  000013      #ENDIF
002800  000014        
002801  000015        
002802  000016      #CONST
002803  000072      #END
002804  000073        
002805  000074        
002806  000075  //===========================================================================================
002807  000076        
002808  000077        
002809  000002        
002810  000003        
002811  000004  // generated 2022. 05. 22. 13:34:46
002812  000005        
002813  000006  #MODE RUNFLASH
002814  000007        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

002815  000008  #inherit "4DGL_16bitColours.fnc"
002816  000008  #inherit "4DGL_16bitColours.fnc"
002817  000004  */
002818  000005        
002819  000006        
002820  000007        
002821  000008  #CONST
002822  000149  #END
002823  000150        
002824  000009        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

002825  000010  #inherit "VisualConst.inc"
002826  000010  #inherit "VisualConst.inc"
002827  000001  // Line Patterns
002828  000002  #constant  LPCOARSE    0xF0F0
002829  000002  #constant  LPCOARSE    0xF0F0
002830  000003  #constant  LPMEDIUM    0x3333
002831  000003  #constant  LPMEDIUM    0x3333
002832  000004  #constant  LPFINE      0xAAAA
002833  000004  #constant  LPFINE      0xAAAA
002834  000005  #constant  LPDASHDOT   0x03CF
002835  000005  #constant  LPDASHDOT   0x03CF
002836  000006  #constant  LPDASHDOTDOT 0x0333
002837  000006  #constant  LPDASHDOTDOT 0x0333
002838  000007  #constant  LPSOLID     0x0000
002839  000007  #constant  LPSOLID     0x0000
002840  000011        
002841  000012        
file D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1Const.inc

002842  000013  #inherit "resp_box_1Const.inc"
002843  000013  #inherit "resp_box_1Const.inc"
002844  000001  // File generated 2022. 05. 22. 13:34:26
002845  000002  // Warning! This is a generated file, any manual changes will be
002846  000003  // lost during the next generation.
002847  000004        
002848  000005  #constant  Strings0Count    1
002849  000005  #constant  Strings0Count    1
002850  000006  #constant  Strings0Size     20
002851  000006  #constant  Strings0Size     20
002852  000007  #constant  Strings1Count    1
002853  000007  #constant  Strings1Count    1
002854  000008  #constant  Strings1Size     20
002855  000008  #constant  Strings1Size     20
002856  000009  #constant  Strings20Count    2
002857  000009  #constant  Strings20Count    2
002858  000010  #constant  Strings20Size     4
002859  000010  #constant  Strings20Size     4
002860  000011  #constant  Strings21Count    2
002861  000011  #constant  Strings21Count    2
002862  000012  #constant  Strings21Size     4
002863  000012  #constant  Strings21Size     4
002864  000013  #constant  Strings16Count    0
002865  000013  #constant  Strings16Count    0
002866  000014  #constant  Strings16Size     1
002867  000014  #constant  Strings16Size     1
002868  000015  #constant  Strings17Count    0
002869  000015  #constant  Strings17Count    0
002870  000016  #constant  Strings17Size     1
002871  000016  #constant  Strings17Size     1
002872  000017  #constant  Strings14Count    0
002873  000017  #constant  Strings14Count    0
002874  000018  #constant  Strings14Size     1
002875  000018  #constant  Strings14Size     1
002876  000019  #constant  Strings15Count    0
002877  000019  #constant  Strings15Count    0
002878  000020  #constant  Strings15Size     1
002879  000020  #constant  Strings15Size     1
002880  000021  #constant  Strings2Count    2
002881  000021  #constant  Strings2Count    2
002882  000022  #constant  Strings2Size     9
002883  000022  #constant  Strings2Size     9
002884  000023  #constant  Strings3Count    2
002885  000023  #constant  Strings3Count    2
002886  000024  #constant  Strings3Size     9
002887  000024  #constant  Strings3Size     9
002888  000025  #constant  Strings4Count    0
002889  000025  #constant  Strings4Count    0
002890  000026  #constant  Strings4Size     1
002891  000026  #constant  Strings4Size     1
002892  000027  #constant  Strings5Count    0
002893  000027  #constant  Strings5Count    0
002894  000028  #constant  Strings5Size     1
002895  000028  #constant  Strings5Size     1
002896  000029  #constant  Strings6Count    0
002897  000029  #constant  Strings6Count    0
002898  000030  #constant  Strings6Size     1
002899  000030  #constant  Strings6Size     1
002900  000031  #constant  Strings7Count    0
002901  000031  #constant  Strings7Count    0
002902  000032  #constant  Strings7Size     1
002903  000032  #constant  Strings7Size     1
002904  000033  #constant  Strings8Count    0
002905  000033  #constant  Strings8Count    0
002906  000034  #constant  Strings8Size     1
002907  000034  #constant  Strings8Size     1
002908  000035  #constant  Strings9Count    0
002909  000035  #constant  Strings9Count    0
002910  000036  #constant  Strings9Size     1
002911  000036  #constant  Strings9Size     1
002912  000037  #constant  Strings10Count    6
002913  000037  #constant  Strings10Count    6
002914  000038  #constant  Strings10Size     39
002915  000038  #constant  Strings10Size     39
002916  000039  #constant  Strings11Count    0
002917  000039  #constant  Strings11Count    0
002918  000040  #constant  Strings11Size     1
002919  000040  #constant  Strings11Size     1
002920  000041  #constant  Strings22Count    12
002921  000041  #constant  Strings22Count    12
002922  000042  #constant  Strings22Size     351
002923  000042  #constant  Strings22Size     351
002924  000043  #constant  Strings23Count    12
002925  000043  #constant  Strings23Count    12
002926  000044  #constant  Strings23Size     38
002927  000044  #constant  Strings23Size     38
002928  000045  #constant  Strings12Count    1
002929  000045  #constant  Strings12Count    1
002930  000046  #constant  Strings12Size     138
002931  000046  #constant  Strings12Size     138
002932  000047  #constant  Strings13Count    0
002933  000047  #constant  Strings13Count    0
002934  000048  #constant  Strings13Size     1
002935  000048  #constant  Strings13Size     1
002936  000049  #constant  Strings19Count    1
002937  000049  #constant  Strings19Count    1
002938  000050  #constant  Strings19Size     34
002939  000050  #constant  Strings19Size     34
002940  000051  #constant  Strings18Count    3
002941  000051  #constant  Strings18Count    3
002942  000052  #constant  Strings18Size     103
002943  000052  #constant  Strings18Size     103
002944  000055  #END
2945  0013
2946  0014
2947  0015
2948  0016
2949  0017
2950  0018
2951  0019
2952  001A
2953  001B
2954  001C
2955  001D
2956  001E
2957  001F
002958  000056        
002959  000057        
002960  000058  #constant  IFONT_OFFSET     24
002961  000058  #constant  IFONT_OFFSET     24
002962  000059  // object indexes into ImageControl
002963  000060  #CONST
002964  000144  #END
002965  000145        
002966  000146        
002967  000147  #constant  Strings0StartH   0x0
002968  000147  #constant  Strings0StartH   0x0
002969  000148  #constant  Strings0StartL   0x0
002970  000148  #constant  Strings0StartL   0x0
002971  000149  #constant  Strings1StartH   0x0
002972  000149  #constant  Strings1StartH   0x0
002973  000150  #constant  Strings1StartL   0x200
002974  000150  #constant  Strings1StartL   0x200
002975  000151  #constant  Strings20StartH   0x0
002976  000151  #constant  Strings20StartH   0x0
002977  000152  #constant  Strings20StartL   0x400
002978  000152  #constant  Strings20StartL   0x400
002979  000153  #constant  Strings21StartH   0x0
002980  000153  #constant  Strings21StartH   0x0
002981  000154  #constant  Strings21StartL   0x600
002982  000154  #constant  Strings21StartL   0x600
002983  000155  #constant  Strings16StartH   0x0
002984  000155  #constant  Strings16StartH   0x0
002985  000156  #constant  Strings16StartL   0x800
002986  000156  #constant  Strings16StartL   0x800
002987  000157  #constant  Strings17StartH   0x0
002988  000157  #constant  Strings17StartH   0x0
002989  000158  #constant  Strings17StartL   0xA00
002990  000158  #constant  Strings17StartL   0xA00
002991  000159  #constant  Strings14StartH   0x0
002992  000159  #constant  Strings14StartH   0x0
002993  000160  #constant  Strings14StartL   0xC00
002994  000160  #constant  Strings14StartL   0xC00
002995  000161  #constant  Strings15StartH   0x0
002996  000161  #constant  Strings15StartH   0x0
002997  000162  #constant  Strings15StartL   0xE00
002998  000162  #constant  Strings15StartL   0xE00
002999  000163  #constant  Strings2StartH   0x0
003000  000163  #constant  Strings2StartH   0x0
003001  000164  #constant  Strings2StartL   0x1000
003002  000164  #constant  Strings2StartL   0x1000
003003  000165  #constant  Strings3StartH   0x0
003004  000165  #constant  Strings3StartH   0x0
003005  000166  #constant  Strings3StartL   0x1200
003006  000166  #constant  Strings3StartL   0x1200
003007  000167  #constant  Strings4StartH   0x0
003008  000167  #constant  Strings4StartH   0x0
003009  000168  #constant  Strings4StartL   0x1400
003010  000168  #constant  Strings4StartL   0x1400
003011  000169  #constant  Strings5StartH   0x0
003012  000169  #constant  Strings5StartH   0x0
003013  000170  #constant  Strings5StartL   0x1600
003014  000170  #constant  Strings5StartL   0x1600
003015  000171  #constant  Strings6StartH   0x0
003016  000171  #constant  Strings6StartH   0x0
003017  000172  #constant  Strings6StartL   0x1800
003018  000172  #constant  Strings6StartL   0x1800
003019  000173  #constant  Strings7StartH   0x0
003020  000173  #constant  Strings7StartH   0x0
003021  000174  #constant  Strings7StartL   0x1A00
003022  000174  #constant  Strings7StartL   0x1A00
003023  000175  #constant  Strings8StartH   0x0
003024  000175  #constant  Strings8StartH   0x0
003025  000176  #constant  Strings8StartL   0x1C00
003026  000176  #constant  Strings8StartL   0x1C00
003027  000177  #constant  Strings9StartH   0x0
003028  000177  #constant  Strings9StartH   0x0
003029  000178  #constant  Strings9StartL   0x1E00
003030  000178  #constant  Strings9StartL   0x1E00
003031  000179  #constant  Strings10StartH   0x0
003032  000179  #constant  Strings10StartH   0x0
003033  000180  #constant  Strings10StartL   0x2000
003034  000180  #constant  Strings10StartL   0x2000
003035  000181  #constant  Strings11StartH   0x0
003036  000181  #constant  Strings11StartH   0x0
003037  000182  #constant  Strings11StartL   0x2200
003038  000182  #constant  Strings11StartL   0x2200
003039  000183  #constant  Strings22StartH   0x0
003040  000183  #constant  Strings22StartH   0x0
003041  000184  #constant  Strings22StartL   0x2400
003042  000184  #constant  Strings22StartL   0x2400
003043  000185  #constant  Strings23StartH   0x0
003044  000185  #constant  Strings23StartH   0x0
003045  000186  #constant  Strings23StartL   0x3600
003046  000186  #constant  Strings23StartL   0x3600
003047  000187  #constant  Strings12StartH   0x0
003048  000187  #constant  Strings12StartH   0x0
003049  000188  #constant  Strings12StartL   0x3800
003050  000188  #constant  Strings12StartL   0x3800
003051  000189  #constant  Strings13StartH   0x0
003052  000189  #constant  Strings13StartH   0x0
003053  000190  #constant  Strings13StartL   0x3A00
003054  000190  #constant  Strings13StartL   0x3A00
003055  000191  #constant  Strings19StartH   0x0
003056  000191  #constant  Strings19StartH   0x0
003057  000192  #constant  Strings19StartL   0x3C00
003058  000192  #constant  Strings19StartL   0x3C00
003059  000193  #constant  Strings18StartH   0x0
003060  000193  #constant  Strings18StartH   0x0
003061  000194  #constant  Strings18StartL   0x3E00
003062  000194  #constant  Strings18StartL   0x3E00
003063  000195        
003064  000196  #IFNOT EXISTS NOGLOBALS
003065  000197  var hndl ;
003066  000198  var hFonts[24] ;
003067  000199  var oKeyboard0[12] := [-1, 0, 0, 0, 0, 255, 255, 255, 255, 255, 13, 0] ;
3068  002B
3069  002C
3070  002D
3071  002E
3072  002F
3073  0030
3074  0031
3075  0032
3076  0033
3077  0034
3078  0035
3079  0036
3080  0037
3081  0038
3082  0039
3083  003A
3084  003B
3085  003C
3086  003D
3087  003E
3088  003F
3089  0040
3090  0041
3091  0042
003092  000200  #ENDIF
003093  000014        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\CLPrintStrings.inc

003094  000015  #inherit "CLPrintStrings.inc"
003095  000015  #inherit "CLPrintStrings.inc"
003096  000001  func PrintStrings(var ID, var *msgid, var String)
003097  000002      var StringID, i, ch, offs32[2], res32[2];
003098  000003      StringID := oStringss[1+ID] ;
003099  000004      if (String)
003100  000005          stringsCV[ID] := -1 ;
003101  000006      else
003102  000007          stringsCV[ID] := msgid ;
003103  000008      endif
003104  000009      if ((StringID == -1) || (*(StringID + Ofs_String_Form) != CurrentForm)) return ;
003105  000010      txt_FontID(hFonts[ID]) ;
003106  000011      txt_Attributes(*(StringID + Ofs_String_FontAttribs)) ; // >> 4 fix for r25,6,7,8 PmmC
003107  000012  //    txt_Opacity(*(StringID + STTransparent)) ;
003108  000013        
003109  000014      if (*(StringID + Ofs_String_Transparent))
003110  000015          gfx_RectangleFilled(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2), *(StringID + Ofs_String_BGColor));
003111  000016      else if (FormBGcolors[CurrentForm] != ColorBGimage)
003112  000017          gfx_RectangleFilled(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2), FormBGcolors[CurrentForm]);
003113  000018      else
003114  000019          gfx_ClipWindow(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2)) ;
003115  000020          gfx_Clipping(ON) ;
003116  000021          img_Show(hndl,FormStartIndex[CurrentForm]) ;
003117  000022          gfx_Clipping(OFF) ;
003118  000023        
003119  000024      endif
003120  000025        
003121  000026      txt_FGcolour(*(StringID + Ofs_String_FGColor)) ;
003122  000027      txt_BGcolour(*(StringID + Ofs_String_BGColor)) ;
003123  000028      txt_Opacity(TRANSPARENT);                // 8  text OPAQUE or TRANSPARENT
003124  000029        
003125  000030      gfx_MoveTo(*(StringID + Ofs_String_x1) , *(StringID + Ofs_String_y1)) ;
003126  000031        
003127  000032      if (String)
003128  000033          i := 0 ;
003129  000034          ch := msgid[i++] ;
003130  000035          while (ch != 0)
003131  000036              putch(ch) ;
003132  000037              ch := msgid[i++] ;
003133  000038          wend
003134  000039      else
003135  000040          umul_1616(offs32, *(StringID + Ofs_String_Size), msgid);
003136  000041          res32[1] := *(StringID + Ofs_String_StartH) ;
003137  000042          res32[0] := *(StringID + Ofs_String_StartL) ;
003138  000043          uadd_3232(res32,res32,offs32) ;
003139  000044          file_Seek(hstrings, res32[1], res32[0]);
003140  000045          repeat
003141  000046              if (*(StringID + Ofs_String_Ansi))
003142  000047                  ch := file_GetC(hstrings) ;
003143  000048              else
003144  000049                  ch := file_GetW(hstrings) ;
003145  000050              endif
003146  000051              putch(ch) ;
003147  000052          until (ch == 0) ;
003148  000053      endif
003149  000054        
003150  000055  endfunc
003151  000056        
003152  000016        
003153  000017  #constant IPDatasize 22
003154  000017  #constant IPDatasize 22
003155  000018        
003156  000019  #CONST
003157  000023  #END
003158  000024        
003159  000025        
003160  000026        
003161  000027  #CONST
003162  000134  #END
003163  000135        
003164  000136  #CONST
003165  000149  #END
003166  000150        
003167  000151  #constant KbShiftBit        01
003168  000151  #constant KbShiftBit        01
003169  000152  #constant KbCapsBit         02
003170  000152  #constant KbCapsBit         02
003171  000153  #constant KbShiftCapsBits   03
003172  000153  #constant KbShiftCapsBits   03
003173  000154  #constant KbCtrlBit         04
003174  000154  #constant KbCtrlBit         04
003175  000155        
003176  000156  func refreshstate(var iKB, var oKB)
003177  000157      var shifted ;
003178  000158      shifted := oKB[Ofs_kb_State] & KbShiftCapsBits ;
003179  000159      if (!shifted || (shifted == KbShiftCapsBits))
003180  000160          shifted := 0 ;
003181  000161          oKB[Ofs_kb_Caps] := 0 ;
003182  000162      else
003183  000163          shifted := 1 ;
003184  000164          oKB[Ofs_kb_Caps] := 2 ;
003185  000165      endif
003186  000166      setkeystate(iKB,shifted) ;
003187  000167      if (oKB[Ofs_kb_State] & KbCapsBit)
003188  000168          setkeystate(iKB + oKB[Ofs_kb_Lock],1) ;
003189  000169      endif
003190  000170      if ((oKB[Ofs_kb_State] & KbShiftBit) && (shifted))
003191  000171          setkeystate(iKB + oKB[Ofs_kb_Shift1],1) ;
003192  000172          setkeystate(iKB + oKB[Ofs_kb_Shift2],1) ;
003193  000173      endif
003194  000174      if (oKB[Ofs_kb_State] & KbCtrlBit)
003195  000175          setkeystate(iKB + oKB[Ofs_kb_Ctrl1],1) ;
003196  000176          setkeystate(iKB + oKB[Ofs_kb_Ctrl2],1) ;
003197  000177      endif
003198  000178  endfunc
003199  000179        
003200  000180  func kbDown(var iKB, var oKB, var KBKeys, var key)
003201  000181      var keyval, rtn ;
003202  000182      oKB[Ofs_kb_Mvt] := 1 ;
003203  000183      oKB[Ofs_kb_Ign]  := 0 ;
003204  000184      if ((key == oKB[Ofs_kb_Shift1]) || (key == oKB[Ofs_kb_Shift2]))
003205  000185          if (oKB[Ofs_kb_State] & KbShiftBit)
003206  000186              oKB[Ofs_kb_State] &= ~KbShiftBit ;
003207  000187              oKB[Ofs_kb_Mvt] := 0 ;
003208  000188          else
003209  000189              oKB[Ofs_kb_State] |= KbShiftBit ;
003210  000190          endif
003211  000191          refreshstate(iKB, oKB) ;
003212  000192          oKB[Ofs_kb_Ign] := 1 ;
003213  000193      else if ((key == oKB[Ofs_kb_Ctrl1]) || (key == oKB[Ofs_kb_Ctrl2]))
003214  000194          if (oKB[Ofs_kb_State] & KbCtrlBit)
003215  000195              oKB[Ofs_kb_State] &= ~KbCtrlBit ;
003216  000196              oKB[Ofs_kb_Mvt] := 0 ;
003217  000197          else
003218  000198              oKB[Ofs_kb_State] |= KbCtrlBit ;
003219  000199          endif
003220  000200          setkeystate(iKB+oKB[Ofs_kb_Ctrl1],oKB[Ofs_kb_Mvt]) ;
003221  000201          key := oKB[Ofs_kb_Ctrl2] ;
003222  000202          oKB[Ofs_kb_Ign] := 1 ;
003223  000203      else if (key == oKB[Ofs_kb_Lock])
003224  000204          if (oKB[Ofs_kb_State] & KbCapsBit)
003225  000205              oKB[Ofs_kb_State] &= ~KbCapsBit ;
003226  000206              oKB[Ofs_kb_Mvt] := 0 ;
003227  000207          else
003228  000208              oKB[Ofs_kb_State] |= KbCapsBit ;
003229  000209          endif
003230  000210          refreshstate(iKB, oKB) ;
003231  000211          oKB[Ofs_kb_Ign] := 1 ;
003232  000212      endif
003233  000213        
003234  000214      if (!oKB[Ofs_kb_Ign])
003235  000215          if (oKB[Ofs_kb_ShiftCaps])
003236  000216              keyval := (oKB[Ofs_kb_State] & KbShiftCapsBits) * oKB[Ofs_kb_Buttons] - 1 ;
003237  000217          else if (((oKB[Ofs_kb_State] & KbShiftCapsBits) == 0) || ((oKB[Ofs_kb_State] & KbShiftCapsBits) == KbShiftCapsBits))
003238  000218                  keyval := - 1 ;
003239  000219              else
003240  000220                  keyval := oKB[Ofs_kb_Buttons] - 1 ;
003241  000221          endif
003242  000222          keyval := KBKeys[key+keyval] ;
003243  000223          if (oKB[Ofs_kb_State] & KbCtrlBit) keyval &= 0x9F ;
003244  000224  //        SendReport(REPORT_EVENT, tKeyboard, actKB, keyval & 0xff) ;
003245  000225  // sendReport, or KBEvent(actKB, keyval & 0xff) 
003246  000226  	rtn := rKeyboardRoutines[ActiveKeyboard] ;
003247  000227          rtn(REPORT_EVENT, tKeyboard, ActiveKeyboard, keyval & 0xff) ;
003248  000228          setkeystate(iKB+key,oKB[Ofs_kb_Mvt]+oKB[Ofs_kb_Caps]) ;
003249  000229      endif
003250  000230      oKB[Ofs_kb_Down] := key ;
003251  000231  endfunc
003252  000232        
003253  000233  func setkeystate(var key, var idx)
003254  000234      img_SetWord(hndl, key,IMAGE_INDEX, idx);
003255  000235      img_Show(hndl,key) ;
003256  000236  endfunc
003257  000237        
003258  000238  func kbUp(var iKB, var oKB)
003259  000239      if (!oKB[Ofs_kb_Ign])
003260  000240          setkeystate(iKB + oKB[Ofs_kb_Down],oKB[Ofs_kb_Caps]) ;
003261  000241          if (oKB[Ofs_kb_State] & KbShiftBit)
003262  000242              oKB[Ofs_kb_State] &= ~KbShiftBit ;
003263  000243              refreshstate(iKB, oKB) ;
003264  000244          endif
003265  000245          if (oKB[Ofs_kb_State] & KbCtrlBit)
003266  000246              oKB[Ofs_kb_State] &= ~KbCtrlBit ;
003267  000247              setkeystate(iKB + oKB[Ofs_kb_Ctrl1],0) ;
003268  000248              setkeystate(iKB + oKB[Ofs_kb_Ctrl2],0) ;
003269  000249          endif
003270  000250          oKB[Ofs_kb_Down] := -1 ;
003271  000251      endif
003272  000252  endfunc
003273  000253        
003274  000380  #END
3275  0BDD
3276  0BDE
3277  0BDF
3278  0BE0
3279  0BE1
3280  0BE2
3281  0BE3
3282  0BE4
3283  0BE5
3284  0BE6
3285  0BE7
3286  0BE8
3287  0BE9
3288  0BEA
3289  0BEB
3290  0BEC
3291  0BED
3292  0BEE
3293  0BEF
3294  0BF0
3295  0BF1
3296  0BF2
3297  0BF3
3298  0BF4
3299  0BF5
3300  0BF6
3301  0BF7
3302  0BF8
3303  0BF9
3304  0BFA
3305  0BFB
3306  0BFC
3307  0BFD
3308  0BFE
3309  0BFF
3310  0C00
3311  0C01
3312  0C02
3313  0C03
3314  0C04
3315  0C05
3316  0C06
3317  0C07
3318  0C08
3319  0C09
3320  0C0A
3321  0C0B
3322  0C0C
3323  0C0D
3324  0C0E
3325  0C0F
3326  0C10
3327  0C11
3328  0C12
3329  0C13
3330  0C14
3331  0C15
3332  0C16
3333  0C17
3334  0C18
3335  0C19
3336  0C1A
3337  0C1B
3338  0C1C
3339  0C1D
3340  0C1E
3341  0C1F
3342  0C20
3343  0C21
3344  0C22
3345  0C23
3346  0C24
3347  0C25
3348  0C26
3349  0C27
3350  0C28
3351  0C29
3352  0C2A
3353  0C2B
3354  0C2C
3355  0C2D
3356  0C2E
3357  0C2F
3358  0C30
3359  0C31
3360  0C32
3361  0C33
3362  0C34
3363  0C35
3364  0C36
3365  0C37
3366  0C38
3367  0C39
3368  0C3A
3369  0C3B
3370  0C3C
3371  0C3D
3372  0C3E
3373  0C3F
3374  0C40
3375  0C41
3376  0C42
3377  0C43
3378  0C44
3379  0C45
3380  0C46
3381  0C47
3382  0C48
3383  0C49
3384  0C4A
3385  0C4B
3386  0C4C
3387  0C4D
3388  0C4E
3389  0C4F
3390  0C50
3391  0C51
3392  0C52
3393  0C53
3394  0C54
3395  0C55
3396  0C56
3397  0C57
3398  0C58
3399  0C59
3400  0C5A
3401  0C5B
3402  0C5C
3403  0C5D
3404  0C5E
3405  0C5F
3406  0C60
3407  0C61
3408  0C62
3409  0C63
3410  0C64
3411  0C65
3412  0C66
3413  0C67
3414  0C68
3415  0C69
3416  0C6A
3417  0C6B
3418  0C6C
3419  0C6D
3420  0C6E
3421  0C6F
3422  0C70
3423  0C71
3424  0C72
3425  0C73
3426  0C74
3427  0C75
3428  0C76
3429  0C77
3430  0C78
3431  0C79
3432  0C7A
3433  0C7B
3434  0C7C
3435  0C7D
3436  0C7E
3437  0C7F
3438  0C80
3439  0C81
3440  0C82
3441  0C83
3442  0C84
3443  0C85
3444  0C86
3445  0C87
3446  0C88
3447  0C89
3448  0C8A
3449  0C8B
3450  0C8C
3451  0C8D
3452  0C8E
3453  0C8F
3454  0C90
3455  0C91
3456  0C92
3457  0C93
3458  0C94
3459  0C95
3460  0C96
3461  0C97
3462  0C98
3463  0C99
3464  0C9A
3465  0C9B
3466  0C9C
3467  0C9D
3468  0C9E
3469  0C9F
3470  0CA0
3471  0CA1
3472  0CA2
3473  0CA3
3474  0CA4
3475  0CA5
3476  0CA6
3477  0CA7
3478  0CA8
3479  0CA9
3480  0CAA
3481  0CAB
3482  0CAC
3483  0CAD
3484  0CAE
3485  0CAF
3486  0CB0
3487  0CB1
3488  0CB2
3489  0CB3
3490  0CB4
3491  0CB5
3492  0CB6
3493  0CB7
3494  0CB8
3495  0CB9
3496  0CBA
3497  0CBB
3498  0CBC
3499  0CBD
3500  0CBE
3501  0CBF
3502  0CC0
3503  0CC1
3504  0CC2
3505  0CC3
3506  0CC4
3507  0CC5
3508  0CC6
3509  0CC7
3510  0CC8
3511  0CC9
3512  0CCA
3513  0CCB
3514  0CCC
3515  0CCD
3516  0CCE
3517  0CCF
3518  0CD0
3519  0CD1
3520  0CD2
3521  0CD3
3522  0CD4
3523  0CD5
3524  0CD6
3525  0CD7
3526  0CD8
3527  0CD9
3528  0CDA
3529  0CDB
3530  0CDC
3531  0CDD
3532  0CDE
3533  0CDF
3534  0CE0
3535  0CE1
3536  0CE2
3537  0CE3
3538  0CE4
3539  0CE5
3540  0CE6
3541  0CE7
3542  0CE8
3543  0CE9
3544  0CEA
3545  0CEB
3546  0CEC
3547  0CED
3548  0CEE
3549  0CEF
3550  0CF0
3551  0CF1
3552  0CF2
3553  0CF3
3554  0CF4
3555  0CF5
3556  0CF6
3557  0CF7
3558  0CF8
3559  0CF9
3560  0CFA
3561  0CFB
3562  0CFC
3563  0CFD
3564  0CFE
3565  0CFF
3566  0D00
3567  0D01
3568  0D02
3569  0D03
3570  0D04
3571  0D05
3572  0D06
3573  0D07
3574  0D08
3575  0D09
3576  0D0A
3577  0D0B
3578  0D0C
3579  0D0D
3580  0D0E
3581  0D0F
3582  0D10
3583  0D11
3584  0D12
3585  0D13
3586  0D14
3587  0D15
3588  0D16
3589  0D17
3590  0D18
3591  0D19
3592  0D1A
3593  0D1B
3594  0D1C
3595  0D1D
3596  0D1E
3597  0D1F
3598  0D20
3599  0D21
3600  0D22
3601  0D23
3602  0D24
3603  0D25
3604  0D26
3605  0D27
3606  0D28
3607  0D29
3608  0D2A
3609  0D2B
3610  0D2C
3611  0D2D
3612  0D2E
3613  0D2F
3614  0D30
3615  0D31
3616  0D32
3617  0D33
3618  0D34
3619  0D35
3620  0D36
3621  0D37
3622  0D38
3623  0D39
3624  0D3A
3625  0D3B
3626  0D3C
3627  0D3D
3628  0D3E
3629  0D3F
3630  0D40
3631  0D41
3632  0D42
3633  0D43
3634  0D44
3635  0D45
3636  0D46
3637  0D47
3638  0D48
3639  0D49
3640  0D4A
3641  0D4B
3642  0D4C
3643  0D4D
3644  0D4E
3645  0D4F
3646  0D50
3647  0D51
3648  0D52
3649  0D53
3650  0D54
3651  0D55
3652  0D56
3653  0D57
3654  0D58
3655  0D59
3656  0D5A
3657  0D5B
3658  0D5C
3659  0D5D
3660  0D5E
3661  0D5F
3662  0D60
3663  0D61
3664  0D62
3665  0D63
3666  0D64
3667  0D65
3668  0D66
3669  0D67
3670  0D68
3671  0D69
3672  0D6A
3673  0D6B
3674  0D6C
3675  0D6D
3676  0D6E
3677  0D6F
3678  0D70
3679  0D71
3680  0D72
3681  0D73
3682  0D74
3683  0D75
3684  0D76
3685  0D77
3686  0D78
3687  0D79
3688  0D7A
3689  0D7B
3690  0D7C
3691  0D7D
3692  0D7E
3693  0D7F
3694  0D80
3695  0D81
3696  0D82
3697  0D83
3698  0D84
3699  0D85
3700  0D86
3701  0D87
3702  0D88
3703  0D89
3704  0D8A
3705  0D8B
3706  0D8C
3707  0D8D
3708  0D8E
3709  0D8F
3710  0D90
3711  0D91
3712  0D92
3713  0D93
3714  0D94
3715  0D95
3716  0D96
3717  0D97
3718  0D98
3719  0D99
3720  0D9A
3721  0D9B
3722  0D9C
3723  0D9D
3724  0D9E
3725  0D9F
3726  0DA0
3727  0DA1
3728  0DA2
3729  0DA3
3730  0DA4
3731  0DA5
3732  0DA6
3733  0DA7
3734  0DA8
3735  0DA9
3736  0DAA
3737  0DAB
3738  0DAC
3739  0DAD
3740  0DAE
3741  0DAF
3742  0DB0
3743  0DB1
3744  0DB2
3745  0DB3
3746  0DB4
3747  0DB5
3748  0DB6
3749  0DB7
3750  0DB8
3751  0DB9
3752  0DBA
3753  0DBB
3754  0DBC
3755  0DBD
3756  0DBE
3757  0DBF
3758  0DC0
3759  0DC1
3760  0DC2
3761  0DC3
3762  0DC4
3763  0DC5
3764  0DC6
3765  0DC7
3766  0DC8
3767  0DC9
3768  0DCA
3769  0DCB
3770  0DCC
3771  0DCD
3772  0DCE
3773  0DCF
3774  0DD0
3775  0DD1
3776  0DD2
3777  0DD3
3778  0DD4
3779  0DD5
3780  0DD6
3781  0DD7
3782  0DD8
3783  0DD9
3784  0DDA
3785  0DDB
3786  0DDC
3787  0DDD
3788  0DDE
3789  0DDF
3790  0DE0
3791  0DE1
3792  0DE2
3793  0DE3
3794  0DE4
3795  0DE5
3796  0DE6
3797  0DE7
3798  0DE8
3799  0DE9
3800  0DEA
3801  0DEB
3802  0DEC
3803  0DED
3804  0DEE
3805  0DEF
3806  0DF0
3807  0DF1
3808  0DF2
3809  0DF3
3810  0DF4
3811  0DF5
3812  0DF6
3813  0DF7
3814  0DF8
3815  0DF9
3816  0DFA
3817  0DFB
3818  0DFC
3819  0DFD
3820  0DFE
3821  0DFF
3822  0E00
3823  0E01
3824  0E02
3825  0E03
3826  0E04
3827  0E05
3828  0E06
3829  0E07
3830  0E08
3831  0E09
3832  0E0A
3833  0E0B
3834  0E0C
3835  0E0D
3836  0E0E
3837  0E0F
3838  0E10
3839  0E11
3840  0E12
3841  0E13
3842  0E14
3843  0E15
3844  0E16
3845  0E17
3846  0E18
3847  0E19
3848  0E1A
3849  0E1B
3850  0E1C
3851  0E1D
3852  0E1E
3853  0E1F
3854  0E20
3855  0E21
3856  0E22
3857  0E23
3858  0E24
3859  0E25
3860  0E26
3861  0E27
3862  0E28
3863  0E29
3864  0E2A
3865  0E2B
3866  0E2C
3867  0E2D
3868  0E2E
3869  0E2F
3870  0E30
3871  0E31
3872  0E32
3873  0E33
3874  0E34
3875  0E35
3876  0E36
3877  0E37
3878  0E38
3879  0E39
3880  0E3A
3881  0E3B
3882  0E3C
3883  0E3D
3884  0E3E
3885  0E3F
3886  0E40
3887  0E41
3888  0E42
3889  0E43
3890  0E44
3891  0E45
3892  0E46
3893  0E47
3894  0E48
3895  0E49
3896  0E4A
3897  0E4B
3898  0E4C
3899  0E4D
3900  0E4E
3901  0E4F
3902  0E50
3903  0E51
3904  0E52
3905  0E53
3906  0E54
3907  0E55
3908  0E56
3909  0E57
3910  0E58
3911  0E59
3912  0E5A
3913  0E5B
3914  0E5C
3915  0E5D
3916  0E5E
3917  0E5F
3918  0E60
3919  0E61
3920  0E62
3921  0E63
3922  0E64
3923  0E65
3924  0E66
3925  0E67
3926  0E68
3927  0E69
3928  0E6A
3929  0E6B
3930  0E6C
3931  0E6D
3932  0E6E
3933  0E6F
3934  0E70
3935  0E71
3936  0E72
3937  0E73
3938  0E74
3939  0E75
3940  0E76
3941  0E77
3942  0E78
3943  0E79
3944  0E7A
3945  0E7B
3946  0E7C
3947  0E7D
3948  0E7E
3949  0E7F
3950  0E80
3951  0E81
3952  0E82
3953  0E83
3954  0E84
3955  0E85
3956  0E86
3957  0E87
3958  0E88
3959  0E89
3960  0E8A
3961  0E8B
3962  0E8C
3963  0E8D
3964  0E8E
3965  0E8F
3966  0E90
3967  0E91
3968  0E92
3969  0E93
3970  0E94
3971  0E95
3972  0E96
3973  0E97
3974  0E98
3975  0E99
3976  0E9A
3977  0E9B
3978  0E9C
3979  0E9D
3980  0E9E
3981  0E9F
3982  0EA0
3983  0EA1
3984  0EA2
3985  0EA3
3986  0EA4
3987  0EA5
3988  0EA6
3989  0EA7
3990  0EA8
3991  0EA9
3992  0EAA
3993  0EAB
3994  0EAC
3995  0EAD
3996  0EAE
3997  0EAF
3998  0EB0
3999  0EB1
4000  0EB2
4001  0EB3
4002  0EB4
4003  0EB5
4004  0EB6
4005  0EB7
4006  0EB8
4007  0EB9
4008  0EBA
4009  0EBB
4010  0EBC
4011  0EBD
4012  0EBE
4013  0EBF
4014  0EC0
4015  0EC1
4016  0EC2
4017  0EC3
4018  0EC4
4019  0EC5
4020  0EC6
4021  0EC7
4022  0EC8
4023  0EC9
4024  0ECA
4025  0ECB
4026  0ECC
4027  0ECD
4028  0ECE
4029  0ECF
4030  0ED0
4031  0ED1
4032  0ED2
4033  0ED3
4034  0ED4
4035  0ED5
4036  0ED6
4037  0ED7
4038  0ED8
4039  0ED9
4040  0EDA
4041  0EDB
4042  0EDC
4043  0EDD
4044  0EDE
4045  0EDF
4046  0EE0
4047  0EE1
4048  0EE2
4049  0EE3
4050  0EE4
4051  0EE5
4052  0EE6
4053  0EE7
4054  0EE8
4055  0EE9
4056  0EEA
4057  0EEB
4058  0EEC
4059  0EED
4060  0EEE
4061  0EEF
4062  0EF0
4063  0EF1
4064  0EF2
4065  0EF3
4066  0EF4
4067  0EF5
4068  0EF6
4069  0EF7
4070  0EF8
4071  0EF9
4072  0EFA
4073  0EFB
4074  0EFC
4075  0EFD
4076  0EFE
4077  0EFF
4078  0F00
4079  0F01
4080  0F02
4081  0F03
4082  0F04
4083  0F05
4084  0F06
4085  0F07
4086  0F08
4087  0F09
4088  0F0A
4089  0F0B
4090  0F0C
4091  0F0D
4092  0F0E
4093  0F0F
4094  0F10
4095  0F11
4096  0F12
4097  0F13
4098  0F14
4099  0F15
4100  0F16
4101  0F17
4102  0F18
4103  0F19
4104  0F1A
4105  0F1B
4106  0F1C
4107  0F1D
4108  0F1E
4109  0F1F
4110  0F20
4111  0F21
4112  0F22
4113  0F23
4114  0F24
4115  0F25
4116  0F26
4117  0F27
4118  0F28
4119  0F29
4120  0F2A
4121  0F2B
4122  0F2C
4123  0F2D
4124  0F2E
4125  0F2F
4126  0F30
4127  0F31
4128  0F32
4129  0F33
4130  0F34
4131  0F35
4132  0F36
4133  0F37
4134  0F38
4135  0F39
4136  0F3A
4137  0F3B
4138  0F3C
4139  0F3D
4140  0F3E
4141  0F3F
4142  0F40
4143  0F41
4144  0F42
4145  0F43
4146  0F44
4147  0F45
4148  0F46
4149  0F47
4150  0F48
4151  0F49
4152  0F4A
4153  0F4B
4154  0F4C
4155  0F4D
4156  0F4E
4157  0F4F
4158  0F50
4159  0F51
4160  0F52
4161  0F53
4162  0F54
4163  0F55
4164  0F56
4165  0F57
4166  0F58
4167  0F59
4168  0F5A
4169  0F5B
4170  0F5C
4171  0F5D
4172  0F5E
4173  0F5F
4174  0F60
4175  0F61
4176  0F62
4177  0F63
4178  0F64
4179  0F65
4180  0F66
4181  0F67
4182  0F68
4183  0F69
4184  0F6A
4185  0F6B
4186  0F6C
4187  0F6D
4188  0F6E
4189  0F6F
4190  0F70
4191  0F71
4192  0F72
4193  0F73
4194  0F74
4195  0F75
4196  0F76
4197  0F77
4198  0F78
4199  0F79
4200  0F7A
4201  0F7B
4202  0F7C
4203  0F7D
4204  0F7E
4205  0F7F
4206  0F80
4207  0F81
4208  0F82
4209  0F83
4210  0F84
4211  0F85
4212  0F86
4213  0F87
4214  0F88
4215  0F89
4216  0F8A
4217  0F8B
4218  0F8C
4219  0F8D
4220  0F8E
4221  0F8F
4222  0F90
4223  0F91
4224  0F92
4225  0F93
4226  0F94
4227  0F95
4228  0F96
4229  0F97
4230  0F98
4231  0F99
4232  0F9A
4233  0F9B
4234  0F9C
4235  0F9D
4236  0F9E
4237  0F9F
4238  0FA0
4239  0FA1
4240  0FA2
4241  0FA3
4242  0FA4
4243  0FA5
4244  0FA6
4245  0FA7
4246  0FA8
4247  0FA9
4248  0FAA
4249  0FAB
4250  0FAC
4251  0FAD
4252  0FAE
4253  0FAF
4254  0FB0
4255  0FB1
4256  0FB2
4257  0FB3
4258  0FB4
4259  0FB5
4260  0FB6
4261  0FB7
4262  0FB8
4263  0FB9
4264  0FBA
4265  0FBB
4266  0FBC
4267  0FBD
4268  0FBE
4269  0FBF
4270  0FC0
4271  0FC1
4272  0FC2
4273  0FC3
4274  0FC4
4275  0FC5
4276  0FC6
4277  0FC7
4278  0FC8
4279  0FC9
4280  0FCA
4281  0FCB
4282  0FCC
4283  0FCD
4284  0FCE
4285  0FCF
4286  0FD0
4287  0FD1
4288  0FD2
4289  0FD3
4290  0FD4
4291  0FD5
4292  0FD6
4293  0FD7
4294  0FD8
4295  0FD9
4296  0FDA
4297  0FDB
4298  0FDC
4299  0FDD
4300  0FDE
4301  0FDF
4302  0FE0
4303  0FE1
4304  0FE2
4305  0FE3
4306  0FE4
4307  0FE5
4308  0FE6
4309  0FE7
4310  0FE8
4311  0FE9
4312  0FEA
4313  0FEB
4314  0FEC
4315  0FED
4316  0FEE
4317  0FEF
4318  0FF0
4319  0FF1
4320  0FF2
4321  0FF3
4322  0FF4
4323  0FF5
4324  0FF6
4325  0FF7
4326  0FF8
4327  0FF9
4328  0FFA
4329  0FFB
4330  0FFC
4331  0FFD
4332  0FFE
4333  0FFF
4334  1000
4335  1001
4336  1002
4337  1003
4338  1004
4339  1005
4340  1006
4341  1007
4342  1008
4343  1009
4344  100A
4345  100B
4346  100C
4347  100D
4348  100E
4349  100F
4350  1010
4351  1011
4352  1012
4353  1013
4354  1014
4355  1015
4356  1016
4357  1017
4358  1018
4359  1019
4360  101A
4361  101B
4362  101C
4363  101D
4364  101E
4365  101F
4366  1020
4367  1021
4368  1022
4369  1023
4370  1024
4371  1025
4372  1026
4373  1027
4374  1028
4375  1029
4376  102A
4377  102B
4378  102C
4379  102D
4380  102E
4381  102F
4382  1030
4383  1031
4384  1032
4385  1033
4386  1034
4387  1035
4388  1036
4389  1037
4390  1038
4391  1039
4392  103A
4393  103B
4394  103C
4395  103D
4396  103E
4397  103F
4398  1040
4399  1041
4400  1042
4401  1043
4402  1044
4403  1045
4404  1046
4405  1047
4406  1048
4407  1049
4408  104A
4409  104B
4410  104C
4411  104D
4412  104E
4413  104F
4414  1050
4415  1051
4416  1052
4417  1053
4418  1054
4419  1055
4420  1056
4421  1057
4422  1058
4423  1059
4424  105A
4425  105B
4426  105C
4427  105D
4428  105E
4429  105F
4430  1060
4431  1061
4432  1062
4433  1063
4434  1064
4435  1065
4436  1066
4437  1067
4438  1068
4439  1069
4440  106A
4441  106B
4442  106C
4443  106D
4444  106E
4445  106F
4446  1070
4447  1071
4448  1072
4449  1073
4450  1074
4451  1075
4452  1076
4453  1077
4454  1078
4455  1079
4456  107A
4457  107B
4458  107C
4459  107D
4460  107E
4461  107F
4462  1080
4463  1081
4464  1082
4465  1083
4466  1084
4467  1085
4468  1086
4469  1087
4470  1088
4471  1089
4472  108A
4473  108B
4474  108C
4475  108D
4476  108E
4477  108F
4478  1090
4479  1091
4480  1092
4481  1093
4482  1094
4483  1095
4484  1096
4485  1097
4486  1098
4487  1099
4488  109A
4489  109B
4490  109C
4491  109D
4492  109E
4493  109F
4494  10A0
4495  10A1
4496  10A2
4497  10A3
4498  10A4
4499  10A5
4500  10A6
4501  10A7
4502  10A8
4503  10A9
4504  10AA
4505  10AB
4506  10AC
4507  10AD
4508  10AE
4509  10AF
4510  10B0
4511  10B1
4512  10B2
4513  10B3
4514  10B4
4515  10B5
4516  10B6
4517  10B7
4518  10B8
4519  10B9
4520  10BA
4521  10BB
4522  10BC
4523  10BD
4524  10BE
4525  10BF
4526  10C0
4527  10C1
4528  10C2
4529  10C3
4530  10C4
4531  10C5
4532  10C6
4533  10C7
4534  10C8
4535  10C9
4536  10CA
4537  10CB
4538  10CC
4539  10CD
4540  10CE
4541  10CF
4542  10D0
4543  10D1
4544  10D2
4545  10D3
4546  10D4
4547  10D5
4548  10D6
4549  10D7
4550  10D8
4551  10D9
4552  10DA
4553  10DB
4554  10DC
4555  10DD
4556  10DE
4557  10DF
4558  10E0
4559  10E1
4560  10E2
4561  10E3
4562  10E4
4563  10E5
4564  10E6
4565  10E7
4566  10E8
4567  10E9
4568  10EA
4569  10EB
4570  10EC
4571  10ED
4572  10EE
4573  10EF
4574  10F0
4575  10F1
4576  10F2
4577  10F3
4578  10F4
4579  10F5
4580  10F6
4581  10F7
4582  10F8
4583  10F9
4584  10FA
4585  10FB
4586  10FC
4587  10FD
4588  10FE
4589  10FF
4590  1100
4591  1101
4592  1102
4593  1103
4594  1104
4595  1105
4596  1106
4597  1107
4598  1108
4599  1109
4600  110A
4601  110B
4602  110C
4603  110D
4604  110E
4605  110F
4606  1110
4607  1111
4608  1112
4609  1113
4610  1114
4611  1115
4612  1116
4613  1117
4614  1118
4615  1119
4616  111A
4617  111B
4618  111C
4619  111D
4620  111E
4621  111F
4622  1120
4623  1121
4624  1122
4625  1123
4626  1124
4627  1125
4628  1126
4629  1127
4630  1128
4631  1129
4632  112A
4633  112B
4634  112C
4635  112D
4636  112E
4637  112F
4638  1130
4639  1131
4640  1132
4641  1133
4642  1134
4643  1135
4644  1136
4645  1137
4646  1138
4647  1139
4648  113A
4649  113B
4650  113C
4651  113D
4652  113E
4653  113F
4654  1140
4655  1141
4656  1142
4657  1143
4658  1144
4659  1145
4660  1146
4661  1147
4662  1148
4663  1149
4664  114A
4665  114B
4666  114C
4667  114D
4668  114E
4669  114F
4670  1150
4671  1151
4672  1152
4673  1153
4674  1154
4675  1155
4676  1156
4677  1157
4678  1158
4679  1159
4680  115A
4681  115B
4682  115C
4683  115D
4684  115E
4685  115F
4686  1160
4687  1161
4688  1162
4689  1163
4690  1164
4691  1165
4692  1166
4693  1167
4694  1168
4695  1169
4696  116A
4697  116B
4698  116C
4699  116D
4700  116E
4701  116F
4702  1170
4703  1171
4704  1172
4705  1173
4706  1174
4707  1175
4708  1176
4709  1177
4710  1178
4711  1179
4712  117A
4713  117B
4714  117C
4715  117D
4716  117E
4717  117F
4718  1180
4719  1181
4720  1182
4721  1183
4722  1184
4723  1185
4724  1186
4725  1187
4726  1188
4727  1189
4728  118A
4729  118B
4730  118C
4731  118D
4732  118E
4733  118F
4734  1190
4735  1191
4736  1192
4737  1193
4738  1194
4739  1195
4740  1196
4741  1197
4742  1198
4743  1199
4744  119A
4745  119B
4746  119C
4747  119D
4748  119E
4749  119F
4750  11A0
4751  11A1
4752  11A2
4753  11A3
4754  11A4
4755  11A5
4756  11A6
4757  11A7
4758  11A8
4759  11A9
4760  11AA
4761  11AB
4762  11AC
4763  11AD
4764  11AE
4765  11AF
4766  11B0
4767  11B1
4768  11B2
4769  11B3
4770  11B4
4771  11B5
4772  11B6
4773  11B7
4774  11B8
4775  11B9
4776  11BA
4777  11BB
4778  11BC
4779  11BD
4780  11BE
4781  11BF
4782  11C0
4783  11C1
4784  11C2
4785  11C3
4786  11C4
4787  11C5
4788  11C6
4789  11C7
4790  11C8
4791  11C9
4792  11CA
4793  11CB
4794  11CC
4795  11CD
4796  11CE
4797  11CF
4798  11D0
4799  11D1
4800  11D2
4801  11D3
4802  11D4
4803  11D5
4804  11D6
4805  11D7
4806  11D8
4807  11D9
4808  11DA
4809  11DB
4810  11DC
4811  11DD
4812  11DE
4813  11DF
4814  11E0
4815  11E1
4816  11E2
4817  11E3
4818  11E4
4819  11E5
4820  11E6
4821  11E7
4822  11E8
4823  11E9
4824  11EA
4825  11EB
4826  11EC
4827  11ED
4828  11EE
4829  11EF
4830  11F0
4831  11F1
4832  11F2
4833  11F3
4834  11F4
4835  11F5
4836  11F6
4837  11F7
4838  11F8
4839  11F9
4840  11FA
4841  11FB
4842  11FC
4843  11FD
4844  11FE
4845  11FF
4846  1200
4847  1201
4848  1202
4849  1203
4850  1204
4851  1205
4852  1206
4853  1207
4854  1208
4855  1209
4856  120A
4857  120B
4858  120C
4859  120D
4860  120E
4861  120F
4862  1210
4863  1211
4864  1212
4865  1213
4866  1214
4867  1215
4868  1216
4869  1217
4870  1218
4871  1219
4872  121A
4873  121B
4874  121C
4875  121D
4876  121E
4877  121F
4878  1220
4879  1221
4880  1222
4881  1223
4882  1224
4883  1225
4884  1226
4885  1227
4886  1228
4887  1229
4888  122A
4889  122B
4890  122C
4891  122D
4892  122E
4893  122F
4894  1230
4895  1231
4896  1232
4897  1233
4898  1234
4899  1235
4900  1236
4901  1237
4902  1238
4903  1239
4904  123A
4905  123B
4906  123C
4907  123D
4908  123E
4909  123F
4910  1240
4911  1241
4912  1242
4913  1243
4914  1244
4915  1245
4916  1246
4917  1247
4918  1248
4919  1249
4920  124A
4921  124B
4922  124C
4923  124D
4924  124E
4925  124F
4926  1250
4927  1251
4928  1252
4929  1253
4930  1254
4931  1255
4932  1256
4933  1257
4934  1258
4935  1259
4936  125A
4937  125B
4938  125C
4939  125D
4940  125E
4941  125F
4942  1260
4943  1261
4944  1262
4945  1263
4946  1264
4947  1265
4948  1266
4949  1267
4950  1268
4951  1269
4952  126A
4953  126B
4954  126C
4955  126D
4956  126E
4957  126F
4958  1270
4959  1271
4960  1272
4961  1273
4962  1274
4963  1275
4964  1276
4965  1277
4966  1278
4967  1279
4968  127A
4969  127B
4970  127C
4971  127D
4972  127E
4973  127F
4974  1280
4975  1281
4976  1282
4977  1283
4978  1284
4979  1285
4980  1286
4981  1287
4982  1288
4983  1289
4984  128A
4985  128B
4986  128C
4987  128D
4988  128E
4989  128F
4990  1290
4991  1291
4992  1292
4993  1293
4994  1294
4995  1295
4996  1296
4997  1297
4998  1298
4999  1299
5000  129A
5001  129B
5002  129C
5003  129D
5004  129E
5005  129F
5006  12A0
5007  12A1
5008  12A2
5009  12A3
5010  12A4
5011  12A5
5012  12A6
5013  12A7
5014  12A8
5015  12A9
5016  12AA
5017  12AB
5018  12AC
5019  12AD
5020  12AE
5021  12AF
5022  12B0
5023  12B1
5024  12B2
5025  12B3
5026  12B4
5027  12B5
5028  12B6
5029  12B7
5030  12B8
5031  12B9
5032  12BA
5033  12BB
5034  12BC
5035  12BD
5036  12BE
5037  12BF
5038  12C0
5039  12C1
5040  12C2
5041  12C3
5042  12C4
5043  12C5
5044  12C6
5045  12C7
5046  12C8
5047  12C9
5048  12CA
5049  12CB
5050  12CC
5051  12CD
5052  12CE
5053  12CF
5054  12D0
5055  12D1
5056  12D2
5057  12D3
5058  12D4
5059  12D5
5060  12D6
5061  12D7
5062  12D8
5063  12D9
5064  12DA
5065  12DB
5066  12DC
5067  12DD
5068  12DE
5069  12DF
5070  12E0
5071  12E1
5072  12E2
5073  12E3
5074  12E4
5075  12E5
5076  12E6
5077  12E7
5078  12E8
5079  12E9
5080  12EA
5081  12EB
5082  12EC
5083  12ED
5084  12EE
5085  12EF
5086  12F0
5087  12F1
5088  12F2
5089  12F3
5090  12F4
5091  12F5
5092  12F6
5093  12F7
5094  12F8
5095  12F9
5096  12FA
5097  12FB
5098  12FC
5099  12FD
5100  12FE
5101  12FF
5102  1300
5103  1301
5104  1302
5105  1303
5106  1304
5107  1305
5108  1306
5109  1307
5110  1308
5111  1309
5112  130A
5113  130B
5114  130C
5115  130D
5116  130E
5117  130F
5118  1310
5119  1311
5120  1312
5121  1313
5122  1314
5123  1315
5124  1316
5125  1317
5126  1318
5127  1319
5128  131A
5129  131B
5130  131C
5131  131D
5132  131E
5133  131F
5134  1320
5135  1321
5136  1322
5137  1323
5138  1324
5139  1325
5140  1326
5141  1327
5142  1328
5143  1329
5144  132A
5145  132B
5146  132C
5147  132D
5148  132E
5149  132F
5150  1330
5151  1331
5152  1332
5153  1333
5154  1334
5155  1335
5156  1336
5157  1337
5158  1338
5159  1339
5160  133A
5161  133B
5162  133C
5163  133D
5164  133E
5165  133F
5166  1340
5167  1341
5168  1342
5169  1343
5170  1344
5171  1345
5172  1346
5173  1347
5174  1348
5175  1349
5176  134A
5177  134B
5178  134C
5179  134D
5180  134E
5181  134F
5182  1350
5183  1351
5184  1352
5185  1353
5186  1354
5187  1355
5188  1356
5189  1357
5190  1358
5191  1359
5192  135A
5193  135B
5194  135C
5195  135D
5196  135E
5197  135F
5198  1360
5199  1361
5200  1362
5201  1363
5202  1364
5203  1365
5204  1366
5205  1367
5206  1368
5207  1369
5208  136A
5209  136B
5210  136C
5211  136D
5212  136E
5213  136F
5214  1370
5215  1371
5216  1372
5217  1373
5218  1374
5219  1375
5220  1376
5221  1377
5222  1378
5223  1379
5224  137A
5225  137B
5226  137C
5227  137D
5228  137E
5229  137F
5230  1380
5231  1381
5232  1382
5233  1383
5234  1384
5235  1385
5236  1386
5237  1387
5238  1388
5239  1389
5240  138A
5241  138B
5242  138C
5243  138D
5244  138E
5245  138F
5246  1390
5247  1391
5248  1392
5249  1393
5250  1394
5251  1395
5252  1396
5253  1397
5254  1398
5255  1399
5256  139A
5257  139B
5258  139C
5259  139D
5260  139E
5261  139F
5262  13A0
5263  13A1
5264  13A2
5265  13A3
5266  13A4
5267  13A5
5268  13A6
5269  13A7
5270  13A8
5271  13A9
5272  13AA
5273  13AB
5274  13AC
5275  13AD
5276  13AE
5277  13AF
5278  13B0
5279  13B1
5280  13B2
5281  13B3
5282  13B4
5283  13B5
5284  13B6
5285  13B7
5286  13B8
5287  13B9
5288  13BA
5289  13BB
5290  13BC
5291  13BD
5292  13BE
5293  13BF
5294  13C0
5295  13C1
5296  13C2
5297  13C3
5298  13C4
5299  13C5
5300  13C6
5301  13C7
5302  13C8
5303  13C9
5304  13CA
5305  13CB
5306  13CC
5307  13CD
5308  13CE
5309  13CF
5310  13D0
5311  13D1
5312  13D2
5313  13D3
5314  13D4
5315  13D5
5316  13D6
5317  13D7
5318  13D8
5319  13D9
5320  13DA
5321  13DB
5322  13DC
5323  13DD
5324  13DE
5325  13DF
5326  13E0
5327  13E1
5328  13E2
5329  13E3
5330  13E4
5331  13E5
5332  13E6
5333  13E7
5334  13E8
5335  13E9
5336  13EA
5337  13EB
5338  13EC
5339  13ED
5340  13EE
5341  13EF
5342  13F0
5343  13F1
5344  13F2
5345  13F3
5346  13F4
5347  13F5
5348  13F6
5349  13F7
5350  13F8
5351  13F9
5352  13FA
5353  13FB
5354  13FC
5355  13FD
5356  13FE
5357  13FF
5358  1400
5359  1401
5360  1402
5361  1403
5362  1404
5363  1405
5364  1406
5365  1407
5366  1408
5367  1409
5368  140A
5369  140B
5370  140C
5371  140D
5372  140E
5373  140F
5374  1410
5375  1411
5376  1412
5377  1413
5378  1414
5379  1415
5380  1416
5381  1417
5382  1418
5383  1419
5384  141A
5385  141B
5386  141C
5387  141D
5388  141E
5389  141F
5390  1420
5391  1421
5392  1422
5393  1423
5394  1424
5395  1425
5396  1426
5397  1427
5398  1428
5399  1429
5400  142A
5401  142B
5402  142C
5403  142D
5404  142E
5405  142F
5406  1430
5407  1431
5408  1432
5409  1433
5410  1434
5411  1435
5412  1436
5413  1437
5414  1438
5415  1439
5416  143A
5417  143B
5418  143C
5419  143D
5420  143E
5421  143F
5422  1440
5423  1441
5424  1442
5425  1443
5426  1444
5427  1445
5428  1446
5429  1447
5430  1448
5431  1449
5432  144A
5433  144B
5434  144C
5435  144D
5436  144E
5437  144F
5438  1450
5439  1451
5440  1452
5441  1453
5442  1454
5443  1455
5444  1456
5445  1457
5446  1458
5447  1459
5448  145A
5449  145B
5450  145C
5451  145D
5452  145E
5453  145F
5454  1460
5455  1461
5456  1462
5457  1463
5458  1464
5459  1465
5460  1466
5461  1467
5462  1468
5463  1469
5464  146A
5465  146B
5466  146C
5467  146D
5468  146E
5469  146F
5470  1470
5471  1471
5472  1472
5473  1473
5474  1474
5475  1475
5476  1476
5477  1477
5478  1478
5479  1479
5480  147A
5481  147B
5482  147C
5483  147D
5484  147E
5485  147F
5486  1480
5487  1481
5488  1482
5489  1483
5490  1484
5491  1485
5492  1486
5493  1487
5494  1488
5495  1489
5496  148A
5497  148B
5498  148C
5499  148D
5500  148E
5501  148F
5502  1490
5503  1491
5504  1492
5505  1493
5506  1494
5507  1495
5508  1496
5509  1497
5510  1498
5511  1499
5512  149A
5513  149B
5514  149C
5515  149D
5516  149E
5517  149F
5518  14A0
5519  14A1
5520  14A2
5521  14A3
5522  14A4
5523  14A5
5524  14A6
5525  14A7
5526  14A8
5527  14A9
5528  14AA
5529  14AB
5530  14AC
5531  14AD
5532  14AE
5533  14AF
5534  14B0
5535  14B1
5536  14B2
5537  14B3
5538  14B4
5539  14B5
5540  14B6
5541  14B7
5542  14B8
5543  14B9
5544  14BA
5545  14BB
5546  14BC
5547  14BD
5548  14BE
5549  14BF
5550  14C0
5551  14C1
5552  14C2
5553  14C3
5554  14C4
5555  14C5
5556  14C6
5557  14C7
5558  14C8
5559  14C9
5560  14CA
5561  14CB
5562  14CC
5563  14CD
5564  14CE
5565  14CF
5566  14D0
5567  14D1
5568  14D2
5569  14D3
5570  14D4
5571  14D5
5572  14D6
5573  14D7
5574  14D8
5575  14D9
5576  14DA
5577  14DB
5578  14DC
5579  14DD
5580  14DE
5581  14DF
5582  14E0
5583  14E1
5584  14E2
5585  14E3
5586  14E4
5587  14E5
5588  14E6
5589  14E7
5590  14E8
5591  14E9
5592  14EA
5593  14EB
5594  14EC
5595  14ED
5596  14EE
5597  14EF
5598  14F0
5599  14F1
5600  14F2
5601  14F3
5602  14F4
5603  14F5
5604  14F6
5605  14F7
5606  14F8
5607  14F9
5608  14FA
5609  14FB
5610  14FC
5611  14FD
5612  14FE
5613  14FF
5614  1500
5615  1501
5616  1502
5617  1503
5618  1504
5619  1505
5620  1506
5621  1507
5622  1508
5623  1509
5624  150A
5625  150B
5626  150C
5627  150D
5628  150E
5629  150F
5630  1510
5631  1511
5632  1512
5633  1513
5634  1514
5635  1515
5636  1516
5637  1517
5638  1518
5639  1519
5640  151A
5641  151B
5642  151C
5643  151D
5644  151E
5645  151F
5646  1520
5647  1521
5648  1522
5649  1523
5650  1524
5651  1525
5652  1526
5653  1527
5654  1528
5655  1529
5656  152A
5657  152B
5658  152C
5659  152D
5660  152E
5661  152F
5662  1530
5663  1531
5664  1532
5665  1533
5666  1534
5667  1535
5668  1536
5669  1537
5670  1538
5671  1539
5672  153A
5673  153B
5674  153C
5675  153D
5676  153E
5677  153F
5678  1540
5679  1541
5680  1542
5681  1543
5682  1544
5683  1545
5684  1546
5685  1547
5686  1548
5687  1549
5688  154A
5689  154B
5690  154C
5691  154D
5692  154E
5693  154F
5694  1550
5695  1551
5696  1552
5697  1553
5698  1554
5699  1555
5700  1556
5701  1557
5702  1558
5703  1559
5704  155A
5705  155B
5706  155C
5707  155D
5708  155E
5709  155F
5710  1560
5711  1561
5712  1562
5713  1563
5714  1564
5715  1565
5716  1566
5717  1567
5718  1568
5719  1569
5720  156A
5721  156B
5722  156C
5723  156D
5724  156E
5725  156F
5726  1570
5727  1571
5728  1572
5729  1573
5730  1574
5731  1575
5732  1576
5733  1577
5734  1578
5735  1579
5736  157A
5737  157B
5738  157C
5739  157D
5740  157E
5741  157F
5742  1580
5743  1581
5744  1582
5745  1583
5746  1584
5747  1585
5748  1586
5749  1587
5750  1588
5751  1589
5752  158A
5753  158B
5754  158C
5755  158D
5756  158E
5757  158F
5758  1590
5759  1591
5760  1592
5761  1593
5762  1594
5763  1595
5764  1596
5765  1597
5766  1598
5767  1599
5768  159A
5769  159B
5770  159C
5771  159D
5772  159E
5773  159F
5774  15A0
5775  15A1
5776  15A2
5777  15A3
5778  15A4
5779  15A5
5780  15A6
5781  15A7
5782  15A8
5783  15A9
5784  15AA
5785  15AB
5786  15AC
5787  15AD
5788  15AE
5789  15AF
5790  15B0
5791  15B1
5792  15B2
5793  15B3
5794  15B4
5795  15B5
5796  15B6
5797  15B7
5798  15B8
5799  15B9
5800  15BA
5801  15BB
5802  15BC
5803  15BD
5804  15BE
5805  15BF
5806  15C0
5807  15C1
5808  15C2
5809  15C3
5810  15C4
5811  15C5
5812  15C6
5813  15C7
5814  15C8
5815  15C9
5816  15CA
5817  15CB
5818  15CC
5819  15CD
5820  15CE
5821  15CF
5822  15D0
5823  15D1
5824  15D2
5825  15D3
5826  15D4
5827  15D5
5828  15D6
5829  15D7
5830  15D8
5831  15D9
5832  15DA
5833  15DB
5834  15DC
5835  15DD
5836  15DE
5837  15DF
5838  15E0
5839  15E1
5840  15E2
5841  15E3
5842  15E4
5843  15E5
5844  15E6
5845  15E7
5846  15E8
5847  15E9
5848  15EA
5849  15EB
5850  15EC
5851  15ED
5852  15EE
5853  15EF
5854  15F0
5855  15F1
5856  15F2
5857  15F3
5858  15F4
5859  15F5
5860  15F6
5861  15F7
5862  15F8
5863  15F9
5864  15FA
5865  15FB
5866  15FC
5867  15FD
5868  15FE
5869  15FF
5870  1600
5871  1601
5872  1602
5873  1603
5874  1604
5875  1605
5876  1606
5877  1607
5878  1608
5879  1609
5880  160A
5881  160B
5882  160C
5883  160D
5884  160E
5885  160F
5886  1610
5887  1611
5888  1612
5889  1613
5890  1614
5891  1615
5892  1616
5893  1617
5894  1618
5895  1619
5896  161A
5897  161B
5898  161C
5899  161D
5900  161E
5901  161F
5902  1620
5903  1621
5904  1622
5905  1623
5906  1624
5907  1625
5908  1626
5909  1627
5910  1628
5911  1629
5912  162A
5913  162B
5914  162C
5915  162D
5916  162E
5917  162F
5918  1630
5919  1631
5920  1632
5921  1633
5922  1634
5923  1635
5924  1636
5925  1637
5926  1638
5927  1639
5928  163A
5929  163B
5930  163C
5931  163D
5932  163E
5933  163F
5934  1640
5935  1641
5936  1642
5937  1643
5938  1644
5939  1645
5940  1646
5941  1647
5942  1648
5943  1649
5944  164A
5945  164B
5946  164C
5947  164D
5948  164E
5949  164F
5950  1650
5951  1651
5952  1652
5953  1653
5954  1654
5955  1655
5956  1656
5957  1657
5958  1658
5959  1659
5960  165A
5961  165B
5962  165C
5963  165D
5964  165E
5965  165F
5966  1660
5967  1661
5968  1662
5969  1663
5970  1664
5971  1665
5972  1666
5973  1667
5974  1668
5975  1669
5976  166A
5977  166B
5978  166C
5979  166D
5980  166E
5981  166F
5982  1670
5983  1671
5984  1672
5985  1673
5986  1674
5987  1675
5988  1676
5989  1677
5990  1678
5991  1679
5992  167A
5993  167B
5994  167C
5995  167D
5996  167E
5997  167F
5998  1680
5999  1681
6000  1682
6001  1683
6002  1684
6003  1685
6004  1686
6005  1687
6006  1688
6007  1689
6008  168A
6009  168B
6010  168C
6011  168D
6012  168E
6013  168F
6014  1690
6015  1691
6016  1692
6017  1693
6018  1694
6019  1695
6020  1696
6021  1697
6022  1698
6023  1699
6024  169A
6025  169B
6026  169C
6027  169D
6028  169E
6029  169F
6030  16A0
6031  16A1
6032  16A2
6033  16A3
6034  16A4
6035  16A5
6036  16A6
6037  16A7
6038  16A8
6039  16A9
6040  16AA
6041  16AB
6042  16AC
6043  16AD
6044  16AE
6045  16AF
6046  16B0
6047  16B1
6048  16B2
6049  16B3
6050  16B4
6051  16B5
6052  16B6
6053  16B7
6054  16B8
6055  16B9
6056  16BA
6057  16BB
6058  16BC
6059  16BD
6060  16BE
6061  16BF
6062  16C0
6063  16C1
6064  16C2
6065  16C3
6066  16C4
6067  16C5
6068  16C6
6069  16C7
6070  16C8
6071  16C9
6072  16CA
6073  16CB
6074  16CC
6075  16CD
6076  16CE
6077  16CF
6078  16D0
6079  16D1
6080  16D2
6081  16D3
6082  16D4
6083  16D5
6084  16D6
6085  16D7
6086  16D8
6087  16D9
6088  16DA
6089  16DB
6090  16DC
6091  16DD
6092  16DE
6093  16DF
6094  16E0
6095  16E1
6096  16E2
6097  16E3
6098  16E4
6099  16E5
6100  16E6
6101  16E7
6102  16E8
6103  16E9
6104  16EA
6105  16EB
6106  16EC
6107  16ED
6108  16EE
6109  16EF
6110  16F0
6111  16F1
6112  16F2
6113  16F3
6114  16F4
6115  16F5
6116  16F6
6117  16F7
6118  16F8
6119  16F9
6120  16FA
6121  16FB
6122  16FC
6123  16FD
6124  16FE
6125  16FF
6126  1700
6127  1701
6128  1702
6129  1703
6130  1704
6131  1705
6132  1706
6133  1707
6134  1708
6135  1709
6136  170A
6137  170B
6138  170C
6139  170D
6140  170E
6141  170F
6142  1710
6143  1711
6144  1712
6145  1713
6146  1714
6147  1715
6148  1716
6149  1717
6150  1718
6151  1719
6152  171A
6153  171B
6154  171C
6155  171D
6156  171E
6157  171F
6158  1720
6159  1721
6160  1722
6161  1723
6162  1724
6163  1725
6164  1726
6165  1727
6166  1728
6167  1729
6168  172A
6169  172B
6170  172C
6171  172D
6172  172E
6173  172F
6174  1730
6175  1731
6176  1732
6177  1733
6178  1734
6179  1735
6180  1736
6181  1737
6182  1738
6183  1739
6184  173A
6185  173B
6186  173C
6187  173D
6188  173E
6189  173F
6190  1740
6191  1741
6192  1742
6193  1743
6194  1744
6195  1745
6196  1746
6197  1747
6198  1748
6199  1749
6200  174A
6201  174B
6202  174C
6203  174D
6204  174E
6205  174F
6206  1750
6207  1751
6208  1752
6209  1753
6210  1754
6211  1755
6212  1756
6213  1757
6214  1758
6215  1759
6216  175A
6217  175B
6218  175C
6219  175D
6220  175E
6221  175F
6222  1760
6223  1761
6224  1762
6225  1763
6226  1764
6227  1765
6228  1766
6229  1767
6230  1768
6231  1769
6232  176A
6233  176B
6234  176C
6235  176D
6236  176E
6237  176F
6238  1770
6239  1771
6240  1772
6241  1773
6242  1774
6243  1775
6244  1776
6245  1777
6246  1778
6247  1779
6248  177A
6249  177B
6250  177C
6251  177D
6252  177E
6253  177F
6254  1780
6255  1781
6256  1782
6257  1783
6258  1784
6259  1785
6260  1786
6261  1787
6262  1788
6263  1789
6264  178A
6265  178B
6266  178C
6267  178D
6268  178E
006269  000381        
006270  000382  var stringsCV[24] := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], hstrings ;
6271  0C0D
6272  0C0E
6273  0C0F
6274  0C10
6275  0C11
6276  0C12
6277  0C13
6278  0C14
6279  0C15
6280  0C16
6281  0C17
6282  0C18
6283  0C19
6284  0C1A
6285  0C1B
6286  0C1C
6287  0C1D
6288  0C1E
6289  0C1F
6290  0C20
6291  0C21
6292  0C22
6293  0C23
6294  0C24
6295  0C25
6296  0C26
6297  0C27
6298  0C28
6299  0C29
6300  0C2A
6301  0C2B
6302  0C2C
6303  0C2D
6304  0C2E
6305  0C2F
6306  0C30
6307  0C31
6308  0C32
6309  0C33
6310  0C34
6311  0C35
6312  0C36
6313  0C37
6314  0C38
6315  0C39
6316  0C3A
6317  0C3B
6318  0C3C
006319  000383  var dKeyboard[1], ActiveKeyboard ;
006320  000384  // Start P2.inc
006321  000385  var oObjects[MaxTotObjects+1] ;                 // address of objects
006322  000386  var CurrentForm, oldn, ImageTouched ;
006323  000387  var TouchXpos, TouchYpos ;
006324  000388  var GObjectType, TouchState, CurInputData, pInputIndex ;
006325  000389  var comRX[40], cmd[CMDLenMAX] ;
006326  000390        
006327  000391  var InputCS, OutputCS ;
006328  000392        
006329  000393  // > ? Constant/Global/Data ? <
006330  000394        
006331  000395  func seroutCS(var op)
006332  000396      serout(op) ;
006333  000397      OutputCS ^= op ;
006334  000398  endfunc
006335  000399        
006336  000400  func nak0()
006337  000401      serout(NAK) ;
006338  000402      InputCS := 0 ;
006339  000403  endfunc
006340  000404        
006341  000405  func seroutOcs()
006342  000406      serout(OutputCS) ;
006343  000407      OutputCS := 0 ;
006344  000408  endfunc
006345  000409        
006346  000410  func SendReport(var id, var objt, var objn, var val)
006347  000411      seroutCS(id) ;
006348  000412      seroutCS(objt) ;
006349  000413      seroutCS(objn) ;
006350  000414      seroutCS(val >> 8) ; // first 8 bits
006351  000415      seroutCS(val) ;
006352  000416      seroutOcs() ;
006353  000417  endfunc
006354  000418        
006355  000419        
006356  000420  func ReadObject(var ObjectType, var ObjectIdx)
006357  000421      var j, k, Objects ;
006358  000422      Objects := *(oObjects+ObjectType) ;
006359  000423        
006360  000424      j := 2 + ObjectIdx * 2 + Objects ;
006361  000425       if (ObjectType == tForm)
006362  000426          k := CurrentForm ;
006363  000427      else if (ObjectType == tStrings)
006364  000428          k := stringsCV[ObjectIdx];
006365  000429          else
006366  000430          k := img_GetWord(hndl, *j, IMAGE_INDEX);
006367  000431          if (((ObjectType == tWinButton) || (ObjectType == tAniButton) || (ObjectType == tUserButton) || (ObjectType == t4Dbutton)) && (k)) k := 1 ; // this is not correct for blocked buttons and cannot be fixed as we cannot
006368  000432                                                                                                                                                      // determine if button is momentary or not which is needed for correct answer.
006369  000433      endif
006370  000434      SendReport(REPORT_OBJ, ObjectType, ObjectIdx, k) ;
006371  000435  endfunc
006372  000436        
006373  000437        
006374  000438  func WriteObject(var ObjectType, var ObjectIdx, var NewVal)
006375  000439      var i, j, k, Objects ;
006376  000440      ObjectType &= 0x3f ;
006377  000441      if (ObjectType == tForm)
006378  000442          ActivateForm(ObjectIdx) ;
006379  000443      else
006380  000444          Objects := *(oObjects+ObjectType)+ObjectIdx*2+2 ;
006381  000445          i := *(Objects) ;
006382  000446          switch (ObjectType)
006383  000447              case tWinButton :
006384  000448                  j := InputControls[oWinButtons[ObjectIdx+1]] ;
006385  000449                  break ;
006386  000450              case t4Dbutton :
006387  000451                  j := InputControls[o4Dbuttons[ObjectIdx+1]] ;
006388  000452                  break ;
006389  000453              default : j := -1 ;
006390  000454          endswitch
006391  000455          if (j != -1)
006392  000456              k := img_GetWord(hndl, i , IMAGE_INDEX) ;
006393  000457              NewVal := NewVal << 1 ;
006394  000458              if (OVF())      // button group index change
006395  000459                  if (*(j+InputData+Ofs_IPD_P1))
006396  000460                      k &= 1 ;    // mask off old group index for momentary
006397  000461                  else
006398  000462                      k &= 3 ;    // mask off old group index for toggle
006399  000463                  endif
006400  000464              else            // normal set
006401  000465                  if (*(j+InputData+Ofs_IPD_P2) != -1) TurnOffButtons(*(j+InputData+Ofs_IPD_P2)) ;
006402  000466                  k &= 0xfffc ;    // retain only group index for state set
006403  000467              endif
006404  000468              NewVal |= k ;
006405  000469          endif
006406  000470           if (ObjectType == tStrings)
006407  000471              PrintStrings(ObjectIdx, NewVal, 0);
006408  000472          else
006409  000473              img_SetWord(hndl, i , IMAGE_INDEX, NewVal); // where state is 0 to 2
006410  000474              img_Show(hndl, i) ; // will only display if form is current
006411  000475          endif
006412  000476      endif
006413  000477  endfunc
006414  000478        
006415  000479  func TurnOffButtons(var group)
006416  000480      var j, k, l;
006417  000481      for (j := 0; j < nInputs; j++)
006418  000482          k := j*IPDatasize ;
006419  000483          if (*(InputData+k+Ofs_IPD_P2) == group)
006420  000484              l := -1 ;
006421  000485               if (*(InputData+k) == t4Dbutton)
006422  000486                  l := o4Dbuttons[*(InputData+k+Ofs_IPD_OBJVIDX)/2] ;
006423  000487                  img_SetWord(hndl, l, IMAGE_INDEX, 0);
006424  000488                  img_Show(hndl, l);      // only shows on current form
006425  000489              else if (*(InputData+k) == tWinButton)
006426  000490                  l := oWinButtons[*(InputData+k+Ofs_IPD_OBJVIDX)/2] ;
006427  000491                  img_SetWord(hndl, l, IMAGE_INDEX, 0);
006428  000492                  img_Show(hndl, l);      // only shows on current form
006429  000493              endif
006430  000494          endif
006431  000495      next
006432  000496  endfunc
006433  000497        
006434  000498        
006435  000499        
006436  000500        
006437  000501  func ActivateForm(var newform)
006438  000502      var i, j, *p ;
006439  000503        
006440  000504      if (CurrentForm != -1) // deactivate old form, by disabling all inputs
006441  000505          for (i := FormStartIndex[CurrentForm]; i <= FormEndIndex[CurrentForm]; i++)
006442  000506              if (img_GetWord(hndl, i, IMAGE_TAG))
006443  000507                  img_Disable(hndl,i) ;
006444  000508              endif
006445  000509          next
006446  000510      endif
006447  000511      CurrentForm := newform ;
006448  000512      // display newform image or clear to image color
006449  000513      if (FormBGcolors[CurrentForm] != ColorBGimage)
006450  000514          gfx_Set(BACKGROUND_COLOUR,FormBGcolors[CurrentForm]);
006451  000515          gfx_Cls() ;
006452  000516          DoGFXObjects() ;                                    // display GFX 'widgets'
006453  000517      endif
006454  000518        
006455  000519      // enable inputs
006456  000520      for (i := FormStartIndex[CurrentForm]; i < FormEndIndex[CurrentForm]; i++)
006457  000521          j := img_GetWord(hndl, i, IMAGE_TAG) ;
006458  000522          if (j)
006459  000523              j-- ;
006460  000524              img_SetAttributes(hndl, i, I_STAYONTOP+I_ENABLED);        // make sure this is on top of form, if applicable
006461  000525              //if (j != tKeyboard)
006462  000526              if ((j <= tWinButton) || (j >= t4Dbutton) )               // enable inputs
006463  000527                  img_ClearAttributes(hndl, i, I_TOUCH_DISABLE);        // ensure touch is enabled
006464  000528              endif
006465  000529              img_Show(hndl,i) ; // show initialy, if required
006466  000530              if (j == tForm)
006467  000531                  DoGFXObjects() ;                                    // display GFX 'widgets' for image backgruobds
006468  000532              endif
006469  000533          endif
006470  000534      next
006471  000535      for (i := 0; i < nStrings; i++)
006472  000536          if (stringsCV[i] != -1)
006473  000537              WriteObject(tStrings, i, stringsCV[i]) ;
006474  000538          endif
006475  000539      next
006476  000540        
006477  000541  endfunc
006478  000542        
006479  000543  func UpdateObjects(var newval)
006480  000544      var IPidx, otherOBJ ;
006481  000545      if ( ( img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) != newval) || (TouchState == Ofs_IPD_RELEASE) ) // only bother if values changed, or release
006482  000546        
006483  000547          img_SetWord(hndl, *(pInputIndex), IMAGE_INDEX, newval);
006484  000548              img_Show(hndl, *(pInputIndex));      // only shows on current form
006485  000549          if ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))
006486  000550              if (*(CurInputData+Ofs_IPD_P1))
006487  000551                  newval &= 1;
006488  000552              else
006489  000553                  newval &= 3;
006490  000554              endif
006491  000555              if (newval > 1) newval := 1;
006492  000556          endif
006493  000557          IPidx := *(CurInputData+TouchState) ;
006494  000558          while(IPidx != 0)
006495  000559              otherOBJ := IPidx + InputData;
006496  000560              if (*(otherOBJ) == OT_REPORT)
006497  000561          SendReport(REPORT_EVENT, GObjectType, *(otherOBJ+Ofs_IPD_OBJVIDX), newval) ;
006498  000562              else if (*(otherOBJ) == OT_MAGIC)
006499  000563                  IPidx := *(otherOBJ+Ofs_IPD_P5) ;
006500  000564                  IPidx(newval) ;
006501  000565              else if (TouchState == *(otherOBJ+Ofs_IPD_P4))
006502  000566                  if (*(otherOBJ) == OT_ACTIVATE)
006503  000567                      ActivateForm(*(otherOBJ+Ofs_IPD_P2) ) ;
006504  000568                      GObjectType := tForm ;
006505  000569                  else if (*(otherOBJ) == OT_SETCONST)
006506  000570                      newval := *(otherOBJ+Ofs_IPD_P3) ;
006507  000571                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
006508  000572                  else if (*(otherOBJ) == OT_SETANOTHER)
006509  000573                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
006510  000574                  else if (*(otherOBJ) == OT_PREVFRAME)
006511  000575                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX))
006512  000576                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)-1) ;
006513  000577                      endif
006514  000578                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
006515  000579                  else if (*(otherOBJ) == OT_NEXTFRAME)
006516  000580                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) < *(otherOBJ+Ofs_IPD_P3))
006517  000581                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)+1) ;
006518  000582                      endif
006519  000583                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
006520  000584                  else if (*(otherOBJ) == OT_PREVSTRING)
006521  000585                      if (stringsCV[*(otherOBJ+Ofs_IPD_P2)])
006522  000586                          WriteObject(tStrings,*(otherOBJ+Ofs_IPD_P2),stringsCV[*(otherOBJ+Ofs_IPD_P2)]-1) ;
006523  000587                      endif
006524  000588                  else if (*(otherOBJ) == OT_NEXTSTRING)
006525  000589                      if (stringsCV[*(otherOBJ+Ofs_IPD_P2)] < *(otherOBJ+Ofs_IPD_P3)) // fix IPD_P2 not filled in yet
006526  000590                          WriteObject(tStrings,*(otherOBJ+Ofs_IPD_P2),stringsCV[*(otherOBJ+Ofs_IPD_P2)]+1) ;
006527  000591                      endif
006528  000592                  endif
006529  000593              endif
006530  000594              IPidx := *(otherOBJ+TouchState) ;
006531  000595          wend
006532  000596      endif
006533  000597  endfunc
006534  000598        
006535  000599  // End P2.inc
006536  000600  func DoGFXObjects()
006537  000601      switch (CurrentForm)
006538  000602          case 4:
006539  000603              gfx_Line(0, 48, 320, 48, SLATEGRAY) ;
006540  000604              gfx_Line(0, 96, 320, 96, SLATEGRAY) ;
006541  000605              gfx_Line(0, 144, 320, 144, SLATEGRAY) ;
006542  000606              gfx_Line(0, 192, 320, 192, SLATEGRAY) ;
006543  000607          break ;
006544  000608          case 5:
006545  000609              gfx_Line(0, 48, 320, 48, SLATEGRAY) ;
006546  000610              gfx_Line(0, 96, 320, 96, SLATEGRAY) ;
006547  000611              gfx_Line(0, 144, 320, 144, SLATEGRAY) ;
006548  000612              gfx_Line(0, 192, 320, 192, SLATEGRAY) ;
006549  000613          break ;
006550  000614          case 9:
006551  000615              gfx_Line(0, 106, 320, 106, 0xFFFF) ;
006552  000616              gfx_OutlineColour(WHITE) ;
006553  000617              gfx_LinePattern(LPSOLID) ;
006554  000618              gfx_Rectangle(9, 0, 143, 101, 0xFFFF) ;
006555  000619              gfx_OutlineColour(BLACK) ;
006556  000620              gfx_LinePattern(LPSOLID) ;
006557  000621          break ;
006558  000622      endswitch
006559  000623  endfunc
006560  000624        
006561  000625  // Start P3.inc
006562  000626  func main()
006563  000627      var comTX[50], cmdi, i, j, TouchStatus ;
006564  000628        
006565  000629      ActiveKeyboard := -1 ;
006566  000630        
006567  000631      gfx_ScreenMode(LANDSCAPE_R) ;
006568  000632        
006569  000633      putstr("Mounting...\n");
006570  000634      if (!(file_Mount()))
006571  000635          while(!(file_Mount()))
006572  000636              putstr("Drive not mounted...");
006573  000637              pause(200);
006574  000638              gfx_Cls();
006575  000639              pause(200);
006576  000640          wend
006577  000641      endif
006578  000642  //    gfx_MoveTo(0, 0);
006579  000643  //    print(mem_Heap()," ") ;
006580  000644  //    gfx_TransparentColour(0x0020);
006581  000645  //    gfx_Transparency(ON);
006582  000646        
006583  000647      // open image control
006584  000648      hndl := file_LoadImageControl("resp_box.dat", "resp_box.gci", 1);
006585  000649        
006586  000650      // init 'constants'
006587  000651  // End P3.inc
006588  000652        
006589  000653      oObjects[tDipSwitch] := oDipSwitchs ; // dummy as no object there
006590  000654      oObjects[tKnob] := oDipSwitchs ; // dummy as no object there
006591  000655      oObjects[tRockerSwitch] := oDipSwitchs ; // dummy as no object there
006592  000656      oObjects[tRotarySwitch] := oDipSwitchs ; // dummy as no object there
006593  000657      oObjects[tGSlider] := oDipSwitchs ; // dummy as no object there
006594  000658      oObjects[tTrackbar] := oDipSwitchs ; // dummy as no object there
006595  000659      oObjects[tWinButton] := oWinButtons ;
006596  000660      oObjects[tAngularmeter] := oDipSwitchs ; // dummy as no object there
006597  000661      oObjects[tCoolgauge] := oDipSwitchs ; // dummy as no object there
006598  000662      oObjects[tCustomdigits] := oDipSwitchs ; // dummy as no object there
006599  000663      oObjects[tForm] := oForms ;
006600  000664      oObjects[tGauge] := oDipSwitchs ; // dummy as no object there
006601  000665      oObjects[tImage] := oDipSwitchs ; // dummy as no object there
006602  000666      oObjects[tKeyboard] := oKeyboards ;
006603  000667      oObjects[tLed] := oDipSwitchs ; // dummy as no object there
006604  000668      oObjects[tLeddigits] := oDipSwitchs ; // dummy as no object there
006605  000669      oObjects[tMeter] := oDipSwitchs ; // dummy as no object there
006606  000670      oObjects[tStrings] := oStringss ;
006607  000671      oObjects[tThermometer] := oDipSwitchs ; // dummy as no object there
006608  000672      oObjects[tUserled] := oUserleds ;
006609  000673      oObjects[tVideo] := oDipSwitchs ; // dummy as no object there
006610  000674      oObjects[tStaticText] := oStaticTexts ;
006611  000675      oObjects[tSounds] := oDipSwitchs ; // dummy as no object there
006612  000676      oObjects[tTimer] := oDipSwitchs ; // dummy as no object there
006613  000677      oObjects[tSpectrum] := oDipSwitchs ; // dummy as no object there
006614  000678      oObjects[tTank] := oDipSwitchs ; // dummy as no object there
006615  000679      oObjects[tUserImages] := oUserImagess ;
006616  000680      oObjects[tPinOutput] := oDipSwitchs ; // dummy as no object there
006617  000681      oObjects[tPinInput] := oDipSwitchs ; // dummy as no object there
006618  000682      oObjects[t4Dbutton] := o4Dbuttons ;
006619  000683      oObjects[tAniButton] := oDipSwitchs ; // dummy as no object there
006620  000684      oObjects[tColorPicker] := oDipSwitchs ; // dummy as no object there
006621  000685      oObjects[tUserButton] := oDipSwitchs ; // dummy as no object there
006622  000686      hFonts[0] := file_LoadImageControl("resp_box.d01", "resp_box.g01", 1)  ;
006623  000687      hFonts[10] := file_LoadImageControl("resp_box.d0H", "resp_box.g0H", 1)  ;
006624  000688      hFonts[12] := FONT3 ;
006625  000689      hFonts[13] := FONT3 ;
006626  000690      hFonts[18] := FONT3 ;
006627  000691      hFonts[19] := FONT3 ;
006628  000692      hFonts[20] := file_LoadImageControl("resp_box.d03", "resp_box.g03", 1)  ;
006629  000693      hFonts[22] := FONT3 ;
006630  000694      hFonts[23] := file_LoadImageControl("resp_box.d0J", "resp_box.g0J", 1)  ;
006631  000695      hFonts[1] := hFonts[0] ;
006632  000696      hFonts[2] := hFonts[20] ;
006633  000697      hFonts[3] := hFonts[20] ;
006634  000698      hFonts[4] := hFonts[20] ;
006635  000699      hFonts[5] := hFonts[20] ;
006636  000700      hFonts[6] := hFonts[20] ;
006637  000701      hFonts[7] := hFonts[20] ;
006638  000702      hFonts[8] := hFonts[20] ;
006639  000703      hFonts[9] := hFonts[20] ;
006640  000704      hFonts[11] := hFonts[0] ;
006641  000705      hFonts[14] := hFonts[0] ;
006642  000706      hFonts[15] := hFonts[0] ;
006643  000707      hFonts[16] := hFonts[0] ;
006644  000708      hFonts[17] := hFonts[0] ;
006645  000709      hFonts[21] := hFonts[20] ;
006646  000710      dKeyboard[0] := oKeyboard0 ;
006647  000711  // Start P4.inc
006648  000712      hstrings := file_Open("resp_box.txf", 'r') ; // Open handle to access uSD strings, uncomment if required
006649  000713      // init comms
006650  000714      com_Init(comRX,CMDLenMAX,0);
006651  000715      com_SetBaud(COM0,11520);
006652  000716      com_TXbuffer(comTX, 100, 0);
006653  000717      // tag 'real' objects
006654  000718      for (i := 0; i <= MaxTotObjects; i++)
006655  000719          if (   (i != tSounds)
006656  000720              && (i != tTimer)
006657  000721              && (i != tPinOutput)
006658  000722              && (i != tPinInput) )
006659  000723              TouchXpos := oObjects[i] ;
006660  000724              TouchYpos := *(TouchXpos) ;
006661  000725              for (ImageTouched := 1; ImageTouched <= TouchYpos; ImageTouched++)
006662  000726                  oldn := *(TouchXpos+ImageTouched*2) ;
006663  000727                  img_SetAttributes(hndl, oldn, I_TOUCH_DISABLE);  // ensure touch is enabled
006664  000728                  if (oldn != -1)
006665  000729                      img_SetWord(hndl, oldn, IMAGE_TAG, i+1);
006666  000730                      img_Disable(hndl, oldn) ;
006667  000731                  endif
006668  000732              next
006669  000733          endif
006670  000734      next
006671  000735        
006672  000736      for (i := 0; i < nKeyboards; i++) // for each kb key, set tag to -1
006673  000737          if (oKeyboards[i+1] != -1)               // if keyboard exists
006674  000738              for(ImageTouched := oKeyboards[i+1]+1; ImageTouched <= oKeyboards[i+1]+*(dKeyboard[i] + Ofs_kb_Buttons); ImageTouched++)
006675  000739                  img_SetWord(hndl, ImageTouched, IMAGE_TAG, -1);
006676  000740              next
006677  000741          endif
006678  000742      next
006679  000743      // display initial form
006680  000744      CurrentForm := -1 ;
006681  000745  // End P4.inc
006682  000746  // Start P5.inc
006683  000747      ActivateForm(0) ; // need to change this according to first actual form
006684  000748        
006685  000749  // End P5.inc
006686  000750  // Start P6.inc Picaso
006687  000751      touch_Set(TOUCH_ENABLE);                            // enable the touch screen
006688  000752      oldn := -1 ;
006689  000753      repeat
006690  000754        
006691  000755          // check comms for command, how to NAK invalid command
006692  000756          if (com_Count() != 0)
006693  000757              i := serin() ;
006694  000758              InputCS ^= i ;               // update checksum
006695  000759              if (   (cmdi > 2)
006696  000760                  && (cmd[0] == WRITE_STRU) )
006697  000761                  j := (cmdi-1) >> 1 + 2 ;
006698  000762                  if (j == CMDLenMAX)    // max length exceeded
006699  000763                      nak0() ;
006700  000764                      cmdi := -1 ;
006701  000765                  else if (cmdi & 1)
006702  000766                      cmd[j] := i ;
006703  000767                      if (cmd[2] == 0)    // if string complete
006704  000768                          if (InputCS)
006705  000769                              nak0() ;
006706  000770                          else
006707  000771                              if (cmd[0] == WRITE_STRU)
006708  000772                              cmd[j] := 0 ;                     // terminate it
006709  000773                              PrintStrings(cmd[1], &cmd[3], 1) ;
006710  000774                              serout(ACK) ;
006711  000775                              else
006712  000776                              endif
006713  000777                          endif
006714  000778                          cmdi := -1 ;
006715  000779                      endif
006716  000780                  else
006717  000781                      cmd[j] := cmd[j] << 8 + i ;
006718  000782                      cmd[2]-- ;          // dec length
006719  000783                  endif
006720  000784                  cmdi++ ;
006721  000785              else // not unicode string
006722  000786                  cmd[cmdi++] := i ;
006723  000787                   if (cmd[0] == WRITE_STR)                  // Ansi String
006724  000788                      if (cmdi == CMDLenMAX)      // max length exceeded
006725  000789                          nak0() ;
006726  000790                          cmdi := 0 ;
006727  000791                      else if (cmdi > 2)
006728  000792                          if (cmd[2] == -1)
006729  000793                              if (InputCS)
006730  000794                                  nak0() ;
006731  000795                              else
006732  000796                                  if (cmd[0] == WRITE_STR)
006733  000797                                  cmd[cmdi-1] := 0 ;                     // terminate it
006734  000798                                  PrintStrings(cmd[1], &cmd[3], 1) ;
006735  000799                                  serout(ACK) ;
006736  000800                                  else
006737  000801                                  endif
006738  000802                              endif
006739  000803                              cmdi := 0 ;
006740  000804                          else
006741  000805                              cmd[2]-- ;          // dec length
006742  000806                          endif
006743  000807                      endif
006744  000808                  else if (   (cmd[0] == READ_OBJ)
006745  000809                           && (cmdi == 4)         )
006746  000810                      if (InputCS)
006747  000811                          nak0() ;
006748  000812                      else
006749  000813                          ReadObject(cmd[1], cmd[2]) ;
006750  000814                      endif
006751  000815                      cmdi := 0 ;
006752  000816                  else if (   (cmd[0] == WRITE_OBJ)    // 6 byte write command (gen option)
006753  000817                           && (cmdi == 6)          )
006754  000818                      if (InputCS)
006755  000819                          nak0() ;
006756  000820                      else
006757  000821                          WriteObject(cmd[1], cmd[2], cmd[3] << 8 + cmd[4]) ;
006758  000822                          serout(ACK) ;
006759  000823                      endif
006760  000824                      cmdi := 0 ;
006761  000825                  else if (   (cmd[0] == WRITE_CONTRAST)
006762  000826                           && (cmdi == 3)         )
006763  000827                      if (InputCS)
006764  000828                          nak0() ;
006765  000829                      else
006766  000830                          gfx_Contrast(cmd[1]) ;
006767  000831                          serout(ACK) ;
006768  000832                      endif
006769  000833                      cmdi := 0 ;
006770  000834                  else if (cmdi == 6)    // we have 6 bytes and we've gotten here -> something wrong
006771  000835                      nak0() ;
006772  000836                      cmdi := 0 ;
006773  000837                  endif
006774  000838              endif   // not unicode string
006775  000839          endif   // a character is available
006776  000840        
006777  000841        
006778  000842      // touch code processing
006779  000843        
006780  000844          TouchStatus := touch_Get(TOUCH_STATUS);               // get touchscreen status
006781  000845          ImageTouched := img_Touched(hndl,-1) ;
006782  000846          if ((TouchStatus == TOUCH_PRESSED) || (TouchStatus == TOUCH_RELEASED) || (TouchStatus == TOUCH_MOVING))
006783  000847              if ((TouchStatus != TOUCH_RELEASED) && (ImageTouched != oldn) && (oldn != -1))
006784  000848                  TouchStatus := TOUCH_RELEASED ;       // simulate release if we move off object
006785  000849              endif
006786  000850              if (TouchStatus != TOUCH_RELEASED)        // if not released
006787  000851                  if (oldn != -1)
006788  000852                      ImageTouched := oldn ;
006789  000853                  else
006790  000854                      if (oldn != ImageTouched)
006791  000855                  oldn := ImageTouched ;
006792  000856                          TouchStatus := TOUCH_PRESSED ;
006793  000857                      endif
006794  000858                  endif
006795  000859                  TouchXpos  := touch_Get(TOUCH_GETX);
006796  000860                  TouchYpos  := touch_Get(TOUCH_GETY);
006797  000861                  TouchState := Ofs_IPD_DOWN ;
006798  000862              else
006799  000863                  ImageTouched := oldn ;                     // simulate release of what we touched
006800  000864                  oldn := -1 ;                    // prevent double release
006801  000865                  TouchState := Ofs_IPD_RELEASE ;
006802  000866              endif
006803  000867              if (ImageTouched != -1)
006804  000868                  // if touch released then find a keyboard down, if one then release it
006805  000869                  if ((TouchStatus == TOUCH_RELEASED) && (ActiveKeyboard != -1))
006806  000870                      kbUp(oKeyboards[ActiveKeyboard+1], dKeyboard[ActiveKeyboard]) ;
006807  000871                      ActiveKeyboard := -1 ;
006808  000872                  else
006809  000873                      i := 0 ;
006810  000874                      while ((i < nKeyboards) && ((ImageTouched <= oKeyboards[i+1]) || (ImageTouched > oKeyboards[i+1] + *(dKeyboard[i]+Ofs_kb_Buttons))))
006811  000875                          i++ ;
006812  000876                      wend
006813  000877                      if (i < nKeyboards)
006814  000878                          if (TouchStatus == TOUCH_PRESSED)
006815  000879                              ActiveKeyboard := i ;
006816  000880                              kbDown(oKeyboards[ActiveKeyboard+1], dKeyboard[ActiveKeyboard], kKeyboardKeystrokes[ActiveKeyboard], ImageTouched-oKeyboards[ActiveKeyboard+1]) ;
006817  000881                          endif
006818  000882                      else
006819  000883                          CurInputData := InputControls[ImageTouched] + InputData;
006820  000884                          GObjectType := *(CurInputData) ;
006821  000885                          i := GObjectType ;
006822  000886                          if (GObjectType >= t4Dbutton) i -= 23 ; // adjust to ensure next in gosub
006823  000887                          gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
006824  000888                      endif
006825  000889                  endif
006826  000890              endif
006827  000891          endif
006828  000892   //       if ((n != -1) && (oldn == -1)) oldn := n ;    // save what we touched in case we move off it
006829  000893        
006830  000894          sys_EventsResume() ;
006831  000895      forever
006832  000896        
006833  000897  cDipswitch:
006834  000898        
006835  000899  cKnob:
006836  000900        
006837  000901  cRockerswitch:
006838  000902        
006839  000903  cRotaryswitch:
006840  000904        
006841  000905  cSlider:
006842  000906  cTrackbar:
006843  000907        
006844  000908  c4DButton:
006845  000909      pInputIndex := o4Dbuttons + *(CurInputData+Ofs_IPD_OBJVIDX) ;
006846  000910      goto gbutton ;
006847  000911  cUserButton:
006848  000912  cWinbutton:
006849  000913      pInputIndex := oWinButtons + *(CurInputData+Ofs_IPD_OBJVIDX) ;
006850  000914  gbutton:
006851  000915      i := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ; // current state
006852  000916      if (*(CurInputData+Ofs_IPD_P1))                                 // momentary, reports 0, but should report 1
006853  000917          if (TouchStatus == TOUCH_RELEASED)
006854  000918              i &= 0xfffe ;
006855  000919              TouchState == Ofs_IPD_DOWN ;
006856  000920          else
006857  000921              i |= 1 ;
006858  000922              TouchState == Ofs_IPD_RELEASE ;
006859  000923          endif
006860  000924      else if (*(CurInputData+Ofs_IPD_P2) == -1)                      // Toggle, reports 0+2, but should report 0+1
006861  000925          if (TouchStatus == TOUCH_RELEASED)                     // only truly change on release
006862  000926              if ((i & 3) == 3)
006863  000927                  i &= 0xfffc ;
006864  000928              else
006865  000929                  i++ ;
006866  000930              endif
006867  000931          else
006868  000932              i |= 1 ;                                      // make down regardless of current state
006869  000933          endif
006870  000934      else                        // group action, up all other buttons on touch press, reports 0 for button down
006871  000935          if (TouchStatus == TOUCH_PRESSED)                     // only truly change on release
006872  000936              TurnOffButtons(*(CurInputData+Ofs_IPD_P2)) ;
006873  000937          endif
006874  000938          i := (i & 0xfffc) | 2 ;
006875  000939      endif
006876  000940        
006877  000941      UpdateObjects(i) ;
006878  000942  endsub ;
006879  000943        
006880  000944  cAniButton:
006881  000945        
006882  000946  cColorPicker:
006883  000947        
006884  000948  endfunc
006885  000949  // End P6.inc
Notice: Check that the function called via pointer  'IPidx' requires 1 argument (line 564 file:resp_box_1.4DGenieS)
Notice: local var 'p' in func 'ActivateForm' is never used (line 502 file:resp_box_1.4DGenieS)
Notice: Check that the function called via pointer  'rtn' requires 4 arguments (line 227 file:resp_box_1.4DGenieS)


Symbol Table:
name                             decimal         hex
_1F                                  -40  0xffffffd8 (PmmC func) args[0] r=0  (not used)
__MAXMEM                           14400  0x00003840 (const dword)  (usage 1)
__MAXPROG                          14400  0x00003840 (const dword)  (usage 1)
__PLATFORM                             1  0x00000001 (const dword)  (not used)
ABS                                  -13  0xfffffff3 (PmmC func) args[1] r=1  (not used)
ACK                                    6  0x00000006 (const dword)  (usage 12)
ActivateForm                        6314  0x000018aa (User func) args[1] r=0  (usage 9)
ActiveKeyboard                       126  0x0000007e (mem) word (global)  (usage 36)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ALL                                65535  0x0000ffff (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AUDIO_ENABLE                           7  0x00000007 (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (usage 3)
BACKLITE                               6  0x00000006 (const dword)  (not used)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (not used)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
BLACK                                  0  0x00000000 (const dword)  (usage 75)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
BUS_0                                  8  0x00000008 (const dword)  (not used)
BUS_1                                  9  0x00000009 (const dword)  (not used)
BUS_2                                 10  0x0000000a (const dword)  (not used)
BUS_3                                 11  0x0000000b (const dword)  (not used)
BUS_4                                 12  0x0000000c (const dword)  (not used)
BUS_5                                 13  0x0000000d (const dword)  (not used)
BUS_6                                 14  0x0000000e (const dword)  (not used)
BUS_7                                 15  0x0000000f (const dword)  (not used)
bus_In                               -45  0xffffffd3 (PmmC func) args[0] r=1  (not used)
bus_Out                              -46  0xffffffd2 (PmmC func) args[1] r=0  (not used)
BUS_RD_PIN                             4  0x00000004 (const dword)  (not used)
bus_Read                             -49  0xffffffcf (PmmC func) args[0] r=1  (not used)
bus_Set                              -47  0xffffffd1 (PmmC func) args[1] r=0  (not used)
BUS_WR_PIN                             5  0x00000005 (const dword)  (not used)
bus_Write                            -48  0xffffffd0 (PmmC func) args[1] r=0  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                            -215  0xffffff29 (PmmC func) args[1] r=1  (not used)
c4DButton                         UNRESOLVED  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
cAniButton                        UNRESOLVED  (not used)
cColorPicker                      UNRESOLVED  (not used)
cDipswitch                        UNRESOLVED  (not used)
charheight                          -159  0xffffff61 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                           -158  0xffffff62 (PmmC func) args[1] r=1  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
CKMODE_0                               0  0x00000000 (const dword)  (not used)
CKMODE_1                               1  0x00000001 (const dword)  (not used)
CKMODE_2                               2  0x00000002 (const dword)  (not used)
CKMODE_3                               3  0x00000003 (const dword)  (not used)
cKnob                             UNRESOLVED  (not used)
CLIPPING                              19  0x00000013 (const dword)  (not used)
cmd                                  294  0x00000126 (mem) word[80] (global)  (usage 84)
CMDLenMAX                             80  0x00000050 (const dword)  (usage 12)
ColorBGimage                          32  0x00000020 (const dword)  (usage 9)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COLOUR_MODE                           27  0x0000001b (const dword)  (not used)
COLUMN_ADDRESS_END1                    5  0x00000005 (const dword)  (not used)
COLUMN_ADDRESS_END2                    4  0x00000004 (const dword)  (not used)
COLUMN_ADDRESS_START1                  3  0x00000003 (const dword)  (not used)
COLUMN_ADDRESS_START2                  2  0x00000002 (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (usage 3)
COM1                               63496  0x0000f808 (const dword)  (not used)
com1_Count                          -132  0xffffff7c (PmmC func) args[0] r=1  (not used)
com1_Error                          -134  0xffffff7a (PmmC func) args[0] r=1  (not used)
com1_Full                           -133  0xffffff7b (PmmC func) args[0] r=1  (not used)
com1_Init                           -130  0xffffff7e (PmmC func) args[3] r=0  (not used)
com1_Reset                          -131  0xffffff7d (PmmC func) args[0] r=0  (not used)
com1_Sync                           -135  0xffffff79 (PmmC func) args[0] r=1  (not used)
com1_TXbuffer                       -136  0xffffff78 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -139  0xffffff75 (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -137  0xffffff77 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -138  0xffffff76 (PmmC func) args[1] r=1  (not used)
com_Count                           -122  0xffffff86 (PmmC func) args[0] r=1  (usage 3)
com_Error                           -124  0xffffff84 (PmmC func) args[0] r=1  (not used)
com_Full                            -123  0xffffff85 (PmmC func) args[0] r=1  (not used)
com_Init                            -120  0xffffff88 (PmmC func) args[3] r=0  (usage 3)
com_Reset                           -121  0xffffff87 (PmmC func) args[0] r=0  (not used)
com_SetBaud                         -142  0xffffff72 (PmmC func) args[2] r=1  (usage 3)
com_Sync                            -125  0xffffff83 (PmmC func) args[0] r=1  (not used)
com_TXbuffer                        -126  0xffffff82 (PmmC func) args[3] r=0  (usage 3)
com_TXbufferHold                    -129  0xffffff7f (PmmC func) args[1] r=1  (not used)
com_TXcount                         -127  0xffffff81 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -128  0xffffff80 (PmmC func) args[1] r=1  (not used)
comRX                                214  0x000000d6 (mem) word[40] (global)  (usage 3)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -18  0xffffffee (PmmC func) args[1] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
cRockerswitch                     UNRESOLVED  (not used)
cRotaryswitch                     UNRESOLVED  (not used)
cSlider                           UNRESOLVED  (not used)
cTrackbar                         UNRESOLVED  (not used)
CurInputData                         210  0x000000d2 (mem) word (global)  (usage 27)
CurrentForm                          196  0x000000c4 (mem) word (global)  (usage 45)
cUserButton                       UNRESOLVED  (not used)
cWinbutton                        UNRESOLVED  (not used)
CY                                  -285  0xfffffee3 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
CYCLE_CONTROL_1                       58  0x0000003a (const dword)  (not used)
CYCLE_CONTROL_2                       59  0x0000003b (const dword)  (not used)
CYCLE_CONTROL_3                       60  0x0000003c (const dword)  (not used)
CYCLE_CONTROL_4                       61  0x0000003d (const dword)  (not used)
CYCLE_CONTROL_5                       62  0x0000003e (const dword)  (not used)
CYCLE_CONTROL_6                       64  0x00000040 (const dword)  (not used)
D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS    2806  0x00000af6 (const ??? 0)  (not used)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_Disconnect                     -293  0xfffffedb (PmmC func) args[0] r=0  (not used)
disp_Init                           -143  0xffffff71 (PmmC func) args[0] r=0  (not used)
disp_ReadWord                       -149  0xffffff6b (PmmC func) args[0] r=1  (not used)
disp_setGRAM                        -145  0xffffff6f (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -144  0xffffff70 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -284  0xfffffee4 (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -147  0xffffff6d (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -148  0xffffff6c (PmmC func) args[1] r=0  (not used)
DISPLAY_CONTROL_1                     38  0x00000026 (const dword)  (not used)
DISPLAY_CONTROL_10                    54  0x00000036 (const dword)  (not used)
DISPLAY_CONTROL_14                    65  0x00000041 (const dword)  (not used)
DISPLAY_CONTROL_2                     39  0x00000027 (const dword)  (not used)
DISPLAY_CONTROL_3                     40  0x00000028 (const dword)  (not used)
DISPLAY_CONTROL_4                     41  0x00000029 (const dword)  (not used)
DISPLAY_CONTROL_5                     42  0x0000002a (const dword)  (not used)
DISPLAY_CONTROL_6                     44  0x0000002c (const dword)  (not used)
DISPLAY_CONTROL_7                     45  0x0000002d (const dword)  (not used)
DISPLAY_CONTROL_8                    144  0x00000090 (const dword)  (not used)
DISPLAY_CONTROL_9                     53  0x00000035 (const dword)  (not used)
DISPLAY_MODE_CONTROL                   1  0x00000001 (const dword)  (not used)
dKeyboard                            124  0x0000007c (mem) word[1] (global)  (usage 15)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DoGFXObjects                        5432  0x00001538 (User func) args[0] r=0  (usage 6)
DOWN                                   0  0x00000000 (const dword)  (not used)
DSK                                63490  0x0000f802 (const dword)  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                              -282  0xfffffee6 (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                           -283  0xfffffee5 (PmmC func) args[0] r=1  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FILE_TIMEOUT                       26  0x0000001a (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_Close                          -232  0xffffff18 (PmmC func) args[1] r=1  (not used)
file_Count                          -226  0xffffff1e (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -247  0xffffff09 (PmmC func) args[1] r=1  (not used)
file_Error                          -225  0xffffff1f (PmmC func) args[0] r=1  (not used)
file_Exec                           -251  0xffffff05 (PmmC func) args[2] r=1  (not used)
file_Exists                         -230  0xffffff1a (PmmC func) args[1] r=1  (not used)
file_FindFirst                      -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
file_FindNext                       -229  0xffffff1b (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -242  0xffffff0e (PmmC func) args[1] r=1  (usage 3)
file_GetS                           -246  0xffffff0a (PmmC func) args[3] r=1  (not used)
file_GetW                           -244  0xffffff0c (PmmC func) args[1] r=1  (usage 3)
file_Image                          -239  0xffffff11 (PmmC func) args[3] r=1  (not used)
file_Index                          -235  0xffffff15 (PmmC func) args[4] r=1  (not used)
file_LoadFunction                   -249  0xffffff07 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -252  0xffffff04 (PmmC func) args[3] r=1  (usage 15)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -253  0xffffff03 (PmmC func) args[0] r=1  (usage 6)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -231  0xffffff19 (PmmC func) args[2] r=1  (usage 3)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -255  0xffffff01 (PmmC func) args[1] r=1  (not used)
file_PutC                           -241  0xffffff0f (PmmC func) args[2] r=1  (not used)
file_PutS                           -245  0xffffff0b (PmmC func) args[2] r=1  (not used)
file_PutW                           -243  0xffffff0d (PmmC func) args[2] r=1  (not used)
file_Read                           -233  0xffffff17 (PmmC func) args[3] r=1  (not used)
file_Rewind                         -248  0xffffff08 (PmmC func) args[1] r=1  (not used)
file_Run                            -250  0xffffff06 (PmmC func) args[2] r=1  (not used)
file_ScreenCapture                  -240  0xffffff10 (PmmC func) args[5] r=1  (not used)
file_Seek                           -234  0xffffff16 (PmmC func) args[3] r=1  (usage 3)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_Size                           -238  0xffffff12 (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -236  0xffffff14 (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -254  0xffffff02 (PmmC func) args[0] r=0  (not used)
file_Write                          -237  0xffffff13 (PmmC func) args[3] r=1  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
flash_BlockErase                    -157  0xffffff63 (PmmC func) args[1] r=1  (not used)
flash_BulkErase                     -156  0xffffff64 (PmmC func) args[0] r=0  (not used)
flash_ID                            -155  0xffffff65 (PmmC func) args[0] r=1  (not used)
flash_SIG                           -154  0xffffff66 (PmmC func) args[0] r=1  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
FONT1                                  0  0x00000000 (const dword)  (not used)
FONT2                                  1  0x00000001 (const dword)  (not used)
FONT3                                  2  0x00000002 (const dword)  (usage 15)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
FormBGcolors                        3010  0x00000bc2FormBGcolors                        3010  0x00000bc2 (mem) word[12] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 8)
FormBGcolors                      UNRESOLVED  (usage 4)
FormEndIndex                          68  0x00000044FormEndIndex                          68  0x00000044 (mem) word[12] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 6)
FormStartIndex                        44  0x0000002cFormStartIndex                        44  0x0000002c (mem) word[12] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 7)
FormStartIndex                    UNRESOLVED  (usage 2)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
GAMMA_CONTROL_1                       70  0x00000046 (const dword)  (not used)
GAMMA_CONTROL_10                      79  0x0000004f (const dword)  (not used)
GAMMA_CONTROL_11                      80  0x00000050 (const dword)  (not used)
GAMMA_CONTROL_12                      81  0x00000051 (const dword)  (not used)
GAMMA_CONTROL_2                       71  0x00000047 (const dword)  (not used)
GAMMA_CONTROL_3                       72  0x00000048 (const dword)  (not used)
GAMMA_CONTROL_4                       73  0x00000049 (const dword)  (not used)
GAMMA_CONTROL_5                       74  0x0000004a (const dword)  (not used)
GAMMA_CONTROL_6                       75  0x0000004b (const dword)  (not used)
GAMMA_CONTROL_7                       76  0x0000004c (const dword)  (not used)
GAMMA_CONTROL_8                       77  0x0000004d (const dword)  (not used)
GAMMA_CONTROL_9                       78  0x0000004e (const dword)  (not used)
gbutton                           UNRESOLVED  (not used)
Gen4_ULCD_32PT                         0  0x00000000 (const ??? 0)  (not used)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                         -85  0xffffffab (PmmC func) args[1] r=1  (not used)
gfx_BevelShadow                     -104  0xffffff98 (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -103  0xffffff99 (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                         -92  0xffffffa4 (PmmC func) args[1] r=1  (not used)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                            -74  0xffffffb6 (PmmC func) args[2] r=0  (not used)
gfx_Bullet                           -71  0xffffffb9 (PmmC func) args[1] r=0  (not used)
gfx_Button                           -80  0xffffffb0 (PmmC func) args[9] r=0  (not used)
GFX_BUTTON_BACKGROUND                 64  0x00000040 (const dword)  (not used)
GFX_BUTTON_FOREGROUND                 63  0x0000003f (const dword)  (not used)
GFX_BUTTON_MODE                       65  0x00000041 (const dword)  (not used)
gfx_ChangeColour                     -76  0xffffffb4 (PmmC func) args[2] r=0  (not used)
gfx_Circle                           -61  0xffffffc3 (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                     -62  0xffffffc2 (PmmC func) args[4] r=0  (not used)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                         -94  0xffffffa2 (PmmC func) args[1] r=0  (usage 6)
gfx_ClipWindow                       -75  0xffffffb5 (PmmC func) args[4] r=0  (usage 3)
gfx_Cls                              -51  0xffffffcd (PmmC func) args[0] r=0  (usage 6)
gfx_ColourMode                      -102  0xffffff9a (PmmC func) args[1] r=1  (not used)
gfx_Contrast                        -100  0xffffff9c (PmmC func) args[1] r=1  (usage 3)
gfx_Dot                              -70  0xffffffba (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                          -78  0xffffffb2 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                    -79  0xffffffb1 (PmmC func) args[5] r=0  (not used)
gfx_FrameDelay                       -97  0xffffff9f (PmmC func) args[1] r=1  (not used)
gfx_Get                              -90  0xffffffa6 (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                         -64  0xffffffc0 (PmmC func) args[2] r=1  (not used)
GFX_HILIGHT_BACKGROUND                61  0x0000003d (const dword)  (not used)
GFX_HILIGHT_FOREGROUND                62  0x0000003e (const dword)  (not used)
GFX_HILITE_LINE                       58  0x0000003a (const dword)  (not used)
gfx_Hline                            -57  0xffffffc7 (PmmC func) args[4] r=1  (not used)
gfx_IncX                             -72  0xffffffb8 (PmmC func) args[0] r=1  (not used)
gfx_IncY                             -73  0xffffffb7 (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_SELECTION                    60  0x0000003c (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
GFX_LEFT_GUTTER_WIDTH                 68  0x00000044 (const dword)  (not used)
gfx_Line                             -56  0xffffffc8 (PmmC func) args[5] r=0  (usage 27)
GFX_LINE_COUNT                        59  0x0000003b (const dword)  (not used)
gfx_LinePattern                     -101  0xffffff9b (PmmC func) args[1] r=1  (usage 6)
gfx_LineRel                          -55  0xffffffc9 (PmmC func) args[2] r=0  (not used)
gfx_LineTo                           -54  0xffffffca (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                          -53  0xffffffcb (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                           -52  0xffffffcc (PmmC func) args[2] r=0  (usage 3)
gfx_ObjectColour                     -93  0xffffffa3 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                            -67  0xffffffbd (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                        -66  0xffffffbe (PmmC func) args[2] r=0  (not used)
gfx_Origin                           -89  0xffffffa7 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                    -99  0xffffff9d (PmmC func) args[1] r=1  (usage 6)
gfx_Panel                            -81  0xffffffaf (PmmC func) args[6] r=0  (not used)
gfx_PenSize                          -91  0xffffffa5 (PmmC func) args[1] r=1  (not used)
GFX_PIXEL_SHIFT                       70  0x00000046 (const dword)  (not used)
gfx_Polygon                          -69  0xffffffbb (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                    -88  0xffffffa8 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                         -68  0xffffffbc (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                         -63  0xffffffc1 (PmmC func) args[3] r=0  (not used)
GFX_RECT_X1                           71  0x00000047 (const dword)  (not used)
GFX_RECT_X2                           73  0x00000049 (const dword)  (not used)
GFX_RECT_Y1                           72  0x00000048 (const dword)  (not used)
GFX_RECT_Y2                           74  0x0000004a (const dword)  (not used)
gfx_Rectangle                        -59  0xffffffc5 (PmmC func) args[5] r=0  (usage 3)
gfx_RectangleFilled                  -60  0xffffffc4 (PmmC func) args[5] r=0  (usage 6)
gfx_RGBto565                         -84  0xffffffac (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
GFX_RIGHT_GUTTER_WIDTH                69  0x00000045 (const dword)  (not used)
gfx_ScreenCopyPaste                  -83  0xffffffad (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                       -98  0xffffff9e (PmmC func) args[1] r=1  (usage 3)
gfx_Selection                        -86  0xffffffaa (PmmC func) args[3] r=0  (not used)
gfx_Set                              -50  0xffffffce (PmmC func) args[2] r=0  (usage 3)
gfx_SetClipRegion                    -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
gfx_Slider                           -82  0xffffffae (PmmC func) args[8] r=1  (not used)
GFX_STATUSBAR_HEIGHT                  67  0x00000043 (const dword)  (not used)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOOLBAR_HEIGHT                    66  0x00000042 (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                     -96  0xffffffa0 (PmmC func) args[1] r=1  (not used)
gfx_TransparentColour                -95  0xffffffa1 (PmmC func) args[1] r=1  (not used)
gfx_Triangle                         -65  0xffffffbf (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                   -87  0xffffffa9 (PmmC func) args[7] r=0  (not used)
gfx_Vline                            -58  0xffffffc6 (PmmC func) args[4] r=1  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -105  0xffffff97 (PmmC func) args[1] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -106  0xffffff96 (PmmC func) args[1] r=1  (not used)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GObjectType                          206  0x000000ce (mem) word (global)  (usage 24)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (not used)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (not used)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
hFonts                                 2  0x00000002 (mem) word[24] (global)  (usage 120)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                              -214  0xffffff2a (PmmC func) args[1] r=1  (not used)
HIDE                                   2  0x00000002 (const dword)  (not used)
hndl                                   0  0x00000000 (mem) word (global)  (usage 99)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
hstrings                             122  0x0000007a (mem) word (global)  (usage 12)
I2C                                63520  0x0000f820 (const dword)  (not used)
I2C_Ack                             -169  0xffffff57 (PmmC func) args[0] r=0  (not used)
I2C_AckPoll                         -172  0xffffff54 (PmmC func) args[1] r=1  (not used)
I2C_AckStatus                       -171  0xffffff55 (PmmC func) args[0] r=0  (not used)
I2C_Close                           -163  0xffffff5d (PmmC func) args[0] r=0  (not used)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_Getn                            -175  0xffffff51 (PmmC func) args[2] r=1  (not used)
I2C_Gets                            -174  0xffffff52 (PmmC func) args[2] r=1  (not used)
I2C_Idle                            -173  0xffffff53 (PmmC func) args[0] r=0  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_Nack                            -170  0xffffff56 (PmmC func) args[0] r=0  (not used)
I2C_Open                            -162  0xffffff5e (PmmC func) args[1] r=0  (not used)
I2C_Putn                            -177  0xffffff4f (PmmC func) args[2] r=1  (not used)
I2C_Puts                            -176  0xffffff50 (PmmC func) args[1] r=1  (not used)
I2C_Read                            -167  0xffffff59 (PmmC func) args[0] r=1  (not used)
I2C_Restart                         -166  0xffffff5a (PmmC func) args[0] r=1  (not used)
I2C_SLOW                               0  0x00000000 (const dword)  (not used)
I2C_Start                           -164  0xffffff5c (PmmC func) args[0] r=1  (not used)
I2C_Stop                            -165  0xffffff5b (PmmC func) args[0] r=1  (not used)
I2C_Write                           -168  0xffffff58 (PmmC func) args[1] r=1  (not used)
i4Dbutton0                            41  0x00000029 (const ??? 0)  (usage 3)
i4Dbutton1                            45  0x0000002d (const ??? 0)  (usage 3)
i4Dbutton2                             7  0x00000007 (const ??? 0)  (usage 3)
i4Dbutton3                             8  0x00000008 (const ??? 0)  (usage 3)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (usage 3)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (usage 3)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (usage 6)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
IFONT_OFFSET                          24  0x00000018 (const dword)  (not used)
iKeyboard0                            57  0x00000039 (const ??? 0)  (usage 3)
iKeyboard0_0                          58  0x0000003a (const ??? 0)  (not used)
iKeyboard0_1                          59  0x0000003b (const ??? 0)  (not used)
iKeyboard0_10                         68  0x00000044 (const ??? 0)  (not used)
iKeyboard0_11                         69  0x00000045 (const ??? 0)  (not used)
iKeyboard0_12                         70  0x00000046 (const ??? 0)  (not used)
iKeyboard0_2                          60  0x0000003c (const ??? 0)  (not used)
iKeyboard0_3                          61  0x0000003d (const ??? 0)  (not used)
iKeyboard0_4                          62  0x0000003e (const ??? 0)  (not used)
iKeyboard0_5                          63  0x0000003f (const ??? 0)  (not used)
iKeyboard0_6                          64  0x00000040 (const ??? 0)  (not used)
iKeyboard0_7                          65  0x00000041 (const ??? 0)  (not used)
iKeyboard0_8                          66  0x00000042 (const ??? 0)  (not used)
iKeyboard0_9                          67  0x00000043 (const ??? 0)  (not used)
iKeyboard0keystrokes                   7  0x00000007iKeyboard0keystrokes                   7  0x00000007 (mem) byte[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (not used)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (not used)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (usage 45)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_TAG                             12  0x0000000c (const dword)  (usage 12)
IMAGE_TAG2                            13  0x0000000d (const dword)  (not used)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (not used)
IMAGE_XPOS                             2  0x00000002 (const dword)  (not used)
IMAGE_YPOS                             3  0x00000003 (const dword)  (not used)
ImageTouched                         200  0x000000c8 (mem) word (global)  (usage 57)
img_ClearAttributes                 -187  0xffffff45 (PmmC func) args[3] r=1  (usage 3)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -181  0xffffff4b (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -180  0xffffff4c (PmmC func) args[2] r=1  (usage 6)
img_Enable                          -179  0xffffff4d (PmmC func) args[2] r=1  (not used)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -184  0xffffff48 (PmmC func) args[3] r=1  (usage 36)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -182  0xffffff4a (PmmC func) args[2] r=1  (not used)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SetAttributes                   -186  0xffffff46 (PmmC func) args[3] r=1  (usage 6)
img_SetPosition                     -178  0xffffff4e (PmmC func) args[4] r=1  (not used)
img_SetWord                         -183  0xffffff49 (PmmC func) args[4] r=1  (usage 21)
img_Show                            -185  0xffffff47 (PmmC func) args[2] r=1  (usage 21)
img_Touched                         -188  0xffffff44 (PmmC func) args[2] r=1  (usage 3)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
INPUT                                  1  0x00000001 (const dword)  (not used)
InputControls                         92  0x0000005cInputControls                         92  0x0000005c (mem) word[82] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 9)
InputCS                              454  0x000001c6 (mem) word (global)  (usage 21)
InputData                            256  0x00000100InputData                            256  0x00000100 (mem) word[946] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 30)
INVERSE                               64  0x00000040 (const dword)  (not used)
IO1_PIN                                1  0x00000001 (const dword)  (not used)
IO2_PIN                                2  0x00000002 (const dword)  (not used)
IO3_PIN                                3  0x00000003 (const dword)  (not used)
IO4_PIN                                4  0x00000004 (const dword)  (not used)
IO5_PIN                                5  0x00000005 (const dword)  (not used)
IPDatasize                            22  0x00000016 (const dword)  (usage 3)
isalnum                             -207  0xffffff31 (PmmC func) args[1] r=1  (not used)
isalpha                             -206  0xffffff32 (PmmC func) args[1] r=1  (not used)
isdigit                             -202  0xffffff36 (PmmC func) args[1] r=1  (not used)
islower                             -205  0xffffff33 (PmmC func) args[1] r=1  (not used)
isprint                             -208  0xffffff30 (PmmC func) args[1] r=1  (not used)
isspace                             -209  0xffffff2f (PmmC func) args[1] r=1  (not used)
iStatictext0                           2  0x00000002 (const ??? 0)  (usage 3)
iStatictext1                           4  0x00000004 (const ??? 0)  (usage 3)
iStatictext10                         42  0x0000002a (const ??? 0)  (usage 3)
iStatictext11                         43  0x0000002b (const ??? 0)  (usage 3)
iStatictext12                         44  0x0000002c (const ??? 0)  (usage 3)
iStatictext13                         53  0x00000035 (const ??? 0)  (usage 3)
iStatictext14                         54  0x00000036 (const ??? 0)  (usage 3)
iStatictext15                         55  0x00000037 (const ??? 0)  (usage 3)
iStatictext16                         56  0x00000038 (const ??? 0)  (usage 3)
iStatictext19                         21  0x00000015 (const ??? 0)  (usage 3)
iStatictext2                           5  0x00000005 (const ??? 0)  (usage 3)
iStatictext20                         22  0x00000016 (const ??? 0)  (usage 3)
iStatictext21                         24  0x00000018 (const ??? 0)  (usage 3)
iStatictext22                         82  0x00000052 (const ??? 0)  (usage 3)
iStatictext23                          9  0x00000009 (const ??? 0)  (usage 3)
iStatictext24                         10  0x0000000a (const ??? 0)  (usage 3)
iStatictext25                         13  0x0000000d (const ??? 0)  (usage 3)
iStatictext3                           6  0x00000006 (const ??? 0)  (usage 3)
iStatictext4                          20  0x00000014 (const ??? 0)  (usage 3)
iStatictext5                          31  0x0000001f (const ??? 0)  (usage 3)
iStatictext6                          32  0x00000020 (const ??? 0)  (usage 3)
iStatictext7                          33  0x00000021 (const ??? 0)  (usage 3)
iStatictext8                          34  0x00000022 (const ??? 0)  (usage 3)
iStatictext9                          40  0x00000028 (const ??? 0)  (usage 3)
iStrings0                           2148  0x00000864iStrings0                           2148  0x00000864 (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings1                           2174  0x0000087eiStrings1                           2174  0x0000087e (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings10                          2408  0x00000968iStrings10                          2408  0x00000968 (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings11                          2434  0x00000982iStrings11                          2434  0x00000982 (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings12                          2460  0x0000099ciStrings12                          2460  0x0000099c (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings13                          2486  0x000009b6iStrings13                          2486  0x000009b6 (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings14                          2512  0x000009d0iStrings14                          2512  0x000009d0 (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings15                          2538  0x000009eaiStrings15                          2538  0x000009ea (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings16                          2564  0x00000a04iStrings16                          2564  0x00000a04 (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings17                          2590  0x00000a1eiStrings17                          2590  0x00000a1e (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings18                          2616  0x00000a38iStrings18                          2616  0x00000a38 (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings19                          2642  0x00000a52iStrings19                          2642  0x00000a52 (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings2                           2200  0x00000898iStrings2                           2200  0x00000898 (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings20                          2668  0x00000a6ciStrings20                          2668  0x00000a6c (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings21                          2694  0x00000a86iStrings21                          2694  0x00000a86 (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings22                          2720  0x00000aa0iStrings22                          2720  0x00000aa0 (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings23                          2746  0x00000abaiStrings23                          2746  0x00000aba (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings3                           2226  0x000008b2iStrings3                           2226  0x000008b2 (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings4                           2252  0x000008cciStrings4                           2252  0x000008cc (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings5                           2278  0x000008e6iStrings5                           2278  0x000008e6 (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings6                           2304  0x00000900iStrings6                           2304  0x00000900 (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings7                           2330  0x0000091aiStrings7                           2330  0x0000091a (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings8                           2356  0x00000934iStrings8                           2356  0x00000934 (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
iStrings9                           2382  0x0000094eiStrings9                           2382  0x0000094e (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
isupper                             -204  0xffffff34 (PmmC func) args[1] r=1  (not used)
iswhite                             -210  0xffffff2e (PmmC func) args[1] r=1  (not used)
isxdigit                            -203  0xffffff35 (PmmC func) args[1] r=1  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
iterator                            -198  0xffffff3a (PmmC func) args[1] r=0  (not used)
iUserimages0                          77  0x0000004d (const ??? 0)  (usage 3)
iUserled0                             30  0x0000001e (const ??? 0)  (usage 3)
iUserled1                             23  0x00000017 (const ??? 0)  (usage 3)
iUserled2                             12  0x0000000c (const ??? 0)  (usage 3)
iUserled3                             11  0x0000000b (const ??? 0)  (usage 3)
IVORY                              65534  0x0000fffe (const dword)  (not used)
iWinbutton0                            0  0x00000000 (const ??? 0)  (usage 3)
iWinbutton1                            1  0x00000001 (const ??? 0)  (usage 3)
iWinbutton10                          26  0x0000001a (const ??? 0)  (usage 3)
iWinbutton11                          27  0x0000001b (const ??? 0)  (usage 3)
iWinbutton12                          28  0x0000001c (const ??? 0)  (usage 3)
iWinbutton13                          29  0x0000001d (const ??? 0)  (usage 3)
iWinbutton14                          35  0x00000023 (const ??? 0)  (usage 3)
iWinbutton15                          36  0x00000024 (const ??? 0)  (usage 3)
iWinbutton16                          37  0x00000025 (const ??? 0)  (usage 3)
iWinbutton17                          38  0x00000026 (const ??? 0)  (usage 3)
iWinbutton18                          39  0x00000027 (const ??? 0)  (usage 3)
iWinbutton19                          46  0x0000002e (const ??? 0)  (usage 3)
iWinbutton2                            3  0x00000003 (const ??? 0)  (usage 3)
iWinbutton20                          47  0x0000002f (const ??? 0)  (usage 3)
iWinbutton21                          48  0x00000030 (const ??? 0)  (usage 3)
iWinbutton22                          49  0x00000031 (const ??? 0)  (usage 3)
iWinbutton23                          50  0x00000032 (const ??? 0)  (usage 3)
iWinbutton24                          51  0x00000033 (const ??? 0)  (usage 3)
iWinbutton25                          52  0x00000034 (const ??? 0)  (usage 3)
iWinbutton26                          71  0x00000047 (const ??? 0)  (usage 3)
iWinbutton27                          72  0x00000048 (const ??? 0)  (usage 3)
iWinbutton28                          73  0x00000049 (const ??? 0)  (usage 3)
iWinbutton3                           14  0x0000000e (const ??? 0)  (usage 3)
iWinbutton31                          75  0x0000004b (const ??? 0)  (usage 3)
iWinbutton32                          74  0x0000004a (const ??? 0)  (usage 3)
iWinbutton33                          81  0x00000051 (const ??? 0)  (usage 3)
iWinbutton34                          78  0x0000004e (const ??? 0)  (usage 3)
iWinbutton35                          79  0x0000004f (const ??? 0)  (usage 3)
iWinbutton36                          80  0x00000050 (const ??? 0)  (usage 3)
iWinbutton37                          76  0x0000004c (const ??? 0)  (usage 3)
iWinbutton4                           15  0x0000000f (const ??? 0)  (usage 3)
iWinbutton5                           16  0x00000010 (const ??? 0)  (usage 3)
iWinbutton6                           17  0x00000011 (const ??? 0)  (usage 3)
iWinbutton7                           18  0x00000012 (const ??? 0)  (usage 3)
iWinbutton8                           19  0x00000013 (const ??? 0)  (usage 3)
iWinbutton9                           25  0x00000019 (const ??? 0)  (usage 3)
KbCapsBit                              2  0x00000002 (const dword)  (usage 12)
KbCtrlBit                              4  0x00000004 (const dword)  (usage 21)
kbDown                              7550  0x00001d7e (User func) args[4] r=0  (usage 3)
KbShiftBit                             1  0x00000001 (const dword)  (usage 18)
KbShiftCapsBits                        3  0x00000003 (const dword)  (usage 18)
kbUp                                7383  0x00001cd7 (User func) args[2] r=0  (usage 3)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
kKeyboardKeystrokes                 3034  0x00000bdakKeyboardKeystrokes                 3034  0x00000bda (mem) word[1] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
LANDSCAPE                              0  0x00000000 (const dword)  (not used)
LANDSCAPE_R                            1  0x00000001 (const dword)  (usage 3)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (not used)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                              -213  0xffffff2b (PmmC func) args[1] r=1  (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (usage 6)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                3322  0x00000cfa (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -15  0xfffffff1 (PmmC func) args[2] r=1  (not used)
MaxTotObjects                         33  0x00000021 (const dword)  (usage 6)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
MEDIA_ADDRESS_MW                      92  0x0000005c (const dword)  (not used)
MEDIA_ADDRESS_UW                      93  0x0000005d (const dword)  (not used)
media_Flush                         -118  0xffffff8a (PmmC func) args[0] r=1  (not used)
media_Image                         -117  0xffffff8b (PmmC func) args[2] r=0  (not used)
media_Init                          -119  0xffffff89 (PmmC func) args[0] r=1  (not used)
media_RdSector                      -111  0xffffff91 (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -113  0xffffff8f (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -114  0xffffff8e (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                      124  0x0000007c (const dword)  (not used)
MEDIA_SECTOR_LO                      123  0x0000007b (const dword)  (not used)
media_SetAdd                        -109  0xffffff93 (PmmC func) args[2] r=0  (not used)
media_SetSector                     -110  0xffffff92 (PmmC func) args[2] r=0  (not used)
media_Video                         -107  0xffffff95 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -108  0xffffff94 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -115  0xffffff8d (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
media_WrSector                      -112  0xffffff90 (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
mem_Alloc                           -216  0xffffff28 (PmmC func) args[1] r=1  (not used)
mem_AllocV                          -217  0xffffff27 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -218  0xffffff26 (PmmC func) args[1] r=1  (not used)
mem_Compare                         -224  0xffffff20 (PmmC func) args[3] r=1  (not used)
mem_Copy                            -223  0xffffff21 (PmmC func) args[3] r=1  (not used)
mem_Free                            -220  0xffffff24 (PmmC func) args[1] r=1  (not used)
mem_Heap                            -221  0xffffff23 (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -219  0xffffff25 (PmmC func) args[2] r=1  (not used)
mem_Set                             -222  0xffffff22 (PmmC func) args[3] r=1  (not used)
MEMORY_ACCESS_CONTROL                 22  0x00000016 (const dword)  (not used)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -14  0xfffffff2 (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
NAK                                   21  0x00000015 (const dword)  (usage 3)
nak0                                7350  0x00001cb6 (User func) args[0] r=0  (usage 24)
nAniTimers                             0  0x00000000 (const dword)  (not used)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
nInputs                               86  0x00000056 (const dword)  (usage 3)
nKeyboards                             1  0x00000001 (const dword)  (usage 9)
nObjects                              83  0x00000053 (const dword)  (not used)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
nStrings                              24  0x00000018 (const dword)  (usage 3)
o4Dbuttons                          3000  0x00000bb8o4Dbuttons                          3000  0x00000bb8 (mem) word[5] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 12)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
oDipSwitchs                         2772  0x00000ad4oDipSwitchs                         2772  0x00000ad4 (mem) word[1] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 75)
OFF                                    0  0x00000000 (const dword)  (usage 3)
oForms                              2852  0x00000b24oForms                              2852  0x00000b24 (mem) word[13] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
Ofs_Digits_Digits                      2  0x00000002 (const dword)  (not used)
Ofs_Digits_LeadingBlanks               8  0x00000008 (const dword)  (not used)
Ofs_Digits_Left                        0  0x00000000 (const dword)  (not used)
Ofs_Digits_MinDigits                   4  0x00000004 (const dword)  (not used)
Ofs_Digits_Widthdigit                  6  0x00000006 (const dword)  (not used)
Ofs_IPD_DOWN                          16  0x00000010 (const dword)  (usage 6)
Ofs_IPD_OBJVIDX                       20  0x00000014 (const dword)  (usage 15)
Ofs_IPD_P1                             2  0x00000002 (const dword)  (usage 15)
Ofs_IPD_P2                             4  0x00000004 (const dword)  (usage 48)
Ofs_IPD_P3                             6  0x00000006 (const dword)  (usage 9)
Ofs_IPD_P4                             8  0x00000008 (const dword)  (usage 3)
Ofs_IPD_P5                            10  0x0000000a (const dword)  (usage 9)
Ofs_IPD_P6                            12  0x0000000c (const dword)  (usage 18)
Ofs_IPD_P7                            14  0x0000000e (const dword)  (not used)
Ofs_IPD_RELEASE                       18  0x00000012 (const dword)  (usage 9)
Ofs_kb_Buttons                        10  0x0000000a (const ??? 0)  (usage 12)
Ofs_kb_Caps                            4  0x00000004 (const ??? 0)  (usage 12)
Ofs_kb_Ctrl1                           7  0x00000007 (const ??? 0)  (usage 12)
Ofs_kb_Ctrl2                           8  0x00000008 (const ??? 0)  (usage 12)
Ofs_kb_Down                            0  0x00000000 (const ??? 0)  (usage 9)
Ofs_kb_Ign                             3  0x00000003 (const ??? 0)  (usage 18)
Ofs_kb_Lock                            9  0x00000009 (const ??? 0)  (usage 6)
Ofs_kb_Mvt                             1  0x00000001 (const ??? 0)  (usage 18)
Ofs_kb_Shift1                          5  0x00000005 (const ??? 0)  (usage 6)
Ofs_kb_Shift2                          6  0x00000006 (const ??? 0)  (usage 6)
Ofs_kb_ShiftCaps                      11  0x0000000b (const ??? 0)  (usage 3)
Ofs_kb_State                           2  0x00000002 (const ??? 0)  (usage 63)
Ofs_String_Ansi                       22  0x00000016 (const dword)  (usage 3)
Ofs_String_BGColor                    16  0x00000010 (const dword)  (usage 6)
Ofs_String_FGColor                    14  0x0000000e (const dword)  (usage 3)
Ofs_String_FontAttribs                18  0x00000012 (const dword)  (usage 3)
Ofs_String_Form                       24  0x00000018 (const dword)  (usage 3)
Ofs_String_Size                        4  0x00000004 (const dword)  (usage 3)
Ofs_String_StartH                      0  0x00000000 (const dword)  (usage 3)
Ofs_String_StartL                      2  0x00000002 (const dword)  (usage 3)
Ofs_String_Transparent                20  0x00000014 (const dword)  (usage 3)
Ofs_String_x1                          6  0x00000006 (const dword)  (usage 12)
Ofs_String_x2                         10  0x0000000a (const dword)  (usage 9)
Ofs_String_y1                          8  0x00000008 (const dword)  (usage 12)
Ofs_String_y2                         12  0x0000000c (const dword)  (usage 9)
oKeyboard0                            50  0x00000032 (mem) word[12] (global)  (usage 3)
oKeyboards                          2878  0x00000b3eoKeyboards                          2878  0x00000b3e (mem) word[2] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 27)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
oldn                                 198  0x000000c6 (mem) word (global)  (usage 42)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
ON                                     1  0x00000001 (const dword)  (usage 3)
oObjects                             128  0x00000080 (mem) word[34] (global)  (usage 108)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
OSC_CONTROL_1                         25  0x00000019 (const dword)  (not used)
OSC_CONTROL_3                        147  0x00000093 (const dword)  (not used)
oStaticTexts                        2942  0x00000b7eoStaticTexts                        2942  0x00000b7e (mem) word[27] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
oStringss                           2882  0x00000b42oStringss                           2882  0x00000b42 (mem) word[25] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 4)
oStringss                         UNRESOLVED  (usage 2)
OT_ACTIVATE                          103  0x00000067 (const dword)  (usage 3)
OT_MAGIC                             108  0x0000006c (const dword)  (usage 3)
OT_NEXTFRAME                         104  0x00000068 (const dword)  (usage 6)
OT_NEXTSTRING                        106  0x0000006a (const dword)  (usage 3)
OT_PREVFRAME                         105  0x00000069 (const dword)  (usage 6)
OT_PREVSTRING                        107  0x0000006b (const dword)  (usage 3)
OT_REPORT                            100  0x00000064 (const dword)  (usage 123)
OT_SETANOTHER                        102  0x00000066 (const dword)  (usage 15)
OT_SETCONST                          101  0x00000065 (const dword)  (usage 3)
oUserImagess                        2996  0x00000bb4oUserImagess                        2996  0x00000bb4 (mem) word[2] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
oUserleds                           2932  0x00000b74oUserleds                           2932  0x00000b74 (mem) word[5] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 3)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OUTPUT                                 0  0x00000000 (const dword)  (not used)
OutputCS                             456  0x000001c8 (mem) word (global)  (usage 9)
OVF                                  -21  0xffffffeb (PmmC func) args[0] r=1  (usage 3)
oWinButtons                         2774  0x00000ad6oWinButtons                         2774  0x00000ad6 (mem) word[39] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 12)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (not used)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 6)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekW                                -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
PEN_SIZE                              16  0x00000010 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
PICASO                                 1  0x00000001 (const dword)  (usage 3)
PICASO_FUNCTIONS                       0  0x00000000 (const ??? 0)  (not used)
pin_HI                               -42  0xffffffd6 (PmmC func) args[1] r=1  (not used)
pin_LO                               -43  0xffffffd5 (PmmC func) args[1] r=1  (not used)
pin_Read                             -44  0xffffffd4 (PmmC func) args[1] r=1  (not used)
pin_Set                              -41  0xffffffd7 (PmmC func) args[2] r=1  (not used)
PINK                               65049  0x0000fe19 (const dword)  (not used)
pInputIndex                          212  0x000000d4 (mem) word (global)  (usage 18)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeW                                -12  0xfffffff4 (PmmC func) args[2] r=0  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
POWER_CONTROL_1                       27  0x0000001b (const dword)  (not used)
POWER_CONTROL_2                       28  0x0000001c (const dword)  (not used)
POWER_CONTROL_3                       29  0x0000001d (const dword)  (not used)
POWER_CONTROL_4                       30  0x0000001e (const dword)  (not used)
POWER_CONTROL_5                       31  0x0000001f (const dword)  (not used)
POWER_CONTROL_6                       32  0x00000020 (const dword)  (not used)
PrintStrings                        8273  0x00002051 (User func) args[3] r=0  (usage 9)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (usage 6)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (not used)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (usage 6)
RAND                                 -19  0xffffffed (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
READ_OBJ                               0  0x00000000 (const dword)  (usage 3)
READ_WRITE_DATA                       34  0x00000022 (const dword)  (not used)
ReadCmd                              128  0x00000080 (const dword)  (not used)
ReadObject                          7137  0x00001be1 (User func) args[2] r=0  (usage 3)
RED                                63488  0x0000f800 (const dword)  (not used)
refreshstate                        8071  0x00001f87 (User func) args[2] r=0  (usage 9)
REPORT_EVENT                           7  0x00000007 (const dword)  (usage 6)
REPORT_MAGIC_EVENT_BYTES              10  0x0000000a (const dword)  (not used)
REPORT_MAGIC_EVENT_DBYTES             11  0x0000000b (const dword)  (not used)
REPORT_OBJ                             5  0x00000005 (const dword)  (usage 3)
reserved                            -294  0xfffffeda (PmmC func) args[0] r=0  (not used)
RGBINT_CONTROL_1                      56  0x00000038 (const dword)  (not used)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
rKeyboardRoutines                   3036  0x00000bdcrKeyboardRoutines                   3036  0x00000bdc (mem) word[1] (member of D:\munka\MTA\projects\MTA_response_box\LCD\resp_box_1.4DWork\resp_box_1.4DGenieS)  (usage 1)
rKeyboardRoutines                 UNRESOLVED  (usage 2)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROW_ADDRESS_END1                       9  0x00000009 (const dword)  (not used)
ROW_ADDRESS_END2                       8  0x00000008 (const dword)  (not used)
ROW_ADDRESS_START1                     7  0x00000007 (const dword)  (not used)
ROW_ADDRESS_START2                     6  0x00000006 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RUNFLASH                             128  0x00000080 (const dword)  (usage 3)
RXMODE_0                               0  0x00000000 (const dword)  (not used)
RXMODE_1                               1  0x00000001 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
SCREEN_MODE                           23  0x00000017 (const dword)  (not used)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SEED                                 -20  0xffffffec (PmmC func) args[1] r=0  (not used)
SELECT                                 3  0x00000003 (const dword)  (not used)
SELECT_MULTIPLE                        4  0x00000004 (const dword)  (not used)
SendReport                          7285  0x00001c75 (User func) args[4] r=0  (usage 9)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (usage 3)
serin1                              -140  0xffffff74 (PmmC func) args[0] r=1  (not used)
serinX                               N/A         N/A (macro) serin   (not used)
serout                                -3  0xfffffffd (PmmC func) args[1] r=0  (usage 21)
serout1                             -141  0xffffff73 (PmmC func) args[1] r=0  (not used)
seroutCS                            7365  0x00001cc5 (User func) args[1] r=0  (usage 15)
seroutOcs                           7335  0x00001ca7 (User func) args[0] r=0  (usage 3)
seroutX                              N/A         N/A (macro) serout   (not used)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (not used)
setkeystate                         7525  0x00001d65 (User func) args[2] r=0  (usage 33)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (not used)
SIN                                  -17  0xffffffef (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (usage 24)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -258  0xfffffefe (PmmC func) args[1] r=0  (not used)
snd_Continue                        -261  0xfffffefb (PmmC func) args[0] r=0  (not used)
snd_Pause                           -260  0xfffffefc (PmmC func) args[0] r=0  (not used)
snd_Pitch                           -257  0xfffffeff (PmmC func) args[1] r=1  (not used)
snd_Playing                         -262  0xfffffefa (PmmC func) args[0] r=1  (not used)
snd_Stop                            -259  0xfffffefd (PmmC func) args[0] r=0  (not used)
snd_Volume                          -256  0xffffff00 (PmmC func) args[1] r=0  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (not used)
spi_Disable                         -153  0xffffff67 (PmmC func) args[0] r=0  (not used)
SPI_FAST                               0  0x00000000 (const dword)  (not used)
spi_Init                            -150  0xffffff6a (PmmC func) args[3] r=0  (not used)
SPI_MED                                1  0x00000001 (const dword)  (not used)
spi_Read                            -151  0xffffff69 (PmmC func) args[0] r=1  (not used)
SPI_SLOW                               2  0x00000002 (const dword)  (not used)
spi_Write                           -152  0xffffff68 (PmmC func) args[1] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -22  0xffffffea (PmmC func) args[1] r=1  (not used)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
str_Cat                             -278  0xfffffeea (PmmC func) args[2] r=1  (not used)
str_CatN                            -279  0xfffffee9 (PmmC func) args[3] r=1  (not used)
str_Copy                            -287  0xfffffee1 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -288  0xfffffee0 (PmmC func) args[3] r=1  (not used)
str_Find                            -274  0xfffffeee (PmmC func) args[2] r=1  (not used)
str_FindI                           -275  0xfffffeed (PmmC func) args[2] r=1  (not used)
str_GetByte                         -268  0xfffffef4 (PmmC func) args[1] r=1  (not used)
str_GetC                            -267  0xfffffef5 (PmmC func) args[2] r=1  (not used)
str_GetD                            -264  0xfffffef8 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -266  0xfffffef6 (PmmC func) args[2] r=1  (not used)
str_GetW                            -265  0xfffffef7 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -269  0xfffffef3 (PmmC func) args[1] r=1  (not used)
str_Length                          -276  0xfffffeec (PmmC func) args[1] r=1  (not used)
str_Match                           -272  0xfffffef0 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -273  0xfffffeef (PmmC func) args[2] r=1  (not used)
str_Printf                          -277  0xfffffeeb (PmmC func) args[2] r=1  (not used)
str_Ptr                             -263  0xfffffef9 (PmmC func) args[1] r=1  (not used)
str_PutByte                         -270  0xfffffef2 (PmmC func) args[2] r=0  (not used)
str_PutWord                         -271  0xfffffef1 (PmmC func) args[2] r=0  (not used)
strheight                           -161  0xffffff5f (PmmC func) args[0] r=1  (not used)
Strings0Count                          1  0x00000001 (const dword)  (not used)
Strings0Size                          20  0x00000014 (const dword)  (usage 3)
Strings0StartH                         0  0x00000000 (const dword)  (usage 3)
Strings0StartL                         0  0x00000000 (const dword)  (usage 3)
Strings10Count                         6  0x00000006 (const dword)  (not used)
Strings10Size                         39  0x00000027 (const dword)  (usage 3)
Strings10StartH                        0  0x00000000 (const dword)  (usage 3)
Strings10StartL                     8192  0x00002000 (const dword)  (usage 3)
Strings11Count                         0  0x00000000 (const dword)  (not used)
Strings11Size                          1  0x00000001 (const dword)  (usage 3)
Strings11StartH                        0  0x00000000 (const dword)  (usage 3)
Strings11StartL                     8704  0x00002200 (const dword)  (usage 3)
Strings12Count                         1  0x00000001 (const dword)  (not used)
Strings12Size                        138  0x0000008a (const dword)  (usage 3)
Strings12StartH                        0  0x00000000 (const dword)  (usage 3)
Strings12StartL                    14336  0x00003800 (const dword)  (usage 3)
Strings13Count                         0  0x00000000 (const dword)  (not used)
Strings13Size                          1  0x00000001 (const dword)  (usage 3)
Strings13StartH                        0  0x00000000 (const dword)  (usage 3)
Strings13StartL                    14848  0x00003a00 (const dword)  (usage 3)
Strings14Count                         0  0x00000000 (const dword)  (not used)
Strings14Size                          1  0x00000001 (const dword)  (usage 3)
Strings14StartH                        0  0x00000000 (const dword)  (usage 3)
Strings14StartL                     3072  0x00000c00 (const dword)  (usage 3)
Strings15Count                         0  0x00000000 (const dword)  (not used)
Strings15Size                          1  0x00000001 (const dword)  (usage 3)
Strings15StartH                        0  0x00000000 (const dword)  (usage 3)
Strings15StartL                     3584  0x00000e00 (const dword)  (usage 3)
Strings16Count                         0  0x00000000 (const dword)  (not used)
Strings16Size                          1  0x00000001 (const dword)  (usage 3)
Strings16StartH                        0  0x00000000 (const dword)  (usage 3)
Strings16StartL                     2048  0x00000800 (const dword)  (usage 3)
Strings17Count                         0  0x00000000 (const dword)  (not used)
Strings17Size                          1  0x00000001 (const dword)  (usage 3)
Strings17StartH                        0  0x00000000 (const dword)  (usage 3)
Strings17StartL                     2560  0x00000a00 (const dword)  (usage 3)
Strings18Count                         3  0x00000003 (const dword)  (not used)
Strings18Size                        103  0x00000067 (const dword)  (usage 3)
Strings18StartH                        0  0x00000000 (const dword)  (usage 3)
Strings18StartL                    15872  0x00003e00 (const dword)  (usage 3)
Strings19Count                         1  0x00000001 (const dword)  (not used)
Strings19Size                         34  0x00000022 (const dword)  (usage 3)
Strings19StartH                        0  0x00000000 (const dword)  (usage 3)
Strings19StartL                    15360  0x00003c00 (const dword)  (usage 3)
Strings1Count                          1  0x00000001 (const dword)  (not used)
Strings1Size                          20  0x00000014 (const dword)  (usage 3)
Strings1StartH                         0  0x00000000 (const dword)  (usage 3)
Strings1StartL                       512  0x00000200 (const dword)  (usage 3)
Strings20Count                         2  0x00000002 (const dword)  (not used)
Strings20Size                          4  0x00000004 (const dword)  (usage 3)
Strings20StartH                        0  0x00000000 (const dword)  (usage 3)
Strings20StartL                     1024  0x00000400 (const dword)  (usage 3)
Strings21Count                         2  0x00000002 (const dword)  (not used)
Strings21Size                          4  0x00000004 (const dword)  (usage 3)
Strings21StartH                        0  0x00000000 (const dword)  (usage 3)
Strings21StartL                     1536  0x00000600 (const dword)  (usage 3)
Strings22Count                        12  0x0000000c (const dword)  (not used)
Strings22Size                        351  0x0000015f (const dword)  (usage 3)
Strings22StartH                        0  0x00000000 (const dword)  (usage 3)
Strings22StartL                     9216  0x00002400 (const dword)  (usage 3)
Strings23Count                        12  0x0000000c (const dword)  (not used)
Strings23Size                         38  0x00000026 (const dword)  (usage 3)
Strings23StartH                        0  0x00000000 (const dword)  (usage 3)
Strings23StartL                    13824  0x00003600 (const dword)  (usage 3)
Strings2Count                          2  0x00000002 (const dword)  (not used)
Strings2Size                           9  0x00000009 (const dword)  (usage 3)
Strings2StartH                         0  0x00000000 (const dword)  (usage 3)
Strings2StartL                      4096  0x00001000 (const dword)  (usage 3)
Strings3Count                          2  0x00000002 (const dword)  (not used)
Strings3Size                           9  0x00000009 (const dword)  (usage 3)
Strings3StartH                         0  0x00000000 (const dword)  (usage 3)
Strings3StartL                      4608  0x00001200 (const dword)  (usage 3)
Strings4Count                          0  0x00000000 (const dword)  (not used)
Strings4Size                           1  0x00000001 (const dword)  (usage 3)
Strings4StartH                         0  0x00000000 (const dword)  (usage 3)
Strings4StartL                      5120  0x00001400 (const dword)  (usage 3)
Strings5Count                          0  0x00000000 (const dword)  (not used)
Strings5Size                           1  0x00000001 (const dword)  (usage 3)
Strings5StartH                         0  0x00000000 (const dword)  (usage 3)
Strings5StartL                      5632  0x00001600 (const dword)  (usage 3)
Strings6Count                          0  0x00000000 (const dword)  (not used)
Strings6Size                           1  0x00000001 (const dword)  (usage 3)
Strings6StartH                         0  0x00000000 (const dword)  (usage 3)
Strings6StartL                      6144  0x00001800 (const dword)  (usage 3)
Strings7Count                          0  0x00000000 (const dword)  (not used)
Strings7Size                           1  0x00000001 (const dword)  (usage 3)
Strings7StartH                         0  0x00000000 (const dword)  (usage 3)
Strings7StartL                      6656  0x00001a00 (const dword)  (usage 3)
Strings8Count                          0  0x00000000 (const dword)  (not used)
Strings8Size                           1  0x00000001 (const dword)  (usage 3)
Strings8StartH                         0  0x00000000 (const dword)  (usage 3)
Strings8StartL                      7168  0x00001c00 (const dword)  (usage 3)
Strings9Count                          0  0x00000000 (const dword)  (not used)
Strings9Size                           1  0x00000001 (const dword)  (usage 3)
Strings9StartH                         0  0x00000000 (const dword)  (usage 3)
Strings9StartL                      7680  0x00001e00 (const dword)  (usage 3)
stringsCV                             74  0x0000004a (mem) word[24] (global)  (usage 27)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                            -160  0xffffff60 (PmmC func) args[1] r=1  (not used)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
SWAP                                 -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
sys_DeepSleep                       -295  0xfffffed9 (PmmC func) args[1] r=1  (not used)
sys_EventQueue                      -194  0xffffff3e (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -195  0xffffff3d (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -196  0xffffff3c (PmmC func) args[0] r=0  (usage 3)
sys_GetTimer                        -192  0xffffff40 (PmmC func) args[1] r=1  (not used)
sys_SetTimer                        -191  0xffffff41 (PmmC func) args[2] r=0  (not used)
sys_SetTimerEvent                   -193  0xffffff3f (PmmC func) args[2] r=1  (not used)
sys_Sleep                           -197  0xffffff3b (PmmC func) args[1] r=1  (not used)
sys_StoreTouchCalibration           -280  0xfffffee8 (PmmC func) args[0] r=1  (not used)
sys_T                               -189  0xffffff43 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -190  0xffffff42 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (not used)
t4Dbutton                             30  0x0000001e (const dword)  (usage 33)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
tAngularmeter                          7  0x00000007 (const dword)  (usage 3)
tAniButton                            31  0x0000001f (const dword)  (usage 6)
tColorPicker                          32  0x00000020 (const dword)  (usage 3)
tCoolgauge                             8  0x00000008 (const dword)  (usage 3)
tCustomdigits                          9  0x00000009 (const dword)  (usage 3)
tDipSwitch                             0  0x00000000 (const dword)  (usage 3)
TEAL                                1040  0x00000410 (const dword)  (not used)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
tForm                                 10  0x0000000a (const dword)  (usage 15)
tGauge                                11  0x0000000b (const dword)  (usage 3)
tGSlider                               4  0x00000004 (const dword)  (usage 3)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
tImage                                12  0x0000000c (const dword)  (usage 3)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (not used)
TIMER2                                 2  0x00000002 (const dword)  (not used)
TIMER3                                 3  0x00000003 (const dword)  (not used)
TIMER4                                 4  0x00000004 (const dword)  (not used)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (not used)
tKeyboard                             13  0x0000000d (const dword)  (usage 6)
tKnob                                  1  0x00000001 (const dword)  (usage 3)
tLed                                  14  0x0000000e (const dword)  (usage 3)
tLeddigits                            15  0x0000000f (const dword)  (usage 3)
tMagicObject                          34  0x00000022 (const dword)  (not used)
tMeter                                16  0x00000010 (const dword)  (usage 3)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (not used)
tolower                             -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -199  0xffffff39 (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -201  0xffffff37 (PmmC func) args[1] r=1  (usage 9)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 3)
TOUCH_GETY                             2  0x00000002 (const dword)  (usage 3)
TOUCH_MOVING                           3  0x00000003 (const dword)  (usage 3)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (usage 12)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (usage 21)
touch_Set                           -200  0xffffff38 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 3)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
TouchState                           208  0x000000d0 (mem) word (global)  (usage 24)
TouchXpos                            202  0x000000ca (mem) word (global)  (usage 12)
TouchYpos                            204  0x000000cc (mem) word (global)  (usage 9)
toupper                             -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
tPinInput                             29  0x0000001d (const dword)  (usage 6)
tPinOutput                            28  0x0000001c (const dword)  (usage 6)
translate                             -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (usage 3)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
tRockerSwitch                          2  0x00000002 (const dword)  (usage 3)
tRotarySwitch                          3  0x00000003 (const dword)  (usage 3)
tScope                                25  0x00000019 (const dword)  (not used)
tSounds                               22  0x00000016 (const dword)  (usage 6)
tSpectrum                             24  0x00000018 (const dword)  (usage 3)
tStaticText                           21  0x00000015 (const dword)  (usage 3)
tStrings                              17  0x00000011 (const dword)  (usage 18)
tTank                                 26  0x0000001a (const dword)  (usage 3)
tThermometer                          18  0x00000012 (const dword)  (usage 3)
tTimer                                23  0x00000017 (const dword)  (usage 6)
tTrackbar                              5  0x00000005 (const dword)  (usage 3)
TurnOffButtons                      6635  0x000019eb (User func) args[1] r=0  (usage 6)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
tUserButton                           33  0x00000021 (const dword)  (usage 9)
tUserImages                           27  0x0000001b (const dword)  (usage 3)
tUserled                              19  0x00000013 (const dword)  (usage 3)
tVideo                                20  0x00000014 (const dword)  (usage 3)
tWinButton                             6  0x00000006 (const dword)  (usage 126)
txt_Attributes                       -38  0xffffffda (PmmC func) args[1] r=1  (usage 3)
txt_BGcolour                         -26  0xffffffe6 (PmmC func) args[1] r=1  (usage 3)
txt_Bold                             -34  0xffffffde (PmmC func) args[1] r=1  (not used)
txt_Delay                            -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -25  0xffffffe7 (PmmC func) args[1] r=1  (usage 3)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontID                           -27  0xffffffe5 (PmmC func) args[1] r=1  (usage 3)
txt_Height                           -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Inverse                          -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
txt_Italic                           -35  0xffffffdd (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -23  0xffffffe9 (PmmC func) args[2] r=0  (not used)
txt_Opacity                          -33  0xffffffdf (PmmC func) args[1] r=1  (usage 3)
txt_Set                              -24  0xffffffe8 (PmmC func) args[2] r=0  (not used)
txt_Underline                        -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
txt_Width                            -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_Wrap                             -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
uadd_3232                           -290  0xfffffede (PmmC func) args[3] r=1  (usage 3)
ucmp_3232                           -292  0xfffffedc (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
umul_1616                           -289  0xfffffedf (PmmC func) args[3] r=1  (usage 3)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                        -281  0xfffffee7 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
UpdateObjects                       5683  0x00001633 (User func) args[1] r=0  (usage 3)
USER_INITIALIZED_DISPLAY              32  0x00000020 (const dword)  (not used)
usub_3232                           -291  0xfffffedd (PmmC func) args[3] r=1  (not used)
VCOM_CONTROL_1                        67  0x00000043 (const dword)  (not used)
VCOM_CONTROL_2                        68  0x00000044 (const dword)  (not used)
VCOM_CONTROL_3                        69  0x00000045 (const dword)  (not used)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
WHEAT                              63222  0x0000f6f6 (const dword)  (not used)
WHITE                              65535  0x0000ffff (const dword)  (usage 75)
WHITESMOKE                         63422  0x0000f7be (const dword)  (not used)
WRITE_CONTRAST                         4  0x00000004 (const dword)  (usage 3)
WRITE_MAGIC_BYTES                      8  0x00000008 (const dword)  (not used)
WRITE_MAGIC_DBYTES                     9  0x00000009 (const dword)  (not used)
WRITE_OBJ                              1  0x00000001 (const dword)  (usage 3)
WRITE_STR                              2  0x00000002 (const dword)  (usage 6)
WRITE_STRU                             3  0x00000003 (const dword)  (usage 6)
WriteCmd                               0  0x00000000 (const dword)  (not used)
WriteObject                         6821  0x00001aa5 (User func) args[3] r=0  (usage 24)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (not used)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
